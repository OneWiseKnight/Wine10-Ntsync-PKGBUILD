From c3f1ffd99044dd567b6783725cb4aedf2aa2e8c7 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Mon, 6 Jan 2025 10:14:56 -0800
Subject: [PATCH 01/14] fsync: Make fsync_cache pointer-sized.

---
 dlls/ntdll/unix/fsync.c | 20 ++++++++++++++------
 1 file changed, 14 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index ebd71ea3b7c..7d12fbc6547 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -255,13 +255,21 @@ static void *get_shm( unsigned int idx )
 #define FSYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct fsync))
 #define FSYNC_LIST_ENTRIES     256
 
+#ifdef __i386__
+struct fsync_cache
+{
+    enum fsync_type type:3;
+    unsigned int shm_idx:29;
+};
+#else
 struct fsync_cache
 {
     enum fsync_type type;
     unsigned int shm_idx;
 };
+#endif
 
-C_ASSERT(sizeof(struct fsync_cache) == sizeof(uint64_t));
+C_ASSERT(sizeof(struct fsync_cache) == sizeof(UINT_PTR));
 
 static struct fsync_cache *fsync_list[FSYNC_LIST_ENTRIES];
 static struct fsync_cache fsync_list_initial_block[FSYNC_LIST_BLOCK_SIZE];
@@ -299,7 +307,7 @@ static void add_to_list( HANDLE handle, enum fsync_type type, unsigned int shm_i
 
     cache.type = type;
     cache.shm_idx = shm_idx;
-    __atomic_store_n( (UINT64 *)&fsync_list[entry][idx], *(UINT64 *)&cache, __ATOMIC_SEQ_CST );
+    __atomic_store_n( (UINT_PTR *)&fsync_list[entry][idx], *(UINT_PTR *)&cache, __ATOMIC_SEQ_CST );
 }
 
 static void grab_object( struct fsync *obj )
@@ -362,7 +370,7 @@ static BOOL get_cached_object( HANDLE handle, struct fsync *obj )
     if (entry >= FSYNC_LIST_ENTRIES || !fsync_list[entry]) return FALSE;
 
 again:
-    *(UINT64 *)&cache = __atomic_load_n( (UINT64 *)&fsync_list[entry][idx], __ATOMIC_SEQ_CST );
+    *(UINT_PTR *)&cache = __atomic_load_n( (UINT_PTR *)&fsync_list[entry][idx], __ATOMIC_SEQ_CST );
 
     if (!cache.type || !cache.shm_idx) return FALSE;
 
@@ -370,7 +378,7 @@ static BOOL get_cached_object( HANDLE handle, struct fsync *obj )
     obj->shm = get_shm( cache.shm_idx );
     grab_object( obj );
     if (((int *)obj->shm)[2] < 2 ||
-        *(UINT64 *)&cache != __atomic_load_n( (UINT64 *)&fsync_list[entry][idx], __ATOMIC_SEQ_CST ))
+        *(UINT_PTR *)&cache != __atomic_load_n( (UINT_PTR *)&fsync_list[entry][idx], __ATOMIC_SEQ_CST ))
     {
         /* This check does not strictly guarantee that we avoid the potential race but is supposed to greatly
          * reduce the probability of that. */
@@ -469,8 +477,8 @@ NTSTATUS fsync_close( HANDLE handle )
 
         cache.type = 0;
         cache.shm_idx = 0;
-        *(UINT64 *)&cache = __atomic_exchange_n( (UINT64 *)&fsync_list[entry][idx],
-                                                   *(UINT64 *)&cache, __ATOMIC_SEQ_CST );
+        *(UINT_PTR *)&cache = __atomic_exchange_n( (UINT_PTR *)&fsync_list[entry][idx],
+                                                   *(UINT_PTR *)&cache, __ATOMIC_SEQ_CST );
         if (cache.type) return STATUS_SUCCESS;
     }
 

From e15af9cd4c47da448a60d7a09f94e846aab4e574 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Mon, 6 Jan 2025 10:46:58 -0800
Subject: [PATCH 02/14] winevulkan: Use platform-compatible atomics.

---
 dlls/winevulkan/vulkan.c         |  4 ++--
 dlls/winevulkan/vulkan_private.h | 13 +++++++++++++
 2 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 47f598d5177..5bebd0201db 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -210,7 +210,7 @@ static void signal_timeline_sem(struct vulkan_device *device, VkSemaphore sem, U
     info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
     info.semaphore = sem;
     info.value = *value + 1;
-    __atomic_store_n(value, info.value, __ATOMIC_RELEASE);
+    WriteRelease64(value, info.value);
     if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
         res = device->p_vkSignalSemaphoreKHR(device->host.device, &info);
     else
@@ -3714,7 +3714,7 @@ static void add_sem_wait_op(struct vulkan_device *device, struct wine_semaphore
     if ((op = get_free_fence_op(device)))
     {
         op->virtual_value = virtual_value;
-        op->shared_physical_value = __atomic_load_n(&semaphore->d3d12_fence_shm->physical_value, __ATOMIC_ACQUIRE) + 1;
+        op->shared_physical_value = ReadAcquire64(&semaphore->d3d12_fence_shm->physical_value) + 1;
         *phys_semaphore = op->local_sem.sem;
         *phys_wait_value = op->local_sem.value + 1;
         op->semaphore = semaphore;
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 9a6a4680af5..a63eef5fecb 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -200,6 +200,19 @@ static inline void free_conversion_context(struct conversion_context *pool)
         free(entry);
 }
 
+/* see include/winnt.h */
+static FORCEINLINE LONG64 ReadAcquire64( LONG64 const volatile *src )
+{
+    LONG64 value;
+    __WINE_ATOMIC_LOAD_ACQUIRE( src, &value );
+    return value;
+}
+
+static FORCEINLINE void WriteRelease64( LONG64 volatile *dest, LONG64 value )
+{
+    __WINE_ATOMIC_STORE_RELEASE( dest, &value );
+}
+
 struct wine_semaphore
 {
     struct vulkan_semaphore obj;

From f1362ac4a1c2121cba1e85cb326f304cb974713c Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Tue, 19 Nov 2024 21:24:08 +0200
Subject: [PATCH 03/14] d3dx11_43: Fix IMPORTLIB directive

---
 dlls/d3dx11_43/Makefile.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/d3dx11_43/Makefile.in b/dlls/d3dx11_43/Makefile.in
index be0a311305e..d617c4a6ae9 100644
--- a/dlls/d3dx11_43/Makefile.in
+++ b/dlls/d3dx11_43/Makefile.in
@@ -1,6 +1,6 @@
 EXTRADEFS = -DD3DX11_SDK_VERSION=43 -DD3DX_D3D_VERSION=11
 MODULE = d3dx11_43.dll
-IMPORTLIB = d3dx11
+IMPORTLIB = d3dx11_43
 IMPORTS   = d3dcompiler ole32
 PARENTSRC = ../d3dx9_36
 DELAYIMPORTS = windowscodecs

From a81b6394afb3d71193113af0156cc7e9f7e331c0 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 14 Nov 2024 02:29:41 -0800
Subject: [PATCH 04/14] clang: fixup lto

---
 loader/preloader.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/loader/preloader.c b/loader/preloader.c
index f27d6df8c17..4e5821d06bd 100644
--- a/loader/preloader.c
+++ b/loader/preloader.c
@@ -93,7 +93,9 @@
 #include "wine/asm.h"
 #include "main.h"
 
+#if !defined(__LLD_LTO__)
 #pragma GCC visibility push(hidden)
+#endif
 
 /* ELF definitions */
 #define ELF_PREFERRED_ADDRESS(loader, maplength, mapstartpref) (mapstartpref)
@@ -1572,6 +1574,8 @@ void* wld_start( void **stack )
     return (void *)ld_so_map.l_entry;
 }
 
+#if !defined(__LLD_LTO__)
 #pragma GCC visibility pop
+#endif
 
 #endif /* __linux__ */

From 1fa02c29ef32cc6d98a795b66a0b2bb9cad7430e Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 22 Nov 2024 10:31:07 -0800
Subject: [PATCH 05/14] configure: Enforce 4-byte stack alignment on clang for
 PE builds.

Same as -mpreferred-stack-boundary=2 for gcc.
Clang interprets this as "n" bytes, while gcc uses "2^n" bytes.
https://linux.kernel.narkive.com/y7hAplfS/patch-x86-build-specify-stack-alignment-for-clang
---
 configure.ac | 1 +
 1 file changed, 1 insertion(+)

diff --git a/configure.ac b/configure.ac
index 9acc7ce2845..4d3471d9211 100644
--- a/configure.ac
+++ b/configure.ac
@@ -980,6 +980,7 @@ This is an error since --enable-archs=$wine_arch was requested.])])
 
     case $wine_arch in
       i386) WINE_TRY_PE_CFLAGS([-fno-omit-frame-pointer])
+            WINE_TRY_PE_CFLAGS([-mstack-alignment=4])
             WINE_TRY_PE_CFLAGS([-mpreferred-stack-boundary=2])
             WINE_TRY_PE_CFLAGS([-Wl,--disable-stdcall-fixup],
                                [AS_VAR_APPEND([${wine_arch}_LDFLAGS],[" -Wl,--disable-stdcall-fixup"])]) ;;

From 27330e95cbedd8e8c7feb3c1614c27efc4c8fde2 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 21 Nov 2024 00:59:01 +0200
Subject: [PATCH 06/14] makedep: add per-source cflags and per-program ldflags
 variables

Co-authored-by: William Horvath <william@horvath.blog>
---
 tools/makedep.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/tools/makedep.c b/tools/makedep.c
index 4c9333e401b..e45be19abb1 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -474,6 +474,19 @@ static const char *get_base_name( const char *name )
     return base;
 }
 
+/*******************************************************************
+ *         replace_char
+ */
+char* replace_char(char* str, char find, char replace)
+{
+    char *current_pos;
+    current_pos = strchr(str, find);
+    while (current_pos) {
+        *current_pos = replace;
+        current_pos = strchr(current_pos + 1, find);
+    };
+    return str;
+}
 
 /*******************************************************************
  *         replace_filename
@@ -3208,6 +3221,7 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
 {
     const int is_cxx = strendswith( source->name, ".cpp" );
     const char *obj_name, *var_cc, *var_cxx, *var_cflags, *var_cxxflags;
+    char obj2[256] = {0};
     struct compile_command *cmd;
     struct strarray cflags = empty_strarray;
 
@@ -3286,6 +3300,11 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
     output_filenames( defines );
     output_filenames( cflags );
     output_filename( is_cxx ? var_cxxflags : var_cflags );
+    strncpy( obj2, obj, sizeof( obj2 ) );
+    obj2[ sizeof( obj2 ) - 1] = '\0';
+    replace_char( obj2, '-', '_' );
+    replace_char( obj2, '.', '_' );
+    output_filename( arch_make_variable( strmake( "%s_CFLAGS", basename( obj2 ) ), arch ));
     output( "\n" );
 
     if (make->testdll && strendswith( source->name, ".c" ) &&
@@ -3741,6 +3760,7 @@ static void output_programs( struct makefile *make )
 {
     unsigned int i, j;
     unsigned int arch = 0;  /* programs are always native */
+    char program2[256] = {0};
 
     for (i = 0; i < make->programs.count; i++)
     {
@@ -3766,6 +3786,10 @@ static void output_programs( struct makefile *make )
         output_filenames_obj_dir( make, objs );
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
+        strncpy( program2, program, sizeof( program2 ) );
+        program2[ sizeof( program2 ) - 1] = '\0';
+        replace_char( program2, '-', '_' );
+        output_filename( arch_make_variable( strmake( "%s_LDFLAGS", basename( program2 ) ), arch ));
         output( "\n" );
         strarray_add( &make->all_targets[arch], program );
 

From f34da4070fcb93b6bcdd9c519fbe35633c2f433e Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Sat, 3 May 2025 04:12:53 -0700
Subject: [PATCH 07/14] makedep: Add the nls subdir to __tooldeps__

---
 tools/makedep.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/tools/makedep.c b/tools/makedep.c
index e45be19abb1..48b0dc9d743 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -3857,6 +3857,8 @@ static void output_subdirs( struct makefile *make )
         strarray_addall_path( &all_targets, submakes[i]->obj_dir, submakes[i]->font_files );
         if (!strcmp( submakes[i]->obj_dir, "tools" ) || !strncmp( submakes[i]->obj_dir, "tools/", 6 ))
             strarray_add( &tooldeps_deps, obj_dir_path( submakes[i], "all" ));
+        if (!strcmp( submakes[i]->obj_dir, "nls" ) || !strncmp( submakes[i]->obj_dir, "nls/", 4 ))
+            strarray_add( &tooldeps_deps, obj_dir_path( submakes[i], "all" ));
         if (submakes[i]->testdll)
             strarray_add( &buildtest_deps, obj_dir_path( submakes[i], "all" ));
         for (j = 0; j < NB_INSTALL_RULES; j++)

From c7cf132f6aba451dc90539491d7c3fe9e8534663 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Mon, 23 Sep 2024 11:03:23 -0700
Subject: [PATCH 08/14] ntdll: Downgrade 'using kernel write watches' from
 MESSAGE to TRACE.

It's overly verbose to be helpful, and clutters the log output.
---
 dlls/ntdll/unix/virtual.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 355a88986a3..72c4cadb3cd 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -3814,7 +3814,7 @@ void virtual_init(void)
         kernel_writewatch_init();
 
     if (use_kernel_writewatch)
-        WARN( "using kernel write watches, use_kernel_writewatch %d.\n", use_kernel_writewatch );
+        TRACE( "using kernel write watches, use_kernel_writewatch %d.\n", use_kernel_writewatch );
 
     if (preload_info && *preload_info)
         for (i = 0; (*preload_info)[i].size; i++)

From 878a9db0a09801150f95698182c1ecbc7101c285 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Wed, 11 Sep 2024 20:42:20 +0300
Subject: [PATCH 09/14] ntdll: fix compilation with link-time optimizations

---
 dlls/ntdll/unix/signal_arm.c    |  2 +-
 dlls/ntdll/unix/signal_arm64.c  |  2 +-
 dlls/ntdll/unix/signal_i386.c   |  2 +-
 dlls/ntdll/unix/signal_x86_64.c |  2 +-
 loader/preloader.c              | 10 +++++-----
 5 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index c8b67929aff..0d4c1910d0d 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -1125,7 +1125,7 @@ void signal_init_process(void)
 /***********************************************************************
  *           call_init_thunk
  */
-void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
+__attribute__((used)) void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
                       struct syscall_frame *frame, void *syscall_cfa )
 {
     struct arm_thread_data *thread_data = (struct arm_thread_data *)&teb->GdiTebBatch;
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index dc8a252704c..fea42c1d0ee 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -1451,7 +1451,7 @@ void syscall_dispatcher_return_slowpath(void)
 /***********************************************************************
  *           call_init_thunk
  */
-void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
+__attribute__((used)) void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
                       struct syscall_frame *frame, void *syscall_cfa )
 {
     struct arm64_thread_data *thread_data = (struct arm64_thread_data *)&teb->GdiTebBatch;
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 33958f76ee9..4a45b5b0dad 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2531,7 +2531,7 @@ void signal_init_process(void)
 /***********************************************************************
  *           call_init_thunk
  */
-void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
+__attribute__((used)) void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
                       struct syscall_frame *frame, void *syscall_cfa )
 {
     struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 10d39bc1098..98f3df697f5 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -2939,7 +2939,7 @@ void set_thread_teb( TEB *teb )
 /***********************************************************************
  *           call_init_thunk
  */
-void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
+__attribute__((used)) void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB *teb,
                       struct syscall_frame *frame, void *syscall_cfa )
 {
     struct amd64_thread_data *thread_data = (struct amd64_thread_data *)&teb->GdiTebBatch;
diff --git a/loader/preloader.c b/loader/preloader.c
index 4e5821d06bd..986ac101777 100644
--- a/loader/preloader.c
+++ b/loader/preloader.c
@@ -185,7 +185,7 @@ void __bb_init_func(void) { return; }
 
 /* data for setting up the glibc-style thread-local storage in %gs */
 
-static int thread_data[256];
+static int thread_data[256] __attribute__((used));
 
 struct
 {
@@ -200,7 +200,7 @@ struct
     unsigned int  seg_not_present : 1;
     unsigned int  usable : 1;
     unsigned int  garbage : 25;
-} thread_ldt = { -1, (unsigned long)thread_data, 0xfffff, 1, 0, 0, 1, 0, 1, 0 };
+} thread_ldt __attribute__((used)) = { -1, (unsigned long)thread_data, 0xfffff, 1, 0, 0, 1, 0, 1, 0 };
 
 
 /*
@@ -339,7 +339,7 @@ static inline int wld_prctl( int code, long arg )
 
 #elif defined(__x86_64__)
 
-void *thread_data[256];
+void *thread_data[256] __attribute__((used));
 
 /*
  * The _start function is the entry and exit point of this program
@@ -428,7 +428,7 @@ SYSCALL_NOERR( wld_getegid, 108 /* SYS_getegid */ );
 
 #elif defined(__aarch64__)
 
-void *thread_data[256];
+void *thread_data[256] __attribute__((used));
 
 /*
  * The _start function is the entry and exit point of this program
@@ -1434,7 +1434,7 @@ static void init_r_debug( struct wld_auxv *av )
  *  Load the binary and then its ELF interpreter.
  *  Note, we assume that the binary is a dynamically linked ELF shared object.
  */
-void* wld_start( void **stack )
+__attribute__((used)) void* wld_start( void **stack )
 {
     long i, *pargc;
     char **argv, **p;

From 88be56ef3bff09ee266aaa4f4362667cb393c2f5 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Wed, 22 Jan 2025 02:18:09 -0800
Subject: [PATCH 10/14] ntdll: Fix the return value of NtDelayExecution.

The key change is to never return STATUS_TIMEOUT, and to instead return the result of
NtYieldExecution() if zero timeout was passed, or STATUS_SUCCESS otherwise.

An overview of the correct values for each combination, copied from the test commit:
 - Non-alertable, zero timeout: STATUS_SUCCESS or STATUS_NO_YIELD_PERFORMED
 - Non-alertable, non-zero timeout: STATUS_SUCCESS
 - Alertable, zero timeout: STATUS_SUCCESS, STATUS_NO_YIELD_PERFORMED, or STATUS_USER_APC
 - Alertable, non-zero timeout: STATUS_SUCCESS or STATUS_USER_APC
 - Sleep/SleepEx don't modify LastError, no matter what
---
 dlls/ntdll/unix/sync.c | 31 +++++++++++++++++++++----------
 1 file changed, 21 insertions(+), 10 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 47fd5b24c46..4f79904bbad 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1764,24 +1764,34 @@ NTSTATUS WINAPI NtYieldExecution(void)
  */
 NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
+    unsigned int status = STATUS_SUCCESS;
+
     /* if alertable, we need to query the server */
     if (alertable)
     {
         if (do_fsync())
         {
-            NTSTATUS ret = fsync_wait_objects( 0, NULL, TRUE, TRUE, timeout );
-            if (ret != STATUS_NOT_IMPLEMENTED)
-                return ret;
+            status = fsync_wait_objects( 0, NULL, TRUE, TRUE, timeout );
+            if (status != STATUS_NOT_IMPLEMENTED)
+                goto alert_waited;
         }
 
         if (do_esync())
         {
-            NTSTATUS ret = esync_wait_objects( 0, NULL, TRUE, TRUE, timeout );
-            if (ret != STATUS_NOT_IMPLEMENTED)
-                return ret;
+            status = esync_wait_objects( 0, NULL, TRUE, TRUE, timeout );
+            if (status != STATUS_NOT_IMPLEMENTED)
+                goto alert_waited;
         }
 
-        return server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
+        /* Since server_wait will result in an unconditional implicit yield,
+           we never return STATUS_NO_YIELD_PERFORMED */
+        status = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
+
+alert_waited:
+        if (status == STATUS_TIMEOUT)
+            status = STATUS_SUCCESS;
+
+        return status;
     }
 
     if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)  /* sleep forever */
@@ -1799,9 +1809,10 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeou
             when = now.QuadPart - when;
         }
 
-        /* Note that we yield after establishing the desired timeout */
-        NtYieldExecution();
-        if (!when) return STATUS_SUCCESS;
+        /* Note that we yield after establishing the desired timeout, but
+           we only care about the result of the yield for zero timeouts */
+        status = NtYieldExecution();
+        if (!when) return status;
 
         for (;;)
         {

From 767c7577f89138fd3fcc06fd23c605fe22687d91 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Sat, 28 Dec 2024 06:45:10 -0800
Subject: [PATCH 11/14] ntdll: Never use CLOCK_REALTIME_COARSE.

This is required for deterministic timekeeping, as
CLOCK_REALTIME_COARSE depends on the kernel tickrate.
Since this function is provided by the vDSO, there is no
performance degradation by using CLOCK_REALTIME instead.
---
 dlls/ntdll/unix/sync.c | 17 +----------------
 1 file changed, 1 insertion(+), 16 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 4f79904bbad..585bc9373c5 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1847,22 +1847,7 @@ NTSTATUS WINAPI NtQuerySystemTime( LARGE_INTEGER *time )
 {
 #ifdef HAVE_CLOCK_GETTIME
     struct timespec ts;
-    static clockid_t clock_id = CLOCK_MONOTONIC; /* placeholder */
-
-    if (clock_id == CLOCK_MONOTONIC)
-    {
-#ifdef CLOCK_REALTIME_COARSE
-        struct timespec res;
-
-        /* Use CLOCK_REALTIME_COARSE if it has 1 ms or better resolution */
-        if (!clock_getres( CLOCK_REALTIME_COARSE, &res ) && res.tv_sec == 0 && res.tv_nsec <= 1000000)
-            clock_id = CLOCK_REALTIME_COARSE;
-        else
-#endif /* CLOCK_REALTIME_COARSE */
-            clock_id = CLOCK_REALTIME;
-    }
-
-    if (!clock_gettime( clock_id, &ts ))
+    if (!clock_gettime( CLOCK_REALTIME, &ts ))
     {
         time->QuadPart = ticks_from_time_t( ts.tv_sec ) + (ts.tv_nsec + 50) / 100;
     }

From 74bdd85e87afd78b3b81fab97b802cb469655f79 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Wed, 12 Feb 2025 14:04:16 -0800
Subject: [PATCH 12/14] ntdll: Use clock_nanosleep for delay.

---
 dlls/ntdll/unix/sync.c | 66 ++++++++++++++++++++++++++++++------------
 1 file changed, 48 insertions(+), 18 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 585bc9373c5..0b1999548f4 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -71,6 +71,11 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
+#define SECSPERDAY         86400
+/* 1601 to 1970 is 369 years plus 89 leap days */
+#define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)SECSPERDAY)
+#define TICKS_1601_TO_1970 (SECS_1601_TO_1970 * TICKSPERSEC)
+
 HANDLE keyed_event = 0;
 
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
@@ -1796,33 +1801,58 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeou
 
     if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)  /* sleep forever */
     {
-        for (;;) select( 0, NULL, NULL, NULL, NULL );
+        struct timespec ts = { .tv_sec = ~0UL >> 1, .tv_nsec = 0 };
+        while (clock_nanosleep( CLOCK_MONOTONIC, 0, &ts, &ts ) == EINTR);
     }
     else
     {
-        LARGE_INTEGER now;
-        timeout_t when, diff;
+        timeout_t when;
+        struct timespec ts;
+        when = timeout->QuadPart;
+
+        /* Note that we only care about the result of the yield for zero timeouts */
+        status = NtYieldExecution();
+        if (!when)
+            return status;
 
-        if ((when = timeout->QuadPart) < 0)
+        if (when < 0)
         {
-            NtQuerySystemTime( &now );
-            when = now.QuadPart - when;
-        }
+            when = -when;
+            when -= 450; /* rough overhead adjustment */
 
-        /* Note that we yield after establishing the desired timeout, but
-           we only care about the result of the yield for zero timeouts */
-        status = NtYieldExecution();
-        if (!when) return status;
+            if (when <= 0)
+                return status;
 
-        for (;;)
+            ts.tv_sec  = when / TICKSPERSEC;
+            ts.tv_nsec = (when % TICKSPERSEC) * 100;
+
+            while (clock_nanosleep( CLOCK_MONOTONIC, 0, &ts, &ts ) == EINTR);
+        }
+        else
         {
-            struct timeval tv;
+            LARGE_INTEGER now;
+            unsigned int ret;
+
+            when -= 450;
+
             NtQuerySystemTime( &now );
-            diff = (when - now.QuadPart + 9) / 10;
-            if (diff <= 0) break;
-            tv.tv_sec  = diff / 1000000;
-            tv.tv_usec = diff % 1000000;
-            if (select( 0, NULL, NULL, NULL, &tv ) != -1) break;
+            if (when <= now.QuadPart)
+                return status;
+
+            when -= TICKS_1601_TO_1970;
+            ts.tv_sec  = when / TICKSPERSEC;
+            ts.tv_nsec = (when % TICKSPERSEC) * 100;
+
+            do
+            {
+                ret = clock_nanosleep( CLOCK_REALTIME, TIMER_ABSTIME, &ts, NULL );
+                if (ret == EINTR)
+                {
+                    LARGE_INTEGER now;
+                    NtQuerySystemTime( &now );
+                    if (when <= now.QuadPart) break;
+                }
+            } while (ret == EINTR);
         }
     }
     return STATUS_SUCCESS;

From cdf05bf28f1dd1b4862b4c370df4213ea38b4f5f Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 1 Mar 2025 15:27:54 +0200
Subject: [PATCH 13/14] ntdll: Enable esync and fsync by default.

---
 dlls/ntdll/unix/esync.c | 2 +-
 dlls/ntdll/unix/fsync.c | 2 +-
 server/esync.c          | 2 +-
 server/fsync.c          | 2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 3074f7c72ea..ec3aff489a5 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -57,7 +57,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync();
 
     return do_esync_cached;
 #else
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 7d12fbc6547..531bf3109c0 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -171,7 +171,7 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
-        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        do_fsync_cached = !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && errno != ENOSYS;
     }
 
     return do_fsync_cached;
diff --git a/server/esync.c b/server/esync.c
index a5164435ed6..d6057d1a45c 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -51,7 +51,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync();
 
     return do_esync_cached;
 #else
diff --git a/server/fsync.c b/server/fsync.c
index dc50aa0a1f3..b83cdc10a51 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -59,7 +59,7 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
-        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        do_fsync_cached = !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && errno != ENOSYS;
     }
 
     return do_fsync_cached;

From c516b9e840e3dbff8573df4c2294e206b51b521e Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Sat, 5 Apr 2025 00:35:46 +0300
Subject: [PATCH 14/14] server: Allow setting realtime priority on wineserver
 with an environment variable.

A stripped down version of the obsolete wine-staging patch by Joakim Hernberg.
---
 server/Makefile.in |  1 +
 server/main.c      |  1 +
 server/priority.c  | 91 ++++++++++++++++++++++++++++++++++++++++++++++
 server/thread.h    |  2 +
 4 files changed, 95 insertions(+)
 create mode 100644 server/priority.c

diff --git a/server/Makefile.in b/server/Makefile.in
index 4e2008a761f..de028a06ee0 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -25,6 +25,7 @@ SOURCES = \
 	mutex.c \
 	named_pipe.c \
 	object.c \
+	priority.c \
 	process.c \
 	procfs.c \
 	ptrace.c \
diff --git a/server/main.c b/server/main.c
index d0a0a4879b5..b16c35bf6fd 100644
--- a/server/main.c
+++ b/server/main.c
@@ -243,6 +243,7 @@ int main( int argc, char *argv[] )
 
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
+    set_server_priority();
     init_signals();
     init_memory();
     init_user_sid();
diff --git a/server/priority.c b/server/priority.c
new file mode 100644
index 00000000000..ed7af0adc6b
--- /dev/null
+++ b/server/priority.c
@@ -0,0 +1,91 @@
+/*
+ * Server priority management
+ *
+ * Copyright (C) 2015 Joakim Hernberg
+ * Copyright (C) 2015 Sebastian Lackner
+ * Copyright (C) 2025 William Horvath
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
+#ifdef HAVE_SCHED_H
+# include <sched.h>
+#endif
+#ifndef SCHED_RESET_ON_FORK
+# define SCHED_RESET_ON_FORK 0x40000000
+#endif
+
+#include "thread.h"
+
+#if defined(__linux__) && defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_SCHED_H)
+
+/* gets the priority value from an environment variable */
+static int get_priority( const char *variable, int min, int max )
+{
+    const char *env;
+    int val;
+
+    env = getenv( variable );
+    if (!env) return -1;
+
+    val = atoi( env );
+    if (val >= min && val <= max) return val;
+    if (debug_level) fprintf( stderr, "wineserver: %s should be between %d and %d\n", variable, min, max );
+    return -1;
+}
+
+void set_server_priority(void)
+{
+    int min, max, priority;
+
+    min = sched_get_priority_min( SCHED_FIFO );
+    max = sched_get_priority_max( SCHED_FIFO );
+    if (min == -1 || max == -1)
+        return;
+
+    /* change the wineserver priority */
+    if ((priority = get_priority( "STAGING_RT_PRIORITY_SERVER", min, max )) != -1)
+    {
+        struct sched_param param;
+        memset( &param, 0, sizeof(param) );
+        param.sched_priority = priority;
+        if (sched_setscheduler( 0, SCHED_FIFO | SCHED_RESET_ON_FORK, &param ) == -1 &&
+            sched_setscheduler( 0, SCHED_FIFO, &param ) == -1)
+        {
+            fprintf( stderr, "wineserver: no realtime permissions to set priority to SCHED_FIFO/%d\n",
+                     param.sched_priority );
+            /* do not bother to check the rest */
+            return;
+        }
+
+        if (debug_level) fprintf( stderr, "wineserver: changed priority to SCHED_FIFO/%d\n",
+                                  param.sched_priority );
+    }
+}
+
+#else
+
+void set_server_priority(void)
+{
+}
+
+#endif
diff --git a/server/thread.h b/server/thread.h
index 057ad9ec2ae..869e054c65d 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -150,4 +150,6 @@ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 |
 
 static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
 
+extern void set_server_priority(void);
+
 #endif  /* __WINE_SERVER_THREAD_H */
