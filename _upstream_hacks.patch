From 7b8f8269313b5c82aa0cdc0b6f4c2b6083945755 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 6 Feb 2025 12:43:39 +0200
Subject: [PATCH 01/55] winewayland: Round the Wayland refresh rate to
 calculate the win32 display frequency.

Round the Wayland refresh rate instead of floor-ing it, to report a more
accurate win32 display frequency. This can slightly improve FPS values
in games that use the reported display frequency to drive their rendering.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56542
(cherry picked from commit 5c708e83b701c0c5ec5f0ca1dde5ee5a48034322)
---
 dlls/winewayland.drv/display.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 5d65fd01c54..851c9638252 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -232,7 +232,8 @@ static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *
     mode->dmBitsPerPel = 32;
     mode->dmPelsWidth = output_mode->width;
     mode->dmPelsHeight = output_mode->height;
-    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+    /* Round the refresh rate to calculate the win32 display frequency. */
+    mode->dmDisplayFrequency = (output_mode->refresh + 500) / 1000;
 }
 
 static void wayland_add_device_modes(const struct gdi_device_manager *device_manager,

From 33bc134c3cb700ca2e1a7ea7096a855dc7aa35ec Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 07:53:36 +0000
Subject: [PATCH 02/55] winewayland: Enable/disable the zwp_text_input_v3
 object.

(cherry picked from commit fab15336250afcfa97e3581ebdf2618f6490764a)
---
 dlls/winewayland.drv/Makefile.in              |   2 +
 .../text-input-unstable-v3.xml                | 457 ++++++++++++++++++
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_text_input.c     | 109 +++++
 dlls/winewayland.drv/waylanddrv.h             |  16 +
 5 files changed, 596 insertions(+)
 create mode 100644 dlls/winewayland.drv/text-input-unstable-v3.xml
 create mode 100644 dlls/winewayland.drv/wayland_text_input.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9ad1ad6889d..9129a3f2839 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ SOURCES = \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
+	text-input-unstable-v3.xml \
 	version.rc \
 	viewporter.xml \
 	vulkan.c \
@@ -17,6 +18,7 @@ SOURCES = \
 	wayland_output.c \
 	wayland_pointer.c \
 	wayland_surface.c \
+	wayland_text_input.c \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
diff --git a/dlls/winewayland.drv/text-input-unstable-v3.xml b/dlls/winewayland.drv/text-input-unstable-v3.xml
new file mode 100644
index 00000000000..1fae54d7ba7
--- /dev/null
+++ b/dlls/winewayland.drv/text-input-unstable-v3.xml
@@ -0,0 +1,457 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<protocol name="text_input_unstable_v3">
+  <copyright>
+    Copyright © 2012, 2013 Intel Corporation
+    Copyright © 2015, 2016 Jan Arne Petersen
+    Copyright © 2017, 2018 Red Hat, Inc.
+    Copyright © 2018       Purism SPC
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for composing text">
+    This protocol allows compositors to act as input methods and to send text
+    to applications. A text input object is used to manage state of what are
+    typically text entry fields in the application.
+
+    This document adheres to the RFC 2119 when using words like "must",
+    "should", "may", etc.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwp_text_input_v3" version="1">
+    <description summary="text input">
+      The zwp_text_input_v3 interface represents text input and input methods
+      associated with a seat. It provides enter/leave events to follow the
+      text input focus for a seat.
+
+      Requests are used to enable/disable the text-input object and set
+      state information like surrounding and selected text or the content type.
+      The information about the entered text is sent to the text-input object
+      via the preedit_string and commit_string events.
+
+      Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
+      must not point to middle bytes inside a code point: they must either
+      point to the first byte of a code point or to the end of the buffer.
+      Lengths must be measured between two valid indices.
+
+      Focus moving throughout surfaces will result in the emission of
+      zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
+      surface must commit zwp_text_input_v3.enable and
+      zwp_text_input_v3.disable requests as the keyboard focus moves across
+      editable and non-editable elements of the UI. Those two requests are not
+      expected to be paired with each other, the compositor must be able to
+      handle consecutive series of the same request.
+
+      State is sent by the state requests (set_surrounding_text,
+      set_content_type and set_cursor_rectangle) and a commit request. After an
+      enter event or disable request all state information is invalidated and
+      needs to be resent by the client.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="Destroy the wp_text_input">
+        Destroy the wp_text_input object. Also disables all surfaces enabled
+        through this wp_text_input object.
+      </description>
+    </request>
+
+    <request name="enable">
+      <description summary="Request text input to be enabled">
+        Requests text input on the surface previously obtained from the enter
+        event.
+
+        This request must be issued every time the active text input changes
+        to a new one, including within the current surface. Use
+        zwp_text_input_v3.disable when there is no longer any input focus on
+        the current surface.
+
+        Clients must not enable more than one text input on the single seat
+        and should disable the current text input before enabling the new one.
+        At most one instance of text input may be in enabled state per instance,
+        Requests to enable the another text input when some text input is active
+        must be ignored by compositor.
+
+        This request resets all state associated with previous enable, disable,
+        set_surrounding_text, set_text_change_cause, set_content_type, and
+        set_cursor_rectangle requests, as well as the state associated with
+        preedit_string, commit_string, and delete_surrounding_text events.
+
+        The set_surrounding_text, set_content_type and set_cursor_rectangle
+        requests must follow if the text input supports the necessary
+        functionality.
+
+        State set with this request is double-buffered. It will get applied on
+        the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The changes must be applied by the compositor after issuing a
+        zwp_text_input_v3.commit request.
+      </description>
+    </request>
+
+    <request name="disable">
+      <description summary="Disable text input on a surface">
+        Explicitly disable text input on the current surface (typically when
+        there is no focus on any text entry inside the surface).
+
+        State set with this request is double-buffered. It will get applied on
+        the next zwp_text_input_v3.commit request.
+      </description>
+    </request>
+
+    <request name="set_surrounding_text">
+      <description summary="sets the surrounding text">
+        Sets the surrounding plain text around the input, excluding the preedit
+        text.
+
+        The client should notify the compositor of any changes in any of the
+        values carried with this request, including changes caused by handling
+        incoming text-input events as well as changes caused by other
+        mechanisms like keyboard typing.
+
+        If the client is unaware of the text around the cursor, it should not
+        issue this request, to signify lack of support to the compositor.
+
+        Text is UTF-8 encoded, and should include the cursor position, the
+        complete selection and additional characters before and after them.
+        There is a maximum length of wayland messages, so text can not be
+        longer than 4000 bytes.
+
+        Cursor is the byte offset of the cursor within text buffer.
+
+        Anchor is the byte offset of the selection anchor within text buffer.
+        If there is no selected text, anchor is the same as cursor.
+
+        If any preedit text is present, it is replaced with a cursor for the
+        purpose of this event.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The initial state for affected fields is empty, meaning that the text
+        input does not support sending surrounding text. If the empty values
+        get applied, subsequent attempts to change them may have no effect.
+      </description>
+      <arg name="text" type="string"/>
+      <arg name="cursor" type="int"/>
+      <arg name="anchor" type="int"/>
+    </request>
+
+    <enum name="change_cause">
+      <description summary="text change reason">
+        Reason for the change of surrounding text or cursor posision.
+      </description>
+      <entry name="input_method" value="0" summary="input method caused the change"/>
+      <entry name="other" value="1" summary="something else than the input method caused the change"/>
+    </enum>
+
+    <request name="set_text_change_cause">
+      <description summary="indicates the cause of surrounding text change">
+        Tells the compositor why the text surrounding the cursor changed.
+
+        Whenever the client detects an external change in text, cursor, or
+        anchor posision, it must issue this request to the compositor. This
+        request is intended to give the input method a chance to update the
+        preedit text in an appropriate way, e.g. by removing it when the user
+        starts typing with a keyboard.
+
+        cause describes the source of the change.
+
+        The value set with this request is double-buffered. It must be applied
+        and reset to initial at the next zwp_text_input_v3.commit request.
+
+        The initial value of cause is input_method.
+      </description>
+      <arg name="cause" type="uint" enum="change_cause"/>
+    </request>
+
+    <enum name="content_hint" bitfield="true">
+      <description summary="content hint">
+        Content hint is a bitmask to allow to modify the behavior of the text
+        input.
+      </description>
+      <entry name="none" value="0x0" summary="no special behavior"/>
+      <entry name="completion" value="0x1" summary="suggest word completions"/>
+      <entry name="spellcheck" value="0x2" summary="suggest word corrections"/>
+      <entry name="auto_capitalization" value="0x4" summary="switch to uppercase letters at the start of a sentence"/>
+      <entry name="lowercase" value="0x8" summary="prefer lowercase letters"/>
+      <entry name="uppercase" value="0x10" summary="prefer uppercase letters"/>
+      <entry name="titlecase" value="0x20" summary="prefer casing for titles and headings (can be language dependent)"/>
+      <entry name="hidden_text" value="0x40" summary="characters should be hidden"/>
+      <entry name="sensitive_data" value="0x80" summary="typed text should not be stored"/>
+      <entry name="latin" value="0x100" summary="just Latin characters should be entered"/>
+      <entry name="multiline" value="0x200" summary="the text input is multiline"/>
+    </enum>
+
+    <enum name="content_purpose">
+      <description summary="content purpose">
+        The content purpose allows to specify the primary purpose of a text
+        input.
+
+        This allows an input method to show special purpose input panels with
+        extra characters or to disallow some characters.
+      </description>
+      <entry name="normal" value="0" summary="default input, allowing all characters"/>
+      <entry name="alpha" value="1" summary="allow only alphabetic characters"/>
+      <entry name="digits" value="2" summary="allow only digits"/>
+      <entry name="number" value="3" summary="input a number (including decimal separator and sign)"/>
+      <entry name="phone" value="4" summary="input a phone number"/>
+      <entry name="url" value="5" summary="input an URL"/>
+      <entry name="email" value="6" summary="input an email address"/>
+      <entry name="name" value="7" summary="input a name of a person"/>
+      <entry name="password" value="8" summary="input a password (combine with sensitive_data hint)"/>
+      <entry name="pin" value="9" summary="input is a numeric password (combine with sensitive_data hint)"/>
+      <entry name="date" value="10" summary="input a date"/>
+      <entry name="time" value="11" summary="input a time"/>
+      <entry name="datetime" value="12" summary="input a date and time"/>
+      <entry name="terminal" value="13" summary="input for a terminal"/>
+    </enum>
+
+    <request name="set_content_type">
+      <description summary="set content purpose and hint">
+        Sets the content purpose and content hint. While the purpose is the
+        basic purpose of an input field, the hint flags allow to modify some of
+        the behavior.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request.
+        Subsequent attempts to update them may have no effect. The values
+        remain valid until the next committed enable or disable request.
+
+        The initial value for hint is none, and the initial value for purpose
+        is normal.
+      </description>
+      <arg name="hint" type="uint" enum="content_hint"/>
+      <arg name="purpose" type="uint" enum="content_purpose"/>
+    </request>
+
+    <request name="set_cursor_rectangle">
+      <description summary="set cursor position">
+        Marks an area around the cursor as a x, y, width, height rectangle in
+        surface local coordinates.
+
+        Allows the compositor to put a window with word suggestions near the
+        cursor, without obstructing the text being input.
+
+        If the client is unaware of the position of edited text, it should not
+        issue this request, to signify lack of support to the compositor.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The initial values describing a cursor rectangle are empty. That means
+        the text input does not support describing the cursor area. If the
+        empty values get applied, subsequent attempts to change them may have
+        no effect.
+      </description>
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </request>
+
+    <request name="commit">
+      <description summary="commit state">
+        Atomically applies state changes recently sent to the compositor.
+
+        The commit request establishes and updates the state of the client, and
+        must be issued after any changes to apply them.
+
+        Text input state (enabled status, content purpose, content hint,
+        surrounding text and change cause, cursor rectangle) is conceptually
+        double-buffered within the context of a text input, i.e. between a
+        committed enable request and the following committed enable or disable
+        request.
+
+        Protocol requests modify the pending state, as opposed to the current
+        state in use by the input method. A commit request atomically applies
+        all pending state, replacing the current state. After commit, the new
+        pending state is as documented for each related request.
+
+        Requests are applied in the order of arrival.
+
+        Neither current nor pending state are modified unless noted otherwise.
+
+        The compositor must count the number of commit requests coming from
+        each zwp_text_input_v3 object and use the count as the serial in done
+        events.
+      </description>
+    </request>
+
+    <event name="enter">
+      <description summary="enter event">
+        Notification that this seat's text-input focus is on a certain surface.
+
+        If client has created multiple text input objects, compositor must send
+        this event to all of them.
+
+        When the seat has the keyboard capability the text-input focus follows
+        the keyboard focus. This event sets the current surface for the
+        text-input object.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </event>
+
+    <event name="leave">
+      <description summary="leave event">
+        Notification that this seat's text-input focus is no longer on a
+        certain surface. The client should reset any preedit string previously
+        set.
+
+        The leave notification clears the current surface. It is sent before
+        the enter notification for the new focus. After leave event, compositor
+        must ignore requests from any text input instances until next enter
+        event.
+
+        When the seat has the keyboard capability the text-input focus follows
+        the keyboard focus.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </event>
+
+    <event name="preedit_string">
+      <description summary="pre-edit">
+        Notify when a new composing text (pre-edit) should be set at the
+        current cursor position. Any previously set composing text must be
+        removed. Any previously existing selected text must be removed.
+
+        The argument text contains the pre-edit string buffer.
+
+        The parameters cursor_begin and cursor_end are counted in bytes
+        relative to the beginning of the submitted text buffer. Cursor should
+        be hidden when both are equal to -1.
+
+        They could be represented by the client as a line if both values are
+        the same, or as a text highlight otherwise.
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial value of text is an empty string, and cursor_begin,
+        cursor_end and cursor_hidden are all 0.
+      </description>
+      <arg name="text" type="string" allow-null="true"/>
+      <arg name="cursor_begin" type="int"/>
+      <arg name="cursor_end" type="int"/>
+    </event>
+
+    <event name="commit_string">
+      <description summary="text commit">
+        Notify when text should be inserted into the editor widget. The text to
+        commit could be either just a single character after a key press or the
+        result of some composing (pre-edit).
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial value of text is an empty string.
+      </description>
+      <arg name="text" type="string" allow-null="true"/>
+    </event>
+
+    <event name="delete_surrounding_text">
+      <description summary="delete surrounding text">
+        Notify when the text around the current cursor position should be
+        deleted.
+
+        Before_length and after_length are the number of bytes before and after
+        the current cursor index (excluding the selection) to delete.
+
+        If a preedit text is present, in effect before_length is counted from
+        the beginning of it, and after_length from its end (see done event
+        sequence).
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial values of both before_length and after_length are 0.
+      </description>
+      <arg name="before_length" type="uint" summary="length of text before current cursor position"/>
+      <arg name="after_length" type="uint" summary="length of text after current cursor position"/>
+    </event>
+
+    <event name="done">
+      <description summary="apply changes">
+        Instruct the application to apply changes to state requested by the
+        preedit_string, commit_string and delete_surrounding_text events. The
+        state relating to these events is double-buffered, and each one
+        modifies the pending state. This event replaces the current state with
+        the pending state.
+
+        The application must proceed by evaluating the changes in the following
+        order:
+
+        1. Replace existing preedit string with the cursor.
+        2. Delete requested surrounding text.
+        3. Insert commit string with the cursor at its end.
+        4. Calculate surrounding text to send.
+        5. Insert new preedit text in cursor position.
+        6. Place cursor inside preedit text.
+
+        The serial number reflects the last state of the zwp_text_input_v3
+        object known to the compositor. The value of the serial argument must
+        be equal to the number of commit requests already issued on that object.
+
+        When the client receives a done event with a serial different than the
+        number of past commit requests, it must proceed with evaluating and
+        applying the changes as normal, except it should not change the current
+        state of the zwp_text_input_v3 object. All pending state requests
+        (set_surrounding_text, set_content_type and set_cursor_rectangle) on
+        the zwp_text_input_v3 object should be sent and committed after
+        receiving a zwp_text_input_v3.done event with a matching serial.
+      </description>
+      <arg name="serial" type="uint"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_text_input_manager_v3" version="1">
+    <description summary="text input manager">
+      A factory for text-input objects. This object is a global singleton.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="Destroy the wp_text_input_manager">
+        Destroy the wp_text_input_manager object.
+      </description>
+    </request>
+
+    <request name="get_text_input">
+      <description summary="create a new text input object">
+        Creates a new text-input object for a given seat.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_text_input_v3"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9432dc934c9..f4170f6dcc4 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -37,6 +37,7 @@ struct wayland process_wayland =
     .seat.mutex = PTHREAD_MUTEX_INITIALIZER,
     .keyboard.mutex = PTHREAD_MUTEX_INITIALIZER,
     .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .text_input.mutex = PTHREAD_MUTEX_INITIALIZER,
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
     .output_mutex = PTHREAD_MUTEX_INITIALIZER
 };
@@ -143,6 +144,7 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         seat->global_id = id;
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
         pthread_mutex_unlock(&seat->mutex);
+        if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -164,6 +166,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwp_relative_pointer_manager_v1 =
             wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "zwp_text_input_manager_v3") == 0)
+    {
+        process_wayland.zwp_text_input_manager_v3 =
+            wl_registry_bind(registry, id, &zwp_text_input_manager_v3_interface, 1);
+        if (process_wayland.seat.wl_seat) wayland_text_input_init();
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -189,6 +197,7 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         TRACE("removing seat\n");
         if (process_wayland.pointer.wl_pointer) wayland_pointer_deinit();
+        if (process_wayland.text_input.zwp_text_input_v3) wayland_text_input_deinit();
         pthread_mutex_lock(&seat->mutex);
         wl_seat_release(seat->wl_seat);
         seat->wl_seat = NULL;
@@ -282,6 +291,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.zwp_relative_pointer_manager_v1)
         ERR("Wayland compositor doesn't support optional zwp_relative_pointer_manager_v1 (relative motion won't work)\n");
 
+    if (!process_wayland.zwp_text_input_manager_v3)
+        ERR("Wayland compositor doesn't support optional zwp_text_input_manager_v3 (host input methods won't work)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
new file mode 100644
index 00000000000..56c17cc3cc6
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -0,0 +1,109 @@
+/*
+ * Wayland text input handling
+ *
+ * Copyright 2025 Attila Fidan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(imm);
+
+static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        struct wl_surface *surface)
+{
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_enable(text_input->zwp_text_input_v3);
+    zwp_text_input_v3_set_content_type(text_input->zwp_text_input_v3,
+            ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
+            ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
+    zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    pthread_mutex_unlock(&text_input->mutex);
+}
+
+static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        struct wl_surface *surface)
+{
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    pthread_mutex_unlock(&text_input->mutex);
+}
+
+static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        const char *text, int32_t cursor_begin, int32_t cursor_end)
+{
+}
+
+static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        const char *text)
+{
+}
+
+static void text_input_delete_surrounding_text(void *data,
+        struct zwp_text_input_v3 *zwp_text_input_v3, uint32_t before_length, uint32_t after_length)
+{
+}
+
+static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        uint32_t serial)
+{
+}
+
+static const struct zwp_text_input_v3_listener text_input_listener =
+{
+    text_input_enter,
+    text_input_leave,
+    text_input_preedit_string,
+    text_input_commit_string,
+    text_input_delete_surrounding_text,
+    text_input_done,
+};
+
+void wayland_text_input_init(void)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+
+    pthread_mutex_lock(&text_input->mutex);
+    text_input->zwp_text_input_v3 = zwp_text_input_manager_v3_get_text_input(
+            process_wayland.zwp_text_input_manager_v3, process_wayland.seat.wl_seat);
+    zwp_text_input_v3_add_listener(text_input->zwp_text_input_v3, &text_input_listener, text_input);
+    pthread_mutex_unlock(&text_input->mutex);
+};
+
+void wayland_text_input_deinit(void)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
+    text_input->zwp_text_input_v3 = NULL;
+    pthread_mutex_unlock(&text_input->mutex);
+};
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 72a37cb3ffb..c5dec335485 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,7 @@
 #include <xkbcommon/xkbregistry.h>
 #include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
+#include "text-input-unstable-v3-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -111,6 +112,12 @@ struct wayland_pointer
     pthread_mutex_t mutex;
 };
 
+struct wayland_text_input
+{
+    struct zwp_text_input_v3 *zwp_text_input_v3;
+    pthread_mutex_t mutex;
+};
+
 struct wayland_seat
 {
     struct wl_seat *wl_seat;
@@ -132,9 +139,11 @@ struct wayland
     struct wl_subcompositor *wl_subcompositor;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
+    struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
+    struct wayland_text_input text_input;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
@@ -340,6 +349,13 @@ void wayland_pointer_init(struct wl_pointer *wl_pointer);
 void wayland_pointer_deinit(void);
 void wayland_pointer_clear_constraint(void);
 
+/**********************************************************************
+ *          Wayland text input
+ */
+
+void wayland_text_input_init(void);
+void wayland_text_input_deinit(void);
+
 /**********************************************************************
  *          OpenGL
  */

From 7aed66dc0954f1ad35437c2246f646ef754b7546 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 08:07:41 +0000
Subject: [PATCH 03/55] winewayland: Post IME update for committed text.

(cherry picked from commit 4106885c8cd349d3cd1e8dacf249876bf6bb4fdf)
---
 dlls/winewayland.drv/wayland_text_input.c | 50 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  2 +
 2 files changed, 52 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 56c17cc3cc6..91355c23a9c 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -24,11 +24,39 @@
 
 #include "config.h"
 
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
+static void post_ime_update(HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR *result_str)
+{
+    NtUserMessageCall(hwnd, WINE_IME_POST_UPDATE, cursor_pos, (LPARAM)comp_str, result_str,
+            NtUserImeDriverCall, FALSE);
+}
+
+static WCHAR *strdupUtoW(const char *str)
+{
+    WCHAR *ret = NULL;
+    size_t len;
+    DWORD reslen;
+
+    if (!str) return ret;
+    len = strlen(str);
+    ret = malloc((len + 1) * sizeof(WCHAR));
+    if (ret)
+    {
+        RtlUTF8ToUnicodeN(ret, len * sizeof(WCHAR), &reslen, str, len);
+        reslen /= sizeof(WCHAR);
+        ret[reslen] = 0;
+    }
+    return ret;
+}
+
 static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         struct wl_surface *surface)
 {
@@ -42,6 +70,7 @@ static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_inpu
             ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
     zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    text_input->wl_surface = surface;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -54,6 +83,7 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -65,6 +95,12 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
 static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         const char *text)
 {
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, text %s.\n", data, zwp_text_input_v3, debugstr_a(text));
+
+    pthread_mutex_lock(&text_input->mutex);
+    text_input->commit_string = strdupUtoW(text);
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static void text_input_delete_surrounding_text(void *data,
@@ -75,6 +111,19 @@ static void text_input_delete_surrounding_text(void *data,
 static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         uint32_t serial)
 {
+    struct wayland_text_input *text_input = data;
+    HWND hwnd;
+    TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
+
+    pthread_mutex_lock(&text_input->mutex);
+    assert(text_input->wl_surface);
+    hwnd = wl_surface_get_user_data(text_input->wl_surface);
+
+    post_ime_update(hwnd, 0, NULL, text_input->commit_string);
+
+    free(text_input->commit_string);
+    text_input->commit_string = NULL;
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static const struct zwp_text_input_v3_listener text_input_listener =
@@ -105,5 +154,6 @@ void wayland_text_input_deinit(void)
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
+    text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c5dec335485..60c345e6601 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,8 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
+    WCHAR *commit_string;
+    struct wl_surface *wl_surface;
     pthread_mutex_t mutex;
 };
 

From 9885fd142d8734d78328a8cb13248af92b72034a Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 08:26:56 +0000
Subject: [PATCH 04/55] winewayland: Implement SetIMECompositionRect.

(cherry picked from commit fc97cec13e0af88fe6ec59cb120fb7c7f10f7fb5)
---
 dlls/winewayland.drv/wayland_text_input.c | 47 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  1 +
 dlls/winewayland.drv/waylanddrv_main.c    |  1 +
 3 files changed, 49 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 91355c23a9c..769862ecdea 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -157,3 +157,50 @@ void wayland_text_input_deinit(void)
     text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
+
+/***********************************************************************
+ *      SetIMECompositionRect (WAYLANDDRV.@)
+ */
+BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+    int cursor_x, cursor_y, cursor_width, cursor_height;
+    TRACE("hwnd %p, rect %s.\n", hwnd, wine_dbgstr_rect(&rect));
+
+    pthread_mutex_lock(&text_input->mutex);
+
+    if (!text_input->zwp_text_input_v3)
+        goto err;
+
+    if (!(data = wayland_win_data_get(hwnd)))
+        goto err;
+
+    if (!(surface = data->wayland_surface) || surface->wl_surface != text_input->wl_surface)
+    {
+        wayland_win_data_release(data);
+        goto err;
+    }
+
+    wayland_surface_coords_from_window(surface,
+            rect.left - surface->window.rect.left,
+            rect.top - surface->window.rect.top,
+            &cursor_x, &cursor_y);
+    wayland_surface_coords_from_window(surface,
+            rect.right - rect.left,
+            rect.bottom - rect.top,
+            &cursor_width, &cursor_height);
+    wayland_win_data_release(data);
+
+    zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3,
+            cursor_x, cursor_y, cursor_width, cursor_height);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+
+    pthread_mutex_unlock(&text_input->mutex);
+    return TRUE;
+
+err:
+    pthread_mutex_unlock(&text_input->mutex);
+    return FALSE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 60c345e6601..afc480e6652 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -392,6 +392,7 @@ RGNDATA *get_region_data(HRGN region);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
+BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 47c1299dd01..633b2f4a043 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -38,6 +38,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
+    .pSetIMECompositionRect = WAYLAND_SetIMECompositionRect,
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,

From 273679337ad43e881af2f1f295779ecb76b8a3b4 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sat, 8 Feb 2025 05:59:04 +0000
Subject: [PATCH 05/55] winewayland: Post IME update for preedit text.

(cherry picked from commit 2673689cba8b9c5140e5fcedf11b39a239338270)
---
 dlls/winewayland.drv/wayland_text_input.c | 21 ++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h         |  2 ++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 769862ecdea..17257634b2e 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -78,11 +78,15 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
+    HWND hwnd;
     TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
 
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    assert(text_input->wl_surface);
+    hwnd = wl_surface_get_user_data(text_input->wl_surface);
+    post_ime_update(hwnd, 0, NULL, NULL);
     text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 }
@@ -90,6 +94,17 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
 static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         const char *text, int32_t cursor_begin, int32_t cursor_end)
 {
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, text %s, cursor_begin %d.\n", data, zwp_text_input_v3,
+            debugstr_a(text), cursor_begin);
+
+    pthread_mutex_lock(&text_input->mutex);
+    if ((text_input->preedit_string = strdupUtoW(text)) && cursor_begin > 0)
+    {
+        RtlUTF8ToUnicodeN(NULL, 0, &text_input->preedit_cursor_pos, text, cursor_begin);
+        text_input->preedit_cursor_pos /= sizeof(WCHAR);
+    }
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
@@ -119,8 +134,12 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     assert(text_input->wl_surface);
     hwnd = wl_surface_get_user_data(text_input->wl_surface);
 
-    post_ime_update(hwnd, 0, NULL, text_input->commit_string);
+    post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
+            text_input->commit_string);
 
+    free(text_input->preedit_string);
+    text_input->preedit_string = NULL;
+    text_input->preedit_cursor_pos = 0;
     free(text_input->commit_string);
     text_input->commit_string = NULL;
     pthread_mutex_unlock(&text_input->mutex);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index afc480e6652..5c5ce5bf130 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,8 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
+    WCHAR *preedit_string;
+    DWORD preedit_cursor_pos;
     WCHAR *commit_string;
     struct wl_surface *wl_surface;
     pthread_mutex_t mutex;

From 839aadc5aaac0e2b1f796c8a569218d1bc32d1ba Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 18 Feb 2025 17:32:42 +0200
Subject: [PATCH 06/55] winewayland: Don't crash on text input done events
 without focus.

Some compositors (e.g., kwin) will send a done event for every commit,
regardless of the focus state of the text input. This behavior is
arguably out of spec, but otherwise harmless, so just ignore the new
state in such cases.

(cherry picked from commit 7165437caadcc559d6625f6fd42adb4502c8e11a)
---
 dlls/winewayland.drv/wayland_text_input.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 17257634b2e..e0181eb8240 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -131,11 +131,15 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
 
     pthread_mutex_lock(&text_input->mutex);
-    assert(text_input->wl_surface);
-    hwnd = wl_surface_get_user_data(text_input->wl_surface);
-
-    post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
-            text_input->commit_string);
+    /* Some compositors will send a done event for every commit, regardless of
+     * the focus state of the text input. This behavior is arguably out of spec,
+     * but otherwise harmless, so just ignore the new state in such cases. */
+    if (text_input->wl_surface)
+    {
+        hwnd = wl_surface_get_user_data(text_input->wl_surface);
+        post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
+                text_input->commit_string);
+    }
 
     free(text_input->preedit_string);
     text_input->preedit_string = NULL;

From b31af1e54468fca699eb8c066664e0ff1ab48b02 Mon Sep 17 00:00:00 2001
From: Esme Povirk <esme@codeweavers.com>
Date: Fri, 20 Dec 2024 21:02:07 +0000
Subject: [PATCH 07/55] appwiz.cpl: Account for unicode characters in
 XDG_CACHE_HOME.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57338
(cherry picked from commit 164264216d0a6854cb37f92a7e8abfa480c87784)
---
 dlls/appwiz.cpl/addons.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/dlls/appwiz.cpl/addons.c b/dlls/appwiz.cpl/addons.c
index 1feaf77103d..4dc64606d3f 100644
--- a/dlls/appwiz.cpl/addons.c
+++ b/dlls/appwiz.cpl/addons.c
@@ -317,15 +317,18 @@ static enum install_res install_from_default_dir(void)
 
 static WCHAR *get_cache_file_name(BOOL ensure_exists)
 {
-    const char *xdg_dir;
+    const WCHAR *xdg_dir;
     const WCHAR *home_dir;
-    WCHAR *cache_dir, *ret;
+    WCHAR *cache_dir=NULL, *ret;
     size_t len, size;
 
-    xdg_dir = getenv( "XDG_CACHE_HOME" );
-    if (xdg_dir && *xdg_dir && p_wine_get_dos_file_name)
+    xdg_dir = _wgetenv( L"XDG_CACHE_HOME" );
+    if (xdg_dir && *xdg_dir)
     {
-        if (!(cache_dir = p_wine_get_dos_file_name( xdg_dir ))) return NULL;
+        if (!(cache_dir = HeapAlloc( GetProcessHeap(), 0, wcslen(xdg_dir) * sizeof(WCHAR) + sizeof(L"\\\\?\\unix") ))) return NULL;
+        lstrcpyW( cache_dir, L"\\\\?\\unix" );
+        lstrcatW( cache_dir, xdg_dir );
+        TRACE("cache dir %s\n", debugstr_w(cache_dir));
     }
     else if ((home_dir = _wgetenv( L"WINEHOMEDIR" )))
     {

From df81da452f3b1383254221097d8ff864b6510870 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Thu, 13 Feb 2025 14:34:25 +0100
Subject: [PATCH 08/55] ntdll: Use signed type for IAT offset in
 LdrResolveDelayLoadedAPI.

Allows negative IAT offsets.

(cherry picked from commit fd59962827a715d321f91c9bdb43f3e61f9ebbcb)
---
 dlls/ntdll/loader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 75669e95b72..c9a18f11624 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -3978,7 +3978,7 @@ void* WINAPI LdrResolveDelayLoadedAPI( void* base, const IMAGE_DELAYLOAD_DESCRIP
     HMODULE *phmod;
     NTSTATUS nts;
     FARPROC fp;
-    DWORD id;
+    INT_PTR id;
 
     TRACE( "(%p, %p, %p, %p, %p, 0x%08lx)\n", base, desc, dllhook, syshook, addr, flags );
 

From d3b8cd4ad31182ac6be8535e2183a88594cbb98b Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Thu, 13 Feb 2025 14:37:02 +0100
Subject: [PATCH 09/55] winebuild: Avoid using .idata section for delay-load
 import libraries.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Recent binutils changes merge .idata sections into the read-only .rdata section.
This is intended to make the IAT read-only, as with other modern linkers, but as
a side effect, it broke delay-load import libraries. Delay-load import libraries
should use separate sections regardless.

Since these new sections are not recognized by the linker, it won’t apply special
handling to maintain proper sorting. In practice, this isn’t an issue as long as
the name table and IAT maintain the same order. This may result in negative IAT
offsets (if the base symbol ends up in the middle of the IAT), but Windows appears
to handle this without issues.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57819
(cherry picked from commit c9519f68ea04915a60704534ab3afec5ec1b8fd7)
---
 tools/winebuild/import.c | 36 +++++++++++++++++++++++-------------
 1 file changed, 23 insertions(+), 13 deletions(-)

diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
index 6aee0fa98f8..9a635a8e8f7 100644
--- a/tools/winebuild/import.c
+++ b/tools/winebuild/import.c
@@ -1331,6 +1331,16 @@ static void build_dlltool_import_lib( const char *lib_name, DLLSPEC *spec, struc
     if (files.count) output_static_lib( output_file_name, files, 0 );
 }
 
+static void output_import_section( int index, int is_delay )
+{
+    if (!is_delay)
+        output( "\n\t.section .idata$%d\n", index );
+    else if (index == 5)
+        output( "\n\t.section .data$didat%d\n", index );
+    else
+        output( "\n\t.section .rdata$didat%d\n", index );
+}
+
 /* create a Windows-style import library */
 static void build_windows_import_lib( const char *lib_name, DLLSPEC *spec, struct strarray files )
 {
@@ -1454,20 +1464,20 @@ static void build_windows_import_lib( const char *lib_name, DLLSPEC *spec, struc
         output( "\t.long 0\n" );                         /* UnloadInformationTableRVA */
         output( "\t.long 0\n" );                         /* TimeDateStamp */
 
-        output( "\n\t.section .idata$5\n" );
+        output_import_section( 5, is_delay );
         output( "\t%s 0\n", get_asm_ptr_keyword() );     /* FirstThunk tail */
         output( ".L__wine_import_addrs:\n" );
 
-        output( "\n\t.section .idata$4\n" );
+        output_import_section( 4, is_delay );
         output( "\t%s 0\n", get_asm_ptr_keyword() );     /* OriginalFirstThunk tail */
         output( ".L__wine_import_names:\n" );
 
         /* required to avoid internal linker errors with some binutils versions */
-        output( "\n\t.section .idata$2\n" );
+        output_import_section( 2, is_delay );
     }
     else
     {
-        output( "\n\t.section .idata$2\n" );
+        output_import_section( 2, is_delay );
         output( "%s\n", asm_globl( import_desc ) );
         output_rva( ".L__wine_import_names" );           /* OriginalFirstThunk */
         output( "\t.long 0\n" );                         /* TimeDateStamp */
@@ -1475,10 +1485,10 @@ static void build_windows_import_lib( const char *lib_name, DLLSPEC *spec, struc
         output_rva( "%s", asm_name( import_name ) );     /* Name */
         output_rva( ".L__wine_import_addrs" );           /* FirstThunk */
 
-        output( "\n\t.section .idata$4\n" );
+        output_import_section( 4, is_delay );
         output( ".L__wine_import_names:\n" );            /* OriginalFirstThunk head */
 
-        output( "\n\t.section .idata$5\n" );
+        output_import_section( 5, is_delay );
         output( ".L__wine_import_addrs:\n" );            /* FirstThunk head */
     }
 
@@ -1489,11 +1499,11 @@ static void build_windows_import_lib( const char *lib_name, DLLSPEC *spec, struc
 
     new_output_as_file();
 
-    output( "\n\t.section .idata$4\n" );
+    output_import_section( 4, is_delay );
     output( "\t%s 0\n", get_asm_ptr_keyword() );         /* OriginalFirstThunk tail */
-    output( "\n\t.section .idata$5\n" );
+    output_import_section( 5, is_delay );
     output( "\t%s 0\n", get_asm_ptr_keyword() );         /* FirstThunk tail */
-    output( "\n\t.section .idata$7\n" );
+    output_import_section( 7, is_delay );
     output( "%s\n", asm_globl( import_name ) );
     output( "\t%s \"%s\"\n", get_asm_string_keyword(), spec->file_name );
 
@@ -1584,10 +1594,10 @@ static void build_windows_import_lib( const char *lib_name, DLLSPEC *spec, struc
                 break;
             }
 
-            output( "\n\t.section .idata$4\n" );
+            output_import_section( 4, is_delay );
             output_thunk_rva( by_name ? -1 : odp->ordinal, ".L__wine_import_name" );
 
-            output( "\n\t.section .idata$5\n" );
+            output_import_section( 5, is_delay );
             output( "%s\n", asm_globl( imp_name ) );
             if (is_delay)
                 output( "\t%s .L__wine_delay_import\n", get_asm_ptr_keyword() );
@@ -1596,14 +1606,14 @@ static void build_windows_import_lib( const char *lib_name, DLLSPEC *spec, struc
 
             if (by_name)
             {
-                output( "\n\t.section .idata$6\n" );
+                output_import_section( 6, is_delay );
                 output( ".L__wine_import_name:\n" );
                 output( "\t.short %d\n", odp->hint );
                 output( "\t%s \"%s\"\n", get_asm_string_keyword(), name );
             }
 
             /* reference head object to always pull its sections */
-            output( "\n\t.section .idata$7\n" );
+            output_import_section( 7, is_delay );
             output_rva( "%s", asm_name( import_desc ) );
 
             free( imp_name );

From 79282a51409c62054c10453a3c2f8235e45a0580 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 25 Feb 2025 14:52:38 +0100
Subject: [PATCH 10/55] win32u: Pass a vulkan_instance pointer to
 vulkan_surface_create.

(cherry picked from commit bc16065593065358dcb9ff426ee9647afa501ed8)
---
 dlls/win32u/vulkan.c          | 7 +++----
 dlls/winemac.drv/vulkan.c     | 6 +++---
 dlls/winewayland.drv/vulkan.c | 4 ++--
 dlls/winex11.drv/vulkan.c     | 4 ++--
 include/wine/vulkan_driver.h  | 4 ++--
 5 files changed, 12 insertions(+), 13 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 4cb3997f648..e7795101c3f 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -148,8 +148,7 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance client_instance, cons
         surface->hwnd = dummy;
     }
 
-    if ((res = driver_funcs->p_vulkan_surface_create( surface->hwnd, instance->host.instance,
-                                                      &host_surface, &surface->driver_private )))
+    if ((res = driver_funcs->p_vulkan_surface_create( surface->hwnd, instance, &host_surface, &surface->driver_private )))
     {
         if (dummy) NtUserDestroyWindow( dummy );
         free( surface );
@@ -1454,7 +1453,7 @@ static struct vulkan_funcs vulkan_funcs =
     .p_get_host_surface_extension = win32u_get_host_surface_extension,
 };
 
-static VkResult nulldrv_vulkan_surface_create( HWND hwnd, VkInstance instance, VkSurfaceKHR *surface, void **private )
+static VkResult nulldrv_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface, void **private )
 {
     FIXME( "stub!\n" );
     return VK_ERROR_INCOMPATIBLE_DRIVER;
@@ -1524,7 +1523,7 @@ static void vulkan_driver_load(void)
     pthread_once( &init_once, vulkan_driver_init );
 }
 
-static VkResult lazydrv_vulkan_surface_create( HWND hwnd, VkInstance instance, VkSurfaceKHR *surface, void **private )
+static VkResult lazydrv_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface, void **private )
 {
     vulkan_driver_load();
     return driver_funcs->p_vulkan_surface_create( hwnd, instance, surface, private );
diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index 063666407cd..f570eceb963 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -88,7 +88,7 @@ static void wine_vk_surface_destroy(struct wine_vk_surface *surface)
     free(surface);
 }
 
-static VkResult macdrv_vulkan_surface_create(HWND hwnd, VkInstance instance, VkSurfaceKHR *surface, void **private)
+static VkResult macdrv_vulkan_surface_create(HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface, void **private)
 {
     VkResult res;
     struct wine_vk_surface *mac_surface;
@@ -135,7 +135,7 @@ static VkResult macdrv_vulkan_surface_create(HWND hwnd, VkInstance instance, VkS
         create_info_host.flags = 0; /* reserved */
         create_info_host.pLayer = macdrv_view_get_metal_layer(mac_surface->view);
 
-        res = pvkCreateMetalSurfaceEXT(instance, &create_info_host, NULL /* allocator */, surface);
+        res = pvkCreateMetalSurfaceEXT(instance->host.instance, &create_info_host, NULL /* allocator */, surface);
     }
     else
     {
@@ -145,7 +145,7 @@ static VkResult macdrv_vulkan_surface_create(HWND hwnd, VkInstance instance, VkS
         create_info_host.flags = 0; /* reserved */
         create_info_host.pView = macdrv_view_get_metal_layer(mac_surface->view);
 
-        res = pvkCreateMacOSSurfaceMVK(instance, &create_info_host, NULL /* allocator */, surface);
+        res = pvkCreateMacOSSurfaceMVK(instance->host.instance, &create_info_host, NULL /* allocator */, surface);
     }
     if (res != VK_SUCCESS)
     {
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 0e1c33707d1..03d1ad09db5 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -66,7 +66,7 @@ static void wine_vk_surface_destroy(struct wayland_client_surface *client)
     if (data) wayland_win_data_release(data);
 }
 
-static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, VkSurfaceKHR *surface, void **private)
+static VkResult wayland_vulkan_surface_create(HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface, void **private)
 {
     VkResult res;
     VkWaylandSurfaceCreateInfoKHR create_info_host;
@@ -86,7 +86,7 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, Vk
     create_info_host.display = process_wayland.wl_display;
     create_info_host.surface = client->wl_surface;
 
-    res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host,
+    res = pvkCreateWaylandSurfaceKHR(instance->host.instance, &create_info_host,
                                      NULL /* allocator */,
                                      surface);
     if (res != VK_SUCCESS)
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 332c5dc3be0..894e80f75f5 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -105,7 +105,7 @@ static BOOL disable_opwr(void)
     return disable;
 }
 
-static VkResult X11DRV_vulkan_surface_create( HWND hwnd, VkInstance instance, VkSurfaceKHR *handle, void **private )
+static VkResult X11DRV_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *handle, void **private )
 {
     VkXlibSurfaceCreateInfoKHR info =
     {
@@ -172,7 +172,7 @@ static VkResult X11DRV_vulkan_surface_create( HWND hwnd, VkInstance instance, Vk
     }
 
     info.window = surface->window;
-    if (pvkCreateXlibSurfaceKHR( instance, &info, NULL /* allocator */, handle ))
+    if (pvkCreateXlibSurfaceKHR( instance->host.instance, &info, NULL /* allocator */, handle ))
     {
         ERR("Failed to create Xlib surface\n");
         vulkan_surface_destroy( hwnd, surface );
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 15d03383e12..b385b93017a 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -51,7 +51,7 @@ struct vulkan_client_object
 #include "wine/list.h"
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 35
+#define WINE_VULKAN_DRIVER_VERSION 36
 
 struct vulkan_object
 {
@@ -218,7 +218,7 @@ struct vulkan_funcs
 /* interface between win32u and the user drivers */
 struct vulkan_driver_funcs
 {
-    VkResult (*p_vulkan_surface_create)(HWND, VkInstance, VkSurfaceKHR *, void **);
+    VkResult (*p_vulkan_surface_create)(HWND, const struct vulkan_instance *, VkSurfaceKHR *, void **);
     void (*p_vulkan_surface_destroy)(HWND, void *);
     void (*p_vulkan_surface_detach)(HWND, void *);
     void (*p_vulkan_surface_update)(HWND, void *);

From e374ea3b349252957d38374388a8502648ce885e Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Mon, 17 Feb 2025 04:15:35 +0000
Subject: [PATCH 11/55] winewayland: Update locked pointer position hint.

This may be used by the compositor to warp the Wayland pointer to where
the win32 cursor is upon unlock, if it's within surface bounds.

(cherry picked from commit 80a7181bce11ec770d27a0a71dfe7fab7f565760)
---
 dlls/winewayland.drv/wayland_pointer.c | 30 ++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index c20ba170285..52aaa337aac 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -885,27 +885,53 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor)
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
+    HWND hwnd;
     struct wl_surface *wl_surface = NULL;
     struct wayland_surface *surface = NULL;
     struct wayland_win_data *data;
     BOOL covers_vscreen = FALSE;
     RECT confine_rect;
+    POINT cursor_pos;
+    int warp_x, warp_y;
 
     TRACE("clip=%s reset=%d\n", wine_dbgstr_rect(clip), reset);
 
-    if (!(data = wayland_win_data_get(NtUserGetForegroundWindow()))) return FALSE;
+    NtUserGetCursorPos(&cursor_pos);
+    hwnd = NtUserGetForegroundWindow();
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
     if ((surface = data->wayland_surface))
     {
         wl_surface = surface->wl_surface;
         if (clip) wayland_surface_calc_confine(surface, clip, &confine_rect);
         covers_vscreen = wayland_surface_client_covers_vscreen(surface);
+        wayland_surface_coords_from_window(surface,
+                cursor_pos.x - surface->window.rect.left,
+                cursor_pos.y - surface->window.rect.top,
+                &warp_x, &warp_y);
     }
     wayland_win_data_release(data);
 
+    pthread_mutex_lock(&pointer->mutex);
+    if (wl_surface && hwnd == pointer->constraint_hwnd && pointer->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_set_cursor_position_hint(
+                pointer->zwp_locked_pointer_v1,
+                wl_fixed_from_int(warp_x),
+                wl_fixed_from_int(warp_y));
+        pthread_mutex_unlock(&pointer->mutex);
+
+        data = wayland_win_data_get(hwnd);
+        wl_surface_commit(wl_surface);
+        wayland_win_data_release(data);
+        TRACE("position hint hwnd=%p wayland_xy=%d,%d screen_xy=%d,%d\n",
+                hwnd, warp_x, warp_y, (int)cursor_pos.x, (int)cursor_pos.y);
+        pthread_mutex_lock(&pointer->mutex);
+    }
+
    /* Since we are running in the context of the foreground thread we know
     * that the wl_surface of the foreground HWND will not be invalidated,
     * so we can access it without having the win data lock. */
-    pthread_mutex_lock(&pointer->mutex);
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
                                       covers_vscreen);

From c4d6c0a9bae87e3f19b0370217351445f87d6fa9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 13:23:46 +0200
Subject: [PATCH 12/55] winewayland: Implement zwlr_data_control_device_v1
 initialization.

---
 dlls/winewayland.drv/Makefile.in              |   2 +
 dlls/winewayland.drv/wayland.c                |   8 +
 dlls/winewayland.drv/wayland_data_device.c    |  59 ++++
 dlls/winewayland.drv/waylanddrv.h             |  15 +
 dlls/winewayland.drv/waylanddrv_main.c        |   1 +
 .../wlr-data-control-unstable-v1.xml          | 278 ++++++++++++++++++
 6 files changed, 363 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device.c
 create mode 100644 dlls/winewayland.drv/wlr-data-control-unstable-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9129a3f2839..142db22ba9e 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ SOURCES = \
 	viewporter.xml \
 	vulkan.c \
 	wayland.c \
+	wayland_data_device.c \
 	wayland_keyboard.c \
 	wayland_output.c \
 	wayland_pointer.c \
@@ -22,5 +23,6 @@ SOURCES = \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
+	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
 	xdg-shell.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f4170f6dcc4..2fb0edf8023 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -145,6 +145,9 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
         pthread_mutex_unlock(&seat->mutex);
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
+        /* Recreate the data device for the new seat. */
+        if (process_wayland.data_device.zwlr_data_control_device_v1)
+            wayland_data_device_init();
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -172,6 +175,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
             wl_registry_bind(registry, id, &zwp_text_input_manager_v3_interface, 1);
         if (process_wayland.seat.wl_seat) wayland_text_input_init();
     }
+    else if (strcmp(interface, "zwlr_data_control_manager_v1") == 0)
+    {
+        process_wayland.zwlr_data_control_manager_v1 =
+            wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..6e53ed4046b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,59 @@
+/*
+ * Wayland clipboard
+ *
+ * Copyright 2025 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+void wayland_data_device_init(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+
+    TRACE("\n");
+
+    if (data_device->zwlr_data_control_device_v1)
+        zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
+    data_device->zwlr_data_control_device_v1 =
+        zwlr_data_control_manager_v1_get_data_device(
+            process_wayland.zwlr_data_control_manager_v1,
+            process_wayland.seat.wl_seat);
+}
+
+LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+        pthread_mutex_lock(&process_wayland.seat.mutex);
+        if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
+            wayland_data_device_init();
+        pthread_mutex_unlock(&process_wayland.seat.mutex);
+        return TRUE;
+    }
+
+    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5c5ce5bf130..12ac686fbd9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -35,6 +35,7 @@
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
+#include "wlr-data-control-unstable-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -129,6 +130,11 @@ struct wayland_seat
     pthread_mutex_t mutex;
 };
 
+struct wayland_data_device
+{
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -144,10 +150,12 @@ struct wayland
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
+    struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     struct wayland_text_input text_input;
+    struct wayland_data_device data_device;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
@@ -360,6 +368,12 @@ void wayland_pointer_clear_constraint(void);
 void wayland_text_input_init(void);
 void wayland_text_input_deinit(void);
 
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(void);
+
 /**********************************************************************
  *          OpenGL
  */
@@ -391,6 +405,7 @@ RGNDATA *get_region_data(HRGN region);
  *          USER driver functions
  */
 
+LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 633b2f4a043..ca7ec47b674 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -35,6 +35,7 @@ char *process_name = NULL;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pClipboardWindowProc = WAYLAND_ClipboardWindowProc,
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
diff --git a/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml b/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml
new file mode 100644
index 00000000000..75e8671b0de
--- /dev/null
+++ b/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml
@@ -0,0 +1,278 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_data_control_unstable_v1">
+  <copyright>
+    Copyright © 2018 Simon Ser
+    Copyright © 2019 Ivan Molodetskikh
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="control data devices">
+    This protocol allows a privileged client to control data devices. In
+    particular, the client will be able to manage the current selection and take
+    the role of a clipboard manager.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwlr_data_control_manager_v1" version="2">
+    <description summary="manager to control data devices">
+      This interface is a manager that allows creating per-seat data device
+      controls.
+    </description>
+
+    <request name="create_data_source">
+      <description summary="create a new data source">
+        Create a new data source.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_source_v1"
+        summary="data source to create"/>
+    </request>
+
+    <request name="get_data_device">
+      <description summary="get a data device for a seat">
+        Create a data device that can be used to manage a seat's selection.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_device_v1"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_data_control_device_v1" version="2">
+    <description summary="manage a data device for a seat">
+      This interface allows a client to manage a seat's selection.
+
+      When the seat is destroyed, this object becomes inert.
+    </description>
+
+    <request name="set_selection">
+      <description summary="copy data to the selection">
+        This request asks the compositor to set the selection to the data from
+        the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source is a protocol error.
+
+        To unset the selection, set the source to NULL.
+      </description>
+      <arg name="source" type="object" interface="zwlr_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this data device">
+        Destroys the data device object.
+      </description>
+    </request>
+
+    <event name="data_offer">
+      <description summary="introduce a new wlr_data_control_offer">
+        The data_offer event introduces a new wlr_data_control_offer object,
+        which will subsequently be used in either the
+        wlr_data_control_device.selection event (for the regular clipboard
+        selections) or the wlr_data_control_device.primary_selection event (for
+        the primary clipboard selections). Immediately following the
+        wlr_data_control_device.data_offer event, the new data_offer object
+        will send out wlr_data_control_offer.offer events to describe the MIME
+        types it offers.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_offer_v1"/>
+    </event>
+
+    <event name="selection">
+      <description summary="advertise new selection">
+        The selection event is sent out to notify the client of a new
+        wlr_data_control_offer for the selection for this device. The
+        wlr_data_control_device.data_offer and the wlr_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The selection event is sent to a client when a new
+        selection is set. The wlr_data_control_offer is valid until a new
+        wlr_data_control_offer or NULL is received. The client must destroy the
+        previous selection wlr_data_control_offer, if any, upon receiving this
+        event.
+
+        The first selection event is sent upon binding the
+        wlr_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="zwlr_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <event name="finished">
+      <description summary="this data control is no longer valid">
+        This data control object is no longer valid and should be destroyed by
+        the client.
+      </description>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <event name="primary_selection" since="2">
+      <description summary="advertise new primary selection">
+        The primary_selection event is sent out to notify the client of a new
+        wlr_data_control_offer for the primary selection for this device. The
+        wlr_data_control_device.data_offer and the wlr_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The primary_selection event is sent to a client when a
+        new primary selection is set. The wlr_data_control_offer is valid until
+        a new wlr_data_control_offer or NULL is received. The client must
+        destroy the previous primary selection wlr_data_control_offer, if any,
+        upon receiving this event.
+
+        If the compositor supports primary selection, the first
+        primary_selection event is sent upon binding the
+        wlr_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="zwlr_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <request name="set_primary_selection" since="2">
+      <description summary="copy data to the primary selection">
+        This request asks the compositor to set the primary selection to the
+        data from the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source is a protocol error.
+
+        To unset the primary selection, set the source to NULL.
+
+        The compositor will ignore this request if it does not support primary
+        selection.
+      </description>
+      <arg name="source" type="object" interface="zwlr_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <enum name="error" since="2">
+      <entry name="used_source" value="1"
+        summary="source given to set_selection or set_primary_selection was already used before"/>
+    </enum>
+  </interface>
+
+  <interface name="zwlr_data_control_source_v1" version="1">
+    <description summary="offer to transfer data">
+      The wlr_data_control_source object is the source side of a
+      wlr_data_control_offer. It is created by the source client in a data
+      transfer and provides a way to describe the offered data and a way to
+      respond to requests to transfer the data.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_offer" value="1"
+        summary="offer sent after wlr_data_control_device.set_selection"/>
+    </enum>
+
+    <request name="offer">
+      <description summary="add an offered MIME type">
+        This request adds a MIME type to the set of MIME types advertised to
+        targets. Can be called several times to offer multiple types.
+
+        Calling this after wlr_data_control_device.set_selection is a protocol
+        error.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type offered by the data source"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this source">
+        Destroys the data source object.
+      </description>
+    </request>
+
+    <event name="send">
+      <description summary="send the data">
+        Request for data from the client. Send the data as the specified MIME
+        type over the passed file descriptor, then close it.
+      </description>
+      <arg name="mime_type" type="string" summary="MIME type for the data"/>
+      <arg name="fd" type="fd" summary="file descriptor for the data"/>
+    </event>
+
+    <event name="cancelled">
+      <description summary="selection was cancelled">
+        This data source is no longer valid. The data source has been replaced
+        by another data source.
+
+        The client should clean up and destroy this data source.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="zwlr_data_control_offer_v1" version="1">
+    <description summary="offer to transfer data">
+      A wlr_data_control_offer represents a piece of data offered for transfer
+      by another client (the source client). The offer describes the different
+      MIME types that the data can be converted to and provides the mechanism
+      for transferring the data directly from the source client.
+    </description>
+
+    <request name="receive">
+      <description summary="request that the data is transferred">
+        To transfer the offered data, the client issues this request and
+        indicates the MIME type it wants to receive. The transfer happens
+        through the passed file descriptor (typically created with the pipe
+        system call). The source client writes the data in the MIME type
+        representation requested and then closes the file descriptor.
+
+        The receiving client reads from the read end of the pipe until EOF and
+        then closes its end, at which point the transfer is complete.
+
+        This request may happen multiple times for different MIME types.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type desired by receiver"/>
+      <arg name="fd" type="fd" summary="file descriptor for data transfer"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this offer">
+        Destroys the data offer object.
+      </description>
+    </request>
+
+    <event name="offer">
+      <description summary="advertise offered MIME type">
+        Sent immediately after creating the wlr_data_control_offer object.
+        One event per offered MIME type.
+      </description>
+      <arg name="mime_type" type="string" summary="offered MIME type"/>
+    </event>
+  </interface>
+</protocol>

From 6555fbba8d5503fe289d6e94bb215e9e41772b9c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 14:33:53 +0200
Subject: [PATCH 13/55] winewayland: Support copying text from win32 clipboard
 to native apps.

---
 dlls/winewayland.drv/wayland.c             |   1 +
 dlls/winewayland.drv/wayland_data_device.c | 173 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 3 files changed, 176 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2fb0edf8023..ee162d8fe77 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -38,6 +38,7 @@ struct wayland process_wayland =
     .keyboard.mutex = PTHREAD_MUTEX_INITIALIZER,
     .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
     .text_input.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .data_device.mutex = PTHREAD_MUTEX_INITIALIZER,
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
     .output_mutex = PTHREAD_MUTEX_INITIALIZER
 };
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 6e53ed4046b..b51f5b25ed4 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -24,23 +24,191 @@
 
 #include "config.h"
 
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+static HWND clipboard_hwnd;
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+    ssize_t ret;
+
+    while (nwritten < count)
+    {
+        ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR) break;
+        else if (ret > 0) nwritten += ret;
+    }
+
+    if (nwritten < count)
+    {
+        WARN("Failed to write all clipboard data, had %zu bytes, wrote %zu bytes\n",
+             count, nwritten);
+    }
+}
+
+static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
+{
+    DWORD byte_count;
+    char *bytes;
+
+    /* Wayland apps expect strings to not be zero-terminated, so avoid
+     * zero-terminating the resulting converted string. */
+    if (size >= sizeof(WCHAR) && ((WCHAR *)data)[size / sizeof(WCHAR) - 1] == 0)
+        size -= sizeof(WCHAR);
+
+    RtlUnicodeToUTF8N(NULL, 0, &byte_count, data, size);
+    if (!(bytes = malloc(byte_count))) return NULL;
+    RtlUnicodeToUTF8N(bytes, byte_count, &byte_count, data, size);
+
+    *ret_size = byte_count;
+    return bytes;
+}
+
+/**********************************************************************
+ *          zwlr_data_control_source_v1 handling
+ */
+
+static void wayland_data_source_export(int32_t fd)
+{
+    struct get_clipboard_params params = { .data_only = TRUE, .size = 1024 };
+    void *exported = NULL;
+    size_t exported_size;
+
+    TRACE("\n");
+
+    if (!NtUserOpenClipboard(clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    for (;;)
+    {
+        if (!(params.data = malloc(params.size))) break;
+        if (NtUserGetClipboardData(CF_UNICODETEXT, &params))
+        {
+            exported = export_unicode_text(params.data, params.size, &exported_size);
+            break;
+        }
+        if (!params.data_size) break;
+        free(params.data);
+        params.size = params.data_size;
+        params.data_size = 0;
+    }
+
+    NtUserCloseClipboard();
+    if (exported) write_all(fd, exported, exported_size);
+
+    free(exported);
+    free(params.data);
+}
+
+static void data_control_source_send(void *data,
+                                     struct zwlr_data_control_source_v1 *source,
+                                     const char *mime_type, int32_t fd)
+{
+    if (!strcmp(mime_type, "text/plain;charset=utf-8"))
+        wayland_data_source_export(fd);
+    close(fd);
+}
+
+static void data_control_source_cancelled(void *data,
+                                          struct zwlr_data_control_source_v1 *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    zwlr_data_control_source_v1_destroy(source);
+    if (source == data_device->zwlr_data_control_source_v1)
+        data_device->zwlr_data_control_source_v1 = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static const struct zwlr_data_control_source_v1_listener data_control_source_listener =
+{
+    data_control_source_send,
+    data_control_source_cancelled,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
 
     TRACE("\n");
 
+    pthread_mutex_lock(&data_device->mutex);
     if (data_device->zwlr_data_control_device_v1)
         zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
     data_device->zwlr_data_control_device_v1 =
         zwlr_data_control_manager_v1_get_data_device(
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void clipboard_update(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct zwlr_data_control_source_v1 *source;
+    UINT *formats, formats_size = 256, i;
+
+    if (!process_wayland.zwlr_data_control_manager_v1) return;
+
+    TRACE("\n");
+
+    source = zwlr_data_control_manager_v1_create_data_source(
+        process_wayland.zwlr_data_control_manager_v1);
+    if (!source)
+    {
+        ERR("failed to create data source\n");
+        return;
+    }
+
+    for (;;)
+    {
+        if (!(formats = malloc(formats_size * sizeof(*formats)))) break;
+        if (NtUserGetUpdatedClipboardFormats(formats, formats_size, &formats_size)) break;
+        free(formats);
+        formats = NULL;
+        if (RtlGetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER) break;
+    }
+
+    if (!formats && formats_size)
+    {
+        ERR("failed to get clipboard formats\n");
+        zwlr_data_control_source_v1_destroy(source);
+        return;
+    }
+
+    for (i = 0; i < formats_size; ++i)
+    {
+        if (formats[i] == CF_UNICODETEXT)
+            zwlr_data_control_source_v1_offer(source, "text/plain;charset=utf-8");
+    }
+
+    free(formats);
+
+    zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
+
+    pthread_mutex_lock(&data_device->mutex);
+    if (data_device->zwlr_data_control_device_v1)
+        zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, source);
+    /* Destroy any previous source only after setting the new source, to
+     * avoid spurious 'selection(nil)' events. */
+    if (data_device->zwlr_data_control_source_v1)
+        zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
+    data_device->zwlr_data_control_source_v1 = source;
+    pthread_mutex_unlock(&data_device->mutex);
+
+    wl_display_flush(process_wayland.wl_display);
 }
 
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
@@ -48,11 +216,16 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
     switch (msg)
     {
     case WM_NCCREATE:
+        clipboard_hwnd = hwnd;
+        NtUserAddClipboardFormatListener(hwnd);
         pthread_mutex_lock(&process_wayland.seat.mutex);
         if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
             wayland_data_device_init();
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        clipboard_update();
+        break;
     }
 
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12ac686fbd9..c8f0ede23ba 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,6 +133,8 @@ struct wayland_seat
 struct wayland_data_device
 {
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+    struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+    pthread_mutex_t mutex;
 };
 
 struct wayland

From d34c869328f5d145ab2fd99827637500d59a374c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Jan 2025 11:10:30 +0200
Subject: [PATCH 14/55] winewayland: Generalize support for exporting clipboard
 formats.

Introduce the infrastructure to export various clipboard formats in a
table-driven manner, similar to what's used by winex11.
---
 dlls/winewayland.drv/wayland_data_device.c | 62 +++++++++++++++++++---
 1 file changed, 54 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index b51f5b25ed4..77b9f4f7af0 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -33,6 +33,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+struct data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    void *(*export)(void *data, size_t size, size_t *ret_size);
+};
+
 static HWND clipboard_hwnd;
 
 static void write_all(int fd, const void *buf, size_t count)
@@ -72,17 +79,49 @@ static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
     return bytes;
 }
 
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct data_device_format supported_formats[] =
+{
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, export_unicode_text},
+    {NULL, 0, NULL},
+};
+
+static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format)
+{
+    struct data_device_format *format;
+
+    for (format = supported_formats; format->mime_type; ++format)
+    {
+        if (format->clipboard_format == clipboard_format) return format;
+    }
+
+    return NULL;
+}
+
+static struct data_device_format *data_device_format_for_mime_type(const char *mime)
+{
+    struct data_device_format *format;
+
+    for (format = supported_formats; format->mime_type; ++format)
+    {
+        if (!strcmp(mime, format->mime_type)) return format;
+    }
+
+    return NULL;
+}
+
 /**********************************************************************
  *          zwlr_data_control_source_v1 handling
  */
 
-static void wayland_data_source_export(int32_t fd)
+static void wayland_data_source_export(struct data_device_format *format, int fd)
 {
     struct get_clipboard_params params = { .data_only = TRUE, .size = 1024 };
     void *exported = NULL;
     size_t exported_size;
 
-    TRACE("\n");
+    TRACE("format=%u => mime=%s\n", format->clipboard_format, format->mime_type);
 
     if (!NtUserOpenClipboard(clipboard_hwnd, 0))
     {
@@ -93,9 +132,9 @@ static void wayland_data_source_export(int32_t fd)
     for (;;)
     {
         if (!(params.data = malloc(params.size))) break;
-        if (NtUserGetClipboardData(CF_UNICODETEXT, &params))
+        if (NtUserGetClipboardData(format->clipboard_format, &params))
         {
-            exported = export_unicode_text(params.data, params.size, &exported_size);
+            exported = format->export(params.data, params.size, &exported_size);
             break;
         }
         if (!params.data_size) break;
@@ -115,8 +154,10 @@ static void data_control_source_send(void *data,
                                      struct zwlr_data_control_source_v1 *source,
                                      const char *mime_type, int32_t fd)
 {
-    if (!strcmp(mime_type, "text/plain;charset=utf-8"))
-        wayland_data_source_export(fd);
+    struct data_device_format *format =
+        data_device_format_for_mime_type(mime_type);
+
+    if (format) wayland_data_source_export(format, fd);
     close(fd);
 }
 
@@ -190,8 +231,13 @@ static void clipboard_update(void)
 
     for (i = 0; i < formats_size; ++i)
     {
-        if (formats[i] == CF_UNICODETEXT)
-            zwlr_data_control_source_v1_offer(source, "text/plain;charset=utf-8");
+        struct data_device_format *format =
+            data_device_format_for_clipboard_format(formats[i]);
+        if (format)
+        {
+            TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
+            zwlr_data_control_source_v1_offer(source, format->mime_type);
+        }
     }
 
     free(formats);

From 866f55251fe52df85c7f51d69afd0012b491f6dc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Jan 2025 11:31:48 +0200
Subject: [PATCH 15/55] winewayland: Support exporting various clipboard
 formats.

Add support for some formats commonly used in applications and which
do not require special exporting: RTF, TIFF, PNG, JPEG, GIF, SVG, RIFF, WAV.
---
 dlls/winewayland.drv/wayland_data_device.c | 39 ++++++++++++++++++++--
 1 file changed, 37 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 77b9f4f7af0..1659e9bd6df 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -37,10 +37,16 @@ struct data_device_format
 {
     const char *mime_type;
     UINT clipboard_format;
+    const WCHAR *register_name;
     void *(*export)(void *data, size_t size, size_t *ret_size);
 };
 
 static HWND clipboard_hwnd;
+static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+static const WCHAR pngW[] = {'P','N','G',0};
+static const WCHAR jfifW[] = {'J','F','I','F',0};
+static const WCHAR gifW[] = {'G','I','F',0};
+static const WCHAR image_svg_xmlW[] = {'i','m','a','g','e','/','s','v','g','+','x','m','l',0};
 
 static void write_all(int fd, const void *buf, size_t count)
 {
@@ -79,11 +85,26 @@ static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
     return bytes;
 }
 
+static void *export_data(void *data, size_t size, size_t *ret_size)
+{
+    *ret_size = size;
+    return data;
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct data_device_format supported_formats[] =
 {
-    {"text/plain;charset=utf-8", CF_UNICODETEXT, export_unicode_text},
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text},
+    {"text/rtf", 0, rich_text_formatW, export_data},
+    {"image/tiff", CF_TIFF, NULL, export_data},
+    {"image/png", 0, pngW, export_data},
+    {"image/jpeg", 0, jfifW, export_data},
+    {"image/gif", 0, gifW, export_data},
+    {"image/svg+xml", 0, image_svg_xmlW, export_data},
+    {"application/x-riff", CF_RIFF, NULL, export_data},
+    {"audio/wav", CF_WAVE, NULL, export_data},
+    {"audio/x-wav", CF_WAVE, NULL, export_data},
     {NULL, 0, NULL},
 };
 
@@ -111,6 +132,13 @@ static struct data_device_format *data_device_format_for_mime_type(const char *m
     return NULL;
 }
 
+static ATOM register_clipboard_format(const WCHAR *name)
+{
+    ATOM atom;
+    if (NtAddAtom(name, lstrlenW(name) * sizeof(WCHAR), &atom)) return 0;
+    return atom;
+}
+
 /**********************************************************************
  *          zwlr_data_control_source_v1 handling
  */
@@ -146,7 +174,7 @@ static void wayland_data_source_export(struct data_device_format *format, int fd
     NtUserCloseClipboard();
     if (exported) write_all(fd, exported, exported_size);
 
-    free(exported);
+    if (exported != params.data) free(exported);
     free(params.data);
 }
 
@@ -182,6 +210,7 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct data_device_format *format = supported_formats;
 
     TRACE("\n");
 
@@ -193,6 +222,12 @@ void wayland_data_device_init(void)
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
     pthread_mutex_unlock(&data_device->mutex);
+
+    for (; format->mime_type; ++format)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = register_clipboard_format(format->register_name);
+    }
 }
 
 static void clipboard_update(void)

From 323dc3e1562a62f5a406bf277c11506a5441687a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Jan 2025 10:23:44 +0200
Subject: [PATCH 16/55] winewayland: Support copying data from native clipboard
 to win32 apps.

---
 dlls/winewayland.drv/wayland_data_device.c | 379 ++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 367 insertions(+), 13 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 1659e9bd6df..4018386b97c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -25,6 +25,7 @@
 #include "config.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -33,12 +34,23 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+/* A special MIME type we mark our data offers with, so we can detect that
+ * they are coming from us. */
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
 struct data_device_format
 {
     const char *mime_type;
     UINT clipboard_format;
     const WCHAR *register_name;
     void *(*export)(void *data, size_t size, size_t *ret_size);
+    void *(*import)(void *data, size_t size, size_t *ret_size);
+};
+
+struct wayland_data_offer
+{
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+    struct wl_array types;
 };
 
 static HWND clipboard_hwnd;
@@ -67,6 +79,59 @@ static void write_all(int fd, const void *buf, size_t count)
     }
 }
 
+static void *read_all(int fd, size_t *size_out)
+{
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    if (!(buffer = malloc(buffer_size)))
+    {
+        ERR("failed to allocate read buffer\n");
+        goto out;
+    }
+
+    do
+    {
+        nread = read(fd, buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            TRACE("failed to read from fd (errno: %d)\n", errno);
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                unsigned char *new_buffer;
+                buffer_size *= 2;
+                new_buffer = realloc(buffer, buffer_size);
+                if (!new_buffer)
+                {
+                    ERR("failed to reallocate read buffer\n");
+                    total = 0;
+                    goto out;
+                }
+                buffer = new_buffer;
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("read %d bytes\n", total);
+
+out:
+    if (total == 0 && buffer != NULL)
+    {
+        free(buffer);
+        buffer = NULL;
+    }
+    *size_out = total;
+    return buffer;
+}
+
 static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
 {
     DWORD byte_count;
@@ -91,30 +156,66 @@ static void *export_data(void *data, size_t size, size_t *ret_size)
     return data;
 }
 
+static void *import_unicode_text(void *data, size_t size, size_t *ret_size)
+{
+    DWORD wsize;
+    WCHAR *ret;
+
+    RtlUTF8ToUnicodeN(NULL, 0, &wsize, data, size);
+    if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+    RtlUTF8ToUnicodeN(ret, wsize, &wsize, data, size);
+    ret[wsize / sizeof(WCHAR)] = 0;
+
+    *ret_size = wsize + sizeof(WCHAR);
+
+    return ret;
+}
+
+static void *import_data(void *data, size_t size, size_t *ret_size)
+{
+    *ret_size = size;
+    return data;
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct data_device_format supported_formats[] =
 {
-    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text},
-    {"text/rtf", 0, rich_text_formatW, export_data},
-    {"image/tiff", CF_TIFF, NULL, export_data},
-    {"image/png", 0, pngW, export_data},
-    {"image/jpeg", 0, jfifW, export_data},
-    {"image/gif", 0, gifW, export_data},
-    {"image/svg+xml", 0, image_svg_xmlW, export_data},
-    {"application/x-riff", CF_RIFF, NULL, export_data},
-    {"audio/wav", CF_WAVE, NULL, export_data},
-    {"audio/x-wav", CF_WAVE, NULL, export_data},
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text, import_unicode_text},
+    {"text/rtf", 0, rich_text_formatW, export_data, import_data},
+    {"image/tiff", CF_TIFF, NULL, export_data, import_data},
+    {"image/png", 0, pngW, export_data, import_data},
+    {"image/jpeg", 0, jfifW, export_data, import_data},
+    {"image/gif", 0, gifW, export_data, import_data},
+    {"image/svg+xml", 0, image_svg_xmlW, export_data, import_data},
+    {"application/x-riff", CF_RIFF, NULL, export_data, import_data},
+    {"audio/wav", CF_WAVE, NULL, export_data, import_data},
+    {"audio/x-wav", CF_WAVE, NULL, export_data, import_data},
     {NULL, 0, NULL},
 };
 
-static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format)
+static BOOL string_array_contains(struct wl_array *array, const char *str)
+{
+    char **p;
+
+    wl_array_for_each(p, array)
+        if (!strcmp(*p, str)) return TRUE;
+
+    return FALSE;
+}
+
+static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                          struct wl_array *types)
 {
     struct data_device_format *format;
 
     for (format = supported_formats; format->mime_type; ++format)
     {
-        if (format->clipboard_format == clipboard_format) return format;
+        if (format->clipboard_format == clipboard_format &&
+            (!types || string_array_contains(types, format->mime_type)))
+        {
+            return format;
+        }
     }
 
     return NULL;
@@ -207,6 +308,202 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
     data_control_source_cancelled,
 };
 
+/**********************************************************************
+ *          zwlr_data_control_offer_v1 handling
+ */
+
+static void data_control_offer_offer(void *data,
+                                     struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1,
+                                     const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    const char *type_copy;
+    const char **p;
+
+    if ((type_copy = strdup(type)) &&
+        (p = wl_array_add(&data_offer->types, sizeof *p)))
+    {
+        *p = type_copy;
+    }
+}
+
+static const struct zwlr_data_control_offer_v1_listener data_control_offer_listener =
+{
+    data_control_offer_offer,
+};
+
+static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    struct wayland_data_offer *data_offer;
+
+    if (!(data_offer = calloc(1, sizeof(*data_offer))))
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    wl_array_init(&data_offer->types);
+    zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
+                                            &data_control_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+
+    zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    wl_array_for_each(p, &data_offer->types)
+        free(*p);
+    wl_array_release(&data_offer->types);
+    free(data_offer);
+}
+
+static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offer,
+                                            const char *mime_type)
+{
+    int data_pipe[2];
+
+#if HAVE_PIPE2
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+#endif
+    {
+        if (pipe(data_pipe) == -1)
+        {
+            ERR("failed to create clipboard data pipe\n");
+            return -1;
+        }
+        fcntl(data_pipe[0], F_SETFD, FD_CLOEXEC);
+        fcntl(data_pipe[1], F_SETFD, FD_CLOEXEC);
+    }
+
+    zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
+                                       mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(process_wayland.wl_display);
+
+    return data_pipe[0];
+}
+
+static void *import_format(int fd, struct data_device_format *format, size_t *ret_size)
+{
+    size_t size;
+    void *data, *ret;
+
+    if (!(data = read_all(fd, &size))) return NULL;
+    ret = format->import(data, size, ret_size);
+    if (ret != data) free(data);
+    return ret;
+}
+
+/**********************************************************************
+ *          zwlr_data_control_device_v1 handling
+ */
+
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_zwlr_data_control_offer_v1)
+    {
+        struct wayland_data_offer *data_offer =
+            zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1);
+        if (data_offer) wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
+    }
+}
+
+static void data_control_device_data_offer(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    wayland_data_offer_create(zwlr_data_control_offer_v1);
+}
+
+static void clipboard_update(void);
+
+static void data_control_device_selection(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer = NULL;
+    char **p;
+
+    if (!zwlr_data_control_offer_v1 ||
+        !(data_offer = zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1)))
+    {
+        TRACE("empty offer, clearing clipboard\n");
+        if (NtUserOpenClipboard(clipboard_hwnd, 0))
+        {
+            NtUserEmptyClipboard();
+            NtUserCloseClipboard();
+        }
+        goto done;
+    }
+
+    TRACE("updating clipboard from wayland offer\n");
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * by a winewayland process to notify external wayland clients about a Wine
+     * clipboard update. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("offer sent by winewayland, ignoring\n");
+            wayland_data_offer_destroy(data_offer);
+            data_offer = NULL;
+            goto done;
+        }
+    }
+
+    if (!NtUserOpenClipboard(clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for selection\n");
+        wayland_data_offer_destroy(data_offer);
+        data_offer = NULL;
+        goto done;
+    }
+
+    NtUserEmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct data_device_format *format = data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            struct set_clipboard_params params = {0};
+            TRACE("available clipboard format for %s => %u\n",
+                  *p, format->clipboard_format);
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+done:
+    pthread_mutex_lock(&data_device->mutex);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    if (data_offer) data_device->clipboard_zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void data_control_device_finished(
+    void *data, struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1)
+{
+}
+
+static const struct zwlr_data_control_device_v1_listener data_control_device_listener =
+{
+    data_control_device_data_offer,
+    data_control_device_selection,
+    data_control_device_finished,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -221,6 +518,12 @@ void wayland_data_device_init(void)
         zwlr_data_control_manager_v1_get_data_device(
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
+    if (data_device->zwlr_data_control_device_v1)
+    {
+        zwlr_data_control_device_v1_add_listener(
+            data_device->zwlr_data_control_device_v1, &data_control_device_listener,
+            data_device);
+    }
     pthread_mutex_unlock(&data_device->mutex);
 
     for (; format->mime_type; ++format)
@@ -267,7 +570,7 @@ static void clipboard_update(void)
     for (i = 0; i < formats_size; ++i)
     {
         struct data_device_format *format =
-            data_device_format_for_clipboard_format(formats[i]);
+            data_device_format_for_clipboard_format(formats[i], NULL);
         if (format)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
@@ -277,6 +580,7 @@ static void clipboard_update(void)
 
     free(formats);
 
+    zwlr_data_control_source_v1_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
     zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
 
     pthread_mutex_lock(&data_device->mutex);
@@ -292,6 +596,48 @@ static void clipboard_update(void)
     wl_display_flush(process_wayland.wl_display);
 }
 
+static void render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct wayland_data_offer *data_offer;
+    struct data_device_format *format;
+    int import_fd = -1;
+
+    TRACE("clipboard_format=%u\n", clipboard_format);
+
+    pthread_mutex_lock(&data_device->mutex);
+    if (data_device->clipboard_zwlr_data_control_offer_v1 &&
+        (data_offer = zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1)) &&
+        (format = data_device_format_for_clipboard_format(clipboard_format,
+                                                          &data_offer->types)))
+    {
+        import_fd = wayland_data_offer_get_import_fd(data_offer, format->mime_type);
+    }
+    pthread_mutex_unlock(&data_device->mutex);
+
+    if (import_fd >= 0)
+    {
+        struct set_clipboard_params params = {0};
+        if ((params.data = import_format(import_fd, format, &params.size)))
+        {
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+            free(params.data);
+        }
+        close(import_fd);
+    }
+}
+
+static void destroy_clipboard(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+
+    TRACE("\n");
+
+    pthread_mutex_lock(&data_device->mutex);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     switch (msg)
@@ -305,8 +651,15 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
     case WM_CLIPBOARDUPDATE:
+        if (NtUserGetClipboardOwner() == clipboard_hwnd) break;
         clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        render_format(wparam);
+        break;
+    case WM_DESTROYCLIPBOARD:
+        destroy_clipboard();
+        break;
     }
 
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c8f0ede23ba..c389167c3b7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -134,6 +134,7 @@ struct wayland_data_device
 {
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
     struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+    struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
     pthread_mutex_t mutex;
 };
 

From b6d9946bb82e41cf8c4c49d88848b3a7d4aa6c5a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Jan 2025 13:39:02 +0200
Subject: [PATCH 17/55] winewayland: Normalize received MIME type strings.

---
 dlls/winewayland.drv/wayland_data_device.c | 45 +++++++++++++++++++---
 1 file changed, 39 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 4018386b97c..04872df4fcb 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -60,6 +60,35 @@ static const WCHAR jfifW[] = {'J','F','I','F',0};
 static const WCHAR gifW[] = {'G','I','F',0};
 static const WCHAR image_svg_xmlW[] = {'i','m','a','g','e','/','s','v','g','+','x','m','l',0};
 
+/* Normalize the MIME type string by skipping inconsequential characters,
+ * such as spaces and double quotes, and convert to lower case. */
+static const char *normalize_mime_type(const char *mime_type)
+{
+    char *new_mime_type;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    for (cur_read = mime_type; *cur_read != '\0'; ++cur_read)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime_type = malloc(new_mime_len + 1);
+    if (!new_mime_type) return NULL;
+
+    for (cur_read = mime_type, cur_write = new_mime_type; *cur_read != '\0'; ++cur_read)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime_type;
+}
+
 static void write_all(int fd, const void *buf, size_t count)
 {
     size_t nwritten = 0;
@@ -283,10 +312,14 @@ static void data_control_source_send(void *data,
                                      struct zwlr_data_control_source_v1 *source,
                                      const char *mime_type, int32_t fd)
 {
-    struct data_device_format *format =
-        data_device_format_for_mime_type(mime_type);
+    struct data_device_format *format;
+    const char *normalized;
 
-    if (format) wayland_data_source_export(format, fd);
+    if ((normalized = normalize_mime_type(mime_type)) &&
+        (format = data_device_format_for_mime_type(normalized)))
+    {
+        wayland_data_source_export(format, fd);
+    }
     close(fd);
 }
 
@@ -317,13 +350,13 @@ static void data_control_offer_offer(void *data,
                                      const char *type)
 {
     struct wayland_data_offer *data_offer = data;
-    const char *type_copy;
+    const char *normalized;
     const char **p;
 
-    if ((type_copy = strdup(type)) &&
+    if ((normalized = normalize_mime_type(type)) &&
         (p = wl_array_add(&data_offer->types, sizeof *p)))
     {
-        *p = type_copy;
+        *p = normalized;
     }
 }
 

From a5f8d03e84f62ee7248d37c10f155c43e2860050 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 16 Feb 2025 10:00:41 +0000
Subject: [PATCH 18/55] winewayland: Implement SetCursorPos via pointer lock.

---
 dlls/winewayland.drv/wayland_pointer.c | 42 ++++++++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 39 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 52aaa337aac..e2b31e02011 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -745,7 +745,8 @@ static BOOL wayland_surface_client_covers_vscreen(struct wayland_surface *surfac
  */
 static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
                                               RECT *confine_rect,
-                                              BOOL covers_vscreen)
+                                              BOOL covers_vscreen,
+                                              BOOL force_lock)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     BOOL needs_relative, needs_lock, needs_confine;
@@ -758,9 +759,10 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_lock = wl_surface && (confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface;
-    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface;
+    needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
+                 !pointer->cursor.wl_surface) || force_lock);
+    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
+                 !force_lock;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
@@ -866,7 +868,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
 void wayland_pointer_clear_constraint(void)
 {
-    wayland_pointer_update_constraint(NULL, NULL, FALSE);
+    wayland_pointer_update_constraint(NULL, NULL, FALSE, FALSE);
 }
 
 /***********************************************************************
@@ -879,6 +881,27 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor)
     wayland_set_cursor(hwnd, hcursor, TRUE);
 }
 
+/***********************************************************************
+ *           WAYLAND_SetCursorPos
+ */
+BOOL WAYLAND_SetCursorPos(INT x, INT y)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    pthread_mutex_lock(&pointer->mutex);
+    if (pointer->zwp_relative_pointer_v1)
+    {
+        pthread_mutex_unlock(&pointer->mutex);
+        return FALSE;
+    }
+    pointer->pending_warp = TRUE;
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("warping to %d,%d\n", x, y);
+    reapply_cursor_clipping();
+    return TRUE;
+}
+
 /***********************************************************************
  *	     WAYLAND_ClipCursor
  */
@@ -913,6 +936,12 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     wayland_win_data_release(data);
 
     pthread_mutex_lock(&pointer->mutex);
+    if (wl_surface && pointer->pending_warp)
+    {
+        wayland_pointer_update_constraint(wl_surface, NULL, FALSE, TRUE);
+        pointer->pending_warp = FALSE;
+    }
+
     if (wl_surface && hwnd == pointer->constraint_hwnd && pointer->zwp_locked_pointer_v1)
     {
         zwp_locked_pointer_v1_set_cursor_position_hint(
@@ -934,7 +963,8 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     * so we can access it without having the win data lock. */
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
-                                      covers_vscreen);
+                                      covers_vscreen,
+                                      FALSE);
     pthread_mutex_unlock(&pointer->mutex);
 
     wl_display_flush(process_wayland.wl_display);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c389167c3b7..ead2269b72c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -107,6 +107,7 @@ struct wayland_pointer
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
     HWND focused_hwnd;
     HWND constraint_hwnd;
+    BOOL pending_warp;
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
@@ -414,6 +415,7 @@ LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
+BOOL WAYLAND_SetCursorPos(INT x, INT y);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
 UINT WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager, void *param);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index ca7ec47b674..1d4ddeb3425 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -43,6 +43,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetCursorPos = WAYLAND_SetCursorPos,
     .pSetWindowText = WAYLAND_SetWindowText,
     .pSysCommand = WAYLAND_SysCommand,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,

From efc001f2ee82e49f9013c867d2666a4ceed5126f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 19 Feb 2025 23:09:03 +0100
Subject: [PATCH 19/55] winewayland: Remove now unnecessary wine_get_wgl_driver
 init guard.

---
 dlls/winewayland.drv/opengl.c | 47 +++++++++++------------------------
 1 file changed, 14 insertions(+), 33 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b8b673f398a..18d304c2754 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1155,19 +1155,12 @@ static void describe_pixel_format(EGLConfig config, struct wgl_pixel_format *fmt
 #undef SET_ATTRIB_ARB
 }
 
-static BOOL has_opengl(void);
-
 static void wayland_get_pixel_formats(struct wgl_pixel_format *formats,
                                       UINT max_formats, UINT *num_formats,
                                       UINT *num_onscreen_formats)
 {
     UINT i;
 
-    if (!has_opengl())
-    {
-        *num_formats = *num_onscreen_formats = 0;
-        return;
-    }
     if (formats)
     {
         for (i = 0; i < min(max_formats, num_egl_configs); ++i)
@@ -1320,15 +1313,25 @@ static BOOL init_egl_configs(void)
     return TRUE;
 }
 
-static void init_opengl(void)
+/**********************************************************************
+ *           WAYLAND_wine_get_wgl_driver
+ */
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
 {
     EGLint egl_version[2];
     const char *egl_client_exts, *egl_exts;
 
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR("Version mismatch, opengl32 wants %u but driver has %u\n",
+            version, WINE_WGL_DRIVER_VERSION);
+        return NULL;
+    }
+
     if (!(egl_handle = dlopen(SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL)))
     {
         ERR("Failed to load %s: %s\n", SONAME_LIBEGL, dlerror());
-        return;
+        return NULL;
     }
 
 #define LOAD_FUNCPTR_DLSYM(func) \
@@ -1403,19 +1406,12 @@ static void init_opengl(void)
 
     if (!init_opengl_funcs()) goto err;
     if (!init_egl_configs()) goto err;
-
-    return;
+    return &opengl_funcs;
 
 err:
     dlclose(egl_handle);
     egl_handle = NULL;
-}
-
-static BOOL has_opengl(void)
-{
-    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
-
-    return !pthread_once(&init_once, init_opengl) && egl_handle;
+    return NULL;
 }
 
 static struct opengl_funcs opengl_funcs =
@@ -1434,21 +1430,6 @@ static struct opengl_funcs opengl_funcs =
     }
 };
 
-/**********************************************************************
- *           WAYLAND_wine_get_wgl_driver
- */
-struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
-{
-    if (version != WINE_WGL_DRIVER_VERSION)
-    {
-        ERR("Version mismatch, opengl32 wants %u but driver has %u\n",
-            version, WINE_WGL_DRIVER_VERSION);
-        return NULL;
-    }
-    if (!has_opengl()) return NULL;
-    return &opengl_funcs;
-}
-
 /**********************************************************************
  *           wayland_destroy_gl_drawable
  */

From 21e8ac2d3cbb5e4382d2549ffaf3536568f25d16 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 5 Mar 2025 12:15:44 +0200
Subject: [PATCH 20/55] winewayland: Present EGL surfaces opaquely.

Many applications request and use GL configs with alpha, but assume that
the windowing system will present their surfaces opaquely. Wayland
compositors normally respect the alpha channel, which leads to unwanted
translucency effects for such applications, so we use the
EGL_EXT_present_opaque extension to avoid this.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57800
---
 dlls/winewayland.drv/opengl.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 18d304c2754..4f90de4b5f9 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -194,6 +194,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     struct wayland_gl_drawable *gl;
     int client_width, client_height;
     RECT client_rect = {0};
+    const EGLint attribs[] = {EGL_PRESENT_OPAQUE_EXT, EGL_TRUE, EGL_NONE};
 
     TRACE("hwnd=%p format=%d\n", hwnd, format);
 
@@ -223,7 +224,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     }
 
     gl->surface = p_eglCreateWindowSurface(egl_display, egl_config_for_format(format),
-                                           gl->wl_egl_window, NULL);
+                                           gl->wl_egl_window, attribs);
     if (!gl->surface)
     {
         ERR("Failed to create EGL surface\n");
@@ -1400,6 +1401,7 @@ struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
     REQUIRE_EXT(EGL_KHR_create_context);
     REQUIRE_EXT(EGL_KHR_create_context_no_error);
     REQUIRE_EXT(EGL_KHR_no_config_context);
+    REQUIRE_EXT(EGL_EXT_present_opaque);
 #undef REQUIRE_EXT
 
     has_egl_ext_pixel_format_float = has_extension(egl_exts, "EGL_EXT_pixel_format_float");

From 4491305be9025df2ef402f6450091b4948fb999d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 6 Mar 2025 17:09:58 +0200
Subject: [PATCH 21/55] winewayland: Treat fully transparent cursors as hidden.

SDL 2.0.18 and newer (including SDL 3) set a fully transparent cursor
object when hiding the cursor (instead of using a NULL cursor handle).
Detect this case and treat it as a request to hide the cursor, to make
our locking/relative-motion heuristics work.
---
 dlls/winewayland.drv/wayland_pointer.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index e2b31e02011..17139c47b13 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -494,6 +494,17 @@ static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
     return TRUE;
 }
 
+static BOOL cursor_buffer_is_transparent(struct wayland_shm_buffer *shm_buffer)
+{
+    uint32_t *pixel = shm_buffer->map_data;
+    uint32_t *end = pixel + shm_buffer->map_size / WINEWAYLAND_BYTES_PER_PIXEL;
+
+    for (; pixel < end; ++pixel)
+        if ((*pixel & 0xff000000) != 0) return FALSE;
+
+    return TRUE;
+}
+
 static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
 {
     struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
@@ -538,6 +549,9 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
         goto clear_cursor;
     }
 
+    if (cursor_buffer_is_transparent(cursor->shm_buffer))
+        goto clear_cursor;
+
     /* Make sure the hotspot is valid. */
     if (cursor->hotspot_x >= cursor->shm_buffer->width ||
         cursor->hotspot_y >= cursor->shm_buffer->height)

From bdb55b7e958e21e48986231d4b4b6f85027974b6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 13:23:46 +0200
Subject: [PATCH 22/55] winewayland: Implement wl_data_device initialization.

The data device is initialized once for each process, from within a
dedicated thread and window that handles clipboard events.
---
 dlls/winewayland.drv/Makefile.in           |  1 +
 dlls/winewayland.drv/dllmain.c             | 61 ++++++++++++++++++++++
 dlls/winewayland.drv/unixlib.h             |  1 +
 dlls/winewayland.drv/wayland.c             | 10 +++-
 dlls/winewayland.drv/wayland_data_device.c | 55 ++++++++++++++-----
 dlls/winewayland.drv/waylanddrv.h          | 17 ++++--
 dlls/winewayland.drv/waylanddrv_main.c     | 11 ++++
 7 files changed, 140 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 142db22ba9e..4141e36c9a8 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -2,6 +2,7 @@ MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS)
 UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS) $(XKBREGISTRY_LIBS) $(PTHREAD_LIBS) -lm
+IMPORTS = user32 win32u
 
 SOURCES = \
 	display.c \
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index d040620957b..8055d883ee0 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -20,6 +20,9 @@
 
 #include "waylanddrv_dll.h"
 
+#include "ntuser.h"
+#include "winuser.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -35,6 +38,61 @@ static DWORD WINAPI wayland_read_events_thread(void *arg)
     return 0;
 }
 
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+    case WM_CLIPBOARDUPDATE:
+    case WM_RENDERFORMAT:
+    case WM_TIMER:
+    case WM_DESTROYCLIPBOARD:
+    case WM_USER:
+        return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserClipboardWindowProc, FALSE);
+    }
+
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+static DWORD WINAPI clipboard_thread(void *arg)
+{
+    static const WCHAR clipboard_classname[] = L"__winewayland_clipboard_manager";
+    WNDCLASSW class;
+    ATOM atom;
+    MSG msg;
+    HWND hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!(atom = RegisterClassW(&class)) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %lu\n", GetLastError());
+        return 0;
+    }
+    /* The HWND_MESSAGE parent window may not have been created yet. It will be
+     * created eventually, so keep trying. */
+    while (!(hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                  HWND_MESSAGE, 0, 0, NULL)) &&
+           GetLastError() == ERROR_INVALID_WINDOW_HANDLE)
+    {
+        SwitchToThread();
+    }
+
+    if (!hwnd)
+    {
+        TRACE("failed to create clipboard window err %lu\n", GetLastError());
+        UnregisterClassW(MAKEINTRESOURCEW(atom), NULL);
+        return 0;
+    }
+
+    TRACE("created per-process clipboard window hwnd=%p\n", hwnd);
+
+    while (GetMessageW(&msg, 0, 0, 0)) DispatchMessageW(&msg);
+    return 0;
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     DWORD tid;
@@ -49,6 +107,9 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 
     /* Read wayland events from a dedicated thread. */
     CloseHandle(CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid));
+    /* Handle clipboard events in a dedicated thread, if needed. */
+    if (!WAYLANDDRV_UNIX_CALL(init_clipboard, NULL))
+        CloseHandle(CreateThread(NULL, 0, clipboard_thread, NULL, 0, &tid));
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index dc3bfdf8893..d9378fe8248 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -27,6 +27,7 @@ enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
     waylanddrv_unix_func_read_events,
+    waylanddrv_unix_func_init_clipboard,
     waylanddrv_unix_func_count,
 };
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ee162d8fe77..2a51222fd5f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -147,8 +147,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         pthread_mutex_unlock(&seat->mutex);
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
         /* Recreate the data device for the new seat. */
-        if (process_wayland.data_device.zwlr_data_control_device_v1)
+        if (process_wayland.data_device.zwlr_data_control_device_v1 ||
+            process_wayland.data_device.wl_data_device)
+        {
             wayland_data_device_init();
+        }
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -181,6 +184,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwlr_data_control_manager_v1 =
             wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        process_wayland.wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface, 2);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 04872df4fcb..472df0a2717 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -545,17 +545,29 @@ void wayland_data_device_init(void)
     TRACE("\n");
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->zwlr_data_control_device_v1)
-        zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
-    data_device->zwlr_data_control_device_v1 =
-        zwlr_data_control_manager_v1_get_data_device(
-            process_wayland.zwlr_data_control_manager_v1,
-            process_wayland.seat.wl_seat);
-    if (data_device->zwlr_data_control_device_v1)
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        if (data_device->zwlr_data_control_device_v1)
+            zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
+        data_device->zwlr_data_control_device_v1 =
+            zwlr_data_control_manager_v1_get_data_device(
+                process_wayland.zwlr_data_control_manager_v1,
+                process_wayland.seat.wl_seat);
+        if (data_device->zwlr_data_control_device_v1)
+        {
+            zwlr_data_control_device_v1_add_listener(
+                data_device->zwlr_data_control_device_v1, &data_control_device_listener,
+                data_device);
+        }
+    }
+    else if (process_wayland.wl_data_device_manager)
     {
-        zwlr_data_control_device_v1_add_listener(
-            data_device->zwlr_data_control_device_v1, &data_control_device_listener,
-            data_device);
+        if (data_device->wl_data_device)
+            wl_data_device_release(data_device->wl_data_device);
+        data_device->wl_data_device =
+            wl_data_device_manager_get_data_device(
+                process_wayland.wl_data_device_manager,
+                process_wayland.seat.wl_seat);
     }
     pthread_mutex_unlock(&data_device->mutex);
 
@@ -671,16 +683,35 @@ static void destroy_clipboard(void)
     pthread_mutex_unlock(&data_device->mutex);
 }
 
+static BOOL is_winewayland_clipboard_hwnd(HWND hwnd)
+{
+    static const WCHAR clipboard_classnameW[] = {
+        '_','_','w','i','n','e','w','a','y','l','a','n','d','_',
+        'c','l','i','p','b','o','a','r','d','_','m','a','n','a','g','e','r'};
+    WCHAR buffer[64];
+    UNICODE_STRING name = {.Buffer = buffer, .MaximumLength = sizeof(buffer)};
+
+    if (!NtUserGetClassName(hwnd, FALSE, &name)) return FALSE;
+    return !wcscmp(buffer, clipboard_classnameW);
+}
+
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     switch (msg)
     {
     case WM_NCCREATE:
+        /* Disable the default clipboard window in the desktop process if we are
+         * using the core wl_data_device protocol. */
+        if (!process_wayland.zwlr_data_control_manager_v1 &&
+            process_wayland.wl_data_device_manager &&
+            !is_winewayland_clipboard_hwnd(hwnd))
+        {
+            return FALSE;
+        }
         clipboard_hwnd = hwnd;
         NtUserAddClipboardFormatListener(hwnd);
         pthread_mutex_lock(&process_wayland.seat.mutex);
-        if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
-            wayland_data_device_init();
+        if (process_wayland.seat.wl_seat) wayland_data_device_init();
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
     case WM_CLIPBOARDUPDATE:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ead2269b72c..c2fb56dc9bf 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,9 +133,19 @@ struct wayland_seat
 
 struct wayland_data_device
 {
-    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
-    struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
-    struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
+    union
+    {
+        struct
+        {
+            struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+            struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+            struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
+        };
+        struct
+        {
+            struct wl_data_device *wl_data_device;
+        };
+    };
     pthread_mutex_t mutex;
 };
 
@@ -155,6 +165,7 @@ struct wayland
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
+    struct wl_data_device_manager *wl_data_device_manager;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1d4ddeb3425..dba519b1df1 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -110,10 +110,20 @@ static NTSTATUS waylanddrv_unix_read_events(void *arg)
     return STATUS_UNSUCCESSFUL;
 }
 
+static NTSTATUS waylanddrv_unix_init_clipboard(void *arg)
+{
+    /* If the compositor supports zwlr_data_control_manager_v1, we don't need
+     * per-process clipboard window and handling, we can use the default clipboard
+     * window from the desktop process. */
+    if (process_wayland.zwlr_data_control_manager_v1) return STATUS_UNSUCCESSFUL;
+    return STATUS_SUCCESS;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_init_clipboard,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
@@ -124,6 +134,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_init_clipboard,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == waylanddrv_unix_func_count);

From 95dce3caeaf79692fc055b9e73926fd36636bf27 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 14 Mar 2025 10:13:26 +0200
Subject: [PATCH 23/55] winewayland: Support wl_data_device for copies from
 win32 clipboard to native apps.

If the wlr-data-control-unstable-v1 extension is not available use
the core data device protocol.
---
 dlls/winewayland.drv/wayland_data_device.c | 124 ++++++++++++++++++---
 dlls/winewayland.drv/wayland_keyboard.c    |   8 ++
 dlls/winewayland.drv/wayland_pointer.c     |   6 +
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 4 files changed, 126 insertions(+), 14 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 472df0a2717..c2d5b6e095c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -537,6 +537,64 @@ static const struct zwlr_data_control_device_v1_listener data_control_device_lis
     data_control_device_finished,
 };
 
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct data_device_format *format;
+    const char *normalized;
+
+    if ((normalized = normalize_mime_type(mime_type)) &&
+        (format = data_device_format_for_mime_type(normalized)))
+    {
+        wayland_data_source_export(format, fd);
+    }
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    wl_data_source_destroy(source);
+    if (source == data_device->wl_data_source)
+        data_device->wl_data_source = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener =
+{
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -581,16 +639,33 @@ void wayland_data_device_init(void)
 static void clipboard_update(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
-    struct zwlr_data_control_source_v1 *source;
+    struct zwlr_data_control_source_v1 *zwlr_source = NULL;
+    struct wl_data_source *wl_source = NULL;
     UINT *formats, formats_size = 256, i;
+    uint32_t serial = 0;
 
-    if (!process_wayland.zwlr_data_control_manager_v1) return;
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        zwlr_source = zwlr_data_control_manager_v1_create_data_source(
+            process_wayland.zwlr_data_control_manager_v1);
+    }
+    else
+    {
+        serial = InterlockedCompareExchange(&process_wayland.input_serial, 0, 0);
+        pthread_mutex_lock(&process_wayland.keyboard.mutex);
+        if (!process_wayland.keyboard.focused_hwnd) serial = 0;
+        pthread_mutex_unlock(&process_wayland.keyboard.mutex);
+        if (process_wayland.wl_data_device_manager && serial)
+        {
+            wl_source = wl_data_device_manager_create_data_source(
+                process_wayland.wl_data_device_manager);
+        }
+        else return;
+    }
 
     TRACE("\n");
 
-    source = zwlr_data_control_manager_v1_create_data_source(
-        process_wayland.zwlr_data_control_manager_v1);
-    if (!source)
+    if (!zwlr_source && !wl_source)
     {
         ERR("failed to create data source\n");
         return;
@@ -608,7 +683,8 @@ static void clipboard_update(void)
     if (!formats && formats_size)
     {
         ERR("failed to get clipboard formats\n");
-        zwlr_data_control_source_v1_destroy(source);
+        if (wl_source) wl_data_source_destroy(wl_source);
+        else zwlr_data_control_source_v1_destroy(zwlr_source);
         return;
     }
 
@@ -619,23 +695,43 @@ static void clipboard_update(void)
         if (format)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
-            zwlr_data_control_source_v1_offer(source, format->mime_type);
+            if (wl_source) wl_data_source_offer(wl_source, format->mime_type);
+            else zwlr_data_control_source_v1_offer(zwlr_source, format->mime_type);
         }
     }
 
     free(formats);
 
-    zwlr_data_control_source_v1_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
-    zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
+    if (wl_source)
+    {
+        wl_data_source_offer(wl_source, WINEWAYLAND_TAG_MIME_TYPE);
+        wl_data_source_add_listener(wl_source, &data_source_listener, data_device);
+    }
+    else
+    {
+        zwlr_data_control_source_v1_offer(zwlr_source, WINEWAYLAND_TAG_MIME_TYPE);
+        zwlr_data_control_source_v1_add_listener(zwlr_source, &data_control_source_listener, data_device);
+    }
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->zwlr_data_control_device_v1)
-        zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, source);
     /* Destroy any previous source only after setting the new source, to
      * avoid spurious 'selection(nil)' events. */
-    if (data_device->zwlr_data_control_source_v1)
-        zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
-    data_device->zwlr_data_control_source_v1 = source;
+    if (wl_source)
+    {
+        if (data_device->wl_data_device)
+            wl_data_device_set_selection(data_device->wl_data_device, wl_source, serial);
+        if (data_device->wl_data_source)
+            wl_data_source_destroy(data_device->wl_data_source);
+        data_device->wl_data_source = wl_source;
+    }
+    else
+    {
+        if (data_device->zwlr_data_control_device_v1)
+            zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, zwlr_source);
+        if (data_device->zwlr_data_control_source_v1)
+            zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
+        data_device->zwlr_data_control_source_v1 = zwlr_source;
+    }
     pthread_mutex_unlock(&data_device->mutex);
 
     wl_display_flush(process_wayland.wl_display);
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 8f7b6dce30f..39b42231b00 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -745,6 +745,8 @@ static void keyboard_handle_enter(void *private, struct wl_keyboard *wl_keyboard
     struct wayland_win_data *data;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -780,6 +782,8 @@ static void keyboard_handle_leave(void *data, struct wl_keyboard *wl_keyboard,
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -817,6 +821,8 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
     INPUT input = {0};
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!(hwnd = wayland_keyboard_get_focused_hwnd())) return;
 
     TRACE_(key)("serial=%u hwnd=%p key=%d scan=%#x state=%#x\n", serial, hwnd, key, scan, state);
@@ -840,6 +846,8 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboar
 {
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wayland_keyboard_get_focused_hwnd()) return;
 
     TRACE("serial=%u mods_depressed=%#x mods_latched=%#x mods_locked=%#x xkb_group=%d stub!\n",
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 17139c47b13..457c3675cf1 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -112,6 +112,8 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
     /* The wl_surface user data remains valid and immutable for the whole
      * lifetime of the object, so it's safe to access without locking. */
@@ -139,6 +141,8 @@ static void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     TRACE("hwnd=%p\n", wl_surface_get_user_data(wl_surface));
@@ -157,6 +161,8 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     INPUT input = {0};
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
 
     input.type = INPUT_MOUSE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c2fb56dc9bf..1649e0f84f3 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -144,6 +144,7 @@ struct wayland_data_device
         struct
         {
             struct wl_data_device *wl_data_device;
+            struct wl_data_source *wl_data_source;
         };
     };
     pthread_mutex_t mutex;
@@ -174,6 +175,7 @@ struct wayland
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
+    LONG input_serial;
 };
 
 struct wayland_output_mode

From cec48f721d12c37aa5291af593efab0dcb736b7a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 17 Mar 2025 09:19:43 +0200
Subject: [PATCH 24/55] winewayland: Support wl_data_device for copies from
 native apps to win32 clipboard.

---
 dlls/winewayland.drv/wayland_data_device.c | 177 +++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 148 insertions(+), 30 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index c2d5b6e095c..e36c0cc9229 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -49,7 +49,11 @@ struct data_device_format
 
 struct wayland_data_offer
 {
-    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+    union
+    {
+        struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+        struct wl_data_offer *wl_data_offer;
+    };
     struct wl_array types;
 };
 
@@ -365,7 +369,17 @@ static const struct zwlr_data_control_offer_v1_listener data_control_offer_liste
     data_control_offer_offer,
 };
 
-static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer, const char *type)
+{
+    data_control_offer_offer(data, NULL, type);
+}
+
+static const struct wl_data_offer_listener data_offer_listener =
+{
+    data_offer_offer,
+};
+
+static void wayland_data_offer_create(void *offer_proxy)
 {
     struct wayland_data_offer *data_offer;
 
@@ -375,17 +389,30 @@ static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_da
         return;
     }
 
-    data_offer->zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
     wl_array_init(&data_offer->types);
-    zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
-                                            &data_control_offer_listener, data_offer);
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        data_offer->zwlr_data_control_offer_v1 = offer_proxy;
+        zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
+                                                &data_control_offer_listener, data_offer);
+    }
+    else
+    {
+        data_offer->wl_data_offer = offer_proxy;
+        wl_data_offer_add_listener(data_offer->wl_data_offer, &data_offer_listener,
+                                   data_offer);
+
+    }
 }
 
 static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
 {
     char **p;
 
-    zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    if (process_wayland.zwlr_data_control_manager_v1)
+        zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    else
+        wl_data_offer_destroy(data_offer->wl_data_offer);
     wl_array_for_each(p, &data_offer->types)
         free(*p);
     wl_array_release(&data_offer->types);
@@ -410,8 +437,15 @@ static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offe
         fcntl(data_pipe[1], F_SETFD, FD_CLOEXEC);
     }
 
-    zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
-                                       mime_type, data_pipe[1]);
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
+                                           mime_type, data_pipe[1]);
+    }
+    else
+    {
+        wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    }
     close(data_pipe[1]);
 
     /* Flush to ensure our receive request reaches the server. */
@@ -431,21 +465,31 @@ static void *import_format(int fd, struct data_device_format *format, size_t *re
     return ret;
 }
 
-/**********************************************************************
- *          zwlr_data_control_device_v1 handling
- */
-
 static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
 {
-    if (data_device->clipboard_zwlr_data_control_offer_v1)
+    struct wayland_data_offer *data_offer = NULL;
+
+    if (process_wayland.zwlr_data_control_manager_v1 &&
+        data_device->clipboard_zwlr_data_control_offer_v1)
     {
-        struct wayland_data_offer *data_offer =
-            zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1);
-        if (data_offer) wayland_data_offer_destroy(data_offer);
+        data_offer = zwlr_data_control_offer_v1_get_user_data(
+            data_device->clipboard_zwlr_data_control_offer_v1);
         data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
     }
+    else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             data_device->clipboard_wl_data_offer)
+    {
+        data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+
+    if (data_offer) wayland_data_offer_destroy(data_offer);
 }
 
+/**********************************************************************
+ *          zwlr_data_control_device_v1 handling
+ */
+
 static void data_control_device_data_offer(
     void *data,
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
@@ -454,19 +498,12 @@ static void data_control_device_data_offer(
     wayland_data_offer_create(zwlr_data_control_offer_v1);
 }
 
-static void clipboard_update(void);
-
-static void data_control_device_selection(
-    void *data,
-    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
-    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+static void handle_selection(struct wayland_data_device *data_device,
+                             struct wayland_data_offer *data_offer)
 {
-    struct wayland_data_device *data_device = data;
-    struct wayland_data_offer *data_offer = NULL;
     char **p;
 
-    if (!zwlr_data_control_offer_v1 ||
-        !(data_offer = zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1)))
+    if (!data_offer)
     {
         TRACE("empty offer, clearing clipboard\n");
         if (NtUserOpenClipboard(clipboard_hwnd, 0))
@@ -521,8 +558,26 @@ static void data_control_device_selection(
 done:
     pthread_mutex_lock(&data_device->mutex);
     wayland_data_device_destroy_clipboard_data_offer(data_device);
-    if (data_offer) data_device->clipboard_zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    if (data_offer)
+    {
+        if (process_wayland.zwlr_data_control_manager_v1)
+            data_device->clipboard_zwlr_data_control_offer_v1 = data_offer->zwlr_data_control_offer_v1;
+        else
+            data_device->clipboard_wl_data_offer = data_offer->wl_data_offer;
+    }
     pthread_mutex_unlock(&data_device->mutex);
+
+}
+
+static void data_control_device_selection(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    handle_selection(data,
+                     zwlr_data_control_offer_v1 ?
+                         zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1) :
+                         NULL);
 }
 
 static void data_control_device_finished(
@@ -595,6 +650,52 @@ static const struct wl_data_source_listener data_source_listener =
     data_source_action,
 };
 
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void data_device_data_offer(void *data, struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+    wayland_data_offer_create(wl_data_offer);
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_selection(void *data, struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+    handle_selection(data, wl_data_offer ? wl_data_offer_get_user_data(wl_data_offer) : NULL);
+}
+
+static const struct wl_data_device_listener data_device_listener =
+{
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -626,6 +727,11 @@ void wayland_data_device_init(void)
             wl_data_device_manager_get_data_device(
                 process_wayland.wl_data_device_manager,
                 process_wayland.seat.wl_seat);
+        if (data_device->wl_data_device)
+        {
+            wl_data_device_add_listener(data_device->wl_data_device,
+                                        &data_device_listener, data_device);
+        }
     }
     pthread_mutex_unlock(&data_device->mutex);
 
@@ -740,15 +846,26 @@ static void clipboard_update(void)
 static void render_format(UINT clipboard_format)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
-    struct wayland_data_offer *data_offer;
+    struct wayland_data_offer *data_offer = NULL;
     struct data_device_format *format;
     int import_fd = -1;
 
     TRACE("clipboard_format=%u\n", clipboard_format);
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->clipboard_zwlr_data_control_offer_v1 &&
-        (data_offer = zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1)) &&
+    if (process_wayland.zwlr_data_control_manager_v1 &&
+        data_device->clipboard_zwlr_data_control_offer_v1)
+    {
+        data_offer = zwlr_data_control_offer_v1_get_user_data(
+            data_device->clipboard_zwlr_data_control_offer_v1);
+    }
+    else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             data_device->clipboard_wl_data_offer)
+    {
+        data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    }
+
+    if (data_offer &&
         (format = data_device_format_for_clipboard_format(clipboard_format,
                                                           &data_offer->types)))
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1649e0f84f3..065d4d31873 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -145,6 +145,7 @@ struct wayland_data_device
         {
             struct wl_data_device *wl_data_device;
             struct wl_data_source *wl_data_source;
+            struct wl_data_offer *clipboard_wl_data_offer;
         };
     };
     pthread_mutex_t mutex;

From 20d1592988976167ef2b5bbfa0aae73587781b17 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 17 Mar 2025 13:51:39 +0200
Subject: [PATCH 25/55] winewayland: Warn about missing clipboard
 functionality.

---
 dlls/winewayland.drv/wayland.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2a51222fd5f..7caf33c872e 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -311,6 +311,14 @@ BOOL wayland_process_init(void)
     if (!process_wayland.zwp_text_input_manager_v3)
         ERR("Wayland compositor doesn't support optional zwp_text_input_manager_v3 (host input methods won't work)\n");
 
+    if (!process_wayland.zwlr_data_control_manager_v1)
+    {
+        if (!process_wayland.wl_data_device_manager)
+            ERR("Wayland compositor doesn't support optional wl_data_device_manager (clipboard won't work)\n");
+        else
+            ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
+    }
+
     process_wayland.initialized = TRUE;
 
     return TRUE;

From deb2ccb4776981db7e275a7be5acd340d74321b0 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 30 Mar 2025 03:47:31 +0000
Subject: [PATCH 26/55] winewayland: Don't use a destroyed surface in text
 input.

Don't assert or get the user data of null surface arguments. When the
callbacks are run with a null surface it means the surface was destroyed
client-side but the compositor has yet to process the destroy request
and has sent events referencing the surface which no longer exists on
the client.

The wl_surface pointer also needs to be removed during
wayland_surface_destroy to prevent it from becoming a dangling pointer
which may be used if text_input_done or text_input_leave is run after
the surface is destroyed. While doing so, track the hwnd instead to be
consistent with keyboard and pointer.
---
 dlls/winewayland.drv/wayland_surface.c    |  5 ++++
 dlls/winewayland.drv/wayland_text_input.c | 35 ++++++++++++-----------
 dlls/winewayland.drv/waylanddrv.h         |  2 +-
 3 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2178f5431cb..701085847a4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -204,6 +204,11 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         process_wayland.keyboard.focused_hwnd = NULL;
     pthread_mutex_unlock(&process_wayland.keyboard.mutex);
 
+    pthread_mutex_lock(&process_wayland.text_input.mutex);
+    if (process_wayland.text_input.focused_hwnd == surface->hwnd)
+        process_wayland.text_input.focused_hwnd = NULL;
+    pthread_mutex_unlock(&process_wayland.text_input.mutex);
+
     wayland_surface_clear_role(surface);
 
     if (surface->wp_viewport)
diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index e0181eb8240..f8df5fe09cb 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -61,16 +61,21 @@ static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
-    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+    HWND hwnd;
+
+    if (!surface) return;
+
+    hwnd = wl_surface_get_user_data(surface);
+    TRACE("data %p, text_input %p, hwnd %p.\n", data, zwp_text_input_v3, hwnd);
 
     pthread_mutex_lock(&text_input->mutex);
+    text_input->focused_hwnd = hwnd;
     zwp_text_input_v3_enable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_set_content_type(text_input->zwp_text_input_v3,
             ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
             ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
     zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
-    text_input->wl_surface = surface;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -78,16 +83,16 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
-    HWND hwnd;
-    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+    TRACE("data %p, text_input %p.\n", data, zwp_text_input_v3);
 
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
-    assert(text_input->wl_surface);
-    hwnd = wl_surface_get_user_data(text_input->wl_surface);
-    post_ime_update(hwnd, 0, NULL, NULL);
-    text_input->wl_surface = NULL;
+    if (text_input->focused_hwnd)
+    {
+        post_ime_update(text_input->focused_hwnd, 0, NULL, NULL);
+        text_input->focused_hwnd = NULL;
+    }
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -127,18 +132,16 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
         uint32_t serial)
 {
     struct wayland_text_input *text_input = data;
-    HWND hwnd;
     TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
 
     pthread_mutex_lock(&text_input->mutex);
     /* Some compositors will send a done event for every commit, regardless of
      * the focus state of the text input. This behavior is arguably out of spec,
      * but otherwise harmless, so just ignore the new state in such cases. */
-    if (text_input->wl_surface)
+    if (text_input->focused_hwnd)
     {
-        hwnd = wl_surface_get_user_data(text_input->wl_surface);
-        post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
-                text_input->commit_string);
+        post_ime_update(text_input->focused_hwnd, text_input->preedit_cursor_pos,
+                text_input->preedit_string, text_input->commit_string);
     }
 
     free(text_input->preedit_string);
@@ -177,7 +180,7 @@ void wayland_text_input_deinit(void)
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
-    text_input->wl_surface = NULL;
+    text_input->focused_hwnd = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
 
@@ -194,13 +197,13 @@ BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect)
 
     pthread_mutex_lock(&text_input->mutex);
 
-    if (!text_input->zwp_text_input_v3)
+    if (!text_input->zwp_text_input_v3 || hwnd != text_input->focused_hwnd)
         goto err;
 
     if (!(data = wayland_win_data_get(hwnd)))
         goto err;
 
-    if (!(surface = data->wayland_surface) || surface->wl_surface != text_input->wl_surface)
+    if (!(surface = data->wayland_surface))
     {
         wayland_win_data_release(data);
         goto err;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 065d4d31873..ba1e715f38e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -120,7 +120,7 @@ struct wayland_text_input
     WCHAR *preedit_string;
     DWORD preedit_cursor_pos;
     WCHAR *commit_string;
-    struct wl_surface *wl_surface;
+    HWND focused_hwnd;
     pthread_mutex_t mutex;
 };
 

From e4d9198cd7ae3169ec1bafd4933a4974224b30c7 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 1 Dec 2024 13:36:40 -0500
Subject: [PATCH 27/55] winewayland.drv: Implement support for
 xdg-toplevel-icon.

---
 dlls/winewayland.drv/Makefile.in              |   3 +-
 dlls/winewayland.drv/wayland.c                |   8 +
 dlls/winewayland.drv/wayland_pointer.c        |  94 +-------
 dlls/winewayland.drv/wayland_surface.c        | 167 ++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             |  33 ++-
 dlls/winewayland.drv/waylanddrv_main.c        |   1 +
 dlls/winewayland.drv/window.c                 |  69 +++++-
 dlls/winewayland.drv/xdg-toplevel-icon-v1.xml | 205 ++++++++++++++++++
 8 files changed, 473 insertions(+), 107 deletions(-)
 create mode 100644 dlls/winewayland.drv/xdg-toplevel-icon-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4141e36c9a8..e7b1bfb90eb 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -26,4 +26,5 @@ SOURCES = \
 	window_surface.c \
 	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
-	xdg-shell.xml
+	xdg-shell.xml \
+	xdg-toplevel-icon-v1.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 7caf33c872e..ba09d32ed89 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -189,6 +189,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.wl_data_device_manager =
             wl_registry_bind(registry, id, &wl_data_device_manager_interface, 2);
     }
+    else if (strcmp(interface, "xdg_toplevel_icon_manager_v1") == 0)
+    {
+        process_wayland.xdg_toplevel_icon_manager_v1 =
+            wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -319,6 +324,9 @@ BOOL wayland_process_init(void)
             ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
     }
 
+    if (!process_wayland.xdg_toplevel_icon_manager_v1)
+        ERR("Wayland compositor doesn't support xdg_toplevel_icon_manager_v1 (window icons will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 457c3675cf1..6c852292c1d 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -382,98 +382,6 @@ static struct wayland_shm_buffer *create_mono_cursor_buffer(HBITMAP bmp)
     return shm_buffer;
 }
 
-/***********************************************************************
- *           create_color_cursor_buffer
- *
- * Create a wayland_shm_buffer for a color cursor bitmap.
- *
- * Adapted from wineandroid.drv code.
- */
-static struct wayland_shm_buffer *create_color_cursor_buffer(HDC hdc, HBITMAP color,
-                                                             HBITMAP mask)
-{
-    struct wayland_shm_buffer *shm_buffer = NULL;
-    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
-    BITMAPINFO *info = (BITMAPINFO *)buffer;
-    BITMAP bm;
-    unsigned int *ptr, *bits = NULL;
-    unsigned char *mask_bits = NULL;
-    int i, j;
-    BOOL has_alpha = FALSE;
-
-    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
-
-    shm_buffer = wayland_shm_buffer_create(bm.bmWidth, bm.bmHeight,
-                                           WL_SHM_FORMAT_ARGB8888);
-    if (!shm_buffer) goto failed;
-    bits = shm_buffer->map_data;
-
-    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    info->bmiHeader.biWidth = bm.bmWidth;
-    info->bmiHeader.biHeight = -bm.bmHeight;
-    info->bmiHeader.biPlanes = 1;
-    info->bmiHeader.biBitCount = 32;
-    info->bmiHeader.biCompression = BI_RGB;
-    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
-    info->bmiHeader.biXPelsPerMeter = 0;
-    info->bmiHeader.biYPelsPerMeter = 0;
-    info->bmiHeader.biClrUsed = 0;
-    info->bmiHeader.biClrImportant = 0;
-
-    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info,
-                                DIB_RGB_COLORS, 0, 0))
-        goto failed;
-
-    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
-        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
-
-    if (!has_alpha)
-    {
-        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
-        /* generate alpha channel from the mask */
-        info->bmiHeader.biBitCount = 1;
-        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
-        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
-        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits,
-                                    info, DIB_RGB_COLORS, 0, 0))
-            goto failed;
-        ptr = bits;
-        for (i = 0; i < bm.bmHeight; i++)
-        {
-            for (j = 0; j < bm.bmWidth; j++, ptr++)
-            {
-                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80))
-                    *ptr |= 0xff000000;
-            }
-        }
-        free(mask_bits);
-    }
-
-    /* Wayland requires pre-multiplied alpha values */
-    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
-    {
-        unsigned char alpha = *ptr >> 24;
-        if (alpha == 0)
-        {
-            *ptr = 0;
-        }
-        else if (alpha != 255)
-        {
-            *ptr = (alpha << 24) |
-                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
-                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
-                   (((BYTE)*ptr * alpha / 255));
-        }
-    }
-
-    return shm_buffer;
-
-failed:
-    if (shm_buffer) wayland_shm_buffer_unref(shm_buffer);
-    free(mask_bits);
-    return NULL;
-}
-
 /***********************************************************************
  *           get_icon_info
  *
@@ -535,7 +443,7 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
     {
         HDC hdc = NtGdiCreateCompatibleDC(0);
         cursor->shm_buffer =
-            create_color_cursor_buffer(hdc, info.hbmColor, info.hbmMask);
+            wayland_shm_buffer_from_color_bitmaps(hdc, info.hbmColor, info.hbmMask);
         NtGdiDeleteObjectApp(hdc);
     }
     else
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 701085847a4..39b6991a5eb 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -329,6 +329,21 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         break;
 
     case WAYLAND_SURFACE_ROLE_TOPLEVEL:
+        if (surface->xdg_toplevel_icon)
+        {
+            xdg_toplevel_icon_manager_v1_set_icon(
+                process_wayland.xdg_toplevel_icon_manager_v1,
+                surface->xdg_toplevel, NULL);
+            xdg_toplevel_icon_v1_destroy(surface->xdg_toplevel_icon);
+            if (surface->big_icon_buffer)
+                wayland_shm_buffer_unref(surface->big_icon_buffer);
+            if (surface->small_icon_buffer)
+                wayland_shm_buffer_unref(surface->small_icon_buffer);
+            surface->big_icon_buffer = NULL;
+            surface->small_icon_buffer = NULL;
+            surface->xdg_toplevel_icon = NULL;
+        }
+
         if (surface->xdg_toplevel)
         {
             xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -851,6 +866,98 @@ struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
     return NULL;
 }
 
+/***********************************************************************
+ *           wayland_shm_buffer_from_color_bitmaps
+ *
+ * Create a wayland_shm_buffer for a color bitmap.
+ *
+ * Adapted from wineandroid.drv code.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMAP color,
+                                                                 HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info,
+                                DIB_RGB_COLORS, 0, 0))
+        goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits,
+                                    info, DIB_RGB_COLORS, 0, 0))
+            goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+        {
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+            {
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+            }
+        }
+        free(mask_bits);
+    }
+
+    /* Wayland requires pre-multiplied alpha values */
+    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
+    {
+        unsigned char alpha = *ptr >> 24;
+        if (alpha == 0)
+        {
+            *ptr = 0;
+        }
+        else if (alpha != 255)
+        {
+            *ptr = (alpha << 24) |
+                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
+                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
+                   (((BYTE)*ptr * alpha / 255));
+        }
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer) wayland_shm_buffer_unref(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_window
  *
@@ -1081,3 +1188,63 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
 
     free(utf8);
 }
+
+/**********************************************************************
+ *          wayland_surface_set_icon
+ */
+void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii)
+{
+    HDC hDC;
+    struct wayland_shm_buffer *icon_buf;
+
+    assert(ii);
+    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+
+    hDC = NtGdiCreateCompatibleDC(0);
+    icon_buf = wayland_shm_buffer_from_color_bitmaps(hDC, ii->hbmColor, ii->hbmMask);
+    NtGdiDeleteObjectApp(hDC);
+
+    if (surface->xdg_toplevel_icon)
+    {
+        xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
+                                              surface->xdg_toplevel, NULL);
+        xdg_toplevel_icon_v1_destroy(surface->xdg_toplevel_icon);
+        if (surface->big_icon_buffer && type == ICON_BIG)
+        {
+            wayland_shm_buffer_unref(surface->big_icon_buffer);
+            surface->big_icon_buffer = NULL;
+        }
+        else if (surface->small_icon_buffer && type != ICON_BIG)
+        {
+            wayland_shm_buffer_unref(surface->small_icon_buffer);
+            surface->small_icon_buffer = NULL;
+        }
+        surface->xdg_toplevel_icon = NULL;
+    }
+
+    if (icon_buf)
+    {
+        surface->xdg_toplevel_icon =
+            xdg_toplevel_icon_manager_v1_create_icon(process_wayland.xdg_toplevel_icon_manager_v1);
+
+        if (type == ICON_BIG) surface->big_icon_buffer = icon_buf;
+        else surface->small_icon_buffer = icon_buf;
+
+        /* FIXME: what to do with scale ? */
+        if (surface->big_icon_buffer)
+        {
+            xdg_toplevel_icon_v1_add_buffer(surface->xdg_toplevel_icon,
+                                            surface->big_icon_buffer->wl_buffer, 1);
+        }
+        if (surface->small_icon_buffer)
+        {
+            xdg_toplevel_icon_v1_add_buffer(surface->xdg_toplevel_icon,
+                                            surface->small_icon_buffer->wl_buffer, 1);
+        }
+
+        xdg_toplevel_icon_v1_set_name(surface->xdg_toplevel_icon, "");
+
+        xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
+                                              surface->xdg_toplevel, surface->xdg_toplevel_icon);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ba1e715f38e..1d0f5e7b921 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -36,6 +36,7 @@
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
+#include "xdg-toplevel-icon-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -168,6 +169,7 @@ struct wayland
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
+    struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -237,6 +239,18 @@ struct wayland_client_surface
     struct wp_viewport *wp_viewport;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    LONG ref;
+    HRGN damage_region;
+};
+
 struct wayland_surface
 {
     HWND hwnd;
@@ -251,6 +265,9 @@ struct wayland_surface
         {
             struct xdg_surface *xdg_surface;
             struct xdg_toplevel *xdg_toplevel;
+            struct xdg_toplevel_icon_v1 *xdg_toplevel_icon;
+            struct wayland_shm_buffer *small_icon_buffer;
+            struct wayland_shm_buffer *big_icon_buffer;
         };
         struct
         {
@@ -266,18 +283,6 @@ struct wayland_surface
     HCURSOR hcursor;
 };
 
-struct wayland_shm_buffer
-{
-    struct wl_list link;
-    struct wl_buffer *wl_buffer;
-    int width, height;
-    void *map_data;
-    size_t map_size;
-    BOOL busy;
-    LONG ref;
-    HRGN damage_region;
-};
-
 /**********************************************************************
  *          Wayland initialization
  */
@@ -321,6 +326,7 @@ void wayland_client_surface_attach(struct wayland_client_surface *client, HWND t
 void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
+void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
 
 /**********************************************************************
  *          Wayland SHM buffer
@@ -328,6 +334,8 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
 struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
                                                      enum wl_shm_format format);
+struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMAP color,
+                                                                 HBITMAP mask);
 void wayland_shm_buffer_ref(struct wayland_shm_buffer *shm_buffer);
 void wayland_shm_buffer_unref(struct wayland_shm_buffer *shm_buffer);
 
@@ -430,6 +438,7 @@ void WAYLAND_DestroyWindow(HWND hwnd);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 BOOL WAYLAND_SetCursorPos(INT x, INT y);
+void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
 UINT WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager, void *param);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index dba519b1df1..5486cc934ef 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -44,6 +44,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
     .pSetCursorPos = WAYLAND_SetCursorPos,
+    .pSetWindowIcon = WAYLAND_SetWindowIcon,
     .pSetWindowText = WAYLAND_SetWindowText,
     .pSysCommand = WAYLAND_SysCommand,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e80bebdc042..184d09c2ed4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -422,6 +422,28 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const str
     return TRUE;
 }
 
+static HICON get_icon_info(HICON icon, ICONINFO *ii)
+{
+    return icon && NtUserGetIconInfo(icon, ii, NULL, NULL, NULL, 0) ? icon : NULL;
+}
+
+static HICON get_window_icon(HWND hwnd, UINT type, HICON icon, ICONINFO *ret)
+{
+    icon = get_icon_info(icon, ret);
+    if (!icon)
+    {
+        icon = get_icon_info((HICON)send_message(hwnd, WM_GETICON, type, 0), ret);
+        if (!icon)
+            icon = get_icon_info((HICON)NtUserGetClassLongPtrW(hwnd, GCLP_HICON), ret);
+        if (!icon && type == ICON_BIG)
+        {
+            icon = LoadImageW(0, (const WCHAR *)IDI_WINLOGO, IMAGE_ICON, 0, 0,
+                              LR_SHARED | LR_DEFAULTSIZE);
+            icon = get_icon_info(icon, ret);
+        }
+    }
+    return icon;
+}
 
 /***********************************************************************
  *           WAYLAND_WindowPosChanged
@@ -433,7 +455,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     struct wayland_surface *toplevel_surface;
     struct wayland_client_surface *client;
     struct wayland_win_data *data, *toplevel_data;
-    BOOL managed;
+    BOOL managed, needs_icon;
 
     TRACE("hwnd %p new_rects %s after %p flags %08x\n", hwnd, debugstr_window_rects(new_rects), insert_after, swp_flags);
 
@@ -471,7 +493,28 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
         wayland_win_data_update_wayland_state(data);
     }
 
+    needs_icon = data->wayland_surface && !data->wayland_surface->big_icon_buffer &&
+                 data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                 data->wayland_surface->xdg_toplevel &&
+                 process_wayland.xdg_toplevel_icon_manager_v1;
+
     wayland_win_data_release(data);
+
+    if (needs_icon)
+    {
+        HICON big, small;
+        ICONINFO ii, ii_small;
+        big = get_window_icon(hwnd, ICON_BIG, 0, &ii);
+        small = get_window_icon(hwnd, ICON_SMALL, 0, &ii_small);
+
+        if((data = wayland_win_data_get(hwnd)))
+        {
+            if (big) wayland_surface_set_icon(data->wayland_surface, ICON_BIG, &ii);
+            if (small) wayland_surface_set_icon(data->wayland_surface, ICON_SMALL, &ii_small);
+
+            wayland_win_data_release(data);
+        }
+    }
 }
 
 static void wayland_configure_window(HWND hwnd)
@@ -642,6 +685,30 @@ static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
     }
 }
 
+/*****************************************************************
+ *		WAYLAND_SetWindowIcon
+ */
+void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon)
+{
+    struct wayland_win_data *data;
+    ICONINFO ii;
+
+    TRACE("hwnd=%p type=%u icon=%p\n", hwnd, type, icon);
+
+    if (process_wayland.xdg_toplevel_icon_manager_v1)
+    {
+        icon = get_window_icon(hwnd, type, icon, &ii);
+        if (icon && (data = wayland_win_data_get(hwnd)))
+        {
+            if (data->wayland_surface &&
+                data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                data->wayland_surface->xdg_toplevel)
+                wayland_surface_set_icon(data->wayland_surface, type, &ii);
+            wayland_win_data_release(data);
+        }
+    }
+}
+
 /*****************************************************************
  *		WAYLAND_SetWindowText
  */
diff --git a/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml b/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml
new file mode 100644
index 00000000000..fc409fef7c6
--- /dev/null
+++ b/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml
@@ -0,0 +1,205 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="xdg_toplevel_icon_v1">
+
+  <copyright>
+    Copyright © 2023-2024 Matthias Klumpp
+    Copyright ©      2024 David Edmundson
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="protocol to assign icons to toplevels">
+    This protocol allows clients to set icons for their toplevel surfaces
+    either via the XDG icon stock (using an icon name), or from pixel data.
+
+    A toplevel icon represents the individual toplevel (unlike the application
+    or launcher icon, which represents the application as a whole), and may be
+    shown in window switchers, window overviews and taskbars that list
+    individual windows.
+
+    This document adheres to RFC 2119 when using words like "must",
+    "should", "may", etc.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="xdg_toplevel_icon_manager_v1" version="1">
+    <description summary="interface to manage toplevel icons">
+      This interface allows clients to create toplevel window icons and set
+      them on toplevel windows to be displayed to the user.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the toplevel icon manager">
+        Destroy the toplevel icon manager.
+        This does not destroy objects created with the manager.
+      </description>
+    </request>
+
+    <request name="create_icon">
+      <description summary="create a new icon instance">
+        Creates a new icon object. This icon can then be attached to a
+        xdg_toplevel via the 'set_icon' request.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_toplevel_icon_v1"/>
+    </request>
+
+    <request name="set_icon">
+      <description summary="set an icon on a toplevel window">
+        This request assigns the icon 'icon' to 'toplevel', or clears the
+        toplevel icon if 'icon' was null.
+        This state is double-buffered and is applied on the next
+        wl_surface.commit of the toplevel.
+
+        After making this call, the xdg_toplevel_icon_v1 provided as 'icon'
+        can be destroyed by the client without 'toplevel' losing its icon.
+        The xdg_toplevel_icon_v1 is immutable from this point, and any
+        future attempts to change it must raise the
+        'xdg_toplevel_icon_v1.immutable' protocol error.
+
+        The compositor must set the toplevel icon from either the pixel data
+        the icon provides, or by loading a stock icon using the icon name.
+        See the description of 'xdg_toplevel_icon_v1' for details.
+
+        If 'icon' is set to null, the icon of the respective toplevel is reset
+        to its default icon (usually the icon of the application, derived from
+        its desktop-entry file, or a placeholder icon).
+        If this request is passed an icon with no pixel buffers or icon name
+        assigned, the icon must be reset just like if 'icon' was null.
+      </description>
+      <arg name="toplevel" type="object" interface="xdg_toplevel" summary="the toplevel to act on"/>
+      <arg name="icon" type="object" interface="xdg_toplevel_icon_v1" allow-null="true"/>
+    </request>
+
+    <event name="icon_size">
+      <description summary="describes a supported &amp; preferred icon size">
+        This event indicates an icon size the compositor prefers to be
+        available if the client has scalable icons and can render to any size.
+
+        When the 'xdg_toplevel_icon_manager_v1' object is created, the
+        compositor may send one or more 'icon_size' events to describe the list
+        of preferred icon sizes. If the compositor has no size preference, it
+        may not send any 'icon_size' event, and it is up to the client to
+        decide a suitable icon size.
+
+        A sequence of 'icon_size' events must be finished with a 'done' event.
+        If the compositor has no size preferences, it must still send the
+        'done' event, without any preceding 'icon_size' events.
+      </description>
+      <arg name="size" type="int"
+	   summary="the edge size of the square icon in surface-local coordinates, e.g. 64"/>
+    </event>
+
+    <event name="done">
+      <description summary="all information has been sent">
+        This event is sent after all 'icon_size' events have been sent.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="xdg_toplevel_icon_v1" version="1">
+    <description summary="a toplevel window icon">
+      This interface defines a toplevel icon.
+      An icon can have a name, and multiple buffers.
+      In order to be applied, the icon must have either a name, or at least
+      one buffer assigned. Applying an empty icon (with no buffer or name) to
+      a toplevel should reset its icon to the default icon.
+
+      It is up to compositor policy whether to prefer using a buffer or loading
+      an icon via its name. See 'set_name' and 'add_buffer' for details.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_buffer"
+             summary="the provided buffer does not satisfy requirements"
+	     value="1"/>
+      <entry name="immutable"
+             summary="the icon has already been assigned to a toplevel and must not be changed"
+	     value="2"/>
+      <entry name="no_buffer"
+             summary="the provided buffer has been destroyed before the toplevel icon"
+             value="3"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the icon object">
+        Destroys the 'xdg_toplevel_icon_v1' object.
+        The icon must still remain set on every toplevel it was assigned to,
+        until the toplevel icon is reset explicitly.
+      </description>
+    </request>
+
+    <request name="set_name">
+      <description summary="set an icon name">
+        This request assigns an icon name to this icon.
+        Any previously set name is overridden.
+
+        The compositor must resolve 'icon_name' according to the lookup rules
+        described in the XDG icon theme specification[1] using the
+        environment's current icon theme.
+
+        If the compositor does not support icon names or cannot resolve
+        'icon_name' according to the XDG icon theme specification it must
+        fall back to using pixel buffer data instead.
+
+        If this request is made after the icon has been assigned to a toplevel
+        via 'set_icon', a 'immutable' error must be raised.
+
+        [1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
+      </description>
+      <arg name="icon_name" type="string"/>
+    </request>
+
+    <request name="add_buffer">
+      <description summary="add icon data from a pixel buffer">
+        This request adds pixel data supplied as wl_buffer to the icon.
+
+        The client should add pixel data for all icon sizes and scales that
+        it can provide, or which are explicitly requested by the compositor
+        via 'icon_size' events on xdg_toplevel_icon_manager_v1.
+
+        The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm
+        and must be a square (width and height being equal).
+        If any of these buffer requirements are not fulfilled, a 'invalid_buffer'
+        error must be raised.
+
+        If this icon instance already has a buffer of the same size and scale
+        from a previous 'add_buffer' request, data from the last request
+        overrides the preexisting pixel data.
+
+        The wl_buffer must be kept alive for as long as the xdg_toplevel_icon
+        it is associated with is not destroyed, otherwise a 'no_buffer' error
+        is raised. The buffer contents must not be modified after it was
+        assigned to the icon. As a result, the region of the wl_shm_pool's
+        backing storage used for the wl_buffer must not be modified after this
+        request is sent. The wl_buffer.release event is unused.
+
+        If this request is made after the icon has been assigned to a toplevel
+        via 'set_icon', a 'immutable' error must be raised.
+      </description>
+      <arg name="buffer" type="object" interface="wl_buffer"/>
+      <arg name="scale" type="int"
+	   summary="the scaling factor of the icon, e.g. 1"/>
+    </request>
+  </interface>
+</protocol>

From 9bbbcf0b62e8a9df0ba9255c77ed3b5fa7475422 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Thu, 17 Apr 2025 04:21:14 +0900
Subject: [PATCH 28/55] winewayland: Use an empty string to clear the
 composition string.

---
 dlls/winewayland.drv/wayland_text_input.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index f8df5fe09cb..bb974cd06fd 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -35,6 +35,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
 static void post_ime_update(HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR *result_str)
 {
+    /* Windows uses an empty string to clear the composition string. */
+    if (!comp_str && !result_str) comp_str = (WCHAR *)L"";
+
     NtUserMessageCall(hwnd, WINE_IME_POST_UPDATE, cursor_pos, (LPARAM)comp_str, result_str,
             NtUserImeDriverCall, FALSE);
 }

From 3a775cea3674daa43a79509f4569f59369187082 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Sun, 6 Apr 2025 10:13:19 +0900
Subject: [PATCH 29/55] winewayland: Extend cursor_pos using cursor_begin,
 cursor_end.

---
 dlls/winewayland.drv/wayland_text_input.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index bb974cd06fd..18f64797131 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -103,14 +103,17 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
         const char *text, int32_t cursor_begin, int32_t cursor_end)
 {
     struct wayland_text_input *text_input = data;
-    TRACE("data %p, text_input %p, text %s, cursor_begin %d.\n", data, zwp_text_input_v3,
-            debugstr_a(text), cursor_begin);
+    TRACE("data %p, text_input %p, text %s, cursor %d - %d.\n", data, zwp_text_input_v3,
+            debugstr_a(text), cursor_begin, cursor_end);
 
     pthread_mutex_lock(&text_input->mutex);
-    if ((text_input->preedit_string = strdupUtoW(text)) && cursor_begin > 0)
+    if ((text_input->preedit_string = strdupUtoW(text)))
     {
-        RtlUTF8ToUnicodeN(NULL, 0, &text_input->preedit_cursor_pos, text, cursor_begin);
-        text_input->preedit_cursor_pos /= sizeof(WCHAR);
+        DWORD begin = 0, end = 0;
+
+        if (cursor_begin > 0) RtlUTF8ToUnicodeN(NULL, 0, &begin, text, cursor_begin);
+        if (cursor_end > 0) RtlUTF8ToUnicodeN(NULL, 0, &end, text, cursor_end);
+        text_input->preedit_cursor_pos = MAKELONG(begin / sizeof(WCHAR), end / sizeof(WCHAR));
     }
     pthread_mutex_unlock(&text_input->mutex);
 }

From 3055381ac967c16a2bbf32536cad3a317d207eab Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 13 Apr 2025 21:21:17 -0400
Subject: [PATCH 30/55] winewayland: Implement relative motion accumulator.

(cherry picked from commit d18f77996b7dd235c12f70493582f47c7e77887a)
---
 dlls/winewayland.drv/wayland_pointer.c | 43 ++++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 35 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 6c852292c1d..b2af6c0db4a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -257,6 +257,19 @@ static const struct wl_pointer_listener pointer_listener =
     pointer_handle_axis_discrete
 };
 
+/**********************************************************************
+ *          wayland_motion_delta_to_window
+ *
+ * Converts the surface-local delta to window (logical) coordinate delta.
+ */
+static void wayland_motion_delta_to_window(struct wayland_surface *surface,
+                                           double surface_x, double surface_y,
+                                           double *window_x, double *window_y)
+{
+    *window_x = surface_x * surface->window.scale;
+    *window_y = surface_y * surface->window.scale;
+}
+
 static void relative_pointer_v1_relative_motion(void *private,
                                                 struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
                                                 uint32_t utime_hi, uint32_t utime_lo,
@@ -265,28 +278,37 @@ static void relative_pointer_v1_relative_motion(void *private,
 {
     INPUT input = {0};
     HWND hwnd;
-    POINT screen;
     struct wayland_win_data *data;
+    double screen_x = 0.0, screen_y = 0.0;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    wayland_surface_coords_to_window(data->wayland_surface,
-                                     wl_fixed_to_double(dx),
-                                     wl_fixed_to_double(dy),
-                                     (int *)&screen.x, (int *)&screen.y);
-
+    wayland_motion_delta_to_window(data->wayland_surface,
+                                   wl_fixed_to_double(dx),
+                                   wl_fixed_to_double(dy),
+                                   &screen_x, &screen_y);
     wayland_win_data_release(data);
 
+    pthread_mutex_lock(&pointer->mutex);
+
+    pointer->accum_x += screen_x;
+    pointer->accum_y += screen_y;
 
     input.type = INPUT_MOUSE;
-    input.mi.dx = screen.x;
-    input.mi.dy = screen.y;
+    input.mi.dx = round(pointer->accum_x);
+    input.mi.dy = round(pointer->accum_y);
     input.mi.dwFlags = MOUSEEVENTF_MOVE;
 
-    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f screen_dxdy=%d,%d\n",
+    pointer->accum_x -= input.mi.dx;
+    pointer->accum_y -= input.mi.dy;
+
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
           hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
-          (int)screen.x, (int)screen.y);
+          (int)input.mi.dx, (int)input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
@@ -778,6 +800,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
     if (needs_relative && !pointer->zwp_relative_pointer_v1)
     {
+        pointer->accum_x = pointer->accum_y = 0;
         pointer->zwp_relative_pointer_v1 =
             zwp_relative_pointer_manager_v1_get_relative_pointer(
                 process_wayland.zwp_relative_pointer_manager_v1,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1d0f5e7b921..d9158f2e6c1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -112,6 +112,8 @@ struct wayland_pointer
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
+    double accum_x;
+    double accum_y;
     pthread_mutex_t mutex;
 };
 

From 5ebcb0dba18e7ec4944b309a131665e648625f76 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 10:40:33 +0300
Subject: [PATCH 31/55] winewayland: Support building with older EGL headers.

Support building on systems with older EGL headers, which may not include
the EGL_EXT_present_opaque extension.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57941
---
 dlls/winewayland.drv/opengl.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 4f90de4b5f9..8c2a511154d 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -43,6 +43,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include "wine/wgl.h"
 #include "wine/wgl_driver.h"
 
+/* Support building on systems with older EGL headers, which may not include
+ * the EGL_EXT_present_opaque extension. */
+#ifndef EGL_PRESENT_OPAQUE_EXT
+#define EGL_PRESENT_OPAQUE_EXT 0x31DF
+#endif
+
 static void *egl_handle;
 static struct opengl_funcs opengl_funcs;
 static EGLDisplay egl_display;

From 258e71328392021abec564b0459c0efd095ff15a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 15:28:18 +0300
Subject: [PATCH 32/55] winewayland: Always check the role to determine whether
 a surface is a toplevel.

Since the role objects in the wayland_surface struct are part of a union, we
first need to check whether the surface has the right role before checking
the role objects themselves. Otherwise we risk using a subsurface as a toplevel
or vice-versa.
---
 dlls/winewayland.drv/wayland_surface.c | 10 +++++++---
 dlls/winewayland.drv/window.c          | 10 +++++++---
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 39b6991a5eb..320ce9daa17 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -48,7 +48,9 @@ static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if ((surface = data->wayland_surface) && surface->xdg_surface == xdg_surface)
+    if ((surface = data->wayland_surface) &&
+        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+        surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
@@ -116,7 +118,9 @@ static void xdg_toplevel_handle_configure(void *private,
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((surface = data->wayland_surface) && surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) &&
+        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+        surface->xdg_toplevel == xdg_toplevel)
     {
         surface->pending.width = width;
         surface->pending.height = height;
@@ -1172,7 +1176,7 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
     DWORD utf8_count;
     char *utf8 = NULL;
 
-    assert(surface->xdg_toplevel);
+    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
 
     TRACE("surface=%p hwnd=%p text='%s'\n",
           surface, surface->hwnd, wine_dbgstr_w(text));
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 184d09c2ed4..03dff29a4cc 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -537,7 +537,7 @@ static void wayland_configure_window(HWND hwnd)
         return;
     }
 
-    if (!surface->xdg_toplevel)
+    if (surface->role != WAYLAND_SURFACE_ROLE_TOPLEVEL || !surface->xdg_toplevel)
     {
         TRACE("missing xdg_toplevel, returning\n");
         wayland_win_data_release(data);
@@ -721,7 +721,9 @@ void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 
     if ((data = wayland_win_data_get(hwnd)))
     {
-        if ((surface = data->wayland_surface) && surface->xdg_toplevel)
+        if ((surface = data->wayland_surface) &&
+            surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+            surface->xdg_toplevel)
             wayland_surface_set_title(surface, text);
         wayland_win_data_release(data);
     }
@@ -755,7 +757,9 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
         {
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
-            if (wl_seat && (surface = data->wayland_surface) && surface->xdg_toplevel && button_serial)
+            if (wl_seat && (surface = data->wayland_surface) &&
+                surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                surface->xdg_toplevel && button_serial)
             {
                 if (command == SC_MOVE)
                 {

From c7bdfcd3da55328e76efc7c169dce8c05f95f559 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 15:46:33 +0300
Subject: [PATCH 33/55] winewayland: Introduce helper to check whether a
 surface is toplevel.

---
 dlls/winewayland.drv/wayland_surface.c | 11 ++++-------
 dlls/winewayland.drv/waylanddrv.h      |  5 +++++
 dlls/winewayland.drv/window.c          | 16 +++++-----------
 3 files changed, 14 insertions(+), 18 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 320ce9daa17..8d6b73a61a9 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -48,8 +48,7 @@ static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if ((surface = data->wayland_surface) &&
-        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+    if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface) &&
         surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
@@ -118,9 +117,7 @@ static void xdg_toplevel_handle_configure(void *private,
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((surface = data->wayland_surface) &&
-        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-        surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface))
     {
         surface->pending.width = width;
         surface->pending.height = height;
@@ -1176,7 +1173,7 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
     DWORD utf8_count;
     char *utf8 = NULL;
 
-    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+    assert(wayland_surface_is_toplevel(surface));
 
     TRACE("surface=%p hwnd=%p text='%s'\n",
           surface, surface->hwnd, wine_dbgstr_w(text));
@@ -1202,7 +1199,7 @@ void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONIN
     struct wayland_shm_buffer *icon_buf;
 
     assert(ii);
-    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+    assert(wayland_surface_is_toplevel(surface));
 
     hDC = NtGdiCreateCompatibleDC(0);
     icon_buf = wayland_shm_buffer_from_color_bitmaps(hDC, ii->hbmColor, ii->hbmMask);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index d9158f2e6c1..f6dc832e311 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -330,6 +330,11 @@ void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
 
+static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
+{
+    return surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel;
+}
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 03dff29a4cc..acc34a18218 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -494,8 +494,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     }
 
     needs_icon = data->wayland_surface && !data->wayland_surface->big_icon_buffer &&
-                 data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                 data->wayland_surface->xdg_toplevel &&
+                 wayland_surface_is_toplevel(data->wayland_surface) &&
                  process_wayland.xdg_toplevel_icon_manager_v1;
 
     wayland_win_data_release(data);
@@ -537,7 +536,7 @@ static void wayland_configure_window(HWND hwnd)
         return;
     }
 
-    if (surface->role != WAYLAND_SURFACE_ROLE_TOPLEVEL || !surface->xdg_toplevel)
+    if (!wayland_surface_is_toplevel(surface))
     {
         TRACE("missing xdg_toplevel, returning\n");
         wayland_win_data_release(data);
@@ -700,9 +699,7 @@ void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon)
         icon = get_window_icon(hwnd, type, icon, &ii);
         if (icon && (data = wayland_win_data_get(hwnd)))
         {
-            if (data->wayland_surface &&
-                data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                data->wayland_surface->xdg_toplevel)
+            if (data->wayland_surface && wayland_surface_is_toplevel(data->wayland_surface))
                 wayland_surface_set_icon(data->wayland_surface, type, &ii);
             wayland_win_data_release(data);
         }
@@ -721,9 +718,7 @@ void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 
     if ((data = wayland_win_data_get(hwnd)))
     {
-        if ((surface = data->wayland_surface) &&
-            surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-            surface->xdg_toplevel)
+        if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface))
             wayland_surface_set_title(surface, text);
         wayland_win_data_release(data);
     }
@@ -758,8 +753,7 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
             if (wl_seat && (surface = data->wayland_surface) &&
-                surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                surface->xdg_toplevel && button_serial)
+                wayland_surface_is_toplevel(surface) && button_serial)
             {
                 if (command == SC_MOVE)
                 {

From 92d8a0a6aa63516b2855c459f869c35b8606473c Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 20 Apr 2025 11:30:03 +0000
Subject: [PATCH 34/55] winewayland: Require wl_pointer for pointer
 constraints.

If ClipCursor is called while the seat doesn't have a pointer and the
call qualifies for locking the pointer, it would have tried to lock a
null wl_pointer.
---
 dlls/winewayland.drv/wayland_pointer.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index b2af6c0db4a..257735dc909 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -710,9 +710,10 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
     }
 
     needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface) || force_lock);
+                 !pointer->cursor.wl_surface) || force_lock) &&
+                 pointer->wl_pointer;
     needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
-                 !force_lock;
+                 !force_lock && pointer->wl_pointer;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {

From 0519cdda414f2f0432c85f77d364638d9ec4ccb1 Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Mon, 28 Apr 2025 12:24:06 +0200
Subject: [PATCH 35/55] winewayland: Remove redundant casts.

---
 dlls/winewayland.drv/wayland_pointer.c | 12 ++++++------
 dlls/winewayland.drv/wayland_surface.c |  6 +++---
 dlls/winewayland.drv/window.c          |  2 +-
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 257735dc909..beb9cc06702 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -87,7 +87,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
 
     TRACE("hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
           hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
-          (int)screen.x, (int)screen.y);
+          screen.x, screen.y);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
@@ -308,7 +308,7 @@ static void relative_pointer_v1_relative_motion(void *private,
 
     TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
           hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
-          (int)input.mi.dx, (int)input.mi.dy);
+          input.mi.dx, input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
@@ -762,9 +762,9 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
         TRACE("Confining to hwnd=%p wayland=%d,%d+%d,%d\n",
               pointer->constraint_hwnd,
-              (int)confine_rect->left, (int)confine_rect->top,
-              (int)(confine_rect->right - confine_rect->left),
-              (int)(confine_rect->bottom - confine_rect->top));
+              confine_rect->left, confine_rect->top,
+              confine_rect->right - confine_rect->left,
+              confine_rect->bottom - confine_rect->top);
 
         wl_region_destroy(region);
     }
@@ -906,7 +906,7 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
         wl_surface_commit(wl_surface);
         wayland_win_data_release(data);
         TRACE("position hint hwnd=%p wayland_xy=%d,%d screen_xy=%d,%d\n",
-                hwnd, warp_x, warp_y, (int)cursor_pos.x, (int)cursor_pos.y);
+                hwnd, warp_x, warp_y, cursor_pos.x, cursor_pos.y);
         pthread_mutex_lock(&pointer->mutex);
     }
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 8d6b73a61a9..99049f4e536 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -817,7 +817,7 @@ struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
                              NULL, &section_size, PAGE_READWRITE, SEC_COMMIT, 0);
     if (status)
     {
-        ERR("Failed to create SHM section status=0x%lx\n", (long)status);
+        ERR("Failed to create SHM section status=0x%x\n", status);
         goto err;
     }
 
@@ -827,14 +827,14 @@ struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
     if (status)
     {
         shm_buffer->map_data = NULL;
-        ERR("Failed to create map SHM handle status=0x%lx\n", (long)status);
+        ERR("Failed to create map SHM handle status=0x%x\n", status);
         goto err;
     }
 
     status = wine_server_handle_to_fd(handle, FILE_READ_DATA, &fd, NULL);
     if (status)
     {
-        ERR("Failed to get fd from SHM handle status=0x%lx\n", (long)status);
+        ERR("Failed to get fd from SHM handle status=0x%x\n", status);
         goto err;
     }
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index acc34a18218..ce5b6bb5143 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -158,7 +158,7 @@ static void wayland_win_data_get_config(struct wayland_win_data *data,
     conf->client_rect = data->rects.client;
     style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
 
-    TRACE("window=%s style=%#lx\n", wine_dbgstr_rect(&conf->rect), (long)style);
+    TRACE("window=%s style=%#x\n", wine_dbgstr_rect(&conf->rect), style);
 
     /* The fullscreen state is implied by the window position and style. */
     if (data->is_fullscreen)

From 61f3533eddef2d9eb010ebbd6014e35bd04073aa Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 20 Feb 2025 11:34:34 -0800
Subject: [PATCH 36/55] server: Use a high precision timespec directly for poll
 timeouts on supported platforms.

Instead of first converting to milliseconds, then back to a nanosecond-precision
timespec.

This mitigates a side effect of the global current_time and monotonic_time
being updated on every server call's timeout, where the end time of any unrelated
server call is moved into the future (depending on the frequency of server calls).

By using a more granular timeout, the overall frequency of server calls doesn't have
as great of an effect on each individual timeout, as we don't have to wait for an
entire millisecond (which was due to the ceiling operation in get_next_timeout).

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57849
---
 server/fd.c | 64 ++++++++++++++++++++++++++---------------------------
 1 file changed, 31 insertions(+), 33 deletions(-)

diff --git a/server/fd.c b/server/fd.c
index 47c7ec7ee9a..6c6b02bf83e 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -350,7 +350,7 @@ timeout_t current_time;
 timeout_t monotonic_time;
 
 struct _KUSER_SHARED_DATA *user_shared_data = NULL;
-static const int user_shared_data_timeout = 16;
+static const timeout_t user_shared_data_timeout = 16 * 10000;
 
 static void atomic_store_ulong(volatile ULONG *ptr, ULONG value)
 {
@@ -508,7 +508,7 @@ static int active_users;                    /* current number of active users */
 static int allocated_users;                 /* count of allocated entries in the array */
 static struct fd **freelist;                /* list of free entries in the array */
 
-static int get_next_timeout(void);
+static int get_next_timeout( struct timespec *ts );
 
 static inline void fd_poll_event( struct fd *fd, int event )
 {
@@ -587,7 +587,7 @@ static inline void main_loop_epoll(void)
 
     while (active_users)
     {
-        timeout = get_next_timeout();
+        timeout = get_next_timeout( NULL );
 
         if (!active_users) break;  /* last user removed by a timeout */
         if (epoll_fd == -1) break;  /* an error occurred with epoll */
@@ -675,26 +675,19 @@ static inline void remove_epoll_user( struct fd *fd, int user )
 static inline void main_loop_epoll(void)
 {
     int i, ret, timeout;
+    struct timespec ts;
     struct kevent events[128];
 
     if (kqueue_fd == -1) return;
 
     while (active_users)
     {
-        timeout = get_next_timeout();
+        timeout = get_next_timeout( &ts );
 
         if (!active_users) break;  /* last user removed by a timeout */
         if (kqueue_fd == -1) break;  /* an error occurred with kqueue */
 
-        if (timeout != -1)
-        {
-            struct timespec ts;
-
-            ts.tv_sec = timeout / 1000;
-            ts.tv_nsec = (timeout % 1000) * 1000000;
-            ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), &ts );
-        }
-        else ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), NULL );
+        ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), timeout == -1 ? NULL : &ts );
 
         set_current_time();
 
@@ -777,27 +770,20 @@ static inline void remove_epoll_user( struct fd *fd, int user )
 static inline void main_loop_epoll(void)
 {
     int i, nget, ret, timeout;
+    struct timespec ts;
     port_event_t events[128];
 
     if (port_fd == -1) return;
 
     while (active_users)
     {
-        timeout = get_next_timeout();
+        timeout = get_next_timeout( &ts );
         nget = 1;
 
         if (!active_users) break;  /* last user removed by a timeout */
         if (port_fd == -1) break;  /* an error occurred with event completion */
 
-        if (timeout != -1)
-        {
-            struct timespec ts;
-
-            ts.tv_sec = timeout / 1000;
-            ts.tv_nsec = (timeout % 1000) * 1000000;
-            ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, &ts );
-        }
-        else ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, NULL );
+        ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, timeout == -1 ? NULL : &ts );
 
 	if (ret == -1) break;  /* an error occurred with event completion */
 
@@ -888,10 +874,11 @@ static void remove_poll_user( struct fd *fd, int user )
     active_users--;
 }
 
-/* process pending timeouts and return the time until the next timeout, in milliseconds */
-static int get_next_timeout(void)
+/* process pending timeouts and return the time until the next timeout in milliseconds,
+ * and full nanosecond precision in the timespec parameter if given */
+static int get_next_timeout( struct timespec *ts )
 {
-    int ret = user_shared_data ? user_shared_data_timeout : -1;
+    timeout_t ret = user_shared_data ? user_shared_data_timeout : -1;
 
     if (!list_empty( &abs_timeout_list ) || !list_empty( &rel_timeout_list ))
     {
@@ -936,21 +923,32 @@ static int get_next_timeout(void)
         if ((ptr = list_head( &abs_timeout_list )) != NULL)
         {
             struct timeout_user *timeout = LIST_ENTRY( ptr, struct timeout_user, entry );
-            timeout_t diff = (timeout->when - current_time + 9999) / 10000;
-            if (diff > INT_MAX) diff = INT_MAX;
-            else if (diff < 0) diff = 0;
+            timeout_t diff = timeout->when - current_time;
+            if (diff < 0) diff = 0;
             if (ret == -1 || diff < ret) ret = diff;
         }
 
         if ((ptr = list_head( &rel_timeout_list )) != NULL)
         {
             struct timeout_user *timeout = LIST_ENTRY( ptr, struct timeout_user, entry );
-            timeout_t diff = (-timeout->when - monotonic_time + 9999) / 10000;
-            if (diff > INT_MAX) diff = INT_MAX;
-            else if (diff < 0) diff = 0;
+            timeout_t diff = -timeout->when - monotonic_time;
+            if (diff < 0) diff = 0;
             if (ret == -1 || diff < ret) ret = diff;
         }
     }
+
+    /* infinite */
+    if (ret == -1) return -1;
+
+    if (ts)
+    {
+        ts->tv_sec = ret / TICKS_PER_SEC;
+        ts->tv_nsec = (ret % TICKS_PER_SEC) * 100;
+    }
+
+    /* convert to milliseconds, ceil to avoid spinning with 0 timeout */
+    ret = (ret + 9999) / 10000;
+    if (ret > INT_MAX) ret = INT_MAX;
     return ret;
 }
 
@@ -967,7 +965,7 @@ void main_loop(void)
 
     while (active_users)
     {
-        timeout = get_next_timeout();
+        timeout = get_next_timeout( NULL );
 
         if (!active_users) break;  /* last user removed by a timeout */
 

From 0f471ff853944b44d832122fad389fff92df3161 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 20 Feb 2025 11:39:06 -0800
Subject: [PATCH 37/55] server: Use epoll_pwait2 for the main loop on Linux.

This allows higher precision waits, to match the other platforms where
we can already use a timespec directly.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57849
---
 configure.ac | 1 +
 server/fd.c  | 8 +++++++-
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 9acc7ce2845..a071770f541 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2115,6 +2115,7 @@ AC_CHECK_FUNCS(\
         dladdr1 \
 	dlinfo \
 	epoll_create \
+	epoll_pwait2 \
 	fstatfs \
 	futimens \
 	futimes \
diff --git a/server/fd.c b/server/fd.c
index 6c6b02bf83e..6d1ab8e1f58 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -576,6 +576,7 @@ static inline void remove_epoll_user( struct fd *fd, int user )
 static inline void main_loop_epoll(void)
 {
     int i, ret, timeout;
+    struct timespec ts;
     struct epoll_event events[128];
 
     assert( POLLIN == EPOLLIN );
@@ -587,12 +588,17 @@ static inline void main_loop_epoll(void)
 
     while (active_users)
     {
-        timeout = get_next_timeout( NULL );
+        timeout = get_next_timeout( &ts );
 
         if (!active_users) break;  /* last user removed by a timeout */
         if (epoll_fd == -1) break;  /* an error occurred with epoll */
 
+#ifdef HAVE_EPOLL_PWAIT2
+        ret = epoll_pwait2( epoll_fd, events, ARRAY_SIZE( events ), timeout == -1 ? NULL : &ts, NULL );
+#else
         ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
+#endif
+
         set_current_time();
 
         /* put the events into the pollfd array first, like poll does */

From b9dc1082a3d5010be937e93cb03b9861c801a786 Mon Sep 17 00:00:00 2001
From: Alfred Agrell <floating@muncher.se>
Date: Sat, 22 Mar 2025 10:38:36 +0100
Subject: [PATCH 38/55] server: Fall back to epoll_wait if epoll_pwait2 doesn't
 work.

Fixes: 87ca5db40e2c1b37423bdc25101a5c5e39e67e6f
---
 server/fd.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/server/fd.c b/server/fd.c
index 6d1ab8e1f58..2c21e343ce4 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -578,6 +578,9 @@ static inline void main_loop_epoll(void)
     int i, ret, timeout;
     struct timespec ts;
     struct epoll_event events[128];
+#ifdef HAVE_EPOLL_PWAIT2
+    static int failed_epoll_pwait2 = 0;
+#endif
 
     assert( POLLIN == EPOLLIN );
     assert( POLLOUT == EPOLLOUT );
@@ -594,10 +597,15 @@ static inline void main_loop_epoll(void)
         if (epoll_fd == -1) break;  /* an error occurred with epoll */
 
 #ifdef HAVE_EPOLL_PWAIT2
-        ret = epoll_pwait2( epoll_fd, events, ARRAY_SIZE( events ), timeout == -1 ? NULL : &ts, NULL );
-#else
-        ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
+        if (!failed_epoll_pwait2)
+        {
+            ret = epoll_pwait2( epoll_fd, events, ARRAY_SIZE( events ), timeout == -1 ? NULL : &ts, NULL );
+            if (ret == -1 && errno == ENOSYS)
+                failed_epoll_pwait2 = 1;
+        }
+        if (failed_epoll_pwait2)
 #endif
+            ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
 
         set_current_time();
 

From 4a3eacadc5939e70f3e06f34a908e206aaa4d935 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 2 May 2025 16:59:04 +0300
Subject: [PATCH 39/55] winewayland: Use ARGB buffers for shaped windows.

When we detect a shaped window, switch to ARGB buffers in order to
be able to apply the shape (in a follow-up commit).
---
 dlls/winewayland.drv/wayland_surface.c |  1 +
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/window_surface.c  | 66 +++++++++++++++++++-------
 3 files changed, 52 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 99049f4e536..d0385f03a4e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -802,6 +802,7 @@ struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
     shm_buffer->ref = 1;
     shm_buffer->width = width;
     shm_buffer->height = height;
+    shm_buffer->format = format;
     shm_buffer->map_size = size;
 
     shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, width, height);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f6dc832e311..3566103c3ab 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -246,6 +246,7 @@ struct wayland_shm_buffer
     struct wl_list link;
     struct wl_buffer *wl_buffer;
     int width, height;
+    uint32_t format;
     void *map_data;
     size_t map_size;
     BOOL busy;
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 36bbb2d4f67..33cffad67af 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -38,6 +38,7 @@ struct wayland_buffer_queue
     struct wl_list buffer_list;
     int width;
     int height;
+    uint32_t format;
 };
 
 struct wayland_window_surface
@@ -101,7 +102,8 @@ static void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
  *
  * Creates a buffer queue containing buffers with the specified width and height.
  */
-static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int height)
+static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int height,
+                                                                uint32_t format)
 {
     struct wayland_buffer_queue *queue;
 
@@ -112,6 +114,7 @@ static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int h
     if (!queue->wl_event_queue) goto err;
     queue->width = width;
     queue->height = height;
+    queue->format = format;
 
     wl_list_init(&queue->buffer_list);
 
@@ -153,7 +156,7 @@ static struct wayland_shm_buffer *wayland_buffer_queue_get_free_buffer(struct wa
         if (nbuffers < 3)
         {
             shm_buffer = wayland_shm_buffer_create(queue->width, queue->height,
-                                                   WL_SHM_FORMAT_XRGB8888);
+                                                   queue->format);
             if (shm_buffer)
             {
                 /* Buffer events go to their own queue so that we can dispatch
@@ -241,7 +244,7 @@ RGNDATA *get_region_data(HRGN region)
  */
 static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
                               char *dst_pixels, RECT *dst_rect,
-                              HRGN region)
+                              HRGN region, BOOL force_opaque)
 {
     static const int bpp = WINEWAYLAND_BYTES_PER_PIXEL;
     RGNDATA *rgndata = get_region_data(region);
@@ -261,7 +264,7 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
     {
         const char *src;
         char *dst;
-        int y, width_bytes, height;
+        int x, y, width, height;
         RECT rc;
 
         TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
@@ -271,21 +274,39 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
 
         src = src_pixels + (rc.top - src_rect->top) * src_stride + (rc.left - src_rect->left) * bpp;
         dst = dst_pixels + (rc.top - dst_rect->top) * dst_stride + (rc.left - dst_rect->left) * bpp;
-        width_bytes = (rc.right - rc.left) * bpp;
+        width = rc.right - rc.left;
         height = rc.bottom - rc.top;
 
         /* Fast path for full width rectangles. */
-        if (width_bytes == src_stride && width_bytes == dst_stride)
+        if (width * bpp == src_stride && src_stride == dst_stride)
         {
-            memcpy(dst, src, height * width_bytes);
+            if (force_opaque)
+            {
+                for (x = 0; x < height * width; ++x)
+                    ((UINT32 *)dst)[x] = ((UINT32 *)src)[x] | 0xff000000;
+            }
+            else memcpy(dst, src, height * width * 4);
             continue;
         }
 
-        for (y = 0; y < height; y++)
+        if (force_opaque)
         {
-            memcpy(dst, src, width_bytes);
-            src += src_stride;
-            dst += dst_stride;
+            for (y = 0; y < height; y++)
+            {
+                for (x = 0; x < width; ++x)
+                    ((UINT32 *)dst)[x] = ((UINT32 *)src)[x] | 0xff000000;
+                src += src_stride;
+                dst += dst_stride;
+            }
+        }
+        else
+        {
+            for (y = 0; y < height; y++)
+            {
+                memcpy(dst, src, width * 4);
+                src += src_stride;
+                dst += dst_stride;
+            }
         }
     }
 
@@ -297,11 +318,11 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
  */
 static void wayland_shm_buffer_copy_data(struct wayland_shm_buffer *buffer,
                                          const char *bits, RECT *rect,
-                                         HRGN region)
+                                         HRGN region, BOOL force_opaque)
 {
     RECT buffer_rect = {0, 0, buffer->width, buffer->height};
     TRACE("buffer=%p bits=%p rect=%s\n", buffer, bits, wine_dbgstr_rect(rect));
-    copy_pixel_region(bits, rect, buffer->map_data, &buffer_rect, region);
+    copy_pixel_region(bits, rect, buffer->map_data, &buffer_rect, region, force_opaque);
 }
 
 static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
@@ -311,7 +332,8 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
     RECT src_rect = {0, 0, src->width, src->height};
     RECT dst_rect = {0, 0, dst->width, dst->height};
     TRACE("src=%p dst=%p\n", src, dst);
-    copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region);
+    copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region,
+                      src->format == WL_SHM_FORMAT_XRGB8888 && dst->format == WL_SHM_FORMAT_ARGB8888);
 }
 
 /***********************************************************************
@@ -327,6 +349,7 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
     BOOL flushed = FALSE;
     HRGN surface_damage_region = NULL;
     HRGN copy_from_window_region;
+    uint32_t buffer_format;
 
     surface_damage_region = NtGdiCreateRectRgn(rect->left + dirty->left, rect->top + dirty->top,
                                                rect->left + dirty->right, rect->top + dirty->bottom);
@@ -336,6 +359,16 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
         goto done;
     }
 
+    buffer_format = shape_bits ? WL_SHM_FORMAT_ARGB8888 : WL_SHM_FORMAT_XRGB8888;
+    if (wws->wayland_buffer_queue->format != buffer_format)
+    {
+        int width = wws->wayland_buffer_queue->width;
+        int height = wws->wayland_buffer_queue->height;
+        TRACE("recreating buffer queue with format %d\n", buffer_format);
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height, buffer_format);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
 
     shm_buffer = wayland_buffer_queue_get_free_buffer(wws->wayland_buffer_queue);
@@ -377,7 +410,8 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
         copy_from_window_region = shm_buffer->damage_region;
     }
 
-    wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region);
+    wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region,
+                                 !!shape_bits);
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
 
     flushed = set_window_surface_contents(window_surface->hwnd, shm_buffer, surface_damage_region);
@@ -433,7 +467,7 @@ static struct window_surface *wayland_window_surface_create(HWND hwnd, const REC
     if ((window_surface = window_surface_create(sizeof(*wws), &wayland_window_surface_funcs, hwnd, rect, info, 0)))
     {
         struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
-        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height);
+        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height, WL_SHM_FORMAT_XRGB8888);
     }
 
     return window_surface;

From b040b15f36b21403bf7f034195fdf88a896c849c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 40/55] winewayland: Implement window surface shape and color
 keying.

---
 dlls/winewayland.drv/window_surface.c | 30 +++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 33cffad67af..f3bda116e6d 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -336,6 +336,34 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
                       src->format == WL_SHM_FORMAT_XRGB8888 && dst->format == WL_SHM_FORMAT_ARGB8888);
 }
 
+/**********************************************************************
+ *          wayland_shm_buffer_copy_shape
+ */
+static void wayland_shm_buffer_copy_shape(struct wayland_shm_buffer *buffer, const RECT *dirty,
+                                          const BITMAPINFO *shape_info, const void *shape_bits)
+{
+    RECT dst_rect = {0, 0, buffer->width, buffer->height};
+    UINT32 *color, shape_stride, color_stride, x, y;
+    const BYTE *shape;
+    RECT rect;
+
+    shape_stride = shape_info->bmiHeader.biSizeImage / abs(shape_info->bmiHeader.biHeight);
+    color_stride = dst_rect.right - dst_rect.left;
+
+    if (!intersect_rect(&rect, &dst_rect, dirty)) return;
+
+    color = (UINT32 *)buffer->map_data + rect.top * color_stride;
+    shape = (const BYTE *)shape_bits + rect.top * shape_stride;
+
+    for (y = rect.top; y < rect.bottom; y++, color += color_stride, shape += shape_stride)
+    {
+        for (x = rect.left; x < rect.right; x++)
+        {
+            if (!(shape[x / 8] & (1 << (7 - (x & 7))))) color[x] = 0;
+        }
+    }
+}
+
 /***********************************************************************
  *           wayland_window_surface_flush
  */
@@ -412,6 +440,8 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
 
     wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region,
                                  !!shape_bits);
+    if (shape_bits) wayland_shm_buffer_copy_shape(shm_buffer, rect, shape_info, shape_bits);
+
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
 
     flushed = set_window_surface_contents(window_surface->hwnd, shm_buffer, surface_damage_region);

From 2210f88650d4c7b7364d8745e522e9f0100e7631 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 27 Feb 2025 19:36:33 -0800
Subject: [PATCH 41/55] server: Determine the highest resolution epoll_wait
 function to use at run-time.

For Linux, using a weakly declared epoll_pwait2. This will allow a Wine built on Linux 5.11+
to work on a Linux 5.10 kernel without epoll_pwait2 available, and vice versa.

There's no precedent for __attribute__((weak)) in Wine, but this should work
even for ancient toolchains. Even GCC 4 supports it.

An extension to https://gitlab.winehq.org/wine/wine/-/merge_requests/7392 to
enable the use of epoll_pwait2 for e.g. SLR SDK builds. (alt)
---
 configure.ac |  1 -
 server/fd.c  | 20 +++++++-------------
 2 files changed, 7 insertions(+), 14 deletions(-)

diff --git a/configure.ac b/configure.ac
index a071770f541..9acc7ce2845 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2115,7 +2115,6 @@ AC_CHECK_FUNCS(\
         dladdr1 \
 	dlinfo \
 	epoll_create \
-	epoll_pwait2 \
 	fstatfs \
 	futimens \
 	futimes \
diff --git a/server/fd.c b/server/fd.c
index 2c21e343ce4..633b078a8a3 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -573,14 +573,16 @@ static inline void remove_epoll_user( struct fd *fd, int user )
     }
 }
 
+__attribute__((weak)) int epoll_pwait2( int, struct epoll_event *, int, const struct timespec *, const sigset_t * );
+
 static inline void main_loop_epoll(void)
 {
     int i, ret, timeout;
     struct timespec ts;
     struct epoll_event events[128];
-#ifdef HAVE_EPOLL_PWAIT2
-    static int failed_epoll_pwait2 = 0;
-#endif
+    int use_epoll_pwait2 = !!epoll_pwait2;
+    if (use_epoll_pwait2 && epoll_pwait2( -1, events, 0, NULL, NULL ) == -1 && errno == ENOSYS)
+        use_epoll_pwait2 = 0;
 
     assert( POLLIN == EPOLLIN );
     assert( POLLOUT == EPOLLOUT );
@@ -596,16 +598,8 @@ static inline void main_loop_epoll(void)
         if (!active_users) break;  /* last user removed by a timeout */
         if (epoll_fd == -1) break;  /* an error occurred with epoll */
 
-#ifdef HAVE_EPOLL_PWAIT2
-        if (!failed_epoll_pwait2)
-        {
-            ret = epoll_pwait2( epoll_fd, events, ARRAY_SIZE( events ), timeout == -1 ? NULL : &ts, NULL );
-            if (ret == -1 && errno == ENOSYS)
-                failed_epoll_pwait2 = 1;
-        }
-        if (failed_epoll_pwait2)
-#endif
-            ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
+        if (use_epoll_pwait2) ret = epoll_pwait2( epoll_fd, events, ARRAY_SIZE( events ), timeout == -1 ? NULL : &ts, NULL );
+        else ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
 
         set_current_time();
 

From bd786f9cbae611f87c37bf321736d223ec4d7e8e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 6 May 2025 09:06:03 -0400
Subject: [PATCH 42/55] hack: winewayland: handle fractional scaling

---
 dlls/winewayland.drv/Makefile.in             |   1 +
 dlls/winewayland.drv/fractional-scale-v1.xml | 102 +++++++++++++++++++
 dlls/winewayland.drv/wayland.c               |   8 ++
 dlls/winewayland.drv/wayland_surface.c       |  39 +++++++
 dlls/winewayland.drv/waylanddrv.h            |   5 +
 dlls/winewayland.drv/window.c                |   2 +-
 6 files changed, 156 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/fractional-scale-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index e7b1bfb90eb..f141c22ee36 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -7,6 +7,7 @@ IMPORTS = user32 win32u
 SOURCES = \
 	display.c \
 	dllmain.c \
+	fractional-scale-v1.xml \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
diff --git a/dlls/winewayland.drv/fractional-scale-v1.xml b/dlls/winewayland.drv/fractional-scale-v1.xml
new file mode 100644
index 00000000000..350bfc01eaf
--- /dev/null
+++ b/dlls/winewayland.drv/fractional-scale-v1.xml
@@ -0,0 +1,102 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="fractional_scale_v1">
+  <copyright>
+    Copyright © 2022 Kenny Levinsen
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for requesting fractional surface scales">
+    This protocol allows a compositor to suggest for surfaces to render at
+    fractional scales.
+
+    A client can submit scaled content by utilizing wp_viewport. This is done by
+    creating a wp_viewport object for the surface and setting the destination
+    rectangle to the surface size before the scale factor is applied.
+
+    The buffer size is calculated by multiplying the surface size by the
+    intended scale.
+
+    The wl_surface buffer scale should remain set to 1.
+
+    If a surface has a surface-local size of 100 px by 50 px and wishes to
+    submit buffers with a scale of 1.5, then a buffer of 150px by 75 px should
+    be used and the wp_viewport destination rectangle should be 100 px by 50 px.
+
+    For toplevel surfaces, the size is rounded halfway away from zero. The
+    rounding algorithm for subsurface position and size is not defined.
+  </description>
+
+  <interface name="wp_fractional_scale_manager_v1" version="1">
+    <description summary="fractional surface scale information">
+      A global interface for requesting surfaces to use fractional scales.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="unbind the fractional surface scale interface">
+        Informs the server that the client will not be using this protocol
+        object anymore. This does not affect any other objects,
+        wp_fractional_scale_v1 objects included.
+      </description>
+    </request>
+
+    <enum name="error">
+      <entry name="fractional_scale_exists" value="0"
+        summary="the surface already has a fractional_scale object associated"/>
+    </enum>
+
+    <request name="get_fractional_scale">
+      <description summary="extend surface interface for scale information">
+        Create an add-on object for the the wl_surface to let the compositor
+        request fractional scales. If the given wl_surface already has a
+        wp_fractional_scale_v1 object associated, the fractional_scale_exists
+        protocol error is raised.
+      </description>
+      <arg name="id" type="new_id" interface="wp_fractional_scale_v1"
+           summary="the new surface scale info interface id"/>
+      <arg name="surface" type="object" interface="wl_surface"
+           summary="the surface"/>
+    </request>
+  </interface>
+
+  <interface name="wp_fractional_scale_v1" version="1">
+    <description summary="fractional scale interface to a wl_surface">
+      An additional interface to a wl_surface object which allows the compositor
+      to inform the client of the preferred scale.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="remove surface scale information for surface">
+        Destroy the fractional scale object. When this object is destroyed,
+        preferred_scale events will no longer be sent.
+      </description>
+    </request>
+
+    <event name="preferred_scale">
+      <description summary="notify of new preferred scale">
+        Notification of a new preferred scale for this surface that the
+        compositor suggests that the client should use.
+
+        The sent scale is the numerator of a fraction with a denominator of 120.
+      </description>
+      <arg name="scale" type="uint" summary="the new preferred scale"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ba09d32ed89..08cbb8c6979 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -194,6 +194,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.xdg_toplevel_icon_manager_v1 =
             wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wp_fractional_scale_manager_v1") == 0)
+    {
+        process_wayland.wp_fractional_scale_manager_v1 =
+            wl_registry_bind(registry, id, &wp_fractional_scale_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -327,6 +332,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.xdg_toplevel_icon_manager_v1)
         ERR("Wayland compositor doesn't support xdg_toplevel_icon_manager_v1 (window icons will not be supported)\n");
 
+    if (!process_wayland.wp_fractional_scale_manager_v1)
+        ERR("Wayland compositor doesn't support wp_fractional_scale_manager_v1 (fractional scaling will be broken)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index d0385f03a4e..cbcb77122cb 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,6 +138,25 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
+void wp_fractional_scale_handle_scale(void* data,
+        struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
+{
+    double *data_scale;
+
+    assert(data);
+    data_scale = data;
+
+    /* FIXME: handle locking! */
+    *data_scale = scale / 120.0;
+
+    TRACE("Got scale %lf\n", *data_scale);
+}
+
+static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener =
+{
+    wp_fractional_scale_handle_scale
+};
+
 /**********************************************************************
  *          wayland_surface_create
  *
@@ -174,8 +193,22 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         goto err;
     }
 
+    /* in case we don't get notification */
+    surface->window.fractional_scale = 1.0;
     surface->window.scale = 1.0;
 
+    if (process_wayland.wp_fractional_scale_manager_v1)
+    {
+        surface->wp_fractional_scale_v1 =
+            wp_fractional_scale_manager_v1_get_fractional_scale(
+                process_wayland.wp_fractional_scale_manager_v1,
+                surface->wl_surface);
+        wp_fractional_scale_v1_add_listener(
+            surface->wp_fractional_scale_v1,
+            &wp_fractional_scale_listener,
+            &surface->window.fractional_scale);
+    }
+
     return surface;
 
 err:
@@ -212,6 +245,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     wayland_surface_clear_role(surface);
 
+    if (surface->wp_fractional_scale_v1)
+    {
+        wp_fractional_scale_v1_destroy(surface->wp_fractional_scale_v1);
+        surface->wp_fractional_scale_v1 = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3566103c3ab..8970b4a4869 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -37,6 +37,7 @@
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
 #include "xdg-toplevel-icon-v1-client-protocol.h"
+#include "fractional-scale-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -166,6 +167,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wp_viewporter *wp_viewporter;
     struct wl_subcompositor *wl_subcompositor;
+    struct wp_fractional_scale_manager_v1 *wp_fractional_scale_manager_v1;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
@@ -225,6 +227,8 @@ struct wayland_window_config
     RECT rect;
     RECT client_rect;
     enum wayland_surface_config_state state;
+    /* The scaling reported by the compositor */
+    double fractional_scale;
     /* The scale (i.e., normalized dpi) the window is rendering at. */
     double scale;
     BOOL visible;
@@ -260,6 +264,7 @@ struct wayland_surface
 
     struct wl_surface *wl_surface;
     struct wp_viewport *wp_viewport;
+    struct wp_fractional_scale_v1 *wp_fractional_scale_v1;
 
     enum wayland_surface_role role;
     union
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ce5b6bb5143..a27bb7f793b 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -174,7 +174,7 @@ static void wayland_win_data_get_config(struct wayland_win_data *data,
     }
 
     conf->state = window_state;
-    conf->scale = NtUserGetSystemDpiForProcess(0) / 96.0;
+    conf->scale = conf->fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
     conf->visible = (style & WS_VISIBLE) == WS_VISIBLE;
     conf->managed = data->managed;
 }

From b24857eecabeb374dae2a5d07504cb8082cf6b0a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 11 May 2025 23:10:42 -0400
Subject: [PATCH 43/55] fixup! winewayland: handle locking with fractional
 scale notification

ruh roh I started using fixup lmao
---
 dlls/winewayland.drv/wayland_surface.c | 25 +++++++++++++++++--------
 1 file changed, 17 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index cbcb77122cb..04ac0e6a5be 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,18 +138,27 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void* data,
+void wp_fractional_scale_handle_scale(void* user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
-    double *data_scale;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+    HWND hwnd = user_data;
+    assert(hwnd);
 
-    assert(data);
-    data_scale = data;
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if((surface = data->wayland_surface))
+        {
+            surface->window.fractional_scale = scale / 120.0;
+            surface->window.scale =
+                surface->window.fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
 
-    /* FIXME: handle locking! */
-    *data_scale = scale / 120.0;
+            TRACE("Got scale %lf\n", surface->window.fractional_scale);
+        }
 
-    TRACE("Got scale %lf\n", *data_scale);
+        wayland_win_data_release(data);
+    }
 }
 
 static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener =
@@ -206,7 +215,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         wp_fractional_scale_v1_add_listener(
             surface->wp_fractional_scale_v1,
             &wp_fractional_scale_listener,
-            &surface->window.fractional_scale);
+            hwnd);
     }
 
     return surface;

From 22aff9d4a43bfcba557df2de18a4f38ea991e7eb Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 12:22:40 -0400
Subject: [PATCH 44/55] hack: win32u: fix opengl applications on winewayland

---
 dlls/win32u/window.c                   | 3 ++-
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 dlls/winewayland.drv/waylanddrv_main.c | 1 +
 dlls/winewayland.drv/window_surface.c  | 8 ++++++++
 4 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 82761d31753..65657fda6c3 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -2040,7 +2040,8 @@ static struct window_surface *get_window_surface( HWND hwnd, UINT swp_flags, BOO
     else if (create_layered || is_layered) needs_surface = TRUE;
 
     if (is_opengl && !is_layered && !create_layered
-        && !(!create_opaque && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags ) && layered_flags & LWA_COLORKEY))
+        && !(!create_opaque && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags ) && layered_flags & LWA_COLORKEY)
+        && !user_driver->pHasWindowManager("waylanddrv"))
     {
         if (new_surface) window_surface_release( new_surface );
         new_surface = NULL;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8970b4a4869..b8d73e5d462 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -460,6 +460,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
                               const struct window_rects *new_rects, struct window_surface *surface);
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const struct window_rects *rects);
 BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
+BOOL WAYLAND_HasWindowManager(const char *name);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5486cc934ef..3806d4a74e5 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -52,6 +52,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
     .pCreateWindowSurface = WAYLAND_CreateWindowSurface,
+    .pHasWindowManager = WAYLAND_HasWindowManager,
     .pVulkanInit = WAYLAND_VulkanInit,
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index f3bda116e6d..408f52f3f77 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -522,3 +522,11 @@ BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_re
     wayland_win_data_release(data);
     return TRUE;
 }
+
+/***********************************************************************
+ *           WAYLAND_HasWindowManager
+ */
+BOOL WAYLAND_HasWindowManager(const char *name)
+{
+    return !strcmp("waylanddrv", name);
+}

From de00c3c7d1615daa9166a4a456fdceec9769125d Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 18:11:35 -0400
Subject: [PATCH 45/55] winewayland: register swap control tear

its up to compositor anyway, just no-op.
---
 dlls/winewayland.drv/opengl.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 8c2a511154d..442246578ee 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1237,6 +1237,7 @@ static BOOL init_opengl_funcs(void)
     opengl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
 
     register_extension("WGL_EXT_swap_control");
+    register_extension("WGL_EXT_swap_control_tear");
     opengl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
     opengl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
 

From 74ecf0b6fa73d17c8d754bdb12c9f8203475c7f4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 27 Mar 2025 10:01:54 +0200
Subject: [PATCH 46/55] winewayland: Use system cursor shapes when possible.

Use the cursor-shapes-v1 protocol to tell the compositor which system
cursor shape to use. If a shape match is not found (or cursor-shapes-v1
is not available) we fall back to setting the cursor buffer from the
Windows cursor data as before.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57648
---
 dlls/winewayland.drv/Makefile.in         |   1 +
 dlls/winewayland.drv/cursor-shape-v1.xml | 162 ++++++++++++++++
 dlls/winewayland.drv/wayland.c           |   6 +
 dlls/winewayland.drv/wayland_pointer.c   | 223 ++++++++++++++++++++---
 dlls/winewayland.drv/waylanddrv.h        |   3 +
 5 files changed, 367 insertions(+), 28 deletions(-)
 create mode 100644 dlls/winewayland.drv/cursor-shape-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f141c22ee36..44b099d4b49 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -5,6 +5,7 @@ UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS
 IMPORTS = user32 win32u
 
 SOURCES = \
+	cursor-shape-v1.xml \
 	display.c \
 	dllmain.c \
 	fractional-scale-v1.xml \
diff --git a/dlls/winewayland.drv/cursor-shape-v1.xml b/dlls/winewayland.drv/cursor-shape-v1.xml
new file mode 100644
index 00000000000..64b2f9b2c87
--- /dev/null
+++ b/dlls/winewayland.drv/cursor-shape-v1.xml
@@ -0,0 +1,162 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="cursor_shape_v1">
+  <copyright>
+    Copyright 2018 The Chromium Authors
+    Copyright 2023 Simon Ser
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <interface name="wp_cursor_shape_manager_v1" version="2">
+    <description summary="cursor shape manager">
+      This global offers an alternative, optional way to set cursor images. This
+      new way uses enumerated cursors instead of a wl_surface like
+      wl_pointer.set_cursor does.
+
+      Warning! The protocol described in this file is currently in the testing
+      phase. Backward compatible changes may be added together with the
+      corresponding interface version bump. Backward incompatible changes can
+      only be done by creating a new major version of the extension.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        Destroy the cursor shape manager.
+      </description>
+    </request>
+
+    <request name="get_pointer">
+      <description summary="manage the cursor shape of a pointer device">
+        Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
+
+        When the pointer capability is removed from the wl_seat, the
+        wp_cursor_shape_device_v1 object becomes inert.
+      </description>
+      <arg name="cursor_shape_device" type="new_id" interface="wp_cursor_shape_device_v1"/>
+      <arg name="pointer" type="object" interface="wl_pointer"/>
+    </request>
+
+    <request name="get_tablet_tool_v2">
+      <description summary="manage the cursor shape of a tablet tool device">
+        Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
+
+        When the zwp_tablet_tool_v2 is removed, the wp_cursor_shape_device_v1
+        object becomes inert.
+      </description>
+      <arg name="cursor_shape_device" type="new_id" interface="wp_cursor_shape_device_v1"/>
+      <arg name="tablet_tool" type="object" interface="zwp_tablet_tool_v2"/>
+    </request>
+  </interface>
+
+  <interface name="wp_cursor_shape_device_v1" version="2">
+    <description summary="cursor shape for a device">
+      This interface allows clients to set the cursor shape.
+    </description>
+
+    <enum name="shape">
+      <description summary="cursor shapes">
+        This enum describes cursor shapes.
+
+        The names are taken from the CSS W3C specification:
+        https://w3c.github.io/csswg-drafts/css-ui/#cursor
+        with a few additions.
+
+        Note that there are some groups of cursor shapes that are related:
+        The first group is drag-and-drop cursors which are used to indicate
+        the selected action during dnd operations. The second group is resize
+        cursors which are used to indicate resizing and moving possibilities
+        on window borders. It is recommended that the shapes in these groups
+        should use visually compatible images and metaphors.
+      </description>
+      <entry name="default" value="1" summary="default cursor"/>
+      <entry name="context_menu" value="2" summary="a context menu is available for the object under the cursor"/>
+      <entry name="help" value="3" summary="help is available for the object under the cursor"/>
+      <entry name="pointer" value="4" summary="pointer that indicates a link or another interactive element"/>
+      <entry name="progress" value="5" summary="progress indicator"/>
+      <entry name="wait" value="6" summary="program is busy, user should wait"/>
+      <entry name="cell" value="7" summary="a cell or set of cells may be selected"/>
+      <entry name="crosshair" value="8" summary="simple crosshair"/>
+      <entry name="text" value="9" summary="text may be selected"/>
+      <entry name="vertical_text" value="10" summary="vertical text may be selected"/>
+      <entry name="alias" value="11" summary="drag-and-drop: alias of/shortcut to something is to be created"/>
+      <entry name="copy" value="12" summary="drag-and-drop: something is to be copied"/>
+      <entry name="move" value="13" summary="drag-and-drop: something is to be moved"/>
+      <entry name="no_drop" value="14" summary="drag-and-drop: the dragged item cannot be dropped at the current cursor location"/>
+      <entry name="not_allowed" value="15" summary="drag-and-drop: the requested action will not be carried out"/>
+      <entry name="grab" value="16" summary="drag-and-drop: something can be grabbed"/>
+      <entry name="grabbing" value="17" summary="drag-and-drop: something is being grabbed"/>
+      <entry name="e_resize" value="18" summary="resizing: the east border is to be moved"/>
+      <entry name="n_resize" value="19" summary="resizing: the north border is to be moved"/>
+      <entry name="ne_resize" value="20" summary="resizing: the north-east corner is to be moved"/>
+      <entry name="nw_resize" value="21" summary="resizing: the north-west corner is to be moved"/>
+      <entry name="s_resize" value="22" summary="resizing: the south border is to be moved"/>
+      <entry name="se_resize" value="23" summary="resizing: the south-east corner is to be moved"/>
+      <entry name="sw_resize" value="24" summary="resizing: the south-west corner is to be moved"/>
+      <entry name="w_resize" value="25" summary="resizing: the west border is to be moved"/>
+      <entry name="ew_resize" value="26" summary="resizing: the east and west borders are to be moved"/>
+      <entry name="ns_resize" value="27" summary="resizing: the north and south borders are to be moved"/>
+      <entry name="nesw_resize" value="28" summary="resizing: the north-east and south-west corners are to be moved"/>
+      <entry name="nwse_resize" value="29" summary="resizing: the north-west and south-east corners are to be moved"/>
+      <entry name="col_resize" value="30" summary="resizing: that the item/column can be resized horizontally"/>
+      <entry name="row_resize" value="31" summary="resizing: that the item/row can be resized vertically"/>
+      <entry name="all_scroll" value="32" summary="something can be scrolled in any direction"/>
+      <entry name="zoom_in" value="33" summary="something can be zoomed in"/>
+      <entry name="zoom_out" value="34" summary="something can be zoomed out"/>
+      <entry name="dnd_ask" value="35" summary="drag-and-drop: the user will select which action will be carried out (non-css value)" since="2"/>
+      <entry name="all_resize" value="36" summary="resizing: something can be moved or resized in any direction (non-css value)" since="2"/>
+    </enum>
+
+    <enum name="error">
+      <entry name="invalid_shape" value="1"
+        summary="the specified shape value is invalid"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the cursor shape device">
+        Destroy the cursor shape device.
+
+        The device cursor shape remains unchanged.
+      </description>
+    </request>
+
+    <request name="set_shape">
+      <description summary="set device cursor to the shape">
+        Sets the device cursor to the specified shape. The compositor will
+        change the cursor image based on the specified shape.
+
+        The cursor actually changes only if the input device focus is one of
+        the requesting client's surfaces. If any, the previous cursor image
+        (surface or shape) is replaced.
+
+        The "shape" argument must be a valid enum entry, otherwise the
+        invalid_shape protocol error is raised.
+
+        This is similar to the wl_pointer.set_cursor and
+        zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
+        shape instead of contents in the form of a surface. Clients can mix
+        set_cursor and set_shape requests.
+
+        The serial parameter must match the latest wl_pointer.enter or
+        zwp_tablet_tool_v2.proximity_in serial number sent to the client.
+        Otherwise the request will be ignored.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the enter event"/>
+      <arg name="shape" type="uint" enum="shape"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 08cbb8c6979..75972be3428 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -194,6 +194,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.xdg_toplevel_icon_manager_v1 =
             wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wp_cursor_shape_manager_v1") == 0)
+    {
+        process_wayland.wp_cursor_shape_manager_v1 =
+            wl_registry_bind(registry, id, &wp_cursor_shape_manager_v1_interface,
+                             version < 2 ? version : 2);
+    }
     else if (strcmp(interface, "wp_fractional_scale_manager_v1") == 0)
     {
         process_wayland.wp_fractional_scale_manager_v1 =
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index beb9cc06702..070f7d8b77e 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -29,11 +29,86 @@
 #include <math.h>
 #include <stdlib.h>
 
+#define OEMRESOURCE
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* The cursor-shape-v1 protocol file references the zwp_tablet_tool_v2
+ * interface object. Since we don't currently use the tablet protocol,
+ * provide a dummy object here to avoid linking errors. */
+void *zwp_tablet_tool_v2_interface = NULL;
+
+struct system_cursors
+{
+    WORD id;
+    enum wp_cursor_shape_device_v1_shape shape;
+};
+
+static const struct system_cursors user32_cursors[] =
+{
+    {OCR_NORMAL,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT},
+    {OCR_IBEAM,       WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_TEXT},
+    {OCR_WAIT,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_WAIT},
+    {OCR_CROSS,       WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CROSSHAIR},
+    {OCR_SIZE,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE},
+    {OCR_SIZENWSE,    WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NWSE_RESIZE},
+    {OCR_SIZENESW,    WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NESW_RESIZE},
+    {OCR_SIZEWE,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_EW_RESIZE},
+    {OCR_SIZENS,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NS_RESIZE},
+    {OCR_SIZEALL,     WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE},
+    {OCR_NO,          WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NOT_ALLOWED},
+    {OCR_HAND,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {OCR_APPSTARTING, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_PROGRESS},
+    {OCR_HELP,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_HELP},
+    {OCR_RDR2DIM,     WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_SCROLL},
+    {0}
+};
+
+static const struct system_cursors comctl32_cursors[] =
+{
+    {102, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {104, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {105, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT},
+    {106, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE},
+    {107, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE},
+    {108, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {135, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ROW_RESIZE},
+    {0}
+};
+
+static const struct system_cursors ole32_cursors[] =
+{
+    {1, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP},
+    {2, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {3, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {4, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALIAS},
+    {0}
+};
+
+static const struct system_cursors riched20_cursors[] =
+{
+    {105, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {109, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {110, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {111, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP},
+    {0}
+};
+
+static const struct
+{
+    const struct system_cursors *cursors;
+    WCHAR name[16];
+} module_cursors[] =
+{
+    {user32_cursors, {'u','s','e','r','3','2','.','d','l','l',0}},
+    {comctl32_cursors, {'c','o','m','c','t','l','3','2','.','d','l','l',0}},
+    {ole32_cursors, {'o','l','e','3','2','.','d','l','l',0}},
+    {riched20_cursors, {'r','i','c','h','e','d','2','0','.','d','l','l',0}}
+};
+
 static HWND wayland_pointer_get_focused_hwnd(void)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
@@ -350,6 +425,11 @@ void wayland_pointer_deinit(void)
         zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
         pointer->zwp_relative_pointer_v1 = NULL;
     }
+    if (pointer->wp_cursor_shape_device_v1)
+    {
+        wp_cursor_shape_device_v1_destroy(pointer->wp_cursor_shape_device_v1);
+        pointer->wp_cursor_shape_device_v1 = NULL;
+    }
     wl_pointer_release(pointer->wl_pointer);
     pointer->wl_pointer = NULL;
     pointer->focused_hwnd = NULL;
@@ -509,6 +589,27 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
     }
 }
 
+static void wayland_pointer_clear_cursor_surface(void)
+{
+    struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
+
+    if (cursor->wp_viewport)
+    {
+        wp_viewport_destroy(cursor->wp_viewport);
+        cursor->wp_viewport = NULL;
+    }
+    if (cursor->wl_surface)
+    {
+        wl_surface_destroy(cursor->wl_surface);
+        cursor->wl_surface = NULL;
+    }
+    if (cursor->shm_buffer)
+    {
+        wayland_shm_buffer_unref(cursor->shm_buffer);
+        cursor->shm_buffer = NULL;
+    }
+}
+
 static void wayland_pointer_update_cursor_surface(double scale)
 {
     struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
@@ -557,21 +658,7 @@ static void wayland_pointer_update_cursor_surface(double scale)
     return;
 
 clear_cursor:
-    if (cursor->shm_buffer)
-    {
-        wayland_shm_buffer_unref(cursor->shm_buffer);
-        cursor->shm_buffer = NULL;
-    }
-    if (cursor->wp_viewport)
-    {
-        wp_viewport_destroy(cursor->wp_viewport);
-        cursor->wp_viewport = NULL;
-    }
-    if (cursor->wl_surface)
-    {
-        wl_surface_destroy(cursor->wl_surface);
-        cursor->wl_surface = NULL;
-    }
+    wayland_pointer_clear_cursor_surface();
 }
 
 static void reapply_cursor_clipping(void)
@@ -582,6 +669,76 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
+static enum wp_cursor_shape_device_v1_shape cursor_shape_from_info(ICONINFOEXW *info,
+                                                                   uint32_t proto_version)
+{
+    const struct system_cursors *cursors;
+    const WCHAR *module;
+    unsigned int i;
+    enum wp_cursor_shape_device_v1_shape shape = 0;
+
+    if (!info->szModName[0]) return 0;
+    if ((module = wcsrchr(info->szModName, '\\'))) module++;
+    else module = info->szModName;
+    for (i = 0; i < ARRAY_SIZE(module_cursors); i++)
+        if (!wcsicmp(module, module_cursors[i].name)) break;
+    if (i == ARRAY_SIZE(module_cursors)) return 0;
+
+    cursors = module_cursors[i].cursors;
+    for (i = 0; cursors[i].id; i++)
+    {
+        if (cursors[i].id == info->wResID)
+        {
+            shape = cursors[i].shape;
+            break;
+        }
+    }
+
+    if (shape >= WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DND_ASK && proto_version < 2)
+        shape = 0;
+
+    return shape;
+}
+
+static BOOL wayland_pointer_set_cursor_shape(HCURSOR hcursor)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+    ICONINFOEXW info = {0};
+    enum wp_cursor_shape_device_v1_shape shape = 0;
+    uint32_t proto_version;
+
+    if (!process_wayland.wp_cursor_shape_manager_v1) return FALSE;
+    if (!hcursor) return FALSE;
+    if (!get_icon_info(hcursor, &info)) return FALSE;
+    proto_version = wp_cursor_shape_manager_v1_get_version(
+        process_wayland.wp_cursor_shape_manager_v1);
+    if (!(shape = cursor_shape_from_info(&info, proto_version))) return FALSE;
+
+    if (!pointer->wp_cursor_shape_device_v1)
+    {
+        pointer->wp_cursor_shape_device_v1 =
+            wp_cursor_shape_manager_v1_get_pointer(
+                process_wayland.wp_cursor_shape_manager_v1, pointer->wl_pointer);
+        if (!pointer->wp_cursor_shape_device_v1) return FALSE;
+    }
+
+    wp_cursor_shape_device_v1_set_shape(pointer->wp_cursor_shape_device_v1,
+                                        pointer->enter_serial, shape);
+
+    return TRUE;
+}
+
+static void wayland_pointer_clear_cursor_shape(void)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (pointer->wp_cursor_shape_device_v1)
+    {
+        wp_cursor_shape_device_v1_destroy(pointer->wp_cursor_shape_device_v1);
+        pointer->wp_cursor_shape_device_v1 = NULL;
+    }
+}
+
 static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
@@ -611,13 +768,22 @@ static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
     pthread_mutex_lock(&pointer->mutex);
     if (pointer->focused_hwnd == hwnd)
     {
-        if (use_hcursor) wayland_pointer_update_cursor_buffer(hcursor, scale);
-        wayland_pointer_update_cursor_surface(scale);
-        wl_pointer_set_cursor(pointer->wl_pointer,
-                              pointer->enter_serial,
-                              pointer->cursor.wl_surface,
-                              pointer->cursor.hotspot_x,
-                              pointer->cursor.hotspot_y);
+        if ((!use_hcursor && pointer->wp_cursor_shape_device_v1) ||
+            (use_hcursor && hcursor && wayland_pointer_set_cursor_shape(hcursor)))
+        {
+            wayland_pointer_clear_cursor_surface();
+        }
+        else
+        {
+            if (use_hcursor) wayland_pointer_update_cursor_buffer(hcursor, scale);
+            wayland_pointer_update_cursor_surface(scale);
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  pointer->cursor.wl_surface,
+                                  pointer->cursor.hotspot_x,
+                                  pointer->cursor.hotspot_y);
+            wayland_pointer_clear_cursor_shape();
+        }
         wl_display_flush(process_wayland.wl_display);
         reapply_clip = TRUE;
     }
@@ -700,6 +866,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     BOOL needs_relative, needs_lock, needs_confine;
+    BOOL is_visible;
     static unsigned int once;
 
     if (!process_wayland.zwp_pointer_constraints_v1)
@@ -709,11 +876,12 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface) || force_lock) &&
+    is_visible = pointer->cursor.wl_surface || pointer->wp_cursor_shape_device_v1;
+    needs_lock = wl_surface &&
+                 (((confine_rect || covers_vscreen) && !is_visible) || force_lock) &&
                  pointer->wl_pointer;
-    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
-                 !force_lock && pointer->wl_pointer;
+    needs_confine = wl_surface && confine_rect && is_visible && !force_lock &&
+                    pointer->wl_pointer;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
@@ -795,8 +963,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_relative = !pointer->cursor.wl_surface &&
-                     pointer->constraint_hwnd &&
+    needs_relative = !is_visible && pointer->constraint_hwnd &&
                      pointer->constraint_hwnd == pointer->focused_hwnd;
 
     if (needs_relative && !pointer->zwp_relative_pointer_v1)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b8d73e5d462..efef3e6073a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -29,6 +29,7 @@
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbregistry.h>
+#include "cursor-shape-v1-client-protocol.h"
 #include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
 #include "text-input-unstable-v3-client-protocol.h"
@@ -107,6 +108,7 @@ struct wayland_pointer
     struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
     struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
+    struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1;
     HWND focused_hwnd;
     HWND constraint_hwnd;
     BOOL pending_warp;
@@ -174,6 +176,7 @@ struct wayland
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
+    struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;

From 2311d9e6157efba7ceb02d1d01a4f6066337305a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 27 Mar 2025 11:21:03 +0200
Subject: [PATCH 47/55] winewayland: Support "UseSystemCursors" driver option.

Allow users to disable system cursor shapes through a driver option.
---
 dlls/winewayland.drv/wayland_pointer.c |   1 +
 dlls/winewayland.drv/waylanddrv.h      |   1 +
 dlls/winewayland.drv/waylanddrv_main.c | 146 +++++++++++++++++++++++++
 3 files changed, 148 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 070f7d8b77e..ea7dc05284e 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -707,6 +707,7 @@ static BOOL wayland_pointer_set_cursor_shape(HCURSOR hcursor)
     enum wp_cursor_shape_device_v1_shape shape = 0;
     uint32_t proto_version;
 
+    if (!option_use_system_cursors) return FALSE;
     if (!process_wayland.wp_cursor_shape_manager_v1) return FALSE;
     if (!hcursor) return FALSE;
     if (!get_icon_info(hcursor, &info)) return FALSE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index efef3e6073a..f3a53e175fc 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -58,6 +58,7 @@
 
 extern char *process_name;
 extern struct wayland process_wayland;
+extern BOOL option_use_system_cursors;
 
 /**********************************************************************
  *          Definitions for wayland types
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 3806d4a74e5..83a60848362 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -31,7 +31,11 @@
 
 #include "waylanddrv.h"
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
 char *process_name = NULL;
+BOOL option_use_system_cursors = TRUE;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
@@ -57,6 +61,147 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
 
+static inline void ascii_to_unicode(WCHAR *dst, const char *src, size_t len)
+{
+    while (len--) *dst++ = (unsigned char)*src++;
+}
+
+static inline UINT asciiz_to_unicode(WCHAR *dst, const char *src)
+{
+    WCHAR *p = dst;
+    while ((*p++ = *src++));
+    return (p - dst) * sizeof(WCHAR);
+}
+
+static HKEY reg_open_key(HKEY root, const WCHAR *name, ULONG name_len)
+{
+    UNICODE_STRING nameW = {name_len, name_len, (WCHAR *)name};
+    OBJECT_ATTRIBUTES attr;
+    HANDLE ret;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
+}
+
+static HKEY open_hkcu_key(const char *name)
+{
+    WCHAR bufferW[256];
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data, len, &len))
+            return 0;
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = sprintf(buffer, "\\Registry\\User\\S-%u-%u", sid->Revision,
+                      MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                        sid->IdentifierAuthority.Value[4]),
+                               MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                        sid->IdentifierAuthority.Value[2])));
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+            len += sprintf(buffer + len, "-%u", sid->SubAuthority[i]);
+
+        ascii_to_unicode(bufferW, buffer, len);
+        hkcu = reg_open_key(NULL, bufferW, len * sizeof(WCHAR));
+    }
+
+    return reg_open_key(hkcu, bufferW, asciiz_to_unicode(bufferW, name) - sizeof(WCHAR));
+}
+
+static ULONG query_reg_value(HKEY hkey, const WCHAR *name,
+                             KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size)
+{
+    unsigned int name_size = name ? lstrlenW(name) * sizeof(WCHAR) : 0;
+    UNICODE_STRING nameW = {name_size, name_size, (WCHAR *)name};
+
+    if (NtQueryValueKey(hkey, &nameW, KeyValuePartialInformation,
+                        info, size, &size))
+        return 0;
+
+    return size - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
+}
+
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   WCHAR *buffer, DWORD size)
+{
+    WCHAR nameW[128];
+    char buf[2048];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)buf;
+
+    asciiz_to_unicode(nameW, name);
+
+    if (appkey && query_reg_value(appkey, nameW, info, sizeof(buf)))
+    {
+        size = min(info->DataLength, size - sizeof(WCHAR));
+        memcpy(buffer, info->Data, size);
+        buffer[size / sizeof(WCHAR)] = 0;
+        return 0;
+    }
+
+    if (defkey && query_reg_value(defkey, nameW, info, sizeof(buf)))
+    {
+        size = min(info->DataLength, size - sizeof(WCHAR));
+        memcpy(buffer, info->Data, size);
+        buffer[size / sizeof(WCHAR)] = 0;
+        return 0;
+    }
+
+    return ERROR_FILE_NOT_FOUND;
+}
+
+static void wayland_init_options(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    WCHAR buffer[MAX_PATH+16], *p, *appname;
+    HKEY hkey, appkey = 0;
+    DWORD len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = open_hkcu_key("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    len = lstrlenW(appname);
+
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+        int i;
+        for (i = 0; appname[i]; i++) buffer[i] = RtlDowncaseUnicodeChar(appname[i]);
+        buffer[i] = 0;
+        appname = buffer;
+        if ((process_name = malloc(len * 3 + 1)))
+            ntdll_wcstoumbs(appname, len + 1, process_name, len * 3 + 1, FALSE);
+        memcpy(appname + i, waylanddriverW, sizeof(waylanddriverW));
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+        if ((tmpkey = open_hkcu_key("Software\\Wine\\AppDefaults")))
+        {
+            appkey = reg_open_key(tmpkey, appname, lstrlenW(appname) * sizeof(WCHAR));
+            NtClose(tmpkey);
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
+    NtClose(appkey);
+    NtClose(hkey);
+}
+
 static void wayland_init_process_name(void)
 {
     WCHAR *p, *appname;
@@ -92,6 +237,7 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
     wayland_init_process_name();
+    wayland_init_options();
 
     if (!wayland_process_init()) goto err;
 

From d28dbcdda760d4f7cc463f136bd5c17c7f2e6d18 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 10:12:42 -0400
Subject: [PATCH 48/55] HACK: kernelbase: Add Wayland specific workarounds.

---
 dlls/kernelbase/process.c | 38 ++++++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 6 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 86d884a7821..0e82c3cfd94 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -584,13 +584,14 @@ static int battleye_launcher_redirect_hack( const WCHAR *app_name, WCHAR *new_na
 
 static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 {
-    static const struct
+    struct option
     {
         const WCHAR *exe_name;
         const WCHAR *append;
         const char *steamgameid;
-    }
-    options[] =
+    };
+
+    static const struct option options[] =
     {
         {L"Willful.exe", L" --disable_direct_composition=1"},
         {L"Banyu Lintar Angin - Little Storm -.exe", L" --disable_direct_composition=1"},
@@ -619,8 +620,17 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
         {L"UnrealCEFSubProcess.exe", L" --use-angle=d3d9", "2684500"},
         {L"\\EACefSubProcess.exe", L" --use-angle=vulkan"},
     };
+
+    /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
+    static const struct option wayland_options[] = {
+        {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
+    };
+
     unsigned int i;
-    char sgi[64];
+    char sgi[64] = {0};
+    char wayland_hack_enabled[64] = {0};
+
+    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
 
     if (!cmd) return NULL;
 
@@ -628,13 +638,29 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     {
         if (wcsstr( cmd, options[i].exe_name ))
         {
-            if (options[i].steamgameid && !(GetEnvironmentVariableA( "SteamGameId", sgi, sizeof(sgi) )
-                && !strcmp( sgi, options[i].steamgameid )))
+            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
                 continue;
             FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
             return options[i].append;
         }
     }
+
+    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
+            wayland_hack_enabled, sizeof(wayland_hack_enabled));
+
+    if (wayland_hack_enabled[0] != '1') return NULL;
+
+    for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
+    {
+        if (wcsstr( cmd, wayland_options[i].exe_name ))
+        {
+            if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+                continue;
+            FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
+            return wayland_options[i].append;
+        }
+    }
+
     return NULL;
 }
 

From 10118304ddf9e98be4590d43131985d280334fb8 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 10:17:06 -0400
Subject: [PATCH 49/55] fixup! kernelbase: Check for wayland hacks first

---
 dlls/kernelbase/process.c | 33 +++++++++++++++++----------------
 1 file changed, 17 insertions(+), 16 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 0e82c3cfd94..b10bdf1fa9b 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -634,30 +634,31 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 
     if (!cmd) return NULL;
 
-    for (i = 0; i < ARRAY_SIZE(options); ++i)
+    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
+        wayland_hack_enabled, sizeof(wayland_hack_enabled));
+
+    if (wayland_hack_enabled[0] == '1')
     {
-        if (wcsstr( cmd, options[i].exe_name ))
+        for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
         {
-            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
-                continue;
-            FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
-            return options[i].append;
+            if (wcsstr( cmd, wayland_options[i].exe_name ))
+            {
+                if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+                    continue;
+                FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
+                return wayland_options[i].append;
+            }
         }
     }
 
-    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
-            wayland_hack_enabled, sizeof(wayland_hack_enabled));
-
-    if (wayland_hack_enabled[0] != '1') return NULL;
-
-    for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
+    for (i = 0; i < ARRAY_SIZE(options); ++i)
     {
-        if (wcsstr( cmd, wayland_options[i].exe_name ))
+        if (wcsstr( cmd, options[i].exe_name ))
         {
-            if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
                 continue;
-            FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
-            return wayland_options[i].append;
+            FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
+            return options[i].append;
         }
     }
 

From 41101f82ad71928b1389fe9fdab152fe47256b61 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 13:47:59 -0400
Subject: [PATCH 50/55] kernelbase: Enable in-process-gpu for battle.net

---
 dlls/kernelbase/process.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index b10bdf1fa9b..39c99885708 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -624,16 +624,16 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
     static const struct option wayland_options[] = {
         {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
+        {L"Battle.net.exe", L" --in-process-gpu"},
     };
 
     unsigned int i;
     char sgi[64] = {0};
     char wayland_hack_enabled[64] = {0};
 
-    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
-
     if (!cmd) return NULL;
 
+    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
     GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
         wayland_hack_enabled, sizeof(wayland_hack_enabled));
 

From 210a13b3ea64bc06964139d4bbce269ef95b05df Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 16:11:24 -0400
Subject: [PATCH 51/55] kernelbase: Add in-process-gpu for RSI launcher

---
 dlls/kernelbase/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 39c99885708..ece61d6829f 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -625,6 +625,7 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     static const struct option wayland_options[] = {
         {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
         {L"Battle.net.exe", L" --in-process-gpu"},
+        {L"RSI Launcher.exe", L" --in-process-gpu"}
     };
 
     unsigned int i;

From 08df9731e189c76def5ec4ffa0bc5e744baa9559 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 19:22:47 -0400
Subject: [PATCH 52/55] winewayland: Use unaccelerated relative motion.

---
 dlls/winewayland.drv/wayland_pointer.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index ea7dc05284e..3644f355c2b 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -360,9 +360,10 @@ static void relative_pointer_v1_relative_motion(void *private,
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
+    /* Use "raw" input by default. However, it's not nessessarily raw */
     wayland_motion_delta_to_window(data->wayland_surface,
-                                   wl_fixed_to_double(dx),
-                                   wl_fixed_to_double(dy),
+                                   wl_fixed_to_double(dx_unaccel),
+                                   wl_fixed_to_double(dy_unaccel),
                                    &screen_x, &screen_y);
     wayland_win_data_release(data);
 
@@ -382,7 +383,7 @@ static void relative_pointer_v1_relative_motion(void *private,
     pthread_mutex_unlock(&pointer->mutex);
 
     TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
-          hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
+          hwnd, wl_fixed_to_double(dx_unaccel), wl_fixed_to_double(dy_unaccel),
           input.mi.dx, input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);

From 87bde3de5d8aa77ef5dff2e664c26beda2eaa242 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 16:14:54 -0400
Subject: [PATCH 53/55] winewayland: Implement touchpad scrolling support.

I hate this so much, but it's the best we can do I think
---
 dlls/winewayland.drv/wayland_pointer.c | 74 ++++++++++++++++++--------
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 2 files changed, 53 insertions(+), 23 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 3644f355c2b..12c19e4a1d7 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -275,6 +275,57 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
                                 uint32_t time, uint32_t axis, wl_fixed_t value)
 {
+    HWND hwnd;
+    INPUT input = {0};
+    /*
+        We are given a distance in the surface local coordinate system.
+        However, we need to convert that into a WHEEL_DELTA which represents
+        physical mouse wheel motion. Using default settings on KDE Plasma,
+        I obtained a value of 15 for one mouse wheel click. So that is the
+        value I have chosen for now. However, what do other compositors default to?
+        Additionally, the system's scroll sensitivity now affects winewayland,
+        is that going to cause issues?
+
+        So many unknowns for such a seemingly trivial task :(
+        just because we are trying to support touchpads...
+    */
+    double scroll_value = (wl_fixed_to_double(value) / 15.0) * WHEEL_DELTA;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    input.type = INPUT_MOUSE;
+
+    /*
+        Truncation makes the most sense:
+        Imagine a infinite resolution scroll wheel
+        Assume that input axis value is some fraction of a tick
+        Accumulate input axis value * WHEEL_DELTA
+        Truncate to WHEEL_DELTA precision
+        Do subtraction on original value
+        Leftover accumulation is just leftover rotation on the wheel
+    */
+    switch (axis)
+    {
+        case WL_POINTER_AXIS_VERTICAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+            pointer->accum_wheel += -scroll_value;
+            input.mi.mouseData = trunc(pointer->accum_wheel / WHEEL_DELTA) * WHEEL_DELTA;
+            pointer->accum_wheel -= (int)input.mi.mouseData;
+            break;
+        case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+            pointer->accum_wheelH += scroll_value;
+            input.mi.mouseData = trunc(pointer->accum_wheelH / WHEEL_DELTA) * WHEEL_DELTA;
+            pointer->accum_wheelH -= (int)input.mi.mouseData;
+            break;
+        default: break;
+    }
+
+    TRACE("hwnd=%p axis=%u value=%lf out=%d\n", hwnd, axis, scroll_value, (int)input.mi.mouseData);
+
+    if (input.mi.mouseData)
+        NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
@@ -294,29 +345,6 @@ static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
-    INPUT input = {0};
-    HWND hwnd;
-
-    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-
-    input.type = INPUT_MOUSE;
-
-    switch (axis)
-    {
-    case WL_POINTER_AXIS_VERTICAL_SCROLL:
-        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
-        input.mi.mouseData = -WHEEL_DELTA * discrete;
-        break;
-    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
-        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
-        input.mi.mouseData = WHEEL_DELTA * discrete;
-        break;
-    default: break;
-    }
-
-    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
-
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static const struct wl_pointer_listener pointer_listener =
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f3a53e175fc..be4fbde9737 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -118,6 +118,8 @@ struct wayland_pointer
     struct wayland_cursor cursor;
     double accum_x;
     double accum_y;
+    double accum_wheel;
+    double accum_wheelH;
     pthread_mutex_t mutex;
 };
 

From 8ab5f35a1867384e45c133c28820af497f74fbdd Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 19:55:01 -0400
Subject: [PATCH 54/55] winewayland: Use discrete event when possible.

---
 dlls/winewayland.drv/wayland_pointer.c | 30 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 12c19e4a1d7..671fbead8d3 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -286,6 +286,9 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
         Additionally, the system's scroll sensitivity now affects winewayland,
         is that going to cause issues?
 
+        We can alleviate these issues for physical scroll wheels using the discrete
+        event at least.
+
         So many unknowns for such a seemingly trivial task :(
         just because we are trying to support touchpads...
     */
@@ -293,6 +296,7 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+    if (InterlockedCompareExchange(&pointer->discrete_event_handled, FALSE, TRUE)) return;
 
     input.type = INPUT_MOUSE;
 
@@ -345,6 +349,32 @@ static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
+    INPUT input = {0};
+    HWND hwnd;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    InterlockedExchange(&pointer->discrete_event_handled, TRUE);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+        case WL_POINTER_AXIS_VERTICAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+            input.mi.mouseData = -WHEEL_DELTA * discrete;
+            break;
+        case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+            input.mi.mouseData = WHEEL_DELTA * discrete;
+            break;
+        default: break;
+    }
+
+    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
+
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static const struct wl_pointer_listener pointer_listener =
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index be4fbde9737..f618dc11e93 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -120,6 +120,7 @@ struct wayland_pointer
     double accum_y;
     double accum_wheel;
     double accum_wheelH;
+    LONG discrete_event_handled;
     pthread_mutex_t mutex;
 };
 

From dfb63cd8995f89d579782a626031121a83c9b2b4 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 17 May 2025 15:08:08 -0400
Subject: [PATCH 55/55] winewayland: Handle rotated screens.

Some win32u issues with vertical monitors? But works exactly the same as winex11 so I think this is a win
---
 dlls/winewayland.drv/wayland_output.c | 19 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  1 +
 2 files changed, 20 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index f76881a1770..ce388d02f21 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -39,6 +39,7 @@ static uint32_t next_output_id = 0;
 #define WAYLAND_OUTPUT_CHANGED_NAME       0x02
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_XY 0x04
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_WH 0x08
+#define WAYLAND_OUTPUT_CHANGED_TRANSFORM  0x10
 
 /**********************************************************************
  *          Output handling
@@ -139,6 +140,14 @@ static void wayland_output_done(struct wayland_output *output)
     {
         RB_FOR_EACH_ENTRY(mode, &output->pending.modes, struct wayland_output_mode, entry)
         {
+            /* Need to flip w,h when the output is transformed by 90 or 270 degrees */
+            if (output->pending.transform == WL_OUTPUT_TRANSFORM_270 ||
+                output->pending.transform == WL_OUTPUT_TRANSFORM_90)
+            {
+                const int32_t temp = mode->width;
+                mode->width = mode->height;
+                mode->height = temp;
+            }
             wayland_output_state_add_mode(&output->current,
                                           mode->width, mode->height, mode->refresh,
                                           mode == output->pending.current_mode);
@@ -167,6 +176,11 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.logical_h = output->pending.logical_h;
     }
 
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_TRANSFORM)
+    {
+        output->current.transform = output->pending.transform;
+    }
+
     output->pending_flags = 0;
 
     /* Ensure the logical dimensions have sane values. */
@@ -200,6 +214,11 @@ static void output_handle_geometry(void *data, struct wl_output *wl_output,
                                    const char *make, const char *model,
                                    int32_t output_transform)
 {
+    struct wayland_output *output = data;
+
+    output->pending.transform = output_transform;
+
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_TRANSFORM;
 }
 
 static void output_handle_mode(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f618dc11e93..df53a16ce75 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -208,6 +208,7 @@ struct wayland_output_state
     char *name;
     int logical_x, logical_y;
     int logical_w, logical_h;
+    int transform;
 };
 
 struct wayland_output
