From 7879ba5f33f90c84243e79d494173e39003107be Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Thu, 2 Oct 2014 19:44:31 +0200
Subject: [PATCH 001/244] ntdll: Print a warning message specifying the
 wine-staging branch name and version.

---
 dlls/ntdll/loader.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 75669e95b72..07d3920c2a8 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -44,6 +44,7 @@ WINE_DECLARE_DEBUG_CHANNEL(relay);
 WINE_DECLARE_DEBUG_CHANNEL(snoop);
 WINE_DECLARE_DEBUG_CHANNEL(loaddll);
 WINE_DECLARE_DEBUG_CHANNEL(imports);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifdef _WIN64
 #define DEFAULT_SECURITY_COOKIE_64  (((ULONGLONG)0x00002b99 << 32) | 0x2ddfa232)
@@ -4059,6 +4060,7 @@ void WINAPI LdrShutdownProcess(void)
     process_detach();
 }
 
+extern const char * CDECL wine_get_version(void);
 
 /******************************************************************
  *		RtlExitUserProcess (NTDLL.@)
@@ -4591,6 +4593,9 @@ static void release_address_space(void)
  */
 void loader_init( CONTEXT *context, void **entry )
 {
+    OBJECT_ATTRIBUTES staging_event_attr;
+    UNICODE_STRING staging_event_string;
+    HANDLE staging_event;
     static int attach_done;
     NTSTATUS status;
     ULONG_PTR cookie, port = 0;
@@ -4702,7 +4707,18 @@ void loader_init( CONTEXT *context, void **entry )
         arm64ec_thread_init();
 #endif
         wm = get_modref( NtCurrentTeb()->Peb->ImageBaseAddress );
+        /* This hunk occasionally applies in the wrong place;
+         * add a comment here to try to prevent that. */
     }
+    RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
+    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF, NULL, NULL );
+    if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
+    {
+        FIXME_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
+        FIXME_(winediag)("Please mention your exact version when filing bug reports on winehq.org.\n");
+    }
+    else
+        WARN_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
 
     NtCurrentTeb()->FlsSlots = fls_alloc_data();
 

From c64ded12e72483d742e1bed863d794d5b19aeb0d Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Thu, 2 Oct 2014 19:53:46 +0200
Subject: [PATCH 002/244] winelib: Append '(Staging)' at the end of the version
 string.

---
 configure.ac | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 9acc7ce2845..ff21aee5038 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3771,7 +3771,7 @@ dnl Rules for generated source files
 
 WINE_APPEND_RULE(
 [dlls/ntdll/unix/version.c: dummy
-	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[[]] = \"\\1\";/p'\` && (echo \$\$version | cmp -s - \$[@]) || echo \$\$version >\$[@] || (rm -f \$[@] && exit 1)
+	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[[]] = \"\\1 (Staging)\";/p'\` && (echo \$\$version | cmp -s - \$[@]) || echo \$\$version >\$[@] || (rm -f \$[@] && exit 1)
 programs/winetest/build.rc: dummy
 	@build=\"STRINGTABLE { 1 \\\"\`GIT_DIR=${wine_srcdir}.git git rev-parse HEAD 2>/dev/null\`\\\" }\" && (echo \$\$build | cmp -s - \$[@]) || echo \$\$build >\$[@] || (rm -f \$[@] && exit 1)
 programs/winetest/build.nfo:

From 6e5a68c7ea88bb6d37c2d154ab6a88244bfab69f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 5 Mar 2017 23:04:36 +0100
Subject: [PATCH 003/244] advapi32: Fix error code when calling LsaOpenPolicy
 for non existing remote machine.

---
 dlls/advapi32/lsa.c       |  2 +-
 dlls/advapi32/tests/lsa.c | 10 ++++++++++
 2 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/dlls/advapi32/lsa.c b/dlls/advapi32/lsa.c
index 8c349a41f39..0bb99f536e7 100644
--- a/dlls/advapi32/lsa.c
+++ b/dlls/advapi32/lsa.c
@@ -766,7 +766,7 @@ NTSTATUS WINAPI LsaOpenPolicy(
           ObjectAttributes, DesiredAccess, PolicyHandle);
 
     ADVAPI_ForceLocalComputer(SystemName ? SystemName->Buffer : NULL,
-                              STATUS_ACCESS_VIOLATION);
+                              RPC_NT_SERVER_UNAVAILABLE);
     dumpLsaAttributes(ObjectAttributes);
 
     if(PolicyHandle) *PolicyHandle = (LSA_HANDLE)0xcafe;
diff --git a/dlls/advapi32/tests/lsa.c b/dlls/advapi32/tests/lsa.c
index 16697ebae4b..2a285f1ed1c 100644
--- a/dlls/advapi32/tests/lsa.c
+++ b/dlls/advapi32/tests/lsa.c
@@ -43,6 +43,8 @@ static NTSTATUS (WINAPI *pLsaGetUserName)(PUNICODE_STRING *user, PUNICODE_STRING
 
 static void test_lsa(void)
 {
+    static WCHAR machineW[] = {'W','i','n','e','N','o','M','a','c','h','i','n','e',0};
+    LSA_UNICODE_STRING machine;
     NTSTATUS status;
     LSA_HANDLE handle;
     LSA_OBJECT_ATTRIBUTES object_attributes;
@@ -50,6 +52,14 @@ static void test_lsa(void)
     ZeroMemory(&object_attributes, sizeof(object_attributes));
     object_attributes.Length = sizeof(object_attributes);
 
+    machine.Buffer = machineW;
+    machine.Length = sizeof(machineW) - 2;
+    machine.MaximumLength = sizeof(machineW);
+
+    status = LsaOpenPolicy( &machine, &object_attributes, POLICY_LOOKUP_NAMES, &handle);
+    ok(status == RPC_NT_SERVER_UNAVAILABLE,
+       "LsaOpenPolicy(POLICY_LOOKUP_NAMES) for invalid machine returned 0x%08lx\n", status);
+
     status = LsaOpenPolicy( NULL, &object_attributes, POLICY_ALL_ACCESS, &handle);
     ok(status == STATUS_SUCCESS || status == STATUS_ACCESS_DENIED,
        "LsaOpenPolicy(POLICY_ALL_ACCESS) returned 0x%08lx\n", status);

From 5a0797238e5417cfb6c210148cef377019955495 Mon Sep 17 00:00:00 2001
From: Andrej Shadura <andrew@shadura.me>
Date: Fri, 1 Feb 2019 08:38:10 +1100
Subject: [PATCH 004/244] comctl32: Fixed rebar behaviour when there's capture
 and no drag

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=14750
---
 dlls/comctl32/rebar.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/dlls/comctl32/rebar.c b/dlls/comctl32/rebar.c
index 7bb8f33ae06..8553e16eb18 100644
--- a/dlls/comctl32/rebar.c
+++ b/dlls/comctl32/rebar.c
@@ -3113,7 +3113,15 @@ REBAR_MouseMove (REBAR_INFO *infoPtr, LPARAM lParam)
         int yPtMove = (infoPtr->dwStyle & CCS_VERT ? ptMove.x : ptMove.y);
 
         if (GetCapture() != infoPtr->hwndSelf)
-            ERR("We are dragging but haven't got capture?!?\n");
+        {
+            if (infoPtr->fStatus & BEGIN_DRAG_ISSUED)
+            {
+                REBAR_Notify_NMREBAR (infoPtr, infoPtr->iGrabbedBand, RBN_ENDDRAG);
+                infoPtr->fStatus &= ~BEGIN_DRAG_ISSUED;
+            }
+            infoPtr->iGrabbedBand = -1;
+            return 0;
+        }
 
         band = REBAR_GetBand(infoPtr, infoPtr->iGrabbedBand);
 

From 5ba0b3e13c82939e4e8b015b0f771b162ef6decf Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 12 Nov 2019 18:13:20 +0800
Subject: [PATCH 005/244] comctl32: Bump version to 6.0.

An application that I have here checks comctl32.dll version information
and refuses to run, changing DLL version to 6.0 makes it run.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/comctl32/comctl32.h  | 2 +-
 dlls/comctl32/comctl32.rc | 2 +-
 include/commctrl.h        | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/comctl32/comctl32.h b/dlls/comctl32/comctl32.h
index f44b4ae132f..22aca6cf840 100644
--- a/dlls/comctl32/comctl32.h
+++ b/dlls/comctl32/comctl32.h
@@ -197,7 +197,7 @@ BOOL Str_SetPtrAtoW(LPWSTR *lppDest, LPCSTR lpSrc);
 BOOL Str_SetPtrWtoA(LPSTR *lppDest, LPCWSTR lpSrc);
 BOOL imagelist_has_alpha(HIMAGELIST, UINT);
 
-#define COMCTL32_VERSION_MINOR 81
+#define COMCTL32_VERSION_MINOR 0
 
 /* Our internal stack structure of the window procedures to subclass */
 typedef struct _SUBCLASSPROCS {
diff --git a/dlls/comctl32/comctl32.rc b/dlls/comctl32/comctl32.rc
index e89ab0ee4d1..7a9d16db0e7 100644
--- a/dlls/comctl32/comctl32.rc
+++ b/dlls/comctl32/comctl32.rc
@@ -114,7 +114,7 @@ LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 #define WINE_FILEDESCRIPTION_STR "Wine Common Controls"
 #define WINE_FILENAME_STR "comctl32.dll"
 #define WINE_FILEVERSION COMCTL32_VERSION, COMCTL32_VERSION_MINOR, 4704, 1100
-#define WINE_FILEVERSION_STR "5.81"
+#define WINE_FILEVERSION_STR "6.00.4704.1100"
 #define WINE_PRODUCTVERSION WINE_FILEVERSION
 #define WINE_PRODUCTVERSION_STR WINE_FILEVERSION_STR
 
diff --git a/include/commctrl.h b/include/commctrl.h
index c84dce3702c..b001ca144cc 100644
--- a/include/commctrl.h
+++ b/include/commctrl.h
@@ -59,7 +59,7 @@ enum _LI_METRIC
 WINCOMMCTRLAPI HRESULT WINAPI LoadIconWithScaleDown(HINSTANCE, const WCHAR *, int, int, HICON *);
 WINCOMMCTRLAPI HRESULT WINAPI LoadIconMetric(HINSTANCE, const WCHAR *, int, HICON *);
 
-#define COMCTL32_VERSION                5  /* dll version */
+#define COMCTL32_VERSION                6  /* dll version */
 
 #define ICC_LISTVIEW_CLASSES   0x00000001  /* listview, header */
 #define ICC_TREEVIEW_CLASSES   0x00000002  /* treeview, tooltips */

From 81555ade88804de4d9111fc254ac2f4dc4d205b2 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 26 Apr 2016 18:28:21 +0800
Subject: [PATCH 006/244] comdlg32: Postpone setting ofn->lpstrFileTitle to
 work around an application bug.

An application in the bug 38400 passes a not initialized ofn->lpstrFileTitle
to GetSaveFileNameW(). Basically ofn->lpstrFileTitle points to the stack
approximately 428 bytes above the current stack pointer, and since Wine's
GetSaveFileNameW() uses more than 4096 bytes one of internal stack frames is
guaranteed to be trashed after copying file name to ofn->lpstrFileTitle.
---
 dlls/comdlg32/filedlg.c | 34 +++++++++++++++++-----------------
 1 file changed, 17 insertions(+), 17 deletions(-)

diff --git a/dlls/comdlg32/filedlg.c b/dlls/comdlg32/filedlg.c
index 441f203fe7b..6d593b08fd4 100644
--- a/dlls/comdlg32/filedlg.c
+++ b/dlls/comdlg32/filedlg.c
@@ -559,6 +559,23 @@ static BOOL GetFileDialog95(FileOpenDlgInfos *info, UINT dlg_type)
         ret = FALSE;
     }
 
+    /* set the lpstrFileTitle */
+    if (ret && info->ofnInfos->lpstrFile && info->ofnInfos->lpstrFileTitle)
+    {
+        if (info->unicode)
+        {
+            LPOPENFILENAMEW ofn = info->ofnInfos;
+            WCHAR *file_title = PathFindFileNameW(ofn->lpstrFile);
+            lstrcpynW(ofn->lpstrFileTitle, file_title, ofn->nMaxFileTitle);
+        }
+        else
+        {
+            LPOPENFILENAMEA ofn = (LPOPENFILENAMEA)info->ofnInfos;
+            char *file_title = PathFindFileNameA(ofn->lpstrFile);
+            lstrcpynA(ofn->lpstrFileTitle, file_title, ofn->nMaxFileTitle);
+        }
+    }
+
     if (current_dir)
     {
         SetCurrentDirectoryW(current_dir);
@@ -2869,23 +2886,6 @@ BOOL FILEDLG95_OnOpen(HWND hwnd)
               fodInfos->ofnInfos->nFileExtension = (*lpszTemp) ? (lpszTemp - tempFileA) + 1 : 0;
           }
 
-          /* set the lpstrFileTitle */
-          if(fodInfos->ofnInfos->lpstrFileTitle)
-	  {
-            LPWSTR lpstrFileTitle = PathFindFileNameW(lpstrPathAndFile);
-            if(fodInfos->unicode)
-            {
-              LPOPENFILENAMEW ofn = fodInfos->ofnInfos;
-	      lstrcpynW(ofn->lpstrFileTitle, lpstrFileTitle, ofn->nMaxFileTitle);
-            }
-            else
-            {
-              LPOPENFILENAMEA ofn = (LPOPENFILENAMEA)fodInfos->ofnInfos;
-              WideCharToMultiByte(CP_ACP, 0, lpstrFileTitle, -1,
-                    ofn->lpstrFileTitle, ofn->nMaxFileTitle, NULL, NULL);
-            }
-	  }
-
           /* copy currently selected filter to lpstrCustomFilter */
           if (fodInfos->ofnInfos->lpstrCustomFilter)
           {

From 9e7ba9991c3c813e1cb01c7057143c7730850ad9 Mon Sep 17 00:00:00 2001
From: Charles Davis <cdavis5x@gmail.com>
Date: Sun, 1 Sep 2013 23:39:41 -0600
Subject: [PATCH 007/244] crypt32: Skip unknown item when decoding a CMS
 certificate.

---
 dlls/crypt32/decode.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/crypt32/decode.c b/dlls/crypt32/decode.c
index 2deacc1cb15..ab1b64591c7 100644
--- a/dlls/crypt32/decode.c
+++ b/dlls/crypt32/decode.c
@@ -5848,6 +5848,9 @@ static BOOL CRYPT_AsnDecodeCMSSignerInfoInternal(const BYTE *pbEncoded,
        offsetof(CMSG_CMS_SIGNER_INFO, AuthAttrs),
        CRYPT_AsnDecodePKCSAttributesInternal, sizeof(CRYPT_ATTRIBUTES),
        TRUE, TRUE, offsetof(CMSG_CMS_SIGNER_INFO, AuthAttrs.rgAttr), 0 },
+     /* FIXME: Tests show that CertOpenStore accepts such certificates, but
+      * how exactly should they be interpreted? */
+     { ASN_CONSTRUCTOR | ASN_UNIVERSAL | 0x11, 0, NULL, 0, TRUE, FALSE, 0, 0 },
      { ASN_SEQUENCEOF, offsetof(CMSG_CMS_SIGNER_INFO, HashEncryptionAlgorithm),
        CRYPT_AsnDecodeAlgorithmId, sizeof(CRYPT_ALGORITHM_IDENTIFIER),
        FALSE, TRUE, offsetof(CMSG_CMS_SIGNER_INFO,

From be1e65fe901a6dad3d7ebea4352b2b49c682c945 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Rafa=C5=82=20Mu=C5=BCy=C5=82o?= <galtgendo@o2.pl>
Date: Wed, 7 Jun 2023 08:17:59 +1000
Subject: [PATCH 008/244] d3dx9: Improve handling of Sprite render states

---
 dlls/d3dx9_36/sprite.c | 76 +++++++++++++++++++++++-------------------
 1 file changed, 41 insertions(+), 35 deletions(-)

diff --git a/dlls/d3dx9_36/sprite.c b/dlls/d3dx9_36/sprite.c
index 2fe822cc1a9..d8c6b77c11f 100644
--- a/dlls/d3dx9_36/sprite.c
+++ b/dlls/d3dx9_36/sprite.c
@@ -193,7 +193,7 @@ static HRESULT WINAPI d3dx9_sprite_SetWorldViewLH(ID3DXSprite *iface,
 }
 
 /* Helper function */
-static void set_states(struct d3dx9_sprite *object)
+static void set_states(struct d3dx9_sprite *object, DWORD flags)
 {
     D3DXMATRIX mat;
     D3DVIEWPORT9 vp;
@@ -204,32 +204,35 @@ static void set_states(struct d3dx9_sprite *object)
     IDirect3DDevice9_SetNPatchMode(object->device, 0.0f);
 
     /* Render states */
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHABLENDENABLE, TRUE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAFUNC, D3DCMP_GREATER);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAREF, 0x00);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHATESTENABLE, object->alphacmp_caps);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_BLENDOP, D3DBLENDOP_ADD);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPING, TRUE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPLANEENABLE, 0);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE |
-                                    D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_CULLMODE, D3DCULL_NONE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ENABLEADAPTIVETESSELLATION, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_FILLMODE, D3DFILL_SOLID);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_FOGENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_LIGHTING, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_RANGEFOGENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SPECULARENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRGBWRITEENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_STENCILENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_VERTEXBLEND, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_WRAP0, 0);
+    if (!(flags & D3DXSPRITE_DONOTMODIFY_RENDERSTATE))
+    {
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHABLENDENABLE, TRUE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAFUNC, D3DCMP_GREATER);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAREF, 0x00);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHATESTENABLE, object->alphacmp_caps);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_BLENDOP, D3DBLENDOP_ADD);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPING, TRUE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPLANEENABLE, 0);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE |
+                                      D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_CULLMODE, D3DCULL_NONE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ENABLEADAPTIVETESSELLATION, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_FILLMODE, D3DFILL_SOLID);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_FOGENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_LIGHTING, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_RANGEFOGENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SPECULARENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRGBWRITEENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_STENCILENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_VERTEXBLEND, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_WRAP0, 0);
+    }
 
     /* Texture stage states */
     IDirect3DDevice9_SetTextureStageState(object->device, 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
@@ -266,12 +269,15 @@ static void set_states(struct d3dx9_sprite *object)
     IDirect3DDevice9_SetSamplerState(object->device, 0, D3DSAMP_SRGBTEXTURE, 0);
 
     /* Matrices */
-    D3DXMatrixIdentity(&mat);
-    IDirect3DDevice9_SetTransform(object->device, D3DTS_WORLD, &mat);
-    IDirect3DDevice9_SetTransform(object->device, D3DTS_VIEW, &object->view);
-    IDirect3DDevice9_GetViewport(object->device, &vp);
-    D3DXMatrixOrthoOffCenterLH(&mat, vp.X+0.5f, (float)vp.Width+vp.X+0.5f, (float)vp.Height+vp.Y+0.5f, vp.Y+0.5f, vp.MinZ, vp.MaxZ);
-    IDirect3DDevice9_SetTransform(object->device, D3DTS_PROJECTION, &mat);
+    if (!(flags & D3DXSPRITE_OBJECTSPACE))
+    {
+      D3DXMatrixIdentity(&mat);
+      IDirect3DDevice9_SetTransform(object->device, D3DTS_WORLD, &mat);
+      IDirect3DDevice9_SetTransform(object->device, D3DTS_VIEW, &object->view);
+      IDirect3DDevice9_GetViewport(object->device, &vp);
+      D3DXMatrixOrthoOffCenterLH(&mat, vp.X+0.5f, (float)vp.Width+vp.X+0.5f, (float)vp.Height+vp.Y+0.5f, vp.Y+0.5f, vp.MinZ, vp.MaxZ);
+      IDirect3DDevice9_SetTransform(object->device, D3DTS_PROJECTION, &mat);
+    }
 }
 
 static HRESULT WINAPI d3dx9_sprite_Begin(ID3DXSprite *iface, DWORD flags)
@@ -317,7 +323,7 @@ D3DXSPRITE_SORT_TEXTURE: sort by texture (so that it doesn't change too often)
             hr=IDirect3DDevice9_BeginStateBlock(This->device);
             if(hr!=D3D_OK) return hr;
 
-            set_states(This);
+            set_states(This, flags);
 
             IDirect3DDevice9_SetVertexDeclaration(This->device, This->vdecl);
             IDirect3DDevice9_SetStreamSource(This->device, 0, NULL, 0, sizeof(struct sprite_vertex));
@@ -330,7 +336,7 @@ D3DXSPRITE_SORT_TEXTURE: sort by texture (so that it doesn't change too often)
     }
 
     /* Apply device state */
-    set_states(This);
+    set_states(This, flags);
 
     This->flags=flags;
     This->ready=TRUE;

From ab80496216a2b158528cbeda5f667c31745a4fdf Mon Sep 17 00:00:00 2001
From: Christian Costa <titan.costa@gmail.com>
Date: Wed, 14 Aug 2013 09:31:31 +0200
Subject: [PATCH 009/244] d3dx9_36: Filter out D3DCompile warning messages that
 are not present with D3DCompileShader. (try 4)

This patch fixes vertex processing issue of bug 33770.

The problem comes from the fact that even if the call succeeds,
the game interprets a non null error_messages pointer as an error.

By calling D3DCompile we use a newer version of the compiler which is more
strict and generates the following warning.
  - warning X3206: 'dot': implicit truncation of vector type
  - warning X3206: implicit truncation of vector type
  - warning X3206: 'mul': implicit truncation of vector type
D3DCompileShader does not generate such warnings.

These is confirmed in the DX SDK release note:
New Warning X3206: Implicit Truncation of Vector Type
Beginning in the August 2009 release of the DirectX SDK, the compiler will warn
when an implicit truncation of a vector type occurs.

The warnings cannot be disable so this patch filters out these strings in D3DCompileShader
and reset the error messages pointer if the resulting buffer is empty.

Try 2:
  - only filter out lines containing "X3206:" in case d3dcompiler_43 has localization

Try 3:
  - use move in place instead of copying the buffer

Try 4:
  - filter simplification by Sebastian and remove 'mul' testing left-out in search string
---
 dlls/d3dx9_36/shader.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/dlls/d3dx9_36/shader.c b/dlls/d3dx9_36/shader.c
index 88c4916b74d..3bcc752cfe1 100644
--- a/dlls/d3dx9_36/shader.c
+++ b/dlls/d3dx9_36/shader.c
@@ -458,6 +458,41 @@ HRESULT WINAPI D3DXCompileShader(const char *data, UINT length, const D3DXMACRO
         }
     }
 
+    /* Filter out D3DCompile warning messages that are not present with D3DCompileShader */
+    if (SUCCEEDED(hr) && error_msgs && *error_msgs)
+    {
+        char *messages = ID3DXBuffer_GetBufferPointer(*error_msgs);
+        DWORD size     = ID3DXBuffer_GetBufferSize(*error_msgs);
+
+        /* Ensure messages are null terminated for safe processing */
+        if (size) messages[size - 1] = 0;
+
+        while (size > 1)
+        {
+            char *prev, *next;
+
+            /* Warning has the form "warning X3206: ... implicit truncation of vector type"
+               but we only search for "X3206:" in case d3dcompiler_43 has localization */
+            prev = next = strstr(messages, "X3206:");
+            if (!prev) break;
+
+            /* get pointer to beginning and end of current line */
+            while (prev > messages && *(prev - 1) != '\n') prev--;
+            while (next < messages + size - 1 && *next != '\n') next++;
+            if (next < messages + size - 1 && *next == '\n') next++;
+
+            memmove(prev, next, messages + size - next);
+            size -= (next - prev);
+        }
+
+        /* Only return a buffer if the resulting string is not empty as some apps depend on that */
+        if (size <= 1)
+        {
+            ID3DXBuffer_Release(*error_msgs);
+            *error_msgs = NULL;
+        }
+    }
+
     return hr;
 }
 

From af3d0d92a839d5b453ce6a97d280a49e1f411603 Mon Sep 17 00:00:00 2001
From: Christian Costa <titan.costa@gmail.com>
Date: Mon, 22 Jul 2013 21:51:20 +0200
Subject: [PATCH 010/244] d3dx9_36: Implement
 ID3DXSkinInfoImpl_UpdateSkinnedMesh.

This patch fixes last problem of bug 32572.
---
 dlls/d3dx9_36/skin.c       | 86 ++++++++++++++++++++++++++++++++++++--
 dlls/d3dx9_36/tests/mesh.c | 83 ++++++++++++++++++++++++++++++++++++
 2 files changed, 166 insertions(+), 3 deletions(-)

diff --git a/dlls/d3dx9_36/skin.c b/dlls/d3dx9_36/skin.c
index 294c652c273..8129878a702 100644
--- a/dlls/d3dx9_36/skin.c
+++ b/dlls/d3dx9_36/skin.c
@@ -2,6 +2,7 @@
  * Skin Info operations specific to D3DX9.
  *
  * Copyright (C) 2011 Dylan Smith
+ * Copyright (C) 2013 Christian Costa
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -396,10 +397,89 @@ static HRESULT WINAPI d3dx9_skin_info_GetDeclaration(ID3DXSkinInfo *iface,
 static HRESULT WINAPI d3dx9_skin_info_UpdateSkinnedMesh(ID3DXSkinInfo *iface, const D3DXMATRIX *bone_transforms,
         const D3DXMATRIX *bone_inv_transpose_transforms, const void *src_vertices, void *dst_vertices)
 {
-    FIXME("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p stub!\n",
-            iface, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+    struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
+    DWORD size = D3DXGetFVFVertexSize(skin->fvf);
+    DWORD i, j;
 
-    return E_NOTIMPL;
+    TRACE("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p\n",
+            skin, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+
+    if (bone_inv_transpose_transforms)
+        FIXME("Skinning vertices with two position elements not supported\n");
+
+    if ((skin->fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZ) {
+        FIXME("Vertex type %#lx not supported\n", skin->fvf & D3DFVF_POSITION_MASK);
+        return E_FAIL;
+    }
+
+    /* Reset all positions */
+    for (i = 0; i < skin->num_vertices; i++) {
+        D3DXVECTOR3 *position = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i);
+        position->x = 0.0f;
+        position->y = 0.0f;
+        position->z = 0.0f;
+    }
+
+    /* Update positions that are influenced by bones */
+    for (i = 0; i < skin->num_bones; i++) {
+        D3DXMATRIX bone_inverse, matrix;
+
+        D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+        D3DXMatrixMultiply(&matrix, &bone_transforms[i], &bone_inverse);
+        D3DXMatrixMultiply(&matrix, &matrix, &skin->bones[i].transform);
+
+        for (j = 0; j < skin->bones[i].num_influences; j++) {
+            D3DXVECTOR3 position;
+            D3DXVECTOR3 *position_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j]);
+            D3DXVECTOR3 *position_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j]);
+            FLOAT weight = skin->bones[i].weights[j];
+
+            D3DXVec3TransformCoord(&position, position_src, &matrix);
+            position_dest->x += weight * position.x;
+            position_dest->y += weight * position.y;
+            position_dest->z += weight * position.z;
+        }
+    }
+
+    if (skin->fvf & D3DFVF_NORMAL) {
+        /* Reset all normals */
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i + sizeof(D3DXVECTOR3));
+            normal->x = 0.0f;
+            normal->y = 0.0f;
+            normal->z = 0.0f;
+        }
+
+        /* Update normals that are influenced by bones */
+        for (i = 0; i < skin->num_bones; i++) {
+            D3DXMATRIX bone_inverse, matrix;
+
+            D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+            D3DXMatrixMultiply(&matrix, &skin->bones[i].transform, &bone_transforms[i]);
+
+            for (j = 0; j < skin->bones[i].num_influences; j++) {
+                D3DXVECTOR3 normal;
+                D3DXVECTOR3 *normal_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                FLOAT weight = skin->bones[i].weights[j];
+
+                D3DXVec3TransformNormal(&normal, normal_src, &bone_inverse);
+                D3DXVec3TransformNormal(&normal, &normal, &matrix);
+                normal_dest->x += weight * normal.x;
+                normal_dest->y += weight * normal.y;
+                normal_dest->z += weight * normal.z;
+            }
+        }
+
+        /* Normalize all normals that are influenced by bones*/
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + (i * size) + sizeof(D3DXVECTOR3));
+            if ((normal_dest->x != 0.0f) && (normal_dest->y != 0.0f) && (normal_dest->z != 0.0f))
+                D3DXVec3Normalize(normal_dest, normal_dest);
+        }
+    }
+
+    return D3D_OK;
 }
 
 static HRESULT WINAPI d3dx9_skin_info_ConvertToBlendedMesh(ID3DXSkinInfo *iface, ID3DXMesh *mesh_in,
diff --git a/dlls/d3dx9_36/tests/mesh.c b/dlls/d3dx9_36/tests/mesh.c
index ef472f00865..4a6ae08d65d 100644
--- a/dlls/d3dx9_36/tests/mesh.c
+++ b/dlls/d3dx9_36/tests/mesh.c
@@ -5459,6 +5459,88 @@ static void test_create_skin_info(void)
     ok(hr == D3DERR_INVALIDCALL, "Expected D3DERR_INVALIDCALL, got %#lx\n", hr);
 }
 
+static void test_update_skinned_mesh(void)
+{
+    static DWORD bone0_vertices[2] = { 1, 3 };
+    static FLOAT bone0_weights[2] = { 1.0f, 0.5f };
+    static DWORD bone1_vertices[2] = { 2, 3 };
+    static FLOAT bone1_weights[2] = { 1.0f, 0.5f };
+    static D3DMATRIX bones_matrix[2] =
+    { { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+               2.0f,  2.0f,  4.0f,  1.0f
+      } } },
+      { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+              -4.0f, -4.0f,  4.0f,  1.0f
+      } } } };
+    static D3DVECTOR vertices_src[] = {{  1.0f,  1.0f,  1.0f },
+                                       {  1.0f,  0.0f,  0.0f },
+                                       {  1.0f,  1.0f, -1.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -1.0f, -1.0f,  1.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -1.0f, -1.0f, -1.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    static D3DVECTOR vertices_ref[] = {{  0.0f,  0.0f,  0.0f },
+                                       {  0.0f,  0.0f,  0.0f },
+                                       {  3.0f,  3.0f,  3.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -5.0f, -5.0f,  5.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -2.0f, -2.0f,  3.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    D3DVECTOR vertices_dest[8];
+    HRESULT hr;
+    ID3DXSkinInfo *skin_info;
+    D3DXMATRIX matrix;
+    int i;
+
+    D3DXMatrixIdentity(&matrix);
+    for (i = 0; i < 8; i++)
+    {
+        vertices_dest[i].x = 10000.0f;
+        vertices_dest[i].y = 10000.0f;
+        vertices_dest[i].z = 10000.0f;
+    }
+
+    hr = D3DXCreateSkinInfoFVF(4, D3DFVF_XYZ | D3DFVF_NORMAL, 2, &skin_info);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 0, 2, bone0_vertices, bone0_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 0, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 1, 2, bone1_vertices, bone1_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 1, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->UpdateSkinnedMesh(skin_info, bones_matrix, NULL, vertices_src, vertices_dest);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    for (i = 0; i < 4; i++)
+    {
+        ok(compare(vertices_dest[i*2].x, vertices_ref[i*2].x), "Vertex[%d].position.x: got %g, expected %g\n",
+           i, vertices_dest[i*2].x, vertices_ref[i*2].x);
+        ok(compare(vertices_dest[i*2].y, vertices_ref[i*2].y), "Vertex[%d].position.y: got %g, expected %g\n",
+           i, vertices_dest[i*2].y, vertices_ref[i*2].y);
+        ok(compare(vertices_dest[i*2].z, vertices_ref[i*2].z), "Vertex[%d].position.z: got %g, expected %g\n",
+           i, vertices_dest[i*2].z, vertices_ref[i*2].z);
+        ok(compare(vertices_dest[i*2+1].x, vertices_ref[i*2+1].x), "Vertex[%d].normal.x: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].x, vertices_ref[i*2+1].x);
+        ok(compare(vertices_dest[i*2+1].y, vertices_ref[i*2+1].y), "Vertex[%d].normal.y: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].y, vertices_ref[i*2+1].y);
+        ok(compare(vertices_dest[i*2+1].z, vertices_ref[i*2+1].z), "Vertex[%d].normal.z: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].z, vertices_ref[i*2+1].z);
+    }
+    skin_info->lpVtbl->Release(skin_info);
+}
+
 static void test_convert_adjacency_to_point_reps(void)
 {
     HRESULT hr;
@@ -11853,6 +11935,7 @@ START_TEST(mesh)
     D3DXGenerateAdjacencyTest();
     test_update_semantics();
     test_create_skin_info();
+    test_update_skinned_mesh();
     test_convert_adjacency_to_point_reps();
     test_convert_point_reps_to_adjacency();
     test_weld_vertices();

From 7ebb35fcf413ea5548b3e8d0cc0633db07669ed1 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 28 Sep 2023 09:14:00 +1000
Subject: [PATCH 011/244] d3dx9: D3DXLoadMeshHierarchyFromXInMemory return
 default Animation Controller

---
 dlls/d3dx9_36/mesh.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/d3dx9_36/mesh.c b/dlls/d3dx9_36/mesh.c
index 578bc5f5102..6754f38e850 100644
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -4079,7 +4079,8 @@ HRESULT WINAPI D3DXLoadMeshHierarchyFromXInMemory(const void *memory, DWORD memo
     if (anim_controller)
     {
         *anim_controller = NULL;
-        FIXME("Animation controller creation not implemented.\n");
+        /*FIXME("Animation controller creation not implemented.\n");*/
+        D3DXCreateAnimationController(1, 1, 1, 1, anim_controller);
     }
 
 cleanup:

From a657a1a909137e6b5923733df2033ad437b8eb28 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sat, 30 Sep 2023 10:18:54 +1000
Subject: [PATCH 012/244] d3dx9: [HACK] D3DXIntersect - Assign hit to FALSE

This functions needs to be implement to make "Humanity Asset" to work correctly.

Added to stop the Infinite loop - Doesn't make the game playable.
---
 dlls/d3dx9_36/mesh.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/d3dx9_36/mesh.c b/dlls/d3dx9_36/mesh.c
index 6754f38e850..3831260600d 100644
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -7678,6 +7678,8 @@ HRESULT WINAPI D3DXIntersect(ID3DXBaseMesh *mesh, const D3DXVECTOR3 *ray_pos, co
     FIXME("mesh %p, ray_pos %p, ray_dir %p, hit %p, face_index %p, u %p, v %p, distance %p, all_hits %p, "
             "count_of_hits %p stub!\n", mesh, ray_pos, ray_dir, hit, face_index, u, v, distance, all_hits, count_of_hits);
 
+    *hit = FALSE;
+
     return E_NOTIMPL;
 }
 

From b8b4fbbc319ee8bfdd8c92ef3e1dd631f450b16b Mon Sep 17 00:00:00 2001
From: Patrick Hibbs <hibbsncc1701@gmail.com>
Date: Fri, 30 Sep 2022 17:58:15 -0400
Subject: [PATCH 013/244] d3dx9: Implement d3dx_effect_SetRawValue

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46012

Signed-off-by: Patrick Hibbs <hibbsncc1701@gmail.com>
---
 dlls/d3dx9_36/effect.c | 154 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 152 insertions(+), 2 deletions(-)

diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 628d8ebc3eb..632348ed3d8 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -4431,10 +4431,160 @@ static HRESULT WINAPI d3dx_effect_CloneEffect(ID3DXEffect *iface, IDirect3DDevic
 static HRESULT WINAPI d3dx_effect_SetRawValue(ID3DXEffect *iface, D3DXHANDLE parameter, const void *data,
         UINT byte_offset, UINT bytes)
 {
-    FIXME("iface %p, parameter %p, data %p, byte_offset %u, bytes %u stub!\n",
+    struct d3dx_effect *effect = impl_from_ID3DXEffect(iface);
+    struct d3dx_parameter *param = (parameter == INVALID_HANDLE_VALUE) ? NULL : get_valid_parameter(effect, parameter);
+    const unsigned int single_size = sizeof(DWORD);
+    unsigned int x, index_offset, remaining_byte_offset, remaining_bytes;
+    void *raw;
+
+    TRACE("iface %p, parameter %p, data %p, byte_offset %u, bytes %u.\n",
             iface, parameter, data, byte_offset, bytes);
 
-    return E_NOTIMPL;
+    /* pendentic */
+    index_offset = 0;
+    remaining_byte_offset = 0;
+
+    /* BOOLs and Matries with a single value copy require sanitization of the
+        byte_offset.
+
+        Specificly, matries with a single value copy only allow byte shifts that
+        are not multiples of the value (DWORD) size. For multiples, we increment
+        the index of the promoted data type, then add any remainder as a byte
+        offset.
+
+        For BOOLs, due to their value sanitization, we only care about the
+        index of their promoted data type. Unless it's a non value size matrix.
+        In that case we do care about the byte offset.
+    */
+    if (byte_offset > 0 && (param->type == D3DXPT_BOOL ||
+            (param->class == D3DXPC_MATRIX_COLUMNS ||
+            param->class == D3DXPC_MATRIX_ROWS)))
+    {
+        remaining_byte_offset = byte_offset % single_size;
+        if (remaining_byte_offset != 0)
+            index_offset = byte_offset / single_size;
+        else
+            index_offset = byte_offset;
+        if (param->type != D3DXPT_BOOL || (bytes != single_size &&
+                (param->class == D3DXPC_MATRIX_COLUMNS ||
+                param->class == D3DXPC_MATRIX_ROWS)))
+        {
+            index_offset = index_offset * single_size;
+            if (param->type != D3DXPT_BOOL)
+                index_offset = index_offset * single_size;
+        }
+    }
+
+    /* If parameter is bad, we are expected to throw C0000005. */
+    switch (param->class)
+    {
+        case D3DXPC_STRUCT:
+            break;
+        case D3DXPC_OBJECT:
+            raw = param_get_data_and_dirtify(effect, param, param->bytes, TRUE);
+            if (data && bytes)
+            {
+                if (((char*)raw)[0] != '\0')
+                {
+                    memset(raw, '\0', param->bytes);
+                    return S_OK; /* This returns a false success. */
+                }
+                else
+                {
+                    return D3DERR_INVALIDCALL;
+                }
+            }
+            break;
+        case D3DXPC_SCALAR:
+            raw = param_get_data_and_dirtify(effect, param, param->bytes, TRUE);
+            if (param->type == D3DXPT_BOOL)
+                *(BOOL*)raw = *(BOOL*)data ? TRUE : FALSE;
+            else
+                memcpy((unsigned char*)raw + byte_offset, data, bytes);
+            return S_OK;
+            break;
+        case D3DXPC_VECTOR:
+            raw = (unsigned char*)param_get_data_and_dirtify(effect, param, param->bytes, TRUE);
+            if (param->type == D3DXPT_BOOL)
+            {
+                raw = (unsigned char*)raw + index_offset;
+                *(DWORD*)raw = *(DWORD*)data ? TRUE : FALSE;
+                memset((unsigned char*)raw + single_size, \
+                        '\0', param->bytes - index_offset - single_size);
+            }
+            else
+            {
+                raw = (unsigned char*)raw + byte_offset;
+                for (x = 0; (x * single_size) + byte_offset < param->bytes && (x * single_size) < bytes; x++)
+                {
+                    memcpy((unsigned char*)raw + (x * single_size), \
+                            (unsigned char*)data + (x * single_size), \
+                            single_size);
+                }
+            }
+            return S_OK;
+            break;
+        case D3DXPC_MATRIX_COLUMNS:
+        case D3DXPC_MATRIX_ROWS:
+            raw = (unsigned char*)param_get_data_and_dirtify(effect, param, param->bytes, TRUE);
+            if (param->type == D3DXPT_BOOL)
+            {
+                if (bytes == single_size)
+                {
+                    raw = (unsigned char*)raw + index_offset;
+                    for (x = 0; (x * single_size) < param->bytes - index_offset; x++)
+                    {
+                        remaining_bytes = param->bytes - index_offset - \
+                                (x * single_size) - single_size;
+                        *(DWORD*)raw = *(DWORD*)data ? TRUE : FALSE;
+                        memset((unsigned char*)raw + single_size, \
+                                '\0', (remaining_bytes > (single_size * 4) ? \
+                                single_size * 4 : remaining_bytes));
+                        raw = (unsigned char*)raw + (remaining_bytes > (single_size * 4) ? \
+                                single_size * 4 : remaining_bytes);
+                    }
+                }
+                else
+                {
+                    raw = (unsigned char*)raw + index_offset;
+                    for (x = 0; (x * single_size) < param->bytes - index_offset; x++)
+                    {
+                        ((DWORD*)raw)[x] = ((DWORD*)data)[x] ? TRUE : FALSE;
+                    }
+                }
+            }
+            else
+            {
+                if (bytes == single_size)
+                {
+                    raw = (unsigned char*)raw + index_offset + remaining_byte_offset;
+                    for (x = 0; (x * single_size) + byte_offset < param->bytes && (x * single_size) < bytes; x++)
+                    {
+                        memcpy((unsigned char*)raw + (x * single_size), \
+                                (unsigned char*)data + (x * single_size), \
+                                single_size);
+                    }
+                }
+                else
+                {
+                    raw = (unsigned char*)raw + byte_offset;
+                    for (x = 0; byte_offset + (x * single_size) < param->bytes &&
+                            (x * single_size) < bytes; x++)
+                    {
+                        memcpy((unsigned char*)raw + (x * single_size), \
+                                (unsigned char*)data + (x * single_size), \
+                                single_size);
+                    }
+                }
+            }
+            return S_OK;
+            break;
+        default:
+            FIXME("Unhandled param class %s.\n", debug_d3dxparameter_class(param->class));
+            break;
+    };
+
+    return D3DERR_INVALIDCALL;
 }
 #endif
 

From c85ed08be6f786c59692d0095790c4bf7592b477 Mon Sep 17 00:00:00 2001
From: Patrick Hibbs <hibbsncc1701@gmail.com>
Date: Sun, 9 Oct 2022 20:23:01 -0400
Subject: [PATCH 014/244] d3dx9/tests: Implement tests for
 d3dx_effect_SetRawValue().

Signed-off-by: Patrick Hibbs <hibbsncc1701@gmail.com>
---
 dlls/d3dx9_36/tests/effect.c | 736 +++++++++++++++++++++++++++++++++++
 1 file changed, 736 insertions(+)

diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index c55019f0f7a..1b9c8c5505b 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -8890,6 +8890,741 @@ static void test_effect_parameter_block(void)
     DestroyWindow(window);
 }
 
+/*
+ * fxc.exe /Tfx_2_0
+ */
+#if 0
+bool b = false;
+bool4 b4 = {false,false,false,false};
+bool4x4 b44 = {{false,false,false,false}, {false,false,false,false},
+        {false,false,false,false}, {false,false,false,false}};
+int i = 0;
+int4 i4 = {0,0,0,0};
+int4x4 i44 = {{4411, 4421, 4431, 4441}, {4412, 4422, 4432, 4442},
+        {4413, 4423, 4433, 4443}, {4414, 4424, 4434, 4444}};
+float f = 0.0;
+float4 f4 = {4.1, 4.2, 4.3, 4.4};
+float4x4 f44 = {{4.1, 4.2, 4.3, 4.4}, {4.5, 4.6, 4.7, 4.8},
+        {4.9, 4.10, 4.11, 4.12}, {4.13, 4.14, 4.15, 4.16}};
+string s = "blank";
+string s_2[2] = {"blank1", "blank2"};
+texture tex;
+texture2D tex2d;
+texture2D tex3d;
+Vertexshader v;
+Vertexshader v_2[2];
+Pixelshader p;
+Pixelshader p_2[2];
+technique t { pass p { } };
+#endif
+static const BYTE test_set_raw_value_blob[] =
+{
+      1,   9, 255, 254, 136,   3,
+      0,   0,   0,   0,   0,   0,
+      1,   0,   0,   0,   0,   0,
+      0,   0,  36,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   1,   0,   0,   0,
+      1,   0,   0,   0,   0,   0,
+      0,   0,   2,   0,   0,   0,
+     98,   0,   0,   0,   1,   0,
+      0,   0,   1,   0,   0,   0,
+     88,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      4,   0,   0,   0,   1,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      3,   0,   0,   0,  98,  52,
+      0,   0,   1,   0,   0,   0,
+      2,   0,   0,   0, 188,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   4,   0,
+      0,   0,   4,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   4,   0,
+      0,   0,  98,  52,  52,   0,
+      2,   0,   0,   0,   0,   0,
+      0,   0, 228,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   1,   0,   0,   0,
+      1,   0,   0,   0,   0,   0,
+      0,   0,   2,   0,   0,   0,
+    105,   0,   0,   0,   2,   0,
+      0,   0,   1,   0,   0,   0,
+     24,   1,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      4,   0,   0,   0,   1,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      3,   0,   0,   0, 105,  52,
+      0,   0,   2,   0,   0,   0,
+      2,   0,   0,   0, 124,   1,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   4,   0,
+      0,   0,   4,   0,   0,   0,
+     59,  17,   0,   0,  69,  17,
+      0,   0,  79,  17,   0,   0,
+     89,  17,   0,   0,  60,  17,
+      0,   0,  70,  17,   0,   0,
+     80,  17,   0,   0,  90,  17,
+      0,   0,  61,  17,   0,   0,
+     71,  17,   0,   0,  81,  17,
+      0,   0,  91,  17,   0,   0,
+     62,  17,   0,   0,  72,  17,
+      0,   0,  82,  17,   0,   0,
+     92,  17,   0,   0,   4,   0,
+      0,   0, 105,  52,  52,   0,
+      3,   0,   0,   0,   0,   0,
+      0,   0, 164,   1,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   1,   0,   0,   0,
+      1,   0,   0,   0,   0,   0,
+      0,   0,   2,   0,   0,   0,
+    102,   0,   0,   0,   3,   0,
+      0,   0,   1,   0,   0,   0,
+    216,   1,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      4,   0,   0,   0,   1,   0,
+      0,   0,  51,  51, 131,  64,
+    102, 102, 134,  64, 154, 153,
+    137,  64, 205, 204, 140,  64,
+      3,   0,   0,   0, 102,  52,
+      0,   0,   3,   0,   0,   0,
+      2,   0,   0,   0,  60,   2,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   4,   0,
+      0,   0,   4,   0,   0,   0,
+     51,  51, 131,  64, 102, 102,
+    134,  64, 154, 153, 137,  64,
+    205, 204, 140,  64,   0,   0,
+    144,  64,  51,  51, 147,  64,
+    102, 102, 150,  64, 154, 153,
+    153,  64, 205, 204, 156,  64,
+     51,  51, 131,  64,  31, 133,
+    131,  64,  10, 215, 131,  64,
+    246,  40, 132,  64, 225, 122,
+    132,  64, 205, 204, 132,  64,
+    184,  30, 133,  64,   4,   0,
+      0,   0, 102,  52,  52,   0,
+      4,   0,   0,   0,   4,   0,
+      0,   0,  92,   2,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   1,   0,   0,   0,
+      2,   0,   0,   0, 115,   0,
+      0,   0,   4,   0,   0,   0,
+      4,   0,   0,   0, 128,   2,
+      0,   0,   0,   0,   0,   0,
+      2,   0,   0,   0,   2,   0,
+      0,   0,   3,   0,   0,   0,
+      4,   0,   0,   0, 115,  95,
+     50,   0,   5,   0,   0,   0,
+      4,   0,   0,   0, 160,   2,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   4,   0,
+      0,   0,   4,   0,   0,   0,
+    116, 101, 120,   0,   7,   0,
+      0,   0,   4,   0,   0,   0,
+    192,   2,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      5,   0,   0,   0,   6,   0,
+      0,   0, 116, 101, 120,  50,
+    100,   0,   0,   0,   7,   0,
+      0,   0,   4,   0,   0,   0,
+    228,   2,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      6,   0,   0,   0,   6,   0,
+      0,   0, 116, 101, 120,  51,
+    100,   0,   0,   0,  16,   0,
+      0,   0,   4,   0,   0,   0,
+      8,   3,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      7,   0,   0,   0,   2,   0,
+      0,   0, 118,   0,   0,   0,
+     16,   0,   0,   0,   4,   0,
+      0,   0,  44,   3,   0,   0,
+      0,   0,   0,   0,   2,   0,
+      0,   0,   8,   0,   0,   0,
+      9,   0,   0,   0,   4,   0,
+      0,   0, 118,  95,  50,   0,
+     15,   0,   0,   0,   4,   0,
+      0,   0,  76,   3,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,  10,   0,   0,   0,
+      2,   0,   0,   0, 112,   0,
+      0,   0,  15,   0,   0,   0,
+      4,   0,   0,   0, 112,   3,
+      0,   0,   0,   0,   0,   0,
+      2,   0,   0,   0,  11,   0,
+      0,   0,  12,   0,   0,   0,
+      4,   0,   0,   0, 112,  95,
+     50,   0,   2,   0,   0,   0,
+    112,   0,   0,   0,   2,   0,
+      0,   0, 116,   0,   0,   0,
+     18,   0,   0,   0,   1,   0,
+      0,   0,   7,   0,   0,   0,
+     13,   0,   0,   0,   4,   0,
+      0,   0,  32,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,  44,   0,   0,   0,
+     72,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+     96,   0,   0,   0, 124,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0, 196,   0,
+      0,   0, 224,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0, 236,   0,   0,   0,
+      8,   1,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+     32,   1,   0,   0,  60,   1,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0, 132,   1,
+      0,   0, 160,   1,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0, 172,   1,   0,   0,
+    200,   1,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+    224,   1,   0,   0, 252,   1,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,  68,   2,
+      0,   0,  88,   2,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0, 100,   2,   0,   0,
+    120,   2,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+    136,   2,   0,   0, 156,   2,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0, 168,   2,
+      0,   0, 188,   2,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0, 204,   2,   0,   0,
+    224,   2,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+    240,   2,   0,   0,   4,   3,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,  16,   3,
+      0,   0,  36,   3,   0,   0,
+      0,   0,   0,   0,   0,   0,
+      0,   0,  52,   3,   0,   0,
+     72,   3,   0,   0,   0,   0,
+      0,   0,   0,   0,   0,   0,
+     84,   3,   0,   0, 104,   3,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0, 128,   3,
+      0,   0,   0,   0,   0,   0,
+      1,   0,   0,   0, 120,   3,
+      0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,  12,   0,
+      0,   0,   0,   0,   0,   0,
+     11,   0,   0,   0,   0,   0,
+      0,   0,  12,   0,   0,   0,
+      0,   0,   0,   0,  10,   0,
+      0,   0,   0,   0,   0,   0,
+      8,   0,   0,   0,   0,   0,
+      0,   0,   9,   0,   0,   0,
+      0,   0,   0,   0,   7,   0,
+      0,   0,   0,   0,   0,   0,
+      6,   0,   0,   0,   0,   0,
+      0,   0,   5,   0,   0,   0,
+      0,   0,   0,   0,   4,   0,
+      0,   0,   0,   0,   0,   0,
+      2,   0,   0,   0,   7,   0,
+      0,   0,  98, 108,  97, 110,
+    107,  49,   0,   0,   3,   0,
+      0,   0,   7,   0,   0,   0,
+     98, 108,  97, 110, 107,  50,
+      0,   0,   1,   0,   0,   0,
+      6,   0,   0,   0,  98, 108,
+     97, 110, 107,   0,   0,   0
+};
+
+struct test_set_raw_data_value
+{
+    const char *param_name;
+    D3DXPARAMETER_TYPE param_type;
+    const void *data;
+    unsigned int data_size;
+    unsigned int offset;
+    HRESULT expected_hr;
+    const void *expected_data;
+    unsigned int expected_data_size;
+};
+
+static const DWORD set_rawdata_clear[16] = { 0 };
+static const int set_rawdata_bool44_a[16] = { 1 };
+static const int set_rawdata_bool4_ba[16] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_bool44_ba[16] = { 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_int44_a[16] = { 2 };
+static const int set_rawdata_int44_b[16] = { 3 };
+static const int set_rawdata_int4_ba[16] = { (3 << 8) | 3, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+static const int set_rawdata_int4_bba[16] = { (3 << 8) | 3, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+static const int set_rawdata_int44_ba[16] = { (3 << 8) | 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_int44_bba[16] = { (3 << 8) | 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_int44_bbaa[16] = { (3 << 8) | 3, 0, 0, 0, 514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_int44_bbaaa[16] = { (3 << 8) | 3, 0, 0, 0, 131586, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_int44_bbaaaa[16] = { (3 << 8) | 3, 0, 0, 0, 33686018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+static const int set_rawdata_int44_bbaaaab[16] = { (3 << 8) | 3, 0, 0, 0, 33686018, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0 };
+static const float set_rawdata_float44_a[16] = { 1.0f };
+static const float set_rawdata_float44_b[16] = { 1.2f };
+/* Note: The values below need to have index 0 updated with a value (1.0f) with
+ * an off-by-one byte alignment copied to them.
+ * See test_effect_setrawvalue_init_floats() below.
+ *
+ * E.x. arr[0] = (1.0f & 0x00FFFFFF) | 1.2f;
+ */
+static float set_rawdata_float4_ba[16] = { 1.2f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
+        1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
+static float set_rawdata_float4_bba[16] = { 1.2f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
+        1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
+static float set_rawdata_float44_ba[16] = { 1.2f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
+static float set_rawdata_float44_bba[16] = { 1.2f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
+
+static void test_effect_setrawvalue_init_floats(void)
+{
+    memcpy(((unsigned char*)&set_rawdata_float4_ba) + 1, &set_rawdata_float44_a, sizeof(FLOAT));
+    memcpy(((unsigned char*)&set_rawdata_float4_bba) + 1, &set_rawdata_float44_a, sizeof(FLOAT));
+    set_rawdata_float4_bba[1] = 1.0f;
+    memcpy(((unsigned char*)&set_rawdata_float44_ba) + 1, &set_rawdata_float44_a, sizeof(FLOAT));
+    set_rawdata_float44_ba[4] = set_rawdata_float44_ba[1];
+    set_rawdata_float44_ba[1] = 0.0f;
+    memcpy(((unsigned char*)&set_rawdata_float44_bba) + 1, &set_rawdata_float44_a, sizeof(FLOAT));
+    set_rawdata_float44_bba[1] = 0.0f;
+}
+
+static inline void dbg_print_bits(void * byte, unsigned int count, char *str)
+{
+    int x, y;
+
+    for (y = 0; y < count; y++)
+    {
+        for (x = 0; x < CHAR_BIT; x++)
+        {
+            str[(y * CHAR_BIT) + x] = (((unsigned char*)byte)[y] & (1 << x)) ? '1' : '0';
+        }
+    }
+}
+
+static void test_effect_setrawvalue(IDirect3DDevice9 *device)
+{
+    const struct test_set_raw_data_value tests[] =
+    {
+        /* All of these cause C0000005 on win10.
+        { "b", D3DXPT_BOOL, NULL, sizeof( BOOL ), 0, D3DERR_INVALIDCALL, NULL, sizeof( BOOL ), 0 },
+        { "b4", D3DXPT_BOOL, NULL, sizeof( BOOL ) * 4, 0, D3DERR_INVALIDCALL, NULL, sizeof( BOOL ) * 4 },
+        { "b44", D3DXPT_BOOL, NULL, sizeof( BOOL ) * 16, 0, D3DERR_INVALIDCALL, NULL, sizeof( BOOL ) * 16 },
+        { "i", D3DXPT_INT, NULL, sizeof( DWORD ), 0, D3DERR_INVALIDCALL, NULL, sizeof( DWORD ) },
+        { "i4", D3DXPT_INT, NULL, sizeof( DWORD ) * 4, 0, D3DERR_INVALIDCALL, NULL, sizeof( DWORD ) * 4 },
+        { "i44", D3DXPT_INT, NULL, sizeof( DWORD ) * 16, 0, D3DERR_INVALIDCALL, NULL, sizeof( DWORD ) * 16 },
+        { "f", D3DXPT_FLOAT, NULL, sizeof( DWORD ), 0, D3DERR_INVALIDCALL, NULL, sizeof( DWORD ) },
+        { "f4", D3DXPT_FLOAT, NULL, sizeof( DWORD ) * 4, 0, D3DERR_INVALIDCALL, NULL, sizeof( DWORD ) * 4 },
+        { "f44", D3DXPT_FLOAT, NULL, sizeof( DWORD ) * 16, 0, D3DERR_INVALIDCALL, NULL, sizeof( DWORD ) * 16 },
+        { "s_2", D3DXPT_STRING, NULL, sizeof( "test" ), 0, D3DERR_INVALIDCALL, "test", sizeof( "test" ) },
+
+        All of these fail on win10 due to the paramater being destroyed* by a previous test.
+            *: GetParamaterByName() returns an invalid handle for the given parameter.
+        { "s", D3DXPT_STRING, "test_longer_string", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "s", D3DXPT_STRING, "test_longer_string", sizeof( "test_longer_string" ), 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "s", D3DXPT_STRING, "test_longer_string", sizeof( "test_longer_string" ), sizeof( "test" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "tex", D3DXPT_TEXTURE, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "tex", D3DXPT_TEXTURE, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "tex2d", D3DXPT_TEXTURE2D, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "tex2d", D3DXPT_TEXTURE2D, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "tex3d", D3DXPT_TEXTURE3D, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "tex3d", D3DXPT_TEXTURE3D, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "v", D3DXPT_VERTEXSHADER, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "v", D3DXPT_VERTEXSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "v_2", D3DXPT_VERTEXSHADER, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "v_2", D3DXPT_VERTEXSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "p", D3DXPT_PIXELSHADER, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "p", D3DXPT_PIXELSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "p_2", D3DXPT_PIXELSHADER, "DEADBEEF", 0, 0, D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        { "p_2", D3DXPT_PIXELSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), sizeof( "DEAFCAFE" ), D3DERR_INVALIDCALL, "", sizeof( "" ) },
+        */
+
+        /* Boolean. Test# 0 */
+        { "b", D3DXPT_BOOL, &set_rawdata_bool44_a, sizeof( BOOL ), 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) },
+        { "b", D3DXPT_BOOL, &set_rawdata_int44_b, 0, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) },
+        { "b", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ), sizeof( BOOL ), S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) },
+        { "b", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ), 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) },
+
+        /* Boolean vector. Test# 4 */
+        { "b4", D3DXPT_BOOL, &set_rawdata_bool44_a, sizeof( BOOL ) * 4, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 4 },
+        { "b4", D3DXPT_BOOL, &set_rawdata_int44_b, 0, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 4 },
+        { "b4", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ) * 4, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 4 },
+        { "b4", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ) * 4, 1, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 4 },
+        { "b4", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ) * 4, sizeof( BOOL ), S_OK, &set_rawdata_bool4_ba, sizeof( BOOL ) * 4 },
+
+        /* Boolean matrix. Test# 9 */
+        { "b44", D3DXPT_BOOL, &set_rawdata_bool44_a, sizeof( DWORD ) * 16, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 16 },
+        { "b44", D3DXPT_BOOL, &set_rawdata_int44_b, 0, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 16 },
+        { "b44", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ) * 16, 0, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 16 },
+        { "b44", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ) * 16, 1, S_OK, &set_rawdata_bool44_a, sizeof( BOOL ) * 16 },
+        { "b44", D3DXPT_BOOL, &set_rawdata_int44_b, sizeof( BOOL ) * 16, sizeof( BOOL ), S_OK, &set_rawdata_bool44_ba, sizeof( BOOL ) * 16 },
+
+        /* Integer. Test# 14 */
+        { "i", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ), 0, S_OK, &set_rawdata_int44_a, sizeof( DWORD ) },
+        { "i", D3DXPT_INT, &set_rawdata_int44_b, 0, 0, S_OK, &set_rawdata_int44_a, sizeof( DWORD ) },
+        { "i", D3DXPT_INT, &set_rawdata_int44_b, sizeof( DWORD ), sizeof( DWORD ), S_OK, &set_rawdata_int44_a, sizeof( DWORD ) },
+
+        /* Integer vector. Test# 17 */
+        { "i4", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ) * 4, 0, S_OK, &set_rawdata_int44_a, sizeof( DWORD ) * 4 },
+        { "i4", D3DXPT_INT, &set_rawdata_int44_b, 0, 0, S_OK, &set_rawdata_int44_a, sizeof( DWORD ) * 4 },
+        { "i4", D3DXPT_INT, &set_rawdata_int44_b, sizeof( DWORD ), 0, S_OK, &set_rawdata_int44_b, sizeof( DWORD ) * 4 },
+        { "i4", D3DXPT_INT, &set_rawdata_int44_b, sizeof( DWORD ), 1, S_OK, &set_rawdata_int4_ba, sizeof( DWORD ) * 4 },
+        { "i4", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ), sizeof( DWORD ), S_OK, &set_rawdata_int4_bba, sizeof( DWORD ) * 4 },
+
+        /* Integer matrix. Test# 22 */
+        { "i44", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ) * 16, 0, S_OK, &set_rawdata_int44_a, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_b, 0, 0, S_OK, &set_rawdata_int44_a, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_b, sizeof( DWORD ), 0, S_OK, &set_rawdata_int44_b, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_b, sizeof( DWORD ), 1, S_OK, &set_rawdata_int44_ba, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ), sizeof( DWORD ), S_OK, &set_rawdata_int44_bba, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ), sizeof( DWORD ) + 1, S_OK, &set_rawdata_int44_bbaa, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ), sizeof( DWORD ) + 2, S_OK, &set_rawdata_int44_bbaaa, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_a, sizeof( DWORD ), sizeof( DWORD ) + 3, S_OK, &set_rawdata_int44_bbaaaa, sizeof( DWORD ) * 16 },
+        { "i44", D3DXPT_INT, &set_rawdata_int44_b, sizeof( DWORD ), sizeof( DWORD ) * 2, S_OK, set_rawdata_int44_bbaaaab, sizeof( DWORD ) * 16 },
+
+        /* Float. Test# 31 */
+        { "f", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ), 0, S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) },
+        { "f", D3DXPT_FLOAT, &set_rawdata_float44_b, 0, 0, S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) },
+        { "f", D3DXPT_FLOAT, &set_rawdata_float44_b, sizeof( FLOAT ), sizeof( FLOAT ), S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) },
+
+        /* Float vector. Test# 34 */
+        { "f4", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ) * 4, 0, S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) * 4 },
+        { "f4", D3DXPT_FLOAT, &set_rawdata_float44_b, 0, 0, S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) * 4 },
+        { "f4", D3DXPT_FLOAT, &set_rawdata_float44_b, sizeof( FLOAT ), 0, S_OK, &set_rawdata_float44_b, sizeof( FLOAT ) * 4 },
+        { "f4", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ), 1, S_OK, &set_rawdata_float4_ba, sizeof( FLOAT ) * 4 },
+        { "f4", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ), sizeof( FLOAT ), S_OK, &set_rawdata_float4_bba, sizeof( FLOAT ) * 4 },
+
+        /* Float matrix. Test# 39 */
+        { "f44", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ) * 16, 0, S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) * 16 },
+        { "f44", D3DXPT_FLOAT, &set_rawdata_float44_b, 0, 0, S_OK, &set_rawdata_float44_a, sizeof( FLOAT ) * 16 },
+        { "f44", D3DXPT_FLOAT, &set_rawdata_float44_b, sizeof( FLOAT ), 0, S_OK, &set_rawdata_float44_b, sizeof( FLOAT ) * 16 },
+        { "f44", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ), 1, S_OK, &set_rawdata_float44_ba, sizeof( FLOAT ) * 16 },
+        { "f44", D3DXPT_FLOAT, &set_rawdata_float44_a, sizeof( FLOAT ), sizeof( FLOAT ), S_OK, &set_rawdata_float44_bba, sizeof( FLOAT ) * 16 },
+
+        /* String vector. Test# 44
+            Note: These tests will always allow getting a handle to their
+                paramater. But the GetString() call will fail without a crash.
+                (Probably due to the string being destroyed. See below.)
+
+                So for these we set the check string to "0xBADBEEF" to allow
+                checking the return value of GetString().
+        */
+        { "s_2", D3DXPT_STRING, "test", sizeof( "test" ), 0, S_OK, "0xBADBEEF", sizeof( "" ) },
+        { "s_2", D3DXPT_STRING, "test_longer_string", 0, 0, S_OK, "0xBADBEEF", sizeof( "" ) },
+        { "s_2", D3DXPT_STRING, "test_longer_string", sizeof( "test_longer_string" ), 0, S_OK, "0xBADBEEF", sizeof( "" ) },
+
+        /* Strings. Test# 47
+            Note: All tests below this point are to check if
+            1) The paramater is destroyed.
+            2) The paramater handle can no longer be
+                retrived by GetParamaterByName().
+
+            Any attempt to get the paramater after it's destruction via it's
+                relevant GetXXX() function will cause us to crash.
+
+            As such the GetParamaterByName() tests have their expected data
+                set to NULL. (Which prevents the call to SetRawValue().)
+
+            The destroying tests have their expected data length set to 0 and
+                expected data set to "". (Which allows calling SetRawValue(),
+                but avoids calling the relavent GetXXX() function.)
+        */
+        { "s", D3DXPT_STRING, "test", sizeof( "test" ), 0, S_OK, "", 0 },
+        { "s", D3DXPT_STRING, NULL, sizeof( "test" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* Textures. Test# 49 */
+        { "tex", D3DXPT_TEXTURE, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "tex", D3DXPT_TEXTURE, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* 2D Textures. Test# 51 */
+        { "tex2d", D3DXPT_TEXTURE2D, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "tex2d", D3DXPT_TEXTURE2D, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* 3D Textures. Test# 53 */
+        { "tex3d", D3DXPT_TEXTURE3D, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "tex3d", D3DXPT_TEXTURE3D, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* Vertex Shaders. Test# 55 */
+        { "v", D3DXPT_VERTEXSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "v", D3DXPT_VERTEXSHADER, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* Vertex Shaders vector. Test# 57 */
+        { "v_2", D3DXPT_VERTEXSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "v_2", D3DXPT_VERTEXSHADER, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* Pixel Shaders. Test# 59 */
+        { "p", D3DXPT_PIXELSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "p", D3DXPT_PIXELSHADER, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 },
+
+        /* Pixel Shaders vector. Test# 61. */
+        { "p_2", D3DXPT_PIXELSHADER, "DEAFCAFE", sizeof( "DEAFCAFE" ), 0, S_OK, "", 0 },
+        { "p_2", D3DXPT_PIXELSHADER, NULL, sizeof( "DEAFCAFE" ), 0, D3DERR_INVALIDCALL, NULL, 0 }
+    };
+
+    void *current_result, *current_expected;
+    char result_buf[64] = { '\0' };
+    char expected_bit_buf[33] = { '\0' };
+    char result_bit_buf[33] = { '\0' };
+    unsigned int x, y, single_size;
+    D3DXHANDLE param_hr;
+    ID3DXEffect *effect;
+    int memcmp_ret;
+    HRESULT hr;
+
+    hr = D3DXCreateEffect(device, test_set_raw_value_blob,
+            sizeof(test_set_raw_value_blob), NULL, NULL, 0, NULL, &effect, NULL);
+    ok(hr == D3D_OK, "Got result %#1.1x, expected 0 (D3D_OK).\n", hr);
+
+    /* All of these cause C0000005 on win10.  */
+    if (0)
+    {
+        hr = effect->lpVtbl->SetRawValue(effect, INVALID_HANDLE_VALUE, NULL, 0, 0);
+        ok(hr == D3DERR_INVALIDCALL, "Got result %#x, expected 0 (D3D_INVALIDCALL).\n", hr);
+        hr = effect->lpVtbl->SetRawValue(effect, INVALID_HANDLE_VALUE, NULL, 1, 0);
+        ok(hr == D3DERR_INVALIDCALL, "Got result %#x, expected 0 (D3D_INVALIDCALL).\n", hr);
+        hr = effect->lpVtbl->SetRawValue(effect, INVALID_HANDLE_VALUE, NULL, 0, 1);
+        ok(hr == D3DERR_INVALIDCALL, "Got result %#x, expected 0 (D3D_INVALIDCALL).\n", hr);
+        hr = effect->lpVtbl->SetRawValue(effect, INVALID_HANDLE_VALUE, NULL, 1, 1);
+        ok(hr == D3DERR_INVALIDCALL, "Got result %#x, expected 0 (D3D_INVALIDCALL).\n", hr);
+    }
+
+    test_effect_setrawvalue_init_floats();
+
+    /* Begin value loop. */
+    for (x = 0; x < (sizeof(tests) / sizeof(struct test_set_raw_data_value)); x++)
+    {
+        param_hr = effect->lpVtbl->GetParameterByName(effect, NULL, tests[x].param_name);
+        ok((param_hr != NULL && tests[x].expected_data != NULL) ||
+                (param_hr == NULL && tests[x].expected_data == NULL),
+                "Test # %d GetParameterByName() did not return the expected result.\n", x);
+        if (tests[x].expected_data != NULL)
+        {
+            memset(result_buf, '\0', tests[x].expected_data_size);
+            hr = effect->lpVtbl->SetRawValue(effect,
+                    param_hr,
+                    tests[x].data,
+                    tests[x].offset,
+                    tests[x].data_size);
+            ok(hr == tests[x].expected_hr,
+                    "Test # %d var name %s : got HRESULT %#1.1x, expected %#1.1x.\n",
+                    x,
+                    tests[x].param_name,
+                    hr,
+                    tests[x].expected_hr);
+            switch (tests[x].param_type)
+            {
+                case D3DXPT_BOOL:
+                case D3DXPT_INT:
+                case D3DXPT_FLOAT:
+                    ok(effect->lpVtbl->GetValue(effect,
+                            param_hr,
+                            result_buf,
+                            tests[x].expected_data_size) == S_OK,
+                            "Test # %d var name %s : could not get value.\n",
+                            x,
+                            tests[x].param_name);
+                    single_size = (tests[x].param_type == D3DXPT_BOOL) ? sizeof(BOOL) :
+                            (tests[x].param_type == D3DXPT_INT) ? sizeof(DWORD) :
+                            sizeof(FLOAT);
+
+                    for (y = 0; y < tests[x].expected_data_size / single_size; y++)
+                    {
+                        current_result = ((unsigned char*)result_buf) + (single_size * y);
+                        current_expected = ((unsigned char*)tests[x].expected_data) +
+                                (single_size * y);
+                        memcmp_ret = memcmp(current_result, current_expected,
+                                single_size);
+                        if (memcmp_ret != 0)
+                        {
+                            dbg_print_bits(current_result, single_size, result_bit_buf);
+                            dbg_print_bits(current_expected, single_size, expected_bit_buf);
+                        }
+                        switch (tests[x].param_type)
+                        {
+                            case D3DXPT_FLOAT:
+                                ok(memcmp_ret == 0,
+                                        "Test # %d type %#1.1x var name %s index %#1.1x: got %.8e (bits: %s), expected %.8e (bits: %s).\n",
+                                        x,
+                                        tests[x].param_type,
+                                        tests[x].param_name,
+                                        y,
+                                        *(float*)current_result,
+                                        result_bit_buf,
+                                        *(float*)current_expected,
+                                        expected_bit_buf);
+                                break;
+                            case D3DXPT_INT:
+                                ok(memcmp_ret == 0,
+                                        "Test # %d type %#1.1x var name %s index %#1.1x: got %#1.1x (bits: %s), expected %#1.1x (bits: %s).\n",
+                                        x,
+                                        tests[x].param_type,
+                                        tests[x].param_name,
+                                        y,
+                                        *(unsigned int*)current_result,
+                                        result_bit_buf,
+                                        *(unsigned int*)current_expected,
+                                        expected_bit_buf);
+                                break;
+                            case D3DXPT_BOOL:
+                                ok(memcmp_ret == 0,
+                                        "Test # %d type %#1.1x var name %s index %#1.1x: got %#1.1x (bits: %s), expected %#1.1x (bits: %s).\n",
+                                        x,
+                                        tests[x].param_type,
+                                        tests[x].param_name,
+                                        y,
+                                        *(unsigned char*)current_result,
+                                        result_bit_buf,
+                                        *(unsigned char*)current_expected,
+                                        expected_bit_buf);
+                                break;
+                            default:
+                                /* Should never get here, but gcc complains without a default... */
+                                skip("Test # %d not performed. Reached dead codepath.\n", x);
+                                return;
+                                break;
+                        };
+                    }
+                    break;
+                /* All types below will crash if we call their GetXXX() function
+                    after the paramater has been destroyed.
+
+                   We use the size check to avoid the crash.
+                */
+                case D3DXPT_STRING:
+                    if (tests[x].expected_data_size > 0)
+                    {
+                        hr = effect->lpVtbl->GetString(effect,
+                                param_hr,
+                                (const char**)&current_result);
+                        if (memcmp(tests[x].expected_data,
+                                "0xBADBEEF",
+                                sizeof("0xBADBEEF")) != 0)
+                        {
+                            ok(hr == S_OK,
+                                    "Test # %d var name %s : could not get value.\n",
+                                    x,
+                                    tests[x].param_name);
+                            ok(memcmp(current_result,
+                                    tests[x].expected_data,
+                                    tests[x].expected_data_size) == 0,
+                                    "Test # %d type %#1.1x var name %s: got %s, expected %s.\n",
+                                    x,
+                                    tests[x].param_type,
+                                    tests[x].param_name,
+                                    (char *)current_result,
+                                    (char *)tests[x].expected_data);
+                        }
+                        else
+                        {
+                            /* Check for invalid call on destroyed string vector. */
+                            ok(hr == D3DERR_INVALIDCALL,
+                                    "Test # %d var name %s : got %#x expected %#x\n",
+                                    x,
+                                    tests[x].param_name,
+                                    hr,
+                                    D3DERR_INVALIDCALL);
+                        }
+                    }
+                    break;
+                case D3DXPT_TEXTURE:
+                case D3DXPT_TEXTURE2D:
+                case D3DXPT_TEXTURE3D:
+                    if (tests[x].expected_data_size > 0)
+                    {
+                        ok(effect->lpVtbl->GetTexture(effect,
+                                param_hr,
+                                (LPDIRECT3DBASETEXTURE9*)&current_result) == S_OK,
+                                "Test # %d var name %s : could not get value.\n",
+                                x,
+                                tests[x].param_name);
+                        ok(memcmp(current_result,
+                                tests[x].expected_data,
+                                tests[x].expected_data_size) == 0,
+                                "Test # %d type %#1.1x var name %s: did not get expected result.\n",
+                                x,
+                                tests[x].param_type,
+                                tests[x].param_name);
+                    }
+                    break;
+                case D3DXPT_VERTEXSHADER:
+                    if (tests[x].expected_data_size > 0)
+                    {
+                        ok(effect->lpVtbl->GetVertexShader(effect,
+                                param_hr,
+                                (LPDIRECT3DVERTEXSHADER9*)&current_result) == S_OK,
+                                "Test # %d var name %s : could not get value.\n",
+                                x,
+                                tests[x].param_name);
+                        ok(memcmp(current_result,
+                                tests[x].expected_data,
+                                tests[x].expected_data_size) == 0,
+                                "Test # %d type %#1.1x var name %s: did not get expected result.\n",
+                                x,
+                                tests[x].param_type,
+                                tests[x].param_name);
+                    }
+                    break;
+                case D3DXPT_PIXELSHADER:
+                    if (tests[x].expected_data_size > 0)
+                    {
+                        ok(effect->lpVtbl->GetPixelShader(effect,
+                                param_hr,
+                                (LPDIRECT3DPIXELSHADER9*)&current_result) == S_OK,
+                                "Test # %d var name %s : could not get value.\n",
+                                x,
+                                tests[x].param_name);
+                        ok(memcmp(current_result,
+                                tests[x].expected_data,
+                                tests[x].expected_data_size) == 0,
+                                "Test # %d type %#1.1x var name %s: did not get expected result.\n",
+                                x,
+                                tests[x].param_type,
+                                tests[x].param_name);
+                    }
+                    break;
+                default:
+                    /* Should never get here. */
+                    skip("Test # %d type %#1.1x var name %s : unknown type.\n",
+                            x,
+                            tests[x].param_type,
+                            tests[x].param_name);
+                    break;
+            };
+            /*effect->lpVtbl->SetRawValue( effect,
+                    effect->lpVtbl->GetParameterByName( effect, NULL, tests[x].param_name ),
+                    set_rawdata_clear,
+                    0,
+                    sizeof( set_rawdata_clear ) );*/
+        }
+        else
+        {
+            effect->lpVtbl->Release(effect);
+            hr = D3DXCreateEffect(device, test_set_raw_value_blob,
+                    sizeof(test_set_raw_value_blob), NULL, NULL, 0, NULL, &effect, NULL);
+            ok(hr == D3D_OK, "Test # %d Unable to recreate effect. Got result %#1.1x, expected 0 (D3D_OK).\n",
+                    x, hr);
+            if (hr != D3D_OK)
+                return;
+        }
+    }
+    effect->lpVtbl->Release(effect);
+}
+
 START_TEST(effect)
 {
     IDirect3DDevice9 *device;
@@ -8918,6 +9653,7 @@ START_TEST(effect)
     test_effect_large_address_aware_flag(device);
     test_effect_get_pass_desc(device);
     test_effect_skip_constants(device);
+    test_effect_setrawvalue( device );
 
     refcount = IDirect3DDevice9_Release(device);
     ok(!refcount, "Device has %lu references left.\n", refcount);

From 577e0e4722394b60242c606f5dbc6e4a78a779bf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 6 Sep 2015 20:21:42 +0200
Subject: [PATCH 015/244] ddraw: Set dwZBufferBitDepth in ddraw7_GetCaps.

---
 dlls/ddraw/ddraw.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index 214befa9aa0..d07eef9e788 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -1483,6 +1483,28 @@ HRESULT ddraw_get_d3dcaps(const struct ddraw *ddraw, D3DDEVICEDESC7 *caps)
     return DD_OK;
 }
 
+HRESULT CALLBACK enum_zbuffer(DDPIXELFORMAT *format, void *ctx)
+{
+    DDCAPS *caps = ctx;
+
+    switch (format->dwZBufferBitDepth)
+    {
+        case 8:
+            caps->dwZBufferBitDepths |= DDBD_8;
+            break;
+        case 16:
+            caps->dwZBufferBitDepths |= DDBD_16;
+            break;
+        case 24:
+            caps->dwZBufferBitDepths |= DDBD_24;
+            break;
+        case 32:
+            caps->dwZBufferBitDepths |= DDBD_32;
+            break;
+    }
+    return D3DENUMRET_OK;
+}
+
 /*****************************************************************************
  * IDirectDraw7::GetCaps
  *
@@ -1563,6 +1585,8 @@ static HRESULT WINAPI ddraw7_GetCaps(IDirectDraw7 *iface, DDCAPS *DriverCaps, DD
     caps.dwCaps |= DDCAPS_ALIGNSTRIDE;
     caps.dwAlignStrideAlign = DDRAW_STRIDE_ALIGNMENT;
 
+    IDirect3D7_EnumZBufferFormats(&ddraw->IDirect3D7_iface, &IID_IDirect3DHALDevice, enum_zbuffer, &caps);
+
     caps.ddsOldCaps.dwCaps = caps.ddsCaps.dwCaps;
 
     if(DriverCaps)

From 75456fe45a4fe434bd46803d9faed225c19090f2 Mon Sep 17 00:00:00 2001
From: Matthew Wong <itsmattkc@gmail.com>
Date: Fri, 18 Sep 2020 00:47:13 +0000
Subject: [PATCH 016/244] ddraw: Implement Pick() and GetPickRecords().

Implement functions used by some games (notably LEGO Island) for
determining which 3D object in a scene was clicked by the mouse cursor.
Fighting Steel also uses this function for mouse over. Previous stubs
would cause LEGO Island to crash upon any click and Fighting Steel
to crash on game start. A patch posted years ago on the bug thread
provided the minimum functionality to prevent crashes, but still
rendered large portions of the game inaccessible without them
implemented correctly.

Picking has been implemented by adding a "pick mode" in
d3d_execute_buffer_execute() which skips any drawing functions
leaving just the vertex processing. Adds click tests for each triangle
when in pick mode for creating an array of D3DPICKRECORDs.

Stress testing reveals this patch's Pick() implementation may have
slight inaccuracies to the original function; occasionally pixels right
on triangle edges result in successful picks when they don't with the
original function (and vice versa). It may be some sort of floating
point rounding error or other algorithm difference that would be
difficult to determine without seeing the original code. In practice, I
believe this inaccuracy is so negligible that it won't produce any
undesirable results for the user.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=10729
Signed-off-by: Matthew Wong <itsmattkc@gmail.com>
Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
 dlls/ddraw/ddraw_private.h |   7 +-
 dlls/ddraw/device.c        |  67 ++++++++++++--
 dlls/ddraw/executebuffer.c | 176 ++++++++++++++++++++++++++++++++++++-
 dlls/ddraw/tests/ddraw1.c  | 133 ++++++++++++++++++++++++++++
 4 files changed, 373 insertions(+), 10 deletions(-)

diff --git a/dlls/ddraw/ddraw_private.h b/dlls/ddraw/ddraw_private.h
index 7e837c40c3b..8fa0f5e8729 100644
--- a/dlls/ddraw/ddraw_private.h
+++ b/dlls/ddraw/ddraw_private.h
@@ -343,6 +343,11 @@ struct d3d_device
     struct d3d_viewport *current_viewport;
     D3DVIEWPORT7 active_viewport;
 
+    /* Pick data */
+    D3DPICKRECORD *pick_records;
+    DWORD pick_record_count;
+    DWORD pick_record_size;
+
     /* Required to keep track which of two available texture blending modes in d3ddevice3 is used */
     BOOL legacyTextureBlending;
     D3DTEXTUREBLEND texture_map_blend;
@@ -579,7 +584,7 @@ struct d3d_execute_buffer *unsafe_impl_from_IDirect3DExecuteBuffer(IDirect3DExec
 
 /* The execute function */
 HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *execute_buffer,
-        struct d3d_device *device);
+        struct d3d_device *device, D3DRECT *pick_rect);
 
 /*****************************************************************************
  * IDirect3DVertexBuffer
diff --git a/dlls/ddraw/device.c b/dlls/ddraw/device.c
index 9882c2613b6..90b3119e833 100644
--- a/dlls/ddraw/device.c
+++ b/dlls/ddraw/device.c
@@ -335,6 +335,9 @@ static ULONG WINAPI d3d_device_inner_Release(IUnknown *iface)
             This->ddraw = NULL;
         }
 
+        if (This->pick_record_size > 0)
+            free(This->pick_records);
+
         TRACE("Releasing render target %p.\n", This->rt_iface);
         rt_iface = This->rt_iface;
         This->rt_iface = NULL;
@@ -750,7 +753,7 @@ static HRESULT WINAPI d3d_device1_Execute(IDirect3DDevice *iface,
 
     /* Execute... */
     wined3d_mutex_lock();
-    hr = d3d_execute_buffer_execute(buffer, device);
+    hr = d3d_execute_buffer_execute(buffer, device, NULL);
     wined3d_mutex_unlock();
 
     return hr;
@@ -1017,16 +1020,44 @@ static HRESULT WINAPI d3d_device1_NextViewport(IDirect3DDevice *iface,
  *        x2 and y2 are ignored.
  *
  * Returns:
- *  D3D_OK because it's a stub
+ *  D3D_OK on success
+ *  DDERR_INVALIDPARAMS if any of the parameters == NULL
  *
  *****************************************************************************/
 static HRESULT WINAPI d3d_device1_Pick(IDirect3DDevice *iface, IDirect3DExecuteBuffer *buffer,
         IDirect3DViewport *viewport, DWORD flags, D3DRECT *rect)
 {
-    FIXME("iface %p, buffer %p, viewport %p, flags %#lx, rect %s stub!\n",
-            iface, buffer, viewport, flags, wine_dbgstr_rect((RECT *)rect));
+    struct d3d_device *device = impl_from_IDirect3DDevice(iface);
+    struct d3d_execute_buffer *buffer_impl = unsafe_impl_from_IDirect3DExecuteBuffer(buffer);
+    struct d3d_viewport *viewport_impl = unsafe_impl_from_IDirect3DViewport(viewport);
+    HRESULT hr;
 
-    return D3D_OK;
+    TRACE("iface %p, buffer %p, viewport %p, flags %#lx, rect %s.\n",
+             iface, buffer, viewport, flags, wine_dbgstr_rect((RECT *)rect));
+
+    /* Sanity checks */
+    if (!buffer)
+    {
+        WARN("NULL buffer, returning DDERR_INVALIDPARAMS\n");
+        return DDERR_INVALIDPARAMS;
+    }
+
+    if (!viewport)
+    {
+        WARN("NULL viewport, returning DDERR_INVALIDPARAMS\n");
+        return DDERR_INVALIDPARAMS;
+    }
+
+    if (FAILED(hr = IDirect3DDevice3_SetCurrentViewport
+            (&device->IDirect3DDevice3_iface, &viewport_impl->IDirect3DViewport3_iface)))
+        return hr;
+
+    /* Execute the pick */
+    wined3d_mutex_lock();
+    hr = d3d_execute_buffer_execute(buffer_impl, device, rect);
+    wined3d_mutex_unlock();
+
+    return hr;
 }
 
 /*****************************************************************************
@@ -1042,13 +1073,35 @@ static HRESULT WINAPI d3d_device1_Pick(IDirect3DDevice *iface, IDirect3DExecuteB
  *  D3DPickRec: Address to store the resulting D3DPICKRECORD array.
  *
  * Returns:
- *  D3D_OK, because it's a stub
+ *  D3D_OK always
  *
  *****************************************************************************/
 static HRESULT WINAPI d3d_device1_GetPickRecords(IDirect3DDevice *iface,
         DWORD *count, D3DPICKRECORD *records)
 {
-    FIXME("iface %p, count %p, records %p stub!\n", iface, count, records);
+    struct d3d_device *device;
+
+    TRACE("iface %p, count %p, records %p.\n", iface, count, records);
+
+    /* Windows doesn't check if count is non-NULL */
+
+    wined3d_mutex_lock();
+
+    device = impl_from_IDirect3DDevice(iface);
+
+    /* Set count to the number of pick records we have */
+    *count = device->pick_record_count;
+
+    /* It is correct usage according to documentation to call this function with records == NULL
+       to retrieve _just_ the record count, which the caller can then use to allocate an
+       appropriately sized array, then call this function again to fill that array with data. */
+    if (records && count)
+    {
+        /* If we have a destination array and records to copy, copy them now */
+        memcpy(records, device->pick_records, sizeof(*device->pick_records) * device->pick_record_count);
+    }
+
+    wined3d_mutex_unlock();
 
     return D3D_OK;
 }
diff --git a/dlls/ddraw/executebuffer.c b/dlls/ddraw/executebuffer.c
index 84bf091db1b..b2008679d38 100644
--- a/dlls/ddraw/executebuffer.c
+++ b/dlls/ddraw/executebuffer.c
@@ -45,15 +45,106 @@ static void _dump_D3DEXECUTEBUFFERDESC(const D3DEXECUTEBUFFERDESC *lpDesc) {
     TRACE("lpData       : %p\n", lpDesc->lpData);
 }
 
-HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d_device *device)
+#define TRIANGLE_SIZE 3
+/*****************************************************************************
+ * d3d_execute_buffer_pick_test
+ *
+ * Determines whether a "point" is inside a "triangle". Mainly used when
+ * executing a "pick" from an execute buffer to determine whether a pixel
+ * coordinate (often a mouse coordinate) is inside a triangle (and
+ * therefore clicking or hovering over a 3D object in the scene). This
+ * function uses triangle rasterization algorithms to determine if the
+ * pixel falls inside (using the top-left rule, in accordance with
+ * documentation).
+ *
+ * Params:
+ *  x:     The X coordinate of the point to verify.
+ *  y:     The Y coordinate of the point to verify.
+ *  verts: An array of vertices describing the screen coordinates of the
+ *         triangle. This function expects 3 elements in this array.
+ *
+ * Returns:
+ *  TRUE if the pixel coordinate is inside this triangle
+ *  FALSE if not
+ *
+ *****************************************************************************/
+static BOOL d3d_execute_buffer_pick_test(LONG x, LONG y, D3DTLVERTEX* verts)
+{
+    UINT i;
+
+    for (i = 0; i < TRIANGLE_SIZE; i++)
+    {
+        D3DTLVERTEX* v1 = &verts[(i)     % TRIANGLE_SIZE];
+        D3DTLVERTEX* v2 = &verts[(i + 1) % TRIANGLE_SIZE];
+        D3DVALUE bias = 0.0f;
+
+        /* Edge function - determines whether pixel is inside triangle */
+        D3DVALUE w = (v2->sx - v1->sx) * (y - v1->sy) - (v2->sy - v1->sy) * (x - v1->sx);
+
+        /* Force top-left rule */
+        if ((v1->sy == v2->sy && v1->sx > v2->sx) || (v1->sy < v2->sy))
+            bias = 1.0f;
+
+        if (w < bias)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+/*****************************************************************************
+ * d3d_execute_buffer_z_value_at_coords
+ *
+ * Returns the Z point of a triangle given an X, Y coordinate somewhere inside
+ * the triangle. Used as the `dvZ` parameter of D3DPICKRECORD.
+ *
+ * Params:
+ *  x:     The X coordinate of the point to verify.
+ *  y:     The Y coordinate of the point to verify.
+ *  verts: An array of vertices describing the screen coordinates of the
+ *         triangle. This function expects 3 elements in this array.
+ *
+ * Returns:
+ *  A floating-point Z value that can be used directly as the dvZ member of a
+ *  D3DPICKRECORD.
+ *
+ *****************************************************************************/
+static D3DVALUE d3d_execute_buffer_z_value_at_coords(LONG x, LONG y, D3DTLVERTEX* verts)
+{
+    UINT i;
+
+    D3DVALUE z1 = 0;
+    D3DVALUE z2 = 0;
+
+    for (i = 0; i < TRIANGLE_SIZE; i++)
+    {
+        D3DTLVERTEX* v1 = &verts[i];
+        D3DTLVERTEX* v2 = &verts[(i + 1) % TRIANGLE_SIZE];
+        D3DTLVERTEX* v3 = &verts[(i + 2) % TRIANGLE_SIZE];
+
+        z1 += v3->sz * (x - v1->sx) * (y - v2->sy) - v2->sz * (x - v1->sx) * (y - v3->sy);
+        z2 += (x - v1->sx) * (y - v2->sy) - (x - v1->sx) * (y - v3->sy);
+    }
+
+    return z1 / z2;
+}
+
+HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d_device *device,
+    D3DRECT* pick_rect)
 {
     DWORD is = buffer->data.dwInstructionOffset;
     char *instr = (char *)buffer->desc.lpData + is;
     unsigned int i, primitive_size;
-    struct wined3d_map_desc map_desc;
+    struct wined3d_map_desc map_desc, vert_map_desc;
     struct wined3d_box box = {0};
     HRESULT hr;
 
+    /* Variables used for picking */
+    const unsigned int vertex_size = get_flexible_vertex_size(D3DFVF_TLVERTEX);
+    D3DTLVERTEX verts[TRIANGLE_SIZE];
+
+    device->pick_record_count = 0;
+
     TRACE("ExecuteData :\n");
     if (TRACE_ON(ddraw))
         _dump_executedata(&(buffer->data));
@@ -69,6 +160,26 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d
         instr += sizeof(*current);
         primitive_size = 0;
 
+        if (pick_rect != NULL)
+        {
+            switch (current->bOpcode)
+            {
+                /* None of these opcodes seem to be necessary for picking */
+                case D3DOP_POINT:
+                case D3DOP_LINE:
+                case D3DOP_STATETRANSFORM:
+                case D3DOP_STATELIGHT:
+                case D3DOP_STATERENDER:
+                case D3DOP_TEXTURELOAD:
+                case D3DOP_SPAN:
+                    FIXME("ignoring opcode %d for picking\n", current->bOpcode);
+                    instr += count * size;
+                    continue;
+                default:
+                    break;
+            }
+        }
+
         switch (current->bOpcode)
         {
             case D3DOP_POINT:
@@ -173,6 +284,66 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d
                     {
                         case 3:
                             indices[(i * primitive_size) + 2] = ci->v3;
+
+                            if (pick_rect != NULL) {
+                                UINT j;
+
+                                /* Get D3DTLVERTEX objects for each triangle vertex */
+                                for (j = 0; j < TRIANGLE_SIZE; j++) {
+
+                                    /* Get index of vertex from D3DTRIANGLE struct */
+                                    switch (j) {
+                                    case 0: box.left = vertex_size * ci->v1; break;
+                                    case 1: box.left = vertex_size * ci->v2; break;
+                                    case 2: box.left = vertex_size * ci->v3; break;
+                                    }
+
+                                    box.right = box.left + vertex_size;
+                                    if (FAILED(hr = wined3d_resource_map(wined3d_buffer_get_resource(buffer->dst_vertex_buffer),
+                                            0, &vert_map_desc, &box, WINED3D_MAP_WRITE))) {
+                                        return hr;
+                                    } else {
+                                        /* Copy vert data into stack array */
+                                        verts[j] = *((D3DTLVERTEX*)vert_map_desc.data);
+
+                                        wined3d_resource_unmap(wined3d_buffer_get_resource(buffer->dst_vertex_buffer), 0);
+                                    }
+                                }
+
+                                /* Use vertices acquired above to test for clicking */
+                                if (d3d_execute_buffer_pick_test(pick_rect->x1, pick_rect->y1, verts))
+                                {
+                                    D3DPICKRECORD* record;
+
+                                    device->pick_record_count++;
+
+                                    /* Grow the array if necessary */
+                                    if (device->pick_record_count > device->pick_record_size)
+                                    {
+                                        if (device->pick_record_size == 0) device->pick_record_size = 1;
+                                        device->pick_record_size *= 2;
+                                        device->pick_records = realloc(device->pick_records,
+                                            sizeof(*device->pick_records) * device->pick_record_size);
+                                    }
+
+                                    /* Fill record parameters */
+                                    record = &device->pick_records[device->pick_record_count - 1];
+
+                                    record->bOpcode = current->bOpcode;
+                                    record->bPad = 0;
+
+                                    /* Write current instruction offset into file */
+                                    record->dwOffset = (DWORD_PTR)instr - (DWORD_PTR)buffer->desc.lpData - is;
+
+                                    /* Formula for returning the Z value at this X/Y */
+                                    record->dvZ = d3d_execute_buffer_z_value_at_coords(pick_rect->x1, pick_rect->y1, verts);
+
+                                    /* We have a successful pick so we can skip the rest of the triangles */
+                                    instr += size * (count - i - 1);
+                                    count = i;
+                                }
+                            }
+
                             /* Drop through. */
                         case 2:
                             indices[(i * primitive_size) + 1] = ci->v2;
@@ -421,6 +592,7 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d
 end_of_buffer:
     return D3D_OK;
 }
+#undef TRIANGLE_SIZE
 
 static inline struct d3d_execute_buffer *impl_from_IDirect3DExecuteBuffer(IDirect3DExecuteBuffer *iface)
 {
diff --git a/dlls/ddraw/tests/ddraw1.c b/dlls/ddraw/tests/ddraw1.c
index 205370a8577..9fe0e5acebc 100644
--- a/dlls/ddraw/tests/ddraw1.c
+++ b/dlls/ddraw/tests/ddraw1.c
@@ -15599,6 +15599,137 @@ static void test_enum_devices(void)
     ok(!refcount, "Device has %lu references left.\n", refcount);
 }
 
+static void test_pick(void)
+{
+    static D3DTLVERTEX tquad[] =
+    {
+        {{320.0f}, {480.0f}, { 1.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+        {{  0.0f}, {480.0f}, {-0.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+        {{320.0f}, {  0.0f}, { 1.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+        {{  0.0f}, {  0.0f}, {-0.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+    };
+    IDirect3DExecuteBuffer *execute_buffer;
+    D3DEXECUTEBUFFERDESC exec_desc;
+    IDirect3DViewport *viewport;
+    IDirect3DDevice *device;
+    IDirectDraw *ddraw;
+    UINT inst_length;
+    HWND window;
+    HRESULT hr;
+    void *ptr;
+    DWORD rec_count;
+    D3DRECT pick_rect;
+    UINT screen_width = 640;
+    UINT screen_height = 480;
+    UINT hits = 0;
+    UINT nohits = 0;
+    int i, j;
+
+    window = create_window();
+    ddraw = create_ddraw();
+    ok(!!ddraw, "Failed to create a ddraw object.\n");
+    if (!(device = create_device(ddraw, window, DDSCL_NORMAL)))
+    {
+        skip("Failed to create a 3D device, skipping test.\n");
+        IDirectDraw_Release(ddraw);
+        DestroyWindow(window);
+        return;
+    }
+
+    viewport = create_viewport(device, 0, 0, screen_width, screen_height);
+
+    memset(&exec_desc, 0, sizeof(exec_desc));
+    exec_desc.dwSize = sizeof(exec_desc);
+    exec_desc.dwFlags = D3DDEB_BUFSIZE | D3DDEB_CAPS;
+    exec_desc.dwBufferSize = 1024;
+    exec_desc.dwCaps = D3DDEBCAPS_SYSTEMMEMORY;
+
+    hr = IDirect3DDevice_CreateExecuteBuffer(device, &exec_desc, &execute_buffer, NULL);
+    ok(SUCCEEDED(hr), "Failed to create execute buffer, hr %#lx.\n", hr);
+    hr = IDirect3DExecuteBuffer_Lock(execute_buffer, &exec_desc);
+    ok(SUCCEEDED(hr), "Failed to lock execute buffer, hr %#lx.\n", hr);
+    memcpy(exec_desc.lpData, tquad, sizeof(tquad));
+    ptr = ((BYTE *)exec_desc.lpData) + sizeof(tquad);
+    emit_process_vertices(&ptr, D3DPROCESSVERTICES_COPY, 0, 4);
+    emit_tquad(&ptr, 0);
+    emit_end(&ptr);
+    inst_length = (BYTE *)ptr - (BYTE *)exec_desc.lpData;
+    inst_length -= sizeof(tquad);
+    hr = IDirect3DExecuteBuffer_Unlock(execute_buffer);
+    ok(SUCCEEDED(hr), "Failed to unlock execute buffer, hr %#lx.\n", hr);
+
+    set_execute_data(execute_buffer, 4, sizeof(tquad), inst_length);
+
+    /* Perform a number of picks, we should have a specific amount by the end */
+    for (i = 0; i < screen_width; i += 80)
+    {
+        for (j = 0; j < screen_height; j += 60)
+        {
+            pick_rect.x1 = i;
+            pick_rect.y1 = j;
+
+            hr = IDirect3DDevice_Pick(device, execute_buffer, viewport, 0, &pick_rect);
+            ok(SUCCEEDED(hr), "Failed to perform pick, hr %#lx.\n", hr);
+            hr = IDirect3DDevice_GetPickRecords(device, &rec_count, NULL);
+            ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+            if (rec_count > 0)
+                hits++;
+            else
+                nohits++;
+        }
+    }
+
+    /*
+        We should have gotten precisely equal numbers of hits and no hits since our quad
+        covers exactly half the screen
+    */
+    ok(hits == nohits, "Got a non-equal amount of pick successes/failures: %i vs %i.\n", hits, nohits);
+
+    /* Try some specific pixel picks */
+    pick_rect.x1 = 480;
+    pick_rect.y1 = 360;
+    hr = IDirect3DDevice_Pick(device, execute_buffer, viewport, 0, &pick_rect);
+    ok(SUCCEEDED(hr), "Failed to perform pick, hr %#lx.\n", hr);
+    hr = IDirect3DDevice_GetPickRecords(device, &rec_count, NULL);
+    ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+    ok(rec_count == 0, "Got incorrect number of pick records (expected 0): %lu.\n", rec_count);
+
+    pick_rect.x1 = 240;
+    pick_rect.y1 = 120;
+    hr = IDirect3DDevice_Pick(device, execute_buffer, viewport, 0, &pick_rect);
+    ok(SUCCEEDED(hr), "Failed to perform pick, hr %#lx.\n", hr);
+    rec_count = 0;
+    hr = IDirect3DDevice_GetPickRecords(device, &rec_count, NULL);
+    ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+    ok(rec_count == 1, "Got incorrect number of pick records (expected 1): %lu.\n", rec_count);
+
+    if (rec_count == 1)
+    {
+        D3DPICKRECORD record;
+
+        hr = IDirect3DDevice_GetPickRecords(device, &rec_count, &record);
+        ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+        ok(rec_count == 1, "Got incorrect number of pick records (expected 1): %lu.\n", rec_count);
+
+        hr = IDirect3DDevice_GetPickRecords(device, &rec_count, &record);
+        ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+        ok(rec_count == 1, "Got incorrect number of pick records (expected 1): %lu.\n", rec_count);
+
+        /* Tests D3DPICKRECORD for correct information */
+        ok(record.bOpcode == 3, "Got incorrect bOpcode: %i.\n", record.bOpcode);
+        ok(record.bPad == 0, "Got incorrect bPad: %i.\n", record.bPad);
+        ok(record.dwOffset == 24, "Got incorrect dwOffset: %lu.\n", record.dwOffset);
+        ok(compare_float(record.dvZ, 1.0, 0.1), "Got incorrect dvZ: %f.\n", record.dvZ);
+    }
+
+    destroy_viewport(device, viewport);
+    IDirect3DExecuteBuffer_Release(execute_buffer);
+    IDirect3DDevice_Release(device);
+    IDirectDraw_Release(ddraw);
+
+    DestroyWindow(window);
+}
+
 /* Emperor: Rise of the Middle Kingdom locks a sysmem surface and then accesses
  * the pointer after unlocking it. This test roughly replicates the calls that
  * it makes. */
@@ -15659,6 +15790,7 @@ static void test_pinned_sysmem(void)
     IDirectDrawSurface_Release(surface);
     refcount = IDirectDraw_Release(ddraw);
     ok(!refcount, "Device has %lu references left.\n", refcount);
+
     DestroyWindow(window);
 }
 
@@ -16051,6 +16183,7 @@ START_TEST(ddraw1)
     test_vtbl_protection();
     test_window_position();
     test_get_display_mode();
+    test_pick();
     run_for_each_device_type(test_texture_wrong_caps);
     test_filling_convention();
     test_enum_devices();

From a32caec9350e493370e5f838b43486796e372f52 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 30 May 2015 02:55:03 +0200
Subject: [PATCH 017/244] ddraw: Allow size and format conversions in
 IDirect3DTexture2::Load.

---
 dlls/ddraw/surface.c | 153 +++++++++++++++++++++++--------------------
 1 file changed, 82 insertions(+), 71 deletions(-)

diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index ce3cc5bf29c..8da415e3063 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -5513,6 +5513,46 @@ static struct ddraw_surface *get_sub_mimaplevel(struct ddraw_surface *surface)
     return impl_from_IDirectDrawSurface7(next_level);
 }
 
+static BOOL compare_format(DDPIXELFORMAT *format1, DDPIXELFORMAT *format2)
+{
+    if ((format1->dwFlags & (DDPF_RGB|DDPF_YUV|DDPF_FOURCC)) !=
+        (format2->dwFlags & (DDPF_RGB|DDPF_YUV|DDPF_FOURCC)))
+        return FALSE;
+
+    if (format1->dwFlags & (DDPF_RGB|DDPF_YUV))
+    {
+        if (!(format1->dwFlags & DDPF_ALPHA))
+        {
+            /* The RGB and YUV bits are stored in the same fields */
+            if (format1->dwRGBBitCount != format2->dwRGBBitCount)
+                return FALSE;
+
+            if (format1->dwRBitMask != format2->dwRBitMask)
+                return FALSE;
+
+            if (format1->dwGBitMask != format2->dwGBitMask)
+                return FALSE;
+
+            if (format1->dwBBitMask != format2->dwBBitMask)
+                return FALSE;
+        }
+
+        if (format1->dwFlags & (DDPF_ALPHAPIXELS | DDPF_ALPHA))
+        {
+            if (format1->dwRGBAlphaBitMask != format2->dwRGBAlphaBitMask)
+                return FALSE;
+        }
+    }
+
+    if (format1->dwFlags & DDPF_FOURCC)
+    {
+        if (format1->dwFourCC != format2->dwFourCC)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
 /*****************************************************************************
  * IDirect3DTexture2::Load
  *
@@ -5534,7 +5574,7 @@ static HRESULT WINAPI d3d_texture2_Load(IDirect3DTexture2 *iface, IDirect3DTextu
 {
     struct ddraw_surface *dst_surface = impl_from_IDirect3DTexture2(iface);
     struct ddraw_surface *src_surface = unsafe_impl_from_IDirect3DTexture2(src_texture);
-    struct wined3d_resource *dst_resource, *src_resource;
+    RECT src_rect, dst_rect;
     HRESULT hr;
 
     TRACE("iface %p, src_texture %p.\n", iface, src_texture);
@@ -5547,90 +5587,62 @@ static HRESULT WINAPI d3d_texture2_Load(IDirect3DTexture2 *iface, IDirect3DTextu
 
     wined3d_mutex_lock();
 
-    dst_resource = wined3d_texture_get_resource(ddraw_surface_get_default_texture(dst_surface, DDRAW_SURFACE_WRITE));
-    src_resource = wined3d_texture_get_resource(ddraw_surface_get_default_texture(src_surface, DDRAW_SURFACE_READ));
-
-    if (((src_surface->surface_desc.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
-            != (dst_surface->surface_desc.ddsCaps.dwCaps & DDSCAPS_MIPMAP))
-            || (src_surface->surface_desc.dwMipMapCount != dst_surface->surface_desc.dwMipMapCount))
-    {
-        ERR("Trying to load surfaces with different mip-map counts.\n");
-    }
-
     for (;;)
     {
-        struct ddraw_palette *dst_pal, *src_pal;
-        DDSURFACEDESC *src_desc, *dst_desc;
+        DDSURFACEDESC *src_desc = (DDSURFACEDESC *)&src_surface->surface_desc;
 
         TRACE("Copying surface %p to surface %p.\n", src_surface, dst_surface);
 
-        /* Suppress the ALLOCONLOAD flag */
-        dst_surface->surface_desc.ddsCaps.dwCaps &= ~DDSCAPS_ALLOCONLOAD;
-
-        /* Get the palettes */
-        dst_pal = dst_surface->palette;
-        src_pal = src_surface->palette;
-
-        if (src_pal)
+        if (compare_format(&src_surface->surface_desc.ddpfPixelFormat,
+                           &dst_surface->surface_desc.ddpfPixelFormat))
         {
-            PALETTEENTRY palent[256];
+            struct ddraw_palette *dst_pal, *src_pal;
 
-            if (!dst_pal)
-            {
-                wined3d_mutex_unlock();
-                return DDERR_NOPALETTEATTACHED;
-            }
-            IDirectDrawPalette_GetEntries(&src_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
-            IDirectDrawPalette_SetEntries(&dst_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
-        }
+            /* Get the palettes */
+            dst_pal = dst_surface->palette;
+            src_pal = src_surface->palette;
 
-        /* Copy one surface on the other */
-        dst_desc = (DDSURFACEDESC *)&(dst_surface->surface_desc);
-        src_desc = (DDSURFACEDESC *)&(src_surface->surface_desc);
+            if (src_pal)
+            {
+                PALETTEENTRY palent[256];
 
-        if ((src_desc->dwWidth != dst_desc->dwWidth) || (src_desc->dwHeight != dst_desc->dwHeight))
-        {
-            /* Should also check for same pixel format, lPitch, ... */
-            ERR("Error in surface sizes.\n");
-            wined3d_mutex_unlock();
-            return D3DERR_TEXTURE_LOAD_FAILED;
-        }
-        else
-        {
-            struct wined3d_map_desc src_map_desc, dst_map_desc;
+                if (!dst_pal)
+                {
+                    wined3d_mutex_unlock();
+                    return DDERR_NOPALETTEATTACHED;
+                }
+                IDirectDrawPalette_GetEntries(&src_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
+                IDirectDrawPalette_SetEntries(&dst_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
+            }
 
-            /* Copy the src blit color key if the source has one, don't erase
-             * the destination's ckey if the source has none */
             if (src_desc->dwFlags & DDSD_CKSRCBLT)
             {
                 IDirectDrawSurface7_SetColorKey(&dst_surface->IDirectDrawSurface7_iface,
                         DDCKEY_SRCBLT, &src_desc->ddckCKSrcBlt);
             }
+        }
+        else
+        {
+            if (src_desc->dwFlags & DDSD_CKSRCBLT)
+                return E_FAIL;
+        }
 
-            if (FAILED(hr = wined3d_resource_map(src_resource,
-                    src_surface->sub_resource_idx, &src_map_desc, NULL, WINED3D_MAP_READ)))
-            {
-                ERR("Failed to lock source surface, hr %#lx.\n", hr);
-                wined3d_mutex_unlock();
-                return D3DERR_TEXTURE_LOAD_FAILED;
-            }
-
-            if (FAILED(hr = wined3d_resource_map(dst_resource,
-                    dst_surface->sub_resource_idx, &dst_map_desc, NULL, WINED3D_MAP_WRITE)))
-            {
-                ERR("Failed to lock destination surface, hr %#lx.\n", hr);
-                wined3d_resource_unmap(src_resource, src_surface->sub_resource_idx);
-                wined3d_mutex_unlock();
-                return D3DERR_TEXTURE_LOAD_FAILED;
-            }
+        /* Suppress the ALLOCONLOAD flag */
+        dst_surface->surface_desc.ddsCaps.dwCaps &= ~DDSCAPS_ALLOCONLOAD;
 
-            if (dst_surface->surface_desc.ddpfPixelFormat.dwFlags & DDPF_FOURCC)
-                memcpy(dst_map_desc.data, src_map_desc.data, src_surface->surface_desc.dwLinearSize);
-            else
-                memcpy(dst_map_desc.data, src_map_desc.data, src_map_desc.row_pitch * src_desc->dwHeight);
+        SetRect(&src_rect, 0, 0, src_surface->surface_desc.dwWidth, src_surface->surface_desc.dwHeight);
+        SetRect(&dst_rect, 0, 0, dst_surface->surface_desc.dwWidth, dst_surface->surface_desc.dwHeight);
 
-            wined3d_resource_unmap(dst_resource, dst_surface->sub_resource_idx);
-            wined3d_resource_unmap(src_resource, src_surface->sub_resource_idx);
+        hr = wined3d_device_context_blt(dst_surface->ddraw->immediate_context,
+                ddraw_surface_get_default_texture(dst_surface, DDRAW_SURFACE_WRITE),
+                dst_surface->sub_resource_idx, &dst_rect,
+                ddraw_surface_get_default_texture(src_surface, DDRAW_SURFACE_READ),
+                src_surface->sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_LINEAR);
+        if (FAILED(hr))
+        {
+            ERR("Failed to blit surface, hr %#lx.\n", hr);
+            wined3d_mutex_unlock();
+            return hr;
         }
 
         if (src_surface->surface_desc.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
@@ -5643,12 +5655,11 @@ static HRESULT WINAPI d3d_texture2_Load(IDirect3DTexture2 *iface, IDirect3DTextu
         else
             dst_surface = NULL;
 
+        if (src_surface && !dst_surface)
+            return DDERR_NOTFOUND;
+
         if (!src_surface || !dst_surface)
-        {
-            if (src_surface != dst_surface)
-                ERR("Loading surface with different mipmap structure.\n");
             break;
-        }
     }
 
     wined3d_mutex_unlock();

From 0b99c2ac2306f1c829e77744fb003a5a1745414a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 30 May 2015 02:56:19 +0200
Subject: [PATCH 018/244] ddraw/tests: Add more tests for
 IDirect3DTexture2::Load.

---
 dlls/ddraw/tests/d3d.c    | 373 ++++++++++++++++++++++++++++++++++++++
 dlls/ddraw/tests/ddraw2.c |  28 ++-
 2 files changed, 400 insertions(+), 1 deletion(-)

diff --git a/dlls/ddraw/tests/d3d.c b/dlls/ddraw/tests/d3d.c
index ec536a83729..06b97fec964 100644
--- a/dlls/ddraw/tests/d3d.c
+++ b/dlls/ddraw/tests/d3d.c
@@ -1057,6 +1057,288 @@ static BOOL colortables_check_equality(PALETTEENTRY table1[256], PALETTEENTRY ta
     return TRUE;
 }
 
+static void fill_surface(IDirectDrawSurface *surface, DWORD fillcolor, int level)
+{
+    DDSCAPS caps = {DDSCAPS_COMPLEX};
+    IDirectDrawSurface *surface2;
+    DDSURFACEDESC ddsd;
+    DWORD x, y;
+    HRESULT hr;
+    int curlevel = -1;
+
+    IDirectDrawSurface_AddRef(surface);
+
+    while (surface)
+    {
+        curlevel++;
+
+        if (level == -1 || curlevel == level)
+        {
+            memset(&ddsd, 0, sizeof(ddsd));
+            ddsd.dwSize = sizeof(ddsd);
+
+            hr = IDirectDrawSurface_Lock(surface, NULL, &ddsd, DDLOCK_WAIT, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Lock returned: %lx\n", hr);
+
+            for (y = 0; y < ddsd.dwHeight; y++)
+            {
+                if (ddsd.ddpfPixelFormat.dwRGBBitCount == 32)
+                {
+                    DWORD *textureRow = (DWORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                        *textureRow++ = fillcolor;
+                }
+                else if (ddsd.ddpfPixelFormat.dwRGBBitCount == 16)
+                {
+                    WORD *textureRow = (WORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                        *textureRow++ = fillcolor;
+                }
+                else
+                {
+                    ok(0, "Unsupported format!\n");
+                    break;
+                }
+            }
+
+            hr = IDirectDrawSurface_Unlock(surface, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Unlock returned: %lx\n", hr);
+        }
+
+        if (level != -1 && curlevel >= level)
+        {
+            IDirectDrawSurface_Release(surface);
+            break;
+        }
+
+        if (IDirectDrawSurface_GetAttachedSurface(surface, &caps, &surface2) != DD_OK)
+            surface2 = NULL;
+
+        IDirectDrawSurface_Release(surface);
+        surface = surface2;
+    }
+}
+
+static BOOL check_surface(IDirectDrawSurface *surface, DWORD fillcolor, int level)
+{
+    DDSCAPS caps = {DDSCAPS_COMPLEX};
+    IDirectDrawSurface *surface2;
+    DDSURFACEDESC ddsd;
+    int curlevel = -1;
+    BOOL result = TRUE;
+    DWORD x, y;
+    HRESULT hr;
+
+    IDirectDrawSurface_AddRef(surface);
+    fillcolor &= 0x00ffffff;
+
+    while (surface)
+    {
+        curlevel++;
+
+        if (level == -1 || curlevel == level)
+        {
+            memset(&ddsd, 0, sizeof(ddsd));
+            ddsd.dwSize = sizeof(ddsd);
+
+            hr = IDirectDrawSurface_Lock(surface, NULL, &ddsd, DDLOCK_WAIT, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Lock returned: %lx\n", hr);
+
+            for (y = 0; y < ddsd.dwHeight; y++)
+            {
+                if (ddsd.ddpfPixelFormat.dwRGBBitCount == 32)
+                {
+                    DWORD *textureRow = (DWORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                    {
+                        if ((*textureRow & 0x00ffffff) != fillcolor)
+                        {
+                            ok(0, "Expected color %lx, got %lx at (%ld, %ld) in level %d\n",
+                               fillcolor, *textureRow, x, y, curlevel);
+                            result = FALSE;
+                            goto end;
+                        }
+                        textureRow++;
+                    }
+                }
+                else if (ddsd.ddpfPixelFormat.dwRGBBitCount == 16)
+                {
+                    WORD *textureRow = (WORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                    {
+                        if (*textureRow != fillcolor)
+                        {
+                            ok(0, "Expected color %lx, got %lx at (%ld, %ld) in level %ld\n",
+                               fillcolor, *textureRow, x, y, curlevel);
+                            result = FALSE;
+                            goto end;
+                        }
+                        textureRow++;
+                    }
+                }
+                else
+                {
+                    ok(0, "Unsupported format!\n");
+                    break;
+                }
+            }
+
+        end:
+            hr = IDirectDrawSurface_Unlock(surface, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Unlock returned: %lx\n", hr);
+        }
+
+        if (level != -1 && curlevel >= level)
+        {
+            IDirectDrawSurface_Release(surface);
+            break;
+        }
+
+        if (IDirectDrawSurface_GetAttachedSurface(surface, &caps, &surface2) != DD_OK)
+            surface2 = NULL;
+
+        IDirectDrawSurface_Release(surface);
+        surface = surface2;
+    }
+
+    return result;
+}
+
+struct rgb_format
+{
+    DWORD dwRGBBitCount;
+    DWORD dwRBitMask;
+    DWORD dwGBitMask;
+    DWORD dwBBitMask;
+};
+
+struct mipmap_surface_info
+{
+    struct rgb_format *format;
+    DWORD             width;
+    DWORD             height;
+    int               levels;
+    DWORD             fill[4];
+};
+
+struct rgb_format test_rgb24 = {32, 0x00FF0000, 0x0000FF00, 0x000000FF};
+struct rgb_format test_rgb16 = {16, 0xf800, 0x07e0, 0x001f};
+
+struct
+{
+    struct mipmap_surface_info surfaces[2];
+    HRESULT hres;
+    int     level_check;
+    DWORD   fill_check[4];
+}
+load_tests[] =
+{
+    /* different formats */
+    { {{&test_rgb16, 256, 256, 0, {0x1234}},
+       {&test_rgb24, 256, 256, 0, {0x789ABC}} },
+                        DD_OK, 1, {0x1045A5}},
+    { {{&test_rgb24, 256, 256, 0, {0x123456}},
+       {&test_rgb16, 256, 256, 0, {0x1234}} },
+                        DD_OK, 1, {0x11AA}},
+
+    /* different sizes, but no mipmap */
+    { {{&test_rgb24, 256, 256, 0, {0xff0000}},
+       {&test_rgb24, 256, 256, 0, {0x00ff00}} },
+                        DD_OK, 1, {0xff0000}},
+    { {{&test_rgb24, 512, 512, 0, {0x00ff00}},
+       {&test_rgb24, 256, 256, 0, {0x0000ff}} },
+                        DD_OK, 1, {0x00ff00}},
+    { {{&test_rgb24, 256, 256, 0, {0x0000ff}},
+       {&test_rgb24, 512, 512, 0, {0xff0000}} },
+                        DD_OK, 1, {0x0000ff}},
+
+    /* different sizes, 1 mapmip level */
+    { {{&test_rgb24, 256, 256, 1, {0xff0000}},
+       {&test_rgb24, 256, 256, 1, {0x00ff00}} },
+                        DD_OK, 1, {0xff0000}},
+    { {{&test_rgb24, 512, 512, 1, {0x00ff00}},
+       {&test_rgb24, 256, 256, 1, {0x0000ff}} },
+                        DD_OK, 1, {0x00ff00}},
+    { {{&test_rgb24, 256, 256, 1, {0x0000ff}},
+       {&test_rgb24, 512, 512, 1, {0xff0000}} },
+                        DD_OK, 1, {0x0000ff}},
+
+    /* different sizes, 2 mapmip levels */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 512, 512, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+
+    /* different sizes, source mipmap levels > dest mimap levels */
+    { {{&test_rgb24, 256, 256, 3, {0xff0000, 0x0000ff, 0x808080}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+               DDERR_NOTFOUND, 0, {}},
+    { {{&test_rgb24, 512, 512, 3, {0xff0000, 0x0000ff, 0x808080}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+               DDERR_NOTFOUND, 0, {}},
+    { {{&test_rgb24, 256, 256, 3, {0xff0000, 0x0000ff, 0x808080}},
+       {&test_rgb24, 512, 512, 2, {0x00ff00, 0x00ff00}} },
+               DDERR_NOTFOUND, 0, {}},
+
+    /* different sizes, source mipmap levels < dest mipmap levels  */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 512, 512, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+
+    /* different sizes, different formats */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 2, {0x07e0, 0x07e0}} },
+                        DD_OK, 2, {0xf800, 0x001f}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 2, {0x07e0, 0x07e0}} },
+                        DD_OK, 2, {0xf800, 0x001f}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 512, 512, 2, {0x07e0, 0x07e0}} },
+                        DD_OK, 2, {0xf800, 0x001f}},
+
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb16, 512, 512, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 512, 512, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+
+    /* different sizes, source mipmap levels < destmipmap levels , different format */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 3, {0x07e0, 0x07e0, 0x1234}} },
+                        DD_OK, 3, {0xf800, 0x001f, 0x1234}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 3, {0x07e0, 0x07e0, 0x1234}} },
+                        DD_OK, 3, {0xf800, 0x001f, 0x1234}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 512, 512, 3, {0x07e0, 0x07e0, 0x1234}} },
+                        DD_OK, 3, {0xf800, 0x001f, 0x1234}},
+
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb16, 512, 512, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 512, 512, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+};
+
 /* test palette handling in IDirect3DTexture_Load */
 static void TextureLoadTest(void)
 {
@@ -1120,6 +1402,97 @@ static void TextureLoadTest(void)
     hr = IDirect3DTexture_Load(Texture2, Texture);
     ok(hr == DD_OK, "Got hr %#lx.\n", hr);
 
+    for (i = 0; i < sizeof(load_tests) / sizeof(load_tests[0]); i++)
+    {
+        IDirectDrawSurface *TexSurfaces[2] = {NULL, NULL};
+        IDirect3DTexture *Textures[2] = {NULL, NULL};
+        DDSURFACEDESC ddsd2;
+        int j, k;
+
+        for (j = 0; j < 2; j++)
+        {
+            memset(&ddsd2, 0, sizeof (ddsd2));
+            ddsd2.dwSize = sizeof (ddsd2);
+            ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
+            ddsd2.dwHeight = load_tests[i].surfaces[j].height;
+            ddsd2.dwWidth = load_tests[i].surfaces[j].width;
+            ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
+            ddsd2.ddpfPixelFormat.dwSize = sizeof(ddsd2.ddpfPixelFormat);
+            ddsd2.ddpfPixelFormat.dwFlags = DDPF_RGB;
+            ddsd2.ddpfPixelFormat.dwRGBBitCount = load_tests[i].surfaces[j].format->dwRGBBitCount;
+            ddsd2.ddpfPixelFormat.dwRBitMask = load_tests[i].surfaces[j].format->dwRBitMask;
+            ddsd2.ddpfPixelFormat.dwGBitMask = load_tests[i].surfaces[j].format->dwGBitMask;
+            ddsd2.ddpfPixelFormat.dwBBitMask = load_tests[i].surfaces[j].format->dwBBitMask;
+
+            if (load_tests[i].surfaces[j].levels)
+            {
+                ddsd2.dwFlags |= DDSD_MIPMAPCOUNT;
+                ddsd2.ddsCaps.dwCaps |= DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;
+                ddsd2.dwMipMapCount = load_tests[i].surfaces[j].levels;
+            }
+
+            hr = IDirectDraw_CreateSurface(DirectDraw1, &ddsd2, &TexSurfaces[j], NULL);
+            ok(hr == D3D_OK, "IDirectDraw_CreateSurface returned %08lx for surface %d in test %d\n", hr, j, i);
+            if (FAILED(hr)) goto next;
+
+            hr = IDirectDrawSurface_QueryInterface(TexSurfaces[j], &IID_IDirect3DTexture, (void *)&Textures[j]);
+            ok(hr == D3D_OK, "IDirectDrawSurface_QueryInterface returned %08lx for surface %d in test %d\n", hr, j, i);
+            if (FAILED(hr)) goto next;
+
+            if (load_tests[i].surfaces[j].levels)
+            {
+                for (k = 0; k < load_tests[i].surfaces[j].levels; k++)
+                    fill_surface(TexSurfaces[j], load_tests[i].surfaces[j].fill[k], k);
+            }
+            else
+                fill_surface(TexSurfaces[j], load_tests[i].surfaces[j].fill[0], -1);
+        }
+
+        hr = IDirect3DTexture_Load(Textures[1], Textures[0]);
+        ok(hr == load_tests[i].hres, "IDirect3DTexture_Load returned %08lx, expected %08x\n", hr, load_tests[i].hres);
+        if (hr != DD_OK) goto next;
+
+        memset(&ddsd2, 0, sizeof (ddsd2));
+        ddsd2.dwSize = sizeof(ddsd2);
+        hr = IDirectDrawSurface_GetSurfaceDesc(TexSurfaces[1], &ddsd2);
+        ok(hr == DD_OK, "IDirectDrawSurface_GetSurfaceDesc returned %08lx\n", hr);
+
+        if (load_tests[i].surfaces[1].levels)
+        {
+            ok(ddsd2.dwMipMapCount == load_tests[i].surfaces[1].levels,
+               "Expected %d mipmap levels, got %d in run %d\n", load_tests[i].surfaces[1].levels,
+               ddsd2.dwMipMapCount, i);
+        }
+
+        for (k = 0; k < load_tests[i].level_check; k++)
+        {
+            if (!check_surface(TexSurfaces[1], load_tests[i].fill_check[k], k))
+                ok(0, "Check surface failed in test %d\n", i);
+        }
+
+        ok(ddsd2.ddpfPixelFormat.dwRGBBitCount == load_tests[i].surfaces[1].format->dwRGBBitCount,
+           "Expected %d rgb bits, got %d in run %d\n", load_tests[i].surfaces[1].format->dwRGBBitCount,
+           ddsd2.ddpfPixelFormat.dwRGBBitCount, i);
+
+        ok(ddsd2.ddpfPixelFormat.dwRBitMask == load_tests[i].surfaces[1].format->dwRBitMask,
+           "Expected %08x red bits, got %08x in run %d\n", load_tests[i].surfaces[1].format->dwRBitMask,
+           ddsd2.ddpfPixelFormat.dwRBitMask, i);
+
+        ok(ddsd2.ddpfPixelFormat.dwGBitMask == load_tests[i].surfaces[1].format->dwGBitMask,
+           "Expected %08x green bits, got %08x in run %d\n", load_tests[i].surfaces[1].format->dwGBitMask,
+           ddsd2.ddpfPixelFormat.dwGBitMask, i);
+
+        ok(ddsd2.ddpfPixelFormat.dwBBitMask == load_tests[i].surfaces[1].format->dwBBitMask,
+           "Expected %08x blue bits, got %08x in run %d\n", load_tests[i].surfaces[1].format->dwBBitMask,
+           ddsd2.ddpfPixelFormat.dwBBitMask, i);
+
+    next:
+        if (Textures[0]) IDirect3DTexture_Release(Textures[0]);
+        if (TexSurfaces[0]) IDirectDrawSurface_Release(TexSurfaces[0]);
+        if (Textures[1]) IDirect3DTexture_Release(Textures[1]);
+        if (TexSurfaces[1]) IDirectDrawSurface_Release(TexSurfaces[1]);
+    }
+
     for (i = 0; i < 256; i++) {
         table1[i].peRed = i;
         table1[i].peGreen = i;
diff --git a/dlls/ddraw/tests/ddraw2.c b/dlls/ddraw/tests/ddraw2.c
index 91565a04dcd..5e33e630ce6 100644
--- a/dlls/ddraw/tests/ddraw2.c
+++ b/dlls/ddraw/tests/ddraw2.c
@@ -1496,8 +1496,10 @@ static void test_texture_load_ckey(void)
     IDirectDraw2 *ddraw = NULL;
     IDirectDrawSurface *src = NULL;
     IDirectDrawSurface *dst = NULL;
+    IDirectDrawSurface *dst2 = NULL;
     IDirect3DTexture *src_tex = NULL;
     IDirect3DTexture *dst_tex = NULL;
+    IDirect3DTexture *dst2_tex = NULL;
     DDSURFACEDESC ddsd;
     HRESULT hr;
     DDCOLORKEY ckey;
@@ -1509,16 +1511,31 @@ static void test_texture_load_ckey(void)
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
-    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
+    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
     ddsd.dwHeight = 128;
     ddsd.dwWidth = 128;
     ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
+    ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
+    ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
+    ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
+    ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000;
+    ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00;
+    ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FF;
+
     hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &src, NULL);
     ok(SUCCEEDED(hr), "Failed to create source texture, hr %#lx.\n", hr);
     ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
     hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &dst, NULL);
     ok(SUCCEEDED(hr), "Failed to create destination texture, hr %#lx.\n", hr);
 
+    ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
+    ddsd.ddpfPixelFormat.dwRBitMask = 0xf800;
+    ddsd.ddpfPixelFormat.dwGBitMask = 0x07e0;
+    ddsd.ddpfPixelFormat.dwBBitMask = 0x001f;
+
+    hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &dst2, NULL);
+    ok(SUCCEEDED(hr), "Failed to create destination texture, hr %#lx.\n", hr);
+
     hr = IDirectDrawSurface_QueryInterface(src, &IID_IDirect3DTexture, (void **)&src_tex);
     ok(SUCCEEDED(hr) || hr == E_NOINTERFACE, "Failed to get Direct3DTexture interface, hr %#lx.\n", hr);
     if (FAILED(hr))
@@ -1529,6 +1546,8 @@ static void test_texture_load_ckey(void)
     }
     hr = IDirectDrawSurface_QueryInterface(dst, &IID_IDirect3DTexture, (void **)&dst_tex);
     ok(SUCCEEDED(hr), "Failed to get Direct3DTexture interface, hr %#lx.\n", hr);
+    hr = IDirectDrawSurface_QueryInterface(dst2, &IID_IDirect3DTexture, (void **)&dst2_tex);
+    ok(SUCCEEDED(hr), "Failed to get Direct3DTexture interface, hr %#lx.\n", hr);
 
     /* No surface has a color key */
     hr = IDirect3DTexture_Load(dst_tex, src_tex);
@@ -1557,6 +1576,11 @@ static void test_texture_load_ckey(void)
     ok(ckey.dwColorSpaceLowValue == 0x0000ff00, "Got unexpected value 0x%08lx.\n", ckey.dwColorSpaceLowValue);
     ok(ckey.dwColorSpaceHighValue == 0x0000ff00, "Got unexpected value 0x%08lx.\n", ckey.dwColorSpaceHighValue);
 
+    /* Source surface has a color key but destination differs in format */
+    ckey.dwColorSpaceLowValue = ckey.dwColorSpaceHighValue = 0x0;
+    hr = IDirect3DTexture_Load(dst2_tex, src_tex);
+    ok(hr == E_FAIL, "Got unexpected hr %#lx, expected E_FAIL.\n", hr);
+
     /* Both surfaces have a color key: Dest ckey is overwritten */
     ckey.dwColorSpaceLowValue = ckey.dwColorSpaceHighValue = 0x000000ff;
     hr = IDirectDrawSurface_SetColorKey(dst, DDCKEY_SRCBLT, &ckey);
@@ -1581,8 +1605,10 @@ static void test_texture_load_ckey(void)
     ok(ckey.dwColorSpaceHighValue == 0x0000ff00, "Got unexpected value 0x%08lx.\n", ckey.dwColorSpaceHighValue);
 
 done:
+    if (dst2_tex) IDirect3DTexture_Release(dst2_tex);
     if (dst_tex) IDirect3DTexture_Release(dst_tex);
     if (src_tex) IDirect3DTexture_Release(src_tex);
+    if (dst2) IDirectDrawSurface_Release(dst2);
     if (dst) IDirectDrawSurface_Release(dst);
     if (src) IDirectDrawSurface_Release(src);
     if (ddraw) IDirectDraw2_Release(ddraw);

From 466893fc4526062c94d519fa0fbba52a5392eca9 Mon Sep 17 00:00:00 2001
From: Andrew D'Addesio <andrew@fatbag.net>
Date: Fri, 8 Feb 2019 18:48:33 -1000
Subject: [PATCH 019/244] ddraw: Return correct devices based off requested
 DirectX version.

---
 dlls/ddraw/ddraw.c | 240 +++++++++++++++++++++++++--------------------
 1 file changed, 131 insertions(+), 109 deletions(-)

diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index d07eef9e788..061daea3c1e 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -44,37 +44,80 @@ static const DDDEVICEIDENTIFIER2 deviceidentifier =
     0
 };
 
+#define D3D_VERSION(x) (1 << (x))
+
 static struct enum_device_entry
 {
-    char interface_name[100];
+    unsigned int version_mask;
+    /* Some games (Motoracer 2 demo) have the bad idea to modify the device
+     * name/description strings. Let's put the strings in sufficiently sized
+     * arrays in static-lifetime writable memory. */
+    char device_desc[100];
     char device_name[100];
     const GUID *device_guid;
     DWORD unsupported_caps;
-} device_list7[] =
+} device_list[] =
 {
-    /* T&L HAL device */
+    /* Ramp Emulation (D3D 1&2 only) */
     {
-        "WINE Direct3D7 Hardware Transform and Lighting acceleration using WineD3D",
-        "Wine D3D7 T&L HAL",
-        &IID_IDirect3DTnLHalDevice,
+        D3D_VERSION(1) | D3D_VERSION(2),
+        "WineD3D Ramp Software Emulation",
+        "Ramp Emulation",
+        &IID_IDirect3DRampDevice,
         0,
     },
 
-    /* HAL device */
+    /* RGB Emulation (D3D 1-7) */
     {
-        "WINE Direct3D7 Hardware acceleration using WineD3D",
+        D3D_VERSION(1) | D3D_VERSION(2) | D3D_VERSION(3) | D3D_VERSION(7),
+        "WineD3D RGB Software Emulation",
+        "RGB Emulation",
+        &IID_IDirect3DRGBDevice,
+        D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION,
+    },
+
+    /* Direct3D HAL (D3D 1-7) */
+    {
+        D3D_VERSION(1) | D3D_VERSION(2) | D3D_VERSION(3) | D3D_VERSION(7),
+        "WineD3D Hardware Acceleration",
         "Direct3D HAL",
         &IID_IDirect3DHALDevice,
         D3DDEVCAPS_HWTRANSFORMANDLIGHT,
     },
 
-    /* RGB device */
+    /* MMX Emulation (D3D2 only) */
     {
-        "WINE Direct3D7 RGB Software Emulation using WineD3D",
-        "Wine D3D7 RGB",
-        &IID_IDirect3DRGBDevice,
-        D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION,
+        D3D_VERSION(2),
+        "WineD3D MMX Software Emulation",
+        "MMX Emulation",
+        &IID_IDirect3DMMXDevice,
+        0,
     },
+
+    /* Direct3D T&L HAL (D3D7 only) */
+    {
+        D3D_VERSION(7),
+        "WineD3D Hardware Transform and Lighting Acceleration",
+        "Direct3D T&L HAL",
+        &IID_IDirect3DTnLHalDevice,
+        0,
+    },
+
+    /* In the future, we may wish to add the "Reference Rasterizer" and
+     * "Null device", which are only available in DX6-8 and must be explicitly
+     * enabled by the registry values:
+     * * EnumReference
+     * * EnumNullDevice,
+     * which are DWORD values which must be created under
+     * HKLM\Software\Microsoft\Direct3D\Drivers and set to any nonzero value.
+     * (Refer to enablerefrast.reg/disablerefrast.reg in the DX6/7 SDKs and
+     * KB249579 for more information.)
+     *
+     * DirectX 9.0 and higher appear to no longer recognize these settings,
+     * so apparently these devices were removed starting with DX9.
+     *
+     * Some games (AvP, Motoracer 2) break if these devices are enumerated.
+     */
 };
 
 static void STDMETHODCALLTYPE ddraw_null_wined3d_object_destroyed(void *parent) {}
@@ -1438,15 +1481,6 @@ HRESULT ddraw_get_d3dcaps(const struct ddraw *ddraw, D3DDEVICEDESC7 *caps)
         D3DPTADDRESSCAPS_WRAP            | D3DPTADDRESSCAPS_MIRROR             | D3DPTADDRESSCAPS_CLAMP              |
         D3DPTADDRESSCAPS_BORDER          | D3DPTADDRESSCAPS_INDEPENDENTUV);
 
-    if (!(caps->dpcLineCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2))
-    {
-        /* DirectX7 always has the np2 flag set, no matter what the card
-         * supports. Some old games (Rollcage) check the caps incorrectly.
-         * If wined3d supports nonpow2 textures it also has np2 conditional
-         * support. */
-        caps->dpcLineCaps.dwTextureCaps |= D3DPTEXTURECAPS_POW2 | D3DPTEXTURECAPS_NONPOW2CONDITIONAL;
-    }
-
     /* Fill the missing members, and do some fixup */
     caps->dpcLineCaps.dwSize = sizeof(caps->dpcLineCaps);
     caps->dpcLineCaps.dwTextureBlendCaps = D3DPTBLENDCAPS_ADD
@@ -3793,8 +3827,7 @@ static HRESULT WINAPI ddraw1_DuplicateSurface(IDirectDraw *iface, IDirectDrawSur
 /*****************************************************************************
  * IDirect3D7::EnumDevices
  *
- * The EnumDevices method for IDirect3D7. It enumerates all supported
- * D3D7 devices. Currently the T&L, HAL and RGB devices are enumerated.
+ * The EnumDevices method for IDirect3D7. It enumerates all D3D7 devices.
  *
  * Params:
  *  callback: Function to call for each enumerated device
@@ -3826,13 +3859,16 @@ static HRESULT WINAPI d3d7_EnumDevices(IDirect3D7 *iface, LPD3DENUMDEVICESCALLBA
     }
     dev_caps = device_desc7.dwDevCaps;
 
-    for (i = 0; i < ARRAY_SIZE(device_list7); i++)
+    for (i = 0; i < ARRAY_SIZE(device_list); i++)
     {
         HRESULT ret;
 
-        device_desc7.deviceGUID = *device_list7[i].device_guid;
-        device_desc7.dwDevCaps = dev_caps & ~device_list7[i].unsupported_caps;
-        ret = callback(device_list7[i].interface_name, device_list7[i].device_name, &device_desc7, context);
+        if (!(device_list[i].version_mask & D3D_VERSION(ddraw->d3dversion)))
+            continue;
+
+        device_desc7.deviceGUID = *device_list[i].device_guid;
+        device_desc7.dwDevCaps = dev_caps & ~device_list[i].unsupported_caps;
+        ret = callback(device_list[i].device_name, device_list[i].device_name, &device_desc7, context);
         if (ret != DDENUMRET_OK)
         {
             TRACE("Application cancelled the enumeration.\n");
@@ -3848,11 +3884,21 @@ static HRESULT WINAPI d3d7_EnumDevices(IDirect3D7 *iface, LPD3DENUMDEVICESCALLBA
     return D3D_OK;
 }
 
+static void clear_device_desc(D3DDEVICEDESC *device_desc)
+{
+    memset(device_desc, 0, sizeof(*device_desc));
+    device_desc->dwSize = sizeof(*device_desc);
+    device_desc->dtcTransformCaps.dwSize = sizeof(device_desc->dtcTransformCaps);
+    device_desc->dlcLightingCaps.dwSize = sizeof(device_desc->dlcLightingCaps);
+    device_desc->dpcLineCaps.dwSize = sizeof(device_desc->dpcLineCaps);
+    device_desc->dpcTriCaps.dwSize = sizeof(device_desc->dpcTriCaps);
+}
+
 /*****************************************************************************
  * IDirect3D3::EnumDevices
  *
- * Enumerates all supported Direct3DDevice interfaces. This is the
- * implementation for Direct3D 1 to Direc3D 3, Version 7 has its own.
+ * Enumerates all Direct3DDevice interfaces. This is the implementation for
+ * Direct3D 1 to Direct3D 3; Version 7 has its own.
  *
  * Versions 1, 2 and 3
  *
@@ -3867,18 +3913,18 @@ static HRESULT WINAPI d3d7_EnumDevices(IDirect3D7 *iface, LPD3DENUMDEVICESCALLBA
  *****************************************************************************/
 static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBACK callback, void *context)
 {
-    static CHAR wined3d_description[] = "Wine D3DDevice using WineD3D and OpenGL";
-
+/* Size of D3DDEVICEDESC in Direct3D 1-3 */
+enum {
+    D3D1_DESC_SIZE = FIELD_OFFSET(D3DDEVICEDESC, dwMinTextureWidth), /* 172 */
+    D3D2_DESC_SIZE = FIELD_OFFSET(D3DDEVICEDESC, dwMaxTextureRepeat), /* 204 */
+    D3D3_DESC_SIZE = sizeof(D3DDEVICEDESC) /* 252 */
+};
     struct ddraw *ddraw = impl_from_IDirect3D3(iface);
-    D3DDEVICEDESC device_desc1, hal_desc, hel_desc;
+    DWORD desc_size;
+    D3DDEVICEDESC device_desc1, empty_desc1, hal_desc, hel_desc;
     D3DDEVICEDESC7 device_desc7;
     HRESULT hr;
-
-    /* Some games (Motoracer 2 demo) have the bad idea to modify the device
-     * name string. Let's put the string in a sufficiently sized array in
-     * writable memory. */
-    char device_name[50];
-    strcpy(device_name,"Direct3D HEL");
+    size_t i;
 
     TRACE("iface %p, callback %p, context %p.\n", iface, callback, context);
 
@@ -3887,58 +3933,59 @@ static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBA
 
     wined3d_mutex_lock();
 
+    switch (ddraw->d3dversion)
+    {
+        case 1:  desc_size = D3D1_DESC_SIZE; break;
+        case 2:  desc_size = D3D2_DESC_SIZE; break;
+        default: desc_size = D3D3_DESC_SIZE; break;
+    }
+
     if (FAILED(hr = ddraw_get_d3dcaps(ddraw, &device_desc7)))
     {
         wined3d_mutex_unlock();
         return hr;
     }
     ddraw_d3dcaps1_from_7(&device_desc1, &device_desc7);
+    device_desc1.dwSize = desc_size;
 
-    /* Do I have to enumerate the reference id? Note from old d3d7:
-     * "It seems that enumerating the reference IID on Direct3D 1 games
-     * (AvP / Motoracer2) breaks them". So do not enumerate this iid in V1
-     *
-     * There's a registry key HKLM\Software\Microsoft\Direct3D\Drivers,
-     * EnumReference which enables / disables enumerating the reference
-     * rasterizer. It's a DWORD, 0 means disabled, 2 means enabled. The
-     * enablerefrast.reg and disablerefrast.reg files in the DirectX 7.0 sdk
-     * demo directory suggest this.
-     *
-     * Some games(GTA 2) seem to use the second enumerated device, so I have
-     * to enumerate at least 2 devices. So enumerate the reference device to
-     * have 2 devices.
-     *
-     * Other games (Rollcage) tell emulation and hal device apart by certain
-     * flags. Rollcage expects D3DPTEXTURECAPS_POW2 to be set (yeah, it is a
-     * limitation flag), and it refuses all devices that have the perspective
-     * flag set. This way it refuses the emulation device, and HAL devices
-     * never have POW2 unset in d3d7 on windows. */
-    if (ddraw->d3dversion != 1)
-    {
-        /* Tomb Raider 3 overwrites the reference device description buffer
-         * with its own custom string. Reserve some extra space in the array
-         * to avoid a buffer overrun. */
-        static CHAR reference_description[64] = "RGB Direct3D emulation";
-
-        TRACE("Enumerating WineD3D D3DDevice interface.\n");
-        hal_desc = device_desc1;
-        hel_desc = device_desc1;
-        /* The rgb device has the pow2 flag set in the hel caps, but not in the hal caps. */
-        hal_desc.dpcLineCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-                | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-        hal_desc.dpcTriCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-                | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-        /* RGB, RAMP and MMX devices have a HAL dcmColorModel of 0 */
-        hal_desc.dcmColorModel = 0;
-        /* RGB, RAMP and MMX devices cannot report HAL hardware flags */
-        hal_desc.dwFlags = 0;
-        /* RGB, REF, RAMP and MMX devices don't report hardware transform and lighting capability */
-        hal_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
-        hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
-
-        hr = callback((GUID *)&IID_IDirect3DRGBDevice, reference_description,
-                device_name, &hal_desc, &hel_desc, context);
-        if (hr != D3DENUMRET_OK)
+    clear_device_desc(&empty_desc1);
+    empty_desc1.dwSize = desc_size;
+
+    for (i = 0; i < ARRAY_SIZE(device_list); i++)
+    {
+        if (!(device_list[i].version_mask & D3D_VERSION(ddraw->d3dversion)))
+            continue;
+
+        if (IsEqualGUID(&IID_IDirect3DHALDevice, device_list[i].device_guid))
+        {
+            hal_desc = device_desc1;
+
+            /* The HAL device's hel_desc is almost empty -- but not completely */
+            hel_desc = empty_desc1;
+            hel_desc.dwFlags = D3DDD_COLORMODEL | D3DDD_DEVCAPS | D3DDD_TRANSFORMCAPS
+                | D3DDD_LIGHTINGCAPS | D3DDD_BCLIPPING;
+            hel_desc.dcmColorModel = 0;
+            hel_desc.dwDevCaps = D3DDEVCAPS_FLOATTLVERTEX;
+            hel_desc.dtcTransformCaps.dwCaps = hal_desc.dtcTransformCaps.dwCaps;
+            hel_desc.dlcLightingCaps = hal_desc.dlcLightingCaps;
+            hel_desc.bClipping = hal_desc.bClipping;
+            hel_desc.dwMaxVertexCount = hal_desc.dwMaxVertexCount;
+        }
+        else
+        {
+            hal_desc = empty_desc1;
+
+            hel_desc = device_desc1;
+            /* Ramp device supports grayscale only */
+            if (IsEqualGUID(&IID_IDirect3DRampDevice, device_list[i].device_guid))
+                hel_desc.dcmColorModel = D3DCOLOR_MONO;
+            /* RGB, REF, RAMP and MMX devices don't report hardware transform and lighting capability */
+            hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
+        }
+
+        hr = callback((GUID *)device_list[i].device_guid, device_list[i].device_desc,
+                device_list[i].device_name, &hal_desc, &hel_desc, context);
+        if (hr != DDENUMRET_OK)
         {
             TRACE("Application cancelled the enumeration.\n");
             wined3d_mutex_unlock();
@@ -3946,31 +3993,6 @@ static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBA
         }
     }
 
-    strcpy(device_name,"Direct3D HAL");
-
-    TRACE("Enumerating HAL Direct3D device.\n");
-    hal_desc = device_desc1;
-    hel_desc = device_desc1;
-
-    /* The hal device does not have the pow2 flag set in hel, but in hal. */
-    hel_desc.dpcLineCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-            | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-    hel_desc.dpcTriCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-            | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-    /* HAL devices have a HEL dcmColorModel of 0 */
-    hel_desc.dcmColorModel = 0;
-    /* HAL devices report hardware transform and lighting capability, but not in hel */
-    hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX);
-
-    hr = callback((GUID *)&IID_IDirect3DHALDevice, wined3d_description,
-            device_name, &hal_desc, &hel_desc, context);
-    if (hr != D3DENUMRET_OK)
-    {
-        TRACE("Application cancelled the enumeration.\n");
-        wined3d_mutex_unlock();
-        return D3D_OK;
-    }
-
     TRACE("End of enumeration.\n");
 
     wined3d_mutex_unlock();

From b50a3a0ee54f21b7922c86297eec061f0596d1cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 23 Aug 2024 08:49:13 +0200
Subject: [PATCH 020/244] dinput: Factor keyboard initialization and
 enumeration loops.

---
 dlls/dinput/keyboard.c | 129 +++++++++++++++++++++++------------------
 1 file changed, 72 insertions(+), 57 deletions(-)

diff --git a/dlls/dinput/keyboard.c b/dlls/dinput/keyboard.c
index 8ec9dd47150..d1fa242574e 100644
--- a/dlls/dinput/keyboard.c
+++ b/dlls/dinput/keyboard.c
@@ -185,12 +185,79 @@ HRESULT keyboard_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instan
     return DI_OK;
 }
 
+static BOOL enum_object( struct keyboard *impl, const DIPROPHEADER *filter, DWORD flags, enum_object_callback callback,
+                         UINT index, DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    if (flags != DIDFT_ALL && !(flags & DIDFT_GETTYPE( instance->dwType ))) return DIENUM_CONTINUE;
+
+    switch (filter->dwHow)
+    {
+    case DIPH_DEVICE:
+        return callback( &impl->base, index, NULL, instance, data );
+    case DIPH_BYOFFSET:
+        if (filter->dwObj != instance->dwOfs) return DIENUM_CONTINUE;
+        return callback( &impl->base, index, NULL, instance, data );
+    case DIPH_BYID:
+        if ((filter->dwObj & 0x00ffffff) != (instance->dwType & 0x00ffffff)) return DIENUM_CONTINUE;
+        return callback( &impl->base, index, NULL, instance, data );
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT enum_objects( struct keyboard *impl, const DIPROPHEADER *filter,
+                             DWORD flags, enum_object_callback callback, void *data )
+{
+    BYTE subtype = GET_DIDEVICE_SUBTYPE( impl->base.instance.dwDevType );
+    DIDEVICEOBJECTINSTANCEW instance =
+    {
+        .dwSize = sizeof(DIDEVICEOBJECTINSTANCEW),
+        .guidType = GUID_Key,
+        .dwOfs = DIK_ESCAPE,
+        .dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( DIK_ESCAPE ),
+    };
+    DWORD index, i, dik;
+    BOOL ret;
+
+    for (i = 0, index = 0; i < 512; ++i)
+    {
+        if (!GetKeyNameTextW( i << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
+        if (!(dik = map_dik_code( i, 0, subtype, impl->base.dinput->dwVersion ))) continue;
+        instance.dwOfs = dik;
+        instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
+        ret = enum_object( impl, filter, flags, callback, index++, &instance, data );
+        if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static BOOL init_object_properties( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                    const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    struct object_properties *properties;
+    UINT dik = instance->dwOfs;
+
+    if (index == -1) return DIENUM_STOP;
+    properties = device->object_properties + index;
+
+    if (dik == DIK_NUMLOCK) properties->scan_code = 0x451de1;
+    else if (dik == DIK_PAUSE) properties->scan_code = 0x45;
+    else if (dik < 0x80) properties->scan_code = dik;
+    else properties->scan_code = (dik - 0x80) << 8 | 0x00e0;
+
+    return DIENUM_CONTINUE;
+}
+
 HRESULT keyboard_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out )
 {
-    DIDEVICEOBJECTINSTANCEW instance;
+    static const DIPROPHEADER filter =
+    {
+        .dwSize = sizeof(filter),
+        .dwHeaderSize = sizeof(filter),
+        .dwHow = DIPH_DEVICE,
+    };
     struct keyboard *impl;
-    DWORD i, index, dik;
-    BYTE subtype;
     HRESULT hr;
 
     TRACE( "dinput %p, guid %s, out %p.\n", dinput, debugstr_guid( guid ), out );
@@ -207,20 +274,9 @@ HRESULT keyboard_create_device( struct dinput *dinput, const GUID *guid, IDirect
     impl->base.caps.dwFirmwareRevision = 100;
     impl->base.caps.dwHardwareRevision = 100;
     if (dinput->dwVersion >= 0x0800) impl->base.use_raw_input = TRUE;
-    subtype = GET_DIDEVICE_SUBTYPE( impl->base.instance.dwDevType );
 
     if (FAILED(hr = dinput_device_init_device_format( &impl->base.IDirectInputDevice8W_iface ))) goto failed;
-
-    for (i = 0, index = 0; i < 512; ++i)
-    {
-        if (!GetKeyNameTextW( i << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
-        if (!(dik = map_dik_code( i, 0, subtype, impl->base.dinput->dwVersion ))) continue;
-
-        if (dik == DIK_NUMLOCK) impl->base.object_properties[index++].scan_code = 0x451de1;
-        else if (dik == DIK_PAUSE) impl->base.object_properties[index++].scan_code = 0x45;
-        else if (dik < 0x80) impl->base.object_properties[index++].scan_code = dik;
-        else impl->base.object_properties[index++].scan_code = (dik - 0x80) << 8 | 0x00e0;
-    }
+    enum_objects( impl, &filter, DIDFT_BUTTON, init_object_properties, NULL );
 
     *out = &impl->base.IDirectInputDevice8W_iface;
     return DI_OK;
@@ -248,52 +304,11 @@ static HRESULT keyboard_unacquire( IDirectInputDevice8W *iface )
     return DI_OK;
 }
 
-static BOOL try_enum_object( struct dinput_device *impl, const DIPROPHEADER *filter, DWORD flags, enum_object_callback callback,
-                             UINT index, DIDEVICEOBJECTINSTANCEW *instance, void *data )
-{
-    if (flags != DIDFT_ALL && !(flags & DIDFT_GETTYPE( instance->dwType ))) return DIENUM_CONTINUE;
-
-    switch (filter->dwHow)
-    {
-    case DIPH_DEVICE:
-        return callback( impl, index, NULL, instance, data );
-    case DIPH_BYOFFSET:
-        if (filter->dwObj != instance->dwOfs) return DIENUM_CONTINUE;
-        return callback( impl, index, NULL, instance, data );
-    case DIPH_BYID:
-        if ((filter->dwObj & 0x00ffffff) != (instance->dwType & 0x00ffffff)) return DIENUM_CONTINUE;
-        return callback( impl, index, NULL, instance, data );
-    }
-
-    return DIENUM_CONTINUE;
-}
-
 static HRESULT keyboard_enum_objects( IDirectInputDevice8W *iface, const DIPROPHEADER *filter,
                                       DWORD flags, enum_object_callback callback, void *context )
 {
     struct keyboard *impl = impl_from_IDirectInputDevice8W( iface );
-    BYTE subtype = GET_DIDEVICE_SUBTYPE( impl->base.instance.dwDevType );
-    DIDEVICEOBJECTINSTANCEW instance =
-    {
-        .dwSize = sizeof(DIDEVICEOBJECTINSTANCEW),
-        .guidType = GUID_Key,
-        .dwOfs = DIK_ESCAPE,
-        .dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( DIK_ESCAPE ),
-    };
-    DWORD index, i, dik;
-    BOOL ret;
-
-    for (i = 0, index = 0; i < 512; ++i)
-    {
-        if (!GetKeyNameTextW( i << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
-        if (!(dik = map_dik_code( i, 0, subtype, impl->base.dinput->dwVersion ))) continue;
-        instance.dwOfs = dik;
-        instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
-        ret = try_enum_object( &impl->base, filter, flags, callback, index++, &instance, context );
-        if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
-    }
-
-    return DIENUM_CONTINUE;
+    return enum_objects( impl, filter, flags, callback, context );
 }
 
 static HRESULT keyboard_get_property( IDirectInputDevice8W *iface, DWORD property,

From 331ea2fe17d67b323b68db0404a6eba11f43894e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 23 Aug 2024 08:51:44 +0200
Subject: [PATCH 021/244] dinput: Avoid duplicated objects in keyboard devices.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55205
---
 dlls/dinput/keyboard.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/dinput/keyboard.c b/dlls/dinput/keyboard.c
index d1fa242574e..d9c73cd7367 100644
--- a/dlls/dinput/keyboard.c
+++ b/dlls/dinput/keyboard.c
@@ -216,13 +216,15 @@ static HRESULT enum_objects( struct keyboard *impl, const DIPROPHEADER *filter,
         .dwOfs = DIK_ESCAPE,
         .dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( DIK_ESCAPE ),
     };
+    BOOL ret, mapped[0x100] = {0};
     DWORD index, i, dik;
-    BOOL ret;
 
     for (i = 0, index = 0; i < 512; ++i)
     {
         if (!GetKeyNameTextW( i << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
         if (!(dik = map_dik_code( i, 0, subtype, impl->base.dinput->dwVersion ))) continue;
+        if (mapped[dik]) continue;
+        mapped[dik] = TRUE;
         instance.dwOfs = dik;
         instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
         ret = enum_object( impl, filter, flags, callback, index++, &instance, data );

From 78fd71e447d56ca21fc071ecc4559997f6961ac7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 23 Aug 2024 08:52:34 +0200
Subject: [PATCH 022/244] dinput: Enumerate lower keyboard scancodes values
 first.

Windows usually doesn't have scancodes higher than 0x7f, or extended
scancodes higher than 0x17f, but X11 does for several XF86 keys.

We want to enumerate the basic keys first including in the extended
scancode range, so they appear before the XF86 keys in the dinput
device object list.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55205
---
 dlls/dinput/keyboard.c | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/dlls/dinput/keyboard.c b/dlls/dinput/keyboard.c
index d9c73cd7367..407634967de 100644
--- a/dlls/dinput/keyboard.c
+++ b/dlls/dinput/keyboard.c
@@ -208,6 +208,7 @@ static BOOL enum_object( struct keyboard *impl, const DIPROPHEADER *filter, DWOR
 static HRESULT enum_objects( struct keyboard *impl, const DIPROPHEADER *filter,
                              DWORD flags, enum_object_callback callback, void *data )
 {
+    static const UINT vsc_base[] = {0, 0x100, 0x80, 0x180};
     BYTE subtype = GET_DIDEVICE_SUBTYPE( impl->base.instance.dwDevType );
     DIDEVICEOBJECTINSTANCEW instance =
     {
@@ -217,18 +218,21 @@ static HRESULT enum_objects( struct keyboard *impl, const DIPROPHEADER *filter,
         .dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( DIK_ESCAPE ),
     };
     BOOL ret, mapped[0x100] = {0};
-    DWORD index, i, dik;
+    DWORD index, i, dik, vsc;
 
-    for (i = 0, index = 0; i < 512; ++i)
+    for (i = 0, index = 0; i < ARRAY_SIZE(vsc_base); ++i)
     {
-        if (!GetKeyNameTextW( i << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
-        if (!(dik = map_dik_code( i, 0, subtype, impl->base.dinput->dwVersion ))) continue;
-        if (mapped[dik]) continue;
-        mapped[dik] = TRUE;
-        instance.dwOfs = dik;
-        instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
-        ret = enum_object( impl, filter, flags, callback, index++, &instance, data );
-        if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
+        for (vsc = vsc_base[i]; vsc < vsc_base[i] + 0x80; vsc++)
+        {
+            if (!GetKeyNameTextW( vsc << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
+            if (!(dik = map_dik_code( vsc, 0, subtype, impl->base.dinput->dwVersion ))) continue;
+            if (mapped[dik]) continue;
+            mapped[dik] = TRUE;
+            instance.dwOfs = dik;
+            instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
+            ret = enum_object( impl, filter, flags, callback, index++, &instance, data );
+            if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
+        }
     }
 
     return DIENUM_CONTINUE;

From eeb7e5fb8ca107d80fb78fbe618205f1aa802cdf Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 1 Nov 2024 17:59:51 +1100
Subject: [PATCH 023/244] dmime: Semi implement
 IDirectMusicSegment::GetAudioPathConfig.

---
 dlls/dmime/audiopath.c | 97 +++++++++++++++++++++++-------------------
 dlls/dmime/segment.c   |  6 +++
 2 files changed, 59 insertions(+), 44 deletions(-)

diff --git a/dlls/dmime/audiopath.c b/dlls/dmime/audiopath.c
index 3389f965b8f..501eecf234c 100644
--- a/dlls/dmime/audiopath.c
+++ b/dlls/dmime/audiopath.c
@@ -649,18 +649,21 @@ HRESULT path_config_get_audio_path_params(IUnknown *iface, WAVEFORMATEX *format,
 {
     struct audio_path_config *This = impl_from_IUnknown(iface);
     struct list *first_port_config, *first_pchannel_to_buffer;
-    struct audio_path_port_config *port_config;
-    struct audio_path_pchannel_to_buffer *pchannel_to_buffer;
+    struct audio_path_port_config *port_config = NULL;
+    struct audio_path_pchannel_to_buffer *pchannel_to_buffer = NULL;
     GUID *guids;
 
     first_port_config = list_head(&This->port_config_entries);
-    if (list_next(&This->port_config_entries, first_port_config))
-        FIXME("Only one port config supported. %p -> %p\n", first_port_config, list_next(&This->port_config_entries, first_port_config));
-    port_config = LIST_ENTRY(first_port_config, struct audio_path_port_config, entry);
-    first_pchannel_to_buffer = list_head(&port_config->pchannel_to_buffer_entries);
-    if (list_next(&port_config->pchannel_to_buffer_entries, first_pchannel_to_buffer))
-        FIXME("Only one pchannel to buffer entry supported.\n");
-    pchannel_to_buffer = LIST_ENTRY(first_pchannel_to_buffer, struct audio_path_pchannel_to_buffer, entry);
+    if (first_port_config)
+    {
+        if (list_next(&This->port_config_entries, first_port_config))
+            FIXME("Only one port config supported. %p -> %p\n", first_port_config, list_next(&This->port_config_entries, first_port_config));
+        port_config = LIST_ENTRY(first_port_config, struct audio_path_port_config, entry);
+        first_pchannel_to_buffer = list_head(&port_config->pchannel_to_buffer_entries);
+        if (list_next(&port_config->pchannel_to_buffer_entries, first_pchannel_to_buffer))
+            FIXME("Only one pchannel to buffer entry supported.\n");
+        pchannel_to_buffer = LIST_ENTRY(first_pchannel_to_buffer, struct audio_path_pchannel_to_buffer, entry);
+    }
 
     /* Secondary buffer description */
     memset(format, 0, sizeof(*format));
@@ -680,50 +683,56 @@ HRESULT path_config_get_audio_path_params(IUnknown *iface, WAVEFORMATEX *format,
     desc->lpwfxFormat = format;
     desc->guid3DAlgorithm = GUID_NULL;
 
-    guids = pchannel_to_buffer->guids;
-    if (pchannel_to_buffer->header.dwBufferCount == 2)
+    if (pchannel_to_buffer)
     {
-        if ((!IsEqualGUID(&guids[0], &GUID_Buffer_Reverb) && !IsEqualGUID(&guids[0], &GUID_Buffer_Stereo)) ||
-                (!IsEqualGUID(&guids[1], &GUID_Buffer_Reverb) && !IsEqualGUID(&guids[1], &GUID_Buffer_Stereo)) ||
-                IsEqualGUID(&guids[0], &guids[1]))
-            FIXME("Only a stereo plus reverb buffer is supported\n");
-        else
+        guids = pchannel_to_buffer->guids;
+        if (pchannel_to_buffer->header.dwBufferCount == 2)
         {
-            desc->dwFlags |= DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
-            format->nChannels = 2;
-            format->nBlockAlign *= 2;
-            format->nAvgBytesPerSec *= 2;
+            if ((!IsEqualGUID(&guids[0], &GUID_Buffer_Reverb) && !IsEqualGUID(&guids[0], &GUID_Buffer_Stereo)) ||
+                    (!IsEqualGUID(&guids[1], &GUID_Buffer_Reverb) && !IsEqualGUID(&guids[1], &GUID_Buffer_Stereo)) ||
+                    IsEqualGUID(&guids[0], &guids[1]))
+                FIXME("Only a stereo plus reverb buffer is supported\n");
+            else
+            {
+                desc->dwFlags |= DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
+                format->nChannels = 2;
+                format->nBlockAlign *= 2;
+                format->nAvgBytesPerSec *= 2;
+            }
         }
-    }
-    else if (pchannel_to_buffer->header.dwBufferCount == 1)
-    {
-        if (IsEqualGUID(guids, &GUID_Buffer_Stereo))
+        else if (pchannel_to_buffer->header.dwBufferCount == 1)
         {
-            desc->dwFlags |= DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
-            format->nChannels = 2;
-            format->nBlockAlign *= 2;
-            format->nAvgBytesPerSec *= 2;
+            if (IsEqualGUID(guids, &GUID_Buffer_Stereo))
+            {
+                desc->dwFlags |= DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
+                format->nChannels = 2;
+                format->nBlockAlign *= 2;
+                format->nAvgBytesPerSec *= 2;
+            }
+            else if (IsEqualGUID(guids, &GUID_Buffer_3D_Dry))
+                desc->dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY | DSBCAPS_MUTE3DATMAXDISTANCE;
+            else if (IsEqualGUID(guids, &GUID_Buffer_Mono))
+                desc->dwFlags |= DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
+            else
+                FIXME("Unsupported buffer guid %s\n", debugstr_dmguid(guids));
         }
-        else if (IsEqualGUID(guids, &GUID_Buffer_3D_Dry))
-            desc->dwFlags |= DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY | DSBCAPS_MUTE3DATMAXDISTANCE;
-        else if (IsEqualGUID(guids, &GUID_Buffer_Mono))
-            desc->dwFlags |= DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
         else
-            FIXME("Unsupported buffer guid %s\n", debugstr_dmguid(guids));
+            FIXME("Multiple buffers not supported\n");
     }
-    else
-        FIXME("Multiple buffers not supported\n");
 
-    *params = port_config->params;
-    if (!(params->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS))
-    {
-        params->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
-        params->dwChannelGroups = (port_config->header.dwPChannelCount + 15) / 16;
-    }
-    if (!(params->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS))
+    if (port_config)
     {
-        params->dwValidParams |= DMUS_PORTPARAMS_AUDIOCHANNELS;
-        params->dwAudioChannels = format->nChannels;
+        *params = port_config->params;
+        if (!(params->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS))
+        {
+            params->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
+            params->dwChannelGroups = (port_config->header.dwPChannelCount + 15) / 16;
+        }
+        if (!(params->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS))
+        {
+            params->dwValidParams |= DMUS_PORTPARAMS_AUDIOCHANNELS;
+            params->dwAudioChannels = format->nChannels;
+        }
     }
     return S_OK;
 }
diff --git a/dlls/dmime/segment.c b/dlls/dmime/segment.c
index b96f0e2e401..36860b7c762 100644
--- a/dlls/dmime/segment.c
+++ b/dlls/dmime/segment.c
@@ -516,6 +516,12 @@ static HRESULT WINAPI segment_GetAudioPathConfig(IDirectMusicSegment8 *iface, IU
 {
     struct segment *This = impl_from_IDirectMusicSegment8(iface);
     FIXME("(%p, %p): stub\n", This, ppAudioPathConfig);
+
+    if (!ppAudioPathConfig)
+        return E_POINTER;
+
+    create_dmaudiopath_config(&IID_IUnknown, (void**)ppAudioPathConfig);
+
     return S_OK;
 }
 

From 1f10429965174dea1465e9889b71d4390a3c41ec Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 1 Nov 2024 19:39:11 +1100
Subject: [PATCH 024/244] dmscript: IDirectMusicScript::EnumRoutine return
 S_FALSE by default

https://bugs.winehq.org/show_bug.cgi?id=55982
---
 dlls/dmscript/script.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/dmscript/script.c b/dlls/dmscript/script.c
index 01d4bcd0290..278405a322a 100644
--- a/dlls/dmscript/script.c
+++ b/dlls/dmscript/script.c
@@ -171,7 +171,7 @@ static HRESULT WINAPI IDirectMusicScriptImpl_EnumRoutine(IDirectMusicScript *ifa
 {
   IDirectMusicScriptImpl *This = impl_from_IDirectMusicScript(iface);
   FIXME("(%p, %ld, %p): stub\n", This, dwIndex, pwszName);
-  return S_OK;
+  return S_FALSE;
 }
 
 static HRESULT WINAPI IDirectMusicScriptImpl_EnumVariable(IDirectMusicScript *iface, DWORD dwIndex,

From a619a8aec870ba21e11a931165870e0a945f8bff Mon Sep 17 00:00:00 2001
From: "Alexander E. Patrakov" <patrakov at gmail.com>
Date: Thu, 7 Aug 2014 17:15:00 -0600
Subject: [PATCH 025/244] dsound: Add a linear resampler for use with a large
 number of mixing buffers. (rev 2)

---
 dlls/dsound/dsound_main.c    |  5 ++++
 dlls/dsound/dsound_private.h |  2 ++
 dlls/dsound/mixer.c          | 48 +++++++++++++++++++++++++++++++++---
 3 files changed, 52 insertions(+), 3 deletions(-)

diff --git a/dlls/dsound/dsound_main.c b/dlls/dsound/dsound_main.c
index bb373a4304d..96e5fe2487e 100644
--- a/dlls/dsound/dsound_main.c
+++ b/dlls/dsound/dsound_main.c
@@ -83,6 +83,7 @@ const WCHAR wine_vxd_drv[] = L"winemm.vxd";
 
 /* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
 int ds_hel_buflen = 32768 * 2;
+int ds_hq_buffers_max = 4;
 
 /*
  * Get a config key from either the app-specific or the default config
@@ -134,10 +135,14 @@ void setup_dsound_options(void)
     if (!get_config_key( hkey, appkey, "HelBuflen", buffer, MAX_PATH ))
         ds_hel_buflen = atoi(buffer);
 
+    if (!get_config_key( hkey, appkey, "HQBuffersMax", buffer, MAX_PATH ))
+        ds_hq_buffers_max = atoi(buffer);
+
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
     TRACE("ds_hel_buflen = %d\n", ds_hel_buflen);
+    TRACE("ds_hq_buffers_max = %d\n", ds_hq_buffers_max);
 }
 
 static const char * get_device_id(LPCGUID pGuid)
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 6b9fbfd6048..8069a93c932 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -34,7 +34,9 @@
 
 #define DS_MAX_CHANNELS 6
 
+
 extern int ds_hel_buflen;
+extern int ds_hq_buffers_max;
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
diff --git a/dlls/dsound/mixer.c b/dlls/dsound/mixer.c
index bf88e94eafd..bb53a58bd11 100644
--- a/dlls/dsound/mixer.c
+++ b/dlls/dsound/mixer.c
@@ -313,7 +313,47 @@ static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, UINT count)
     return count;
 }
 
-static UINT cp_fields_resample(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+{
+    UINT i, channel;
+    UINT istride = dsb->pwfx->nBlockAlign;
+    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
+    UINT channels = dsb->mix_channels;
+
+    LONG64 freqAcc_start = *freqAccNum;
+    LONG64 freqAcc_end = freqAcc_start + count * dsb->freqAdjustNum;
+    UINT max_ipos = freqAcc_end / dsb->freqAdjustDen;
+
+    for (i = 0; i < count; ++i) {
+        float cur_freqAcc = (freqAcc_start + i * dsb->freqAdjustNum) / (float)dsb->freqAdjustDen;
+        float cur_freqAcc2;
+        UINT ipos = cur_freqAcc;
+        UINT idx = dsb->sec_mixpos + ipos * istride;
+        cur_freqAcc -= (int)cur_freqAcc;
+        cur_freqAcc2 = 1.0f - cur_freqAcc;
+        for (channel = 0; channel < channels; channel++) {
+            /**
+             * Generally we cannot cache the result of get_current_sample().
+             * Consider the case of resampling from 192000 Hz to 44100 Hz -
+             * none of the values will get reused for the next value of i.
+             * OTOH, for resampling from 44100 Hz to 192000 Hz both values
+             * will likely be reused.
+             *
+             * So far, this possibility of saving calls to
+             * get_current_sample() is ignored.
+             */
+            float s1 = get_current_sample(dsb, dsb->buffer->memory, dsb->buflen, idx, channel);
+            float s2 = get_current_sample(dsb, dsb->buffer->memory, dsb->buflen, idx + istride, channel);
+            float result = s1 * cur_freqAcc2 + s2 * cur_freqAcc;
+            dsb->put(dsb, i * ostride, channel, result);
+        }
+    }
+
+    *freqAccNum = freqAcc_end % dsb->freqAdjustDen;
+    return max_ipos;
+}
+
+static UINT cp_fields_resample_hq(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
 {
     UINT i, channel;
     UINT istride = dsb->pwfx->nBlockAlign;
@@ -404,9 +444,11 @@ static void cp_fields(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNu
     DWORD ipos, adv;
 
     if (dsb->freqAdjustNum == dsb->freqAdjustDen)
-        adv = cp_fields_noresample(dsb, count); /* *freqAccNum is unmodified */
+        adv = cp_fields_noresample(dsb, count); /* *freqAcc is unmodified */
+    else if (dsb->device->nrofbuffers > ds_hq_buffers_max)
+        adv = cp_fields_resample_lq(dsb, count, freqAccNum);
     else
-        adv = cp_fields_resample(dsb, count, freqAccNum);
+        adv = cp_fields_resample_hq(dsb, count, freqAccNum);
 
     ipos = dsb->sec_mixpos + adv * dsb->pwfx->nBlockAlign;
     if (ipos >= dsb->buflen) {

From 56545e51ba613880899dd58cf99c06de6f12073b Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 28 Mar 2015 08:18:10 +0100
Subject: [PATCH 026/244] dsound: Apply filters before sound is multiplied to
 speakers.

Based on a patch by Mark Harmstone.
---
 dlls/dsound/dsound.c         |   1 +
 dlls/dsound/dsound_private.h |   4 +-
 dlls/dsound/mixer.c          | 112 ++++++++++++++++++++++++-----------
 3 files changed, 81 insertions(+), 36 deletions(-)

diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index e548cbbd5b1..f724f1a99ed 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -235,6 +235,7 @@ static ULONG DirectSoundDevice_Release(DirectSoundDevice * device)
         if(device->mmdevice)
             IMMDevice_Release(device->mmdevice);
         CloseHandle(device->sleepev);
+        free(device->dsp_buffer);
         free(device->tmp_buffer);
         free(device->cp_buffer);
         free(device->buffer);
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 8069a93c932..7fc63d03717 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -90,8 +90,8 @@ struct DirectSoundDevice
     int                         speaker_num[DS_MAX_CHANNELS];
     int                         num_speakers;
     int                         lfe_channel;
-    float *tmp_buffer, *cp_buffer;
-    DWORD                       tmp_buffer_len, cp_buffer_len;
+    float *tmp_buffer, *cp_buffer, *dsp_buffer;
+    DWORD                       tmp_buffer_len, cp_buffer_len, dsp_buffer_len;
     CO_MTA_USAGE_COOKIE         mta_cookie;
 
     DSVOLUMEPAN                 volpan;
diff --git a/dlls/dsound/mixer.c b/dlls/dsound/mixer.c
index bb53a58bd11..068c55e07d1 100644
--- a/dlls/dsound/mixer.c
+++ b/dlls/dsound/mixer.c
@@ -285,10 +285,9 @@ static inline float get_current_sample(const IDirectSoundBufferImpl *dsb,
     return dsb->get(dsb, buffer + (mixpos % buflen), channel);
 }
 
-static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, UINT count)
+static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, bitsputfunc put, UINT ostride, UINT count)
 {
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
     UINT committed_samples = 0;
     DWORD channel, i;
 
@@ -307,17 +306,16 @@ static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, UINT count)
 
     for (; i < count; i++)
         for (channel = 0; channel < dsb->mix_channels; channel++)
-            dsb->put(dsb, i * ostride, channel, get_current_sample(dsb, dsb->buffer->memory,
+            put(dsb, i * ostride, channel, get_current_sample(dsb, dsb->buffer->memory,
                 dsb->buflen, dsb->sec_mixpos + i * istride, channel));
-
     return count;
 }
 
-static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                                  UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     UINT i, channel;
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
     UINT channels = dsb->mix_channels;
 
     LONG64 freqAcc_start = *freqAccNum;
@@ -345,7 +343,7 @@ static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, UINT count, LONG6
             float s1 = get_current_sample(dsb, dsb->buffer->memory, dsb->buflen, idx, channel);
             float s2 = get_current_sample(dsb, dsb->buffer->memory, dsb->buflen, idx + istride, channel);
             float result = s1 * cur_freqAcc2 + s2 * cur_freqAcc;
-            dsb->put(dsb, i * ostride, channel, result);
+            put(dsb, i * ostride, channel, result);
         }
     }
 
@@ -353,11 +351,11 @@ static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, UINT count, LONG6
     return max_ipos;
 }
 
-static UINT cp_fields_resample_hq(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static UINT cp_fields_resample_hq(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                                  UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     UINT i, channel;
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
     UINT committed_samples = 0;
 
     LONG64 freqAcc_start = *freqAccNum;
@@ -432,23 +430,24 @@ static UINT cp_fields_resample_hq(IDirectSoundBufferImpl *dsb, UINT count, LONG6
             float* cache = &intermediate[channel * required_input + ipos];
             for (j = 0; j < fir_used; j++)
                 sum += fir_copy[j] * cache[j];
-            dsb->put(dsb, i * ostride, channel, sum * dsb->firgain);
+            put(dsb, i * ostride, channel, sum * dsb->firgain);
         }
     }
 
     return max_ipos;
 }
 
-static void cp_fields(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static void cp_fields(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                      UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     DWORD ipos, adv;
 
     if (dsb->freqAdjustNum == dsb->freqAdjustDen)
-        adv = cp_fields_noresample(dsb, count); /* *freqAcc is unmodified */
+        adv = cp_fields_noresample(dsb, put, ostride, count); /* *freqAcc is unmodified */
     else if (dsb->device->nrofbuffers > ds_hq_buffers_max)
-        adv = cp_fields_resample_lq(dsb, count, freqAccNum);
+        adv = cp_fields_resample_lq(dsb, put, ostride, count, freqAccNum);
     else
-        adv = cp_fields_resample_hq(dsb, count, freqAccNum);
+        adv = cp_fields_resample_hq(dsb, put, ostride, count, freqAccNum);
 
     ipos = dsb->sec_mixpos + adv * dsb->pwfx->nBlockAlign;
     if (ipos >= dsb->buflen) {
@@ -484,6 +483,21 @@ static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
 		return buflen + ptr1 - ptr2;
 	}
 }
+
+static float getieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD channel)
+{
+    const BYTE *buf = (BYTE *)dsb->device->dsp_buffer;
+    const float *fbuf = (const float*)(buf + pos + sizeof(float) * channel);
+    return *fbuf;
+}
+
+static void putieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD channel, float value)
+{
+    BYTE *buf = (BYTE *)dsb->device->dsp_buffer;
+    float *fbuf = (float*)(buf + pos + sizeof(float) * channel);
+    *fbuf = value;
+}
+
 /**
  * Mix at most the given amount of data into the allocated temporary buffer
  * of the given secondary buffer, starting from the dsb's first currently
@@ -499,31 +513,61 @@ static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
  */
 static void DSOUND_MixToTemporary(IDirectSoundBufferImpl *dsb, DWORD frames)
 {
-	UINT size_bytes = frames * sizeof(float) * dsb->device->pwfx->nChannels;
+    BOOL using_filters = dsb->num_filters > 0;
+    UINT istride, ostride, size_bytes;
+    DWORD channel, i;
+    bitsputfunc put;
 	HRESULT hr;
-	int i;
 
-	if (dsb->device->tmp_buffer_len < size_bytes || !dsb->device->tmp_buffer)
-	{
-		dsb->device->tmp_buffer_len = size_bytes;
-		dsb->device->tmp_buffer = realloc(dsb->device->tmp_buffer, size_bytes);
-	}
-	if(dsb->put_aux == putieee32_sum)
-		memset(dsb->device->tmp_buffer, 0, dsb->device->tmp_buffer_len);
+    put = dsb->put;
+    ostride = dsb->device->pwfx->nChannels * sizeof(float);
+    size_bytes = frames * ostride;
 
-	cp_fields(dsb, frames, &dsb->freqAccNum);
+    if (dsb->device->tmp_buffer_len < size_bytes || !dsb->device->tmp_buffer)
+    {
+        dsb->device->tmp_buffer_len = size_bytes;
+        dsb->device->tmp_buffer = realloc(dsb->device->tmp_buffer, size_bytes);
+    }
+    if(dsb->put_aux == putieee32_sum)
+        memset(dsb->device->tmp_buffer, 0, dsb->device->tmp_buffer_len);
+
+    if (using_filters) {
+        put = putieee32_dsp;
+        ostride = dsb->mix_channels * sizeof(float);
+        size_bytes = frames * ostride;
+
+        if (dsb->device->dsp_buffer_len < size_bytes || !dsb->device->dsp_buffer) {
+            if (dsb->device->dsp_buffer)
+                dsb->device->dsp_buffer = HeapReAlloc(GetProcessHeap(), 0, dsb->device->dsp_buffer, size_bytes);
+            else
+                dsb->device->dsp_buffer = HeapAlloc(GetProcessHeap(), 0, size_bytes);
+            dsb->device->dsp_buffer_len = size_bytes;
+        }
+    }
 
-	if (size_bytes > 0) {
-		for (i = 0; i < dsb->num_filters; i++) {
-			if (dsb->filters[i].inplace) {
-				hr = IMediaObjectInPlace_Process(dsb->filters[i].inplace, size_bytes, (BYTE*)dsb->device->tmp_buffer, 0, DMO_INPLACE_NORMAL);
+    cp_fields(dsb, put, ostride, frames, &dsb->freqAccNum);
+
+    if (using_filters) {
+        if (frames > 0) {
+            for (i = 0; i < dsb->num_filters; i++) {
+                if (dsb->filters[i].inplace) {
+                    hr = IMediaObjectInPlace_Process(dsb->filters[i].inplace, frames * sizeof(float) * dsb->mix_channels,
+                                                     (BYTE *)dsb->device->dsp_buffer, 0, DMO_INPLACE_NORMAL);
+                    if (FAILED(hr))
+                        WARN("IMediaObjectInPlace_Process failed for filter %lu\n", i);
+                } else
+                    WARN("filter %lu has no inplace object - unsupported\n", i);
+            }
+        }
 
-				if (FAILED(hr))
-					WARN("IMediaObjectInPlace_Process failed for filter %u\n", i);
-			} else
-				WARN("filter %u has no inplace object - unsupported\n", i);
-		}
-	}
+        istride = ostride;
+        ostride = dsb->device->pwfx->nChannels * sizeof(float);
+        for (i = 0; i < frames; i++) {
+            for (channel = 0; channel < dsb->mix_channels; channel++) {
+                dsb->put(dsb, i * ostride, channel, getieee32_dsp(dsb, i * istride, channel));
+            }
+        }
+    }
 }
 
 static void DSOUND_MixerVol(const IDirectSoundBufferImpl *dsb, INT frames)

From f67bd69496d3a21e781fcb69b234a88dcca5b0d0 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 15 Mar 2015 18:04:16 +0000
Subject: [PATCH 027/244] dsound: Add EAX v1 constants and structs.

---
 dlls/dsound/dsound_eax.h     | 89 ++++++++++++++++++++++++++++++++++++
 dlls/dsound/dsound_private.h |  1 +
 2 files changed, 90 insertions(+)
 create mode 100644 dlls/dsound/dsound_eax.h

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
new file mode 100644
index 00000000000..600029fa94f
--- /dev/null
+++ b/dlls/dsound/dsound_eax.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2015 Mark Harmstone
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef DSOUND_EAX_H_DEFINED
+#define DSOUND_EAX_H_DEFINED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+DEFINE_GUID(DSPROPSETID_EAX_ReverbProperties, 0x4a4e6fc1, 0xc341, 0x11d1, 0xb7, 0x3a, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
+DEFINE_GUID(DSPROPSETID_EAXBUFFER_ReverbProperties, 0x4a4e6fc0, 0xc341, 0x11d1, 0xb7, 0x3a, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
+
+typedef enum {
+    DSPROPERTY_EAX_ALL,
+    DSPROPERTY_EAX_ENVIRONMENT,
+    DSPROPERTY_EAX_VOLUME,
+    DSPROPERTY_EAX_DECAYTIME,
+    DSPROPERTY_EAX_DAMPING
+} DSPROPERTY_EAX_REVERBPROPERTY;
+
+typedef struct {
+    unsigned long environment;
+    float fVolume;
+    float fDecayTime_sec;
+    float fDamping;
+} EAX_REVERBPROPERTIES;
+
+enum {
+    EAX_ENVIRONMENT_GENERIC,
+    EAX_ENVIRONMENT_PADDEDCELL,
+    EAX_ENVIRONMENT_ROOM,
+    EAX_ENVIRONMENT_BATHROOM,
+    EAX_ENVIRONMENT_LIVINGROOM,
+    EAX_ENVIRONMENT_STONEROOM,
+    EAX_ENVIRONMENT_AUDITORIUM,
+    EAX_ENVIRONMENT_CONCERTHALL,
+    EAX_ENVIRONMENT_CAVE,
+    EAX_ENVIRONMENT_ARENA,
+    EAX_ENVIRONMENT_HANGAR,
+    EAX_ENVIRONMENT_CARPETEDHALLWAY,
+    EAX_ENVIRONMENT_HALLWAY,
+    EAX_ENVIRONMENT_STONECORRIDOR,
+    EAX_ENVIRONMENT_ALLEY,
+    EAX_ENVIRONMENT_FOREST,
+    EAX_ENVIRONMENT_CITY,
+    EAX_ENVIRONMENT_MOUNTAINS,
+    EAX_ENVIRONMENT_QUARRY,
+    EAX_ENVIRONMENT_PLAIN,
+    EAX_ENVIRONMENT_PARKINGLOT,
+    EAX_ENVIRONMENT_SEWERPIPE,
+    EAX_ENVIRONMENT_UNDERWATER,
+    EAX_ENVIRONMENT_DRUGGED,
+    EAX_ENVIRONMENT_DIZZY,
+    EAX_ENVIRONMENT_PSYCHOTIC,
+    EAX_ENVIRONMENT_COUNT
+};
+
+typedef enum {
+    DSPROPERTY_EAXBUFFER_ALL,
+    DSPROPERTY_EAXBUFFER_REVERBMIX
+} DSPROPERTY_EAXBUFFER_REVERBPROPERTY;
+
+typedef struct {
+    float fMix;
+} EAXBUFFER_REVERBPROPERTIES;
+
+#define EAX_REVERBMIX_USEDISTANCE -1.0f
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 7fc63d03717..c2d355108e2 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -29,6 +29,7 @@
 #include "mediaobj.h"
 #include "mmsystem.h"
 #include "uuids.h"
+#include "dsound_eax.h"
 
 #include "wine/list.h"
 

From 1bbb88f25742c7f18748cf944686b9540a867b76 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 15 Mar 2015 18:04:38 +0000
Subject: [PATCH 028/244] dsound: Report that we support EAX v1.

---
 dlls/dsound/buffer.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index 8e261fde32c..c304bb1eac2 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1362,6 +1362,18 @@ static HRESULT WINAPI IKsPropertySetImpl_QuerySupport(IKsPropertySet *iface, REF
 
     TRACE("(%p,%s,%ld,%p)\n",This,debugstr_guid(guidPropSet),dwPropID,pTypeSupport);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
+        if (dwPropID <= DSPROPERTY_EAX_DAMPING) {
+            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
+            return S_OK;
+        }
+    } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
+        if (dwPropID <= DSPROPERTY_EAXBUFFER_REVERBMIX) {
+            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
+            return S_OK;
+        }
+    }
+
     return E_PROP_ID_UNSUPPORTED;
 }
 

From 060228861b590d0aa9ee5282beaf155773c6450a Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 13:58:53 +0000
Subject: [PATCH 029/244] dsound: Add EAX propset stubs.

---
 dlls/dsound/Makefile.in      |  1 +
 dlls/dsound/buffer.c         |  6 ++++
 dlls/dsound/dsound_private.h |  8 ++++++
 dlls/dsound/eax.c            | 54 ++++++++++++++++++++++++++++++++++++
 4 files changed, 69 insertions(+)
 create mode 100644 dlls/dsound/eax.c

diff --git a/dlls/dsound/Makefile.in b/dlls/dsound/Makefile.in
index 13cb6e8b615..ee097767ecd 100644
--- a/dlls/dsound/Makefile.in
+++ b/dlls/dsound/Makefile.in
@@ -10,6 +10,7 @@ SOURCES = \
 	dsound_convert.c \
 	dsound_main.c \
 	duplex.c \
+	eax.c \
 	mixer.c \
 	primary.c \
 	propset.c \
diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index c304bb1eac2..d15fed36234 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1341,6 +1341,9 @@ static HRESULT WINAPI IKsPropertySetImpl_Get(IKsPropertySet *iface, REFGUID guid
     TRACE("(iface=%p,guidPropSet=%s,dwPropID=%ld,pInstanceData=%p,cbInstanceData=%ld,pPropData=%p,cbPropData=%ld,pcbReturned=%p)\n",
     This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet))
+        return EAX_Get(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -1352,6 +1355,9 @@ static HRESULT WINAPI IKsPropertySetImpl_Set(IKsPropertySet *iface, REFGUID guid
 
     TRACE("(%p,%s,%ld,%p,%ld,%p,%ld)\n",This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet))
+        return EAX_Set(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index c2d355108e2..49b3235b904 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -230,6 +230,14 @@ LONG capped_refcount_dec(LONG *ref);
 
 HRESULT DSOUND_FullDuplexCreate(REFIID riid, void **ppv);
 
+/* eax.c */
+HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData, ULONG *pcbReturned);
+HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData);
+
 /* mixer.c */
 void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len);
 void DSOUND_RecalcVolPan(PDSVOLUMEPAN volpan);
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
new file mode 100644
index 00000000000..c1264f977b6
--- /dev/null
+++ b/dlls/dsound/eax.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015 Mark Harmstone
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <math.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "mmsystem.h"
+#include "winternl.h"
+#include "vfwmsgs.h"
+#include "wine/debug.h"
+#include "dsound.h"
+#include "dsound_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(eax);
+
+HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData, ULONG *pcbReturned)
+{
+    TRACE("(buf=%p,guidPropSet=%s,dwPropID=%lu,pInstanceData=%p,cbInstanceData=%lu,pPropData=%p,cbPropData=%lu,pcbReturned=%p)\n",
+        buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+
+    *pcbReturned = 0;
+
+    return E_PROP_ID_UNSUPPORTED;
+}
+
+HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData)
+{
+    TRACE("(%p,%s,%lu,%p,%lu,%p,%lu)\n",
+        buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
+
+    return E_PROP_ID_UNSUPPORTED;
+}

From cbcf6c8d90ed6c3e7826ef4d550e5709e054ef0d Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 14:10:06 +0000
Subject: [PATCH 030/244] dsound: Add EAX presets.

---
 dlls/dsound/dsound_eax.h | 29 +++++++++++++++++++
 dlls/dsound/eax.c        | 61 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 90 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index 600029fa94f..06d961e006e 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2008-2009 Christopher Fitzgerald
  * Copyright (c) 2015 Mark Harmstone
  *
  * This library is free software; you can redistribute it and/or
@@ -16,6 +17,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+/* Taken in large part from OpenAL. */
+
 #ifndef DSOUND_EAX_H_DEFINED
 #define DSOUND_EAX_H_DEFINED
 
@@ -82,6 +85,32 @@ typedef struct {
 
 #define EAX_REVERBMIX_USEDISTANCE -1.0f
 
+typedef struct {
+    float flDensity;
+    float flDiffusion;
+    float flGain;
+    float flGainHF;
+    float flGainLF;
+    float flDecayTime;
+    float flDecayHFRatio;
+    float flDecayLFRatio;
+    float flReflectionsGain;
+    float flReflectionsDelay;
+    float flReflectionsPan[3];
+    float flLateReverbGain;
+    float flLateReverbDelay;
+    float flLateReverbPan[3];
+    float flEchoTime;
+    float flEchoDepth;
+    float flModulationTime;
+    float flModulationDepth;
+    float flAirAbsorptionGainHF;
+    float flHFReference;
+    float flLFReference;
+    float flRoomRolloffFactor;
+    int   iDecayHFLimit;
+} EFXEAXREVERBPROPERTIES, *LPEFXEAXREVERBPROPERTIES;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index c1264f977b6..c1653a200c5 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2008-2009 Christopher Fitzgerald
  * Copyright (c) 2015 Mark Harmstone
  *
  * This library is free software; you can redistribute it and/or
@@ -16,6 +17,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+/* Taken in large part from OpenAL's Alc/alcReverb.c. */
+
 #include <stdarg.h>
 #include <math.h>
 
@@ -31,6 +34,64 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(eax);
 
+static const EAX_REVERBPROPERTIES presets[] = {
+    { EAX_ENVIRONMENT_GENERIC, 0.5f, 1.493f, 0.5f },
+    { EAX_ENVIRONMENT_PADDEDCELL, 0.25f, 0.1f, 0.0f },
+    { EAX_ENVIRONMENT_ROOM, 0.417f, 0.4f, 0.666f },
+    { EAX_ENVIRONMENT_BATHROOM, 0.653f, 1.499f, 0.166f },
+    { EAX_ENVIRONMENT_LIVINGROOM, 0.208f, 0.478f, 0.0f },
+    { EAX_ENVIRONMENT_STONEROOM, 0.5f, 2.309f, 0.888f },
+    { EAX_ENVIRONMENT_AUDITORIUM, 0.403f, 4.279f, 0.5f },
+    { EAX_ENVIRONMENT_CONCERTHALL, 0.5f, 3.961f, 0.5f },
+    { EAX_ENVIRONMENT_CAVE, 0.5f, 2.886f, 1.304f },
+    { EAX_ENVIRONMENT_ARENA, 0.361f, 7.284f, 0.332f },
+    { EAX_ENVIRONMENT_HANGAR, 0.5f, 10.0f, 0.3f },
+    { EAX_ENVIRONMENT_CARPETEDHALLWAY, 0.153f, 0.259f, 2.0f },
+    { EAX_ENVIRONMENT_HALLWAY, 0.361f, 1.493f, 0.0f },
+    { EAX_ENVIRONMENT_STONECORRIDOR, 0.444f, 2.697f, 0.638f },
+    { EAX_ENVIRONMENT_ALLEY, 0.25f, 1.752f, 0.776f },
+    { EAX_ENVIRONMENT_FOREST, 0.111f, 3.145f, 0.472f },
+    { EAX_ENVIRONMENT_CITY, 0.111f, 2.767f, 0.224f },
+    { EAX_ENVIRONMENT_MOUNTAINS, 0.194f, 7.841f, 0.472f },
+    { EAX_ENVIRONMENT_QUARRY, 1.0f, 1.499f, 0.5f },
+    { EAX_ENVIRONMENT_PLAIN, 0.097f, 2.767f, 0.224f },
+    { EAX_ENVIRONMENT_PARKINGLOT, 0.208f, 1.652f, 1.5f },
+    { EAX_ENVIRONMENT_SEWERPIPE, 0.652f, 2.886f, 0.25f },
+    { EAX_ENVIRONMENT_UNDERWATER, 1.0f, 1.499f, 0.0f },
+    { EAX_ENVIRONMENT_DRUGGED, 0.875f, 8.392f, 1.388f },
+    { EAX_ENVIRONMENT_DIZZY, 0.139f, 17.234f, 0.666f },
+    { EAX_ENVIRONMENT_PSYCHOTIC, 0.486f, 7.563f, 0.806f }
+};
+
+static const EFXEAXREVERBPROPERTIES efx_presets[] = {
+    { 1.0000f, 1.0000f, 0.3162f, 0.8913f, 1.0000f, 1.4900f, 0.8300f, 1.0000f, 0.0500f, 0.0070f, { 0.0000f, 0.0000f, 0.0000f }, 1.2589f, 0.0110f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* generic */
+    { 0.1715f, 1.0000f, 0.3162f, 0.0010f, 1.0000f, 0.1700f, 0.1000f, 1.0000f, 0.2500f, 0.0010f, { 0.0000f, 0.0000f, 0.0000f }, 1.2691f, 0.0020f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* padded cell */
+    { 0.4287f, 1.0000f, 0.3162f, 0.5929f, 1.0000f, 0.4000f, 0.8300f, 1.0000f, 0.1503f, 0.0020f, { 0.0000f, 0.0000f, 0.0000f }, 1.0629f, 0.0030f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* room */
+    { 0.1715f, 1.0000f, 0.3162f, 0.2512f, 1.0000f, 1.4900f, 0.5400f, 1.0000f, 0.6531f, 0.0070f, { 0.0000f, 0.0000f, 0.0000f }, 3.2734f, 0.0110f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* bathroom */
+    { 0.9766f, 1.0000f, 0.3162f, 0.0010f, 1.0000f, 0.5000f, 0.1000f, 1.0000f, 0.2051f, 0.0030f, { 0.0000f, 0.0000f, 0.0000f }, 0.2805f, 0.0040f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* living room */
+    { 1.0000f, 1.0000f, 0.3162f, 0.7079f, 1.0000f, 2.3100f, 0.6400f, 1.0000f, 0.4411f, 0.0120f, { 0.0000f, 0.0000f, 0.0000f }, 1.1003f, 0.0170f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* stone room */
+    { 1.0000f, 1.0000f, 0.3162f, 0.5781f, 1.0000f, 4.3200f, 0.5900f, 1.0000f, 0.4032f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 0.7170f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* auditorium */
+    { 1.0000f, 1.0000f, 0.3162f, 0.5623f, 1.0000f, 3.9200f, 0.7000f, 1.0000f, 0.2427f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 0.9977f, 0.0290f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* concert hall */
+    { 1.0000f, 1.0000f, 0.3162f, 1.0000f, 1.0000f, 2.9100f, 1.3000f, 1.0000f, 0.5000f, 0.0150f, { 0.0000f, 0.0000f, 0.0000f }, 0.7063f, 0.0220f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 }, /* cave */
+    { 1.0000f, 1.0000f, 0.3162f, 0.4477f, 1.0000f, 7.2400f, 0.3300f, 1.0000f, 0.2612f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 1.0186f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* arena */
+    { 1.0000f, 1.0000f, 0.3162f, 0.3162f, 1.0000f, 10.0500f, 0.2300f, 1.0000f, 0.5000f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 1.2560f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* hangar */
+    { 0.4287f, 1.0000f, 0.3162f, 0.0100f, 1.0000f, 0.3000f, 0.1000f, 1.0000f, 0.1215f, 0.0020f, { 0.0000f, 0.0000f, 0.0000f }, 0.1531f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* carpeted hallway */
+    { 0.3645f, 1.0000f, 0.3162f, 0.7079f, 1.0000f, 1.4900f, 0.5900f, 1.0000f, 0.2458f, 0.0070f, { 0.0000f, 0.0000f, 0.0000f }, 1.6615f, 0.0110f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* hallway */
+    { 1.0000f, 1.0000f, 0.3162f, 0.7612f, 1.0000f, 2.7000f, 0.7900f, 1.0000f, 0.2472f, 0.0130f, { 0.0000f, 0.0000f, 0.0000f }, 1.5758f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* stone corridor */
+    { 1.0000f, 0.3000f, 0.3162f, 0.7328f, 1.0000f, 1.4900f, 0.8600f, 1.0000f, 0.2500f, 0.0070f, { 0.0000f, 0.0000f, 0.0000f }, 0.9954f, 0.0110f, { 0.0000f, 0.0000f, 0.0000f }, 0.1250f, 0.9500f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* alley */
+    { 1.0000f, 0.3000f, 0.3162f, 0.0224f, 1.0000f, 1.4900f, 0.5400f, 1.0000f, 0.0525f, 0.1620f, { 0.0000f, 0.0000f, 0.0000f }, 0.7682f, 0.0880f, { 0.0000f, 0.0000f, 0.0000f }, 0.1250f, 1.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* forest */
+    { 1.0000f, 0.5000f, 0.3162f, 0.3981f, 1.0000f, 1.4900f, 0.6700f, 1.0000f, 0.0730f, 0.0070f, { 0.0000f, 0.0000f, 0.0000f }, 0.1427f, 0.0110f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* city */
+    { 1.0000f, 0.2700f, 0.3162f, 0.0562f, 1.0000f, 1.4900f, 0.2100f, 1.0000f, 0.0407f, 0.3000f, { 0.0000f, 0.0000f, 0.0000f }, 0.1919f, 0.1000f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 1.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 }, /* mountains */
+    { 1.0000f, 1.0000f, 0.3162f, 0.3162f, 1.0000f, 1.4900f, 0.8300f, 1.0000f, 0.0000f, 0.0610f, { 0.0000f, 0.0000f, 0.0000f }, 1.7783f, 0.0250f, { 0.0000f, 0.0000f, 0.0000f }, 0.1250f, 0.7000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* quarry */
+    { 1.0000f, 0.2100f, 0.3162f, 0.1000f, 1.0000f, 1.4900f, 0.5000f, 1.0000f, 0.0585f, 0.1790f, { 0.0000f, 0.0000f, 0.0000f }, 0.1089f, 0.1000f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 1.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* plain */
+    { 1.0000f, 1.0000f, 0.3162f, 1.0000f, 1.0000f, 1.6500f, 1.5000f, 1.0000f, 0.2082f, 0.0080f, { 0.0000f, 0.0000f, 0.0000f }, 0.2652f, 0.0120f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 }, /* parking lot */
+    { 0.3071f, 0.8000f, 0.3162f, 0.3162f, 1.0000f, 2.8100f, 0.1400f, 1.0000f, 1.6387f, 0.0140f, { 0.0000f, 0.0000f, 0.0000f }, 3.2471f, 0.0210f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 0.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* sewer pipe */
+    { 0.3645f, 1.0000f, 0.3162f, 0.0100f, 1.0000f, 1.4900f, 0.1000f, 1.0000f, 0.5963f, 0.0070f, { 0.0000f, 0.0000f, 0.0000f }, 7.0795f, 0.0110f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 1.1800f, 0.3480f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x1 }, /* underwater */
+    { 0.4287f, 0.5000f, 0.3162f, 1.0000f, 1.0000f, 8.3900f, 1.3900f, 1.0000f, 0.8760f, 0.0020f, { 0.0000f, 0.0000f, 0.0000f }, 3.1081f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 0.2500f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 }, /* drugged */
+    { 0.3645f, 0.6000f, 0.3162f, 0.6310f, 1.0000f, 17.2300f, 0.5600f, 1.0000f, 0.1392f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 0.4937f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 1.0000f, 0.8100f, 0.3100f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 }, /* dizzy */
+    { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
+};
+
 HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData, ULONG *pcbReturned)

From 48cd4621f1ff46d71eb6554a42c7161281b4dd3f Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 14:22:02 +0000
Subject: [PATCH 031/244] dsound: Support getting and setting EAX properties.

---
 dlls/dsound/dsound_eax.h     |   8 ++
 dlls/dsound/dsound_private.h |   2 +
 dlls/dsound/eax.c            | 167 +++++++++++++++++++++++++++++++++++
 3 files changed, 177 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index 06d961e006e..c90d82d9a3f 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -111,6 +111,14 @@ typedef struct {
     int   iDecayHFLimit;
 } EFXEAXREVERBPROPERTIES, *LPEFXEAXREVERBPROPERTIES;
 
+typedef struct {
+    BOOL using_eax;
+    unsigned long environment;
+    float volume;
+    float damping;
+    EFXEAXREVERBPROPERTIES eax_props;
+} eax_info;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 49b3235b904..cd8090f7d3b 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -99,6 +99,8 @@ struct DirectSoundDevice
 
     normfunc normfunction;
 
+    eax_info                    eax;
+
     /* DirectSound3DListener fields */
     DS3DLISTENER                ds3dl;
     BOOL                        ds3dl_need_recalc;
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index c1653a200c5..13471aec3a9 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,6 +92,22 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
+{
+    /* stub */
+    return TRUE;
+}
+
+static void init_eax(DirectSoundDevice *dev)
+{
+    dev->eax.using_eax = TRUE;
+    dev->eax.environment = presets[0].environment;
+    dev->eax.volume = presets[0].fVolume;
+    dev->eax.damping = presets[0].fDamping;
+    memcpy(&dev->eax.eax_props, &efx_presets[0], sizeof(dev->eax.eax_props));
+    dev->eax.eax_props.flDecayTime = presets[0].fDecayTime_sec;
+}
+
 HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData, ULONG *pcbReturned)
@@ -101,6 +117,70 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
 
     *pcbReturned = 0;
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
+        EAX_REVERBPROPERTIES *props;
+
+        if (!buf->device->eax.using_eax)
+            init_eax(buf->device);
+
+        switch (dwPropID) {
+            case DSPROPERTY_EAX_ALL:
+                if (cbPropData < sizeof(EAX_REVERBPROPERTIES))
+                    return E_FAIL;
+
+                props = pPropData;
+
+                props->environment = buf->device->eax.environment;
+                props->fVolume = buf->device->eax.volume;
+                props->fDecayTime_sec = buf->device->eax.eax_props.flDecayTime;
+                props->fDamping = buf->device->eax.damping;
+
+                *pcbReturned = sizeof(EAX_REVERBPROPERTIES);
+            break;
+
+            case DSPROPERTY_EAX_ENVIRONMENT:
+                if (cbPropData < sizeof(unsigned long))
+                    return E_FAIL;
+
+                *(unsigned long*)pPropData = buf->device->eax.environment;
+
+                *pcbReturned = sizeof(unsigned long);
+            break;
+
+            case DSPROPERTY_EAX_VOLUME:
+                if (cbPropData < sizeof(float))
+                    return E_FAIL;
+
+                *(float*)pPropData = buf->device->eax.volume;
+
+                *pcbReturned = sizeof(float);
+            break;
+
+            case DSPROPERTY_EAX_DECAYTIME:
+                if (cbPropData < sizeof(float))
+                    return E_FAIL;
+
+                *(float*)pPropData = buf->device->eax.eax_props.flDecayTime;
+
+                *pcbReturned = sizeof(float);
+            break;
+
+            case DSPROPERTY_EAX_DAMPING:
+                if (cbPropData < sizeof(float))
+                    return E_FAIL;
+
+                *(float*)pPropData = buf->device->eax.damping;
+
+                *pcbReturned = sizeof(float);
+            break;
+
+            default:
+                return E_PROP_ID_UNSUPPORTED;
+        }
+
+        return S_OK;
+    }
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -108,8 +188,95 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData)
 {
+    EAX_REVERBPROPERTIES *props;
+
     TRACE("(%p,%s,%lu,%p,%lu,%p,%lu)\n",
         buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
+        if (!buf->device->eax.using_eax)
+            init_eax(buf->device);
+
+        switch (dwPropID) {
+            case DSPROPERTY_EAX_ALL:
+                if (cbPropData != sizeof(EAX_REVERBPROPERTIES))
+                    return E_FAIL;
+
+                props = pPropData;
+
+                TRACE("setting environment = %lu, fVolume = %f, fDecayTime_sec = %f, fDamping = %f\n",
+                      props->environment, props->fVolume, props->fDecayTime_sec,
+                      props->fDamping);
+
+                buf->device->eax.environment = props->environment;
+
+                if (buf->device->eax.environment < EAX_ENVIRONMENT_COUNT)
+                    memcpy(&buf->device->eax.eax_props, &efx_presets[buf->device->eax.environment], sizeof(buf->device->eax.eax_props));
+
+                buf->device->eax.volume = props->fVolume;
+                buf->device->eax.eax_props.flDecayTime = props->fDecayTime_sec;
+                buf->device->eax.damping = props->fDamping;
+
+                ReverbDeviceUpdate(buf->device);
+            break;
+
+            case DSPROPERTY_EAX_ENVIRONMENT:
+                if (cbPropData != sizeof(unsigned long))
+                    return E_FAIL;
+
+                TRACE("setting environment to %lu\n", *(unsigned long*)pPropData);
+
+                buf->device->eax.environment = *(unsigned long*)pPropData;
+
+                if (buf->device->eax.environment < EAX_ENVIRONMENT_COUNT) {
+                    memcpy(&buf->device->eax.eax_props, &efx_presets[buf->device->eax.environment], sizeof(buf->device->eax.eax_props));
+                    buf->device->eax.volume = presets[buf->device->eax.environment].fVolume;
+                    buf->device->eax.eax_props.flDecayTime = presets[buf->device->eax.environment].fDecayTime_sec;
+                    buf->device->eax.damping = presets[buf->device->eax.environment].fDamping;
+                }
+
+                ReverbDeviceUpdate(buf->device);
+            break;
+
+            case DSPROPERTY_EAX_VOLUME:
+                if (cbPropData != sizeof(float))
+                    return E_FAIL;
+
+                TRACE("setting volume to %f\n", *(float*)pPropData);
+
+                buf->device->eax.volume = *(float*)pPropData;
+
+                ReverbDeviceUpdate(buf->device);
+            break;
+
+            case DSPROPERTY_EAX_DECAYTIME:
+                if (cbPropData != sizeof(float))
+                    return E_FAIL;
+
+                TRACE("setting decay time to %f\n", *(float*)pPropData);
+
+                buf->device->eax.eax_props.flDecayTime = *(float*)pPropData;
+
+                ReverbDeviceUpdate(buf->device);
+            break;
+
+            case DSPROPERTY_EAX_DAMPING:
+                if (cbPropData != sizeof(float))
+                    return E_FAIL;
+
+                TRACE("setting damping to %f\n", *(float*)pPropData);
+
+                buf->device->eax.damping = *(float*)pPropData;
+
+                ReverbDeviceUpdate(buf->device);
+            break;
+
+            default:
+                return E_PROP_ID_UNSUPPORTED;
+        }
+
+        return S_OK;
+    }
+
     return E_PROP_ID_UNSUPPORTED;
 }

From 615ff8658ad9554e79929800cfab0b172619073b Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Fri, 27 Mar 2015 20:48:19 +0000
Subject: [PATCH 032/244] dsound: Support getting and setting EAX buffer
 properties.

---
 dlls/dsound/buffer.c         |  2 ++
 dlls/dsound/dsound_eax.h     |  4 +++
 dlls/dsound/dsound_private.h |  2 ++
 dlls/dsound/eax.c            | 64 ++++++++++++++++++++++++++++++++++++
 4 files changed, 72 insertions(+)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index d15fed36234..5b098585b83 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1110,6 +1110,8 @@ HRESULT secondarybuffer_create(DirectSoundDevice *device, const DSBUFFERDESC *ds
 	dsb->sec_mixpos = 0;
 	dsb->state = STATE_STOPPED;
 
+	dsb->eax.reverb_mix = EAX_REVERBMIX_USEDISTANCE;
+
 	if (dsb->dsbd.dwFlags & DSBCAPS_CTRL3D) {
 		dsb->ds3db_ds3db.dwSize = sizeof(DS3DBUFFER);
 		dsb->ds3db_ds3db.vPosition.x = 0.0;
diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index c90d82d9a3f..2ee83b94ff9 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -119,6 +119,10 @@ typedef struct {
     EFXEAXREVERBPROPERTIES eax_props;
 } eax_info;
 
+typedef struct {
+    float reverb_mix;
+} eax_buffer_info;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index cd8090f7d3b..6d5fb6ecfe1 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -179,6 +179,8 @@ struct IDirectSoundBufferImpl
     int                         num_filters;
     DSFilter*                   filters;
 
+    eax_buffer_info             eax;
+
     struct list entry;
 };
 
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 13471aec3a9..03b6e0a9813 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -178,6 +178,38 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
                 return E_PROP_ID_UNSUPPORTED;
         }
 
+        return S_OK;
+    } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
+        EAXBUFFER_REVERBPROPERTIES *props;
+
+        if (!buf->device->eax.using_eax)
+            init_eax(buf->device);
+
+        switch (dwPropID) {
+            case DSPROPERTY_EAXBUFFER_ALL:
+                if (cbPropData < sizeof(EAXBUFFER_REVERBPROPERTIES))
+                    return E_FAIL;
+
+                props = pPropData;
+
+                props->fMix = buf->eax.reverb_mix;
+
+                *pcbReturned = sizeof(EAXBUFFER_REVERBPROPERTIES);
+            break;
+
+            case DSPROPERTY_EAXBUFFER_REVERBMIX:
+                if (cbPropData < sizeof(float))
+                    return E_FAIL;
+
+                *(float*)pPropData = buf->eax.reverb_mix;
+
+                *pcbReturned = sizeof(float);
+            break;
+
+            default:
+                return E_PROP_ID_UNSUPPORTED;
+        }
+
         return S_OK;
     }
 
@@ -275,6 +307,38 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
                 return E_PROP_ID_UNSUPPORTED;
         }
 
+        return S_OK;
+    } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
+        EAXBUFFER_REVERBPROPERTIES *props;
+
+        if (!buf->device->eax.using_eax)
+            init_eax(buf->device);
+
+        switch (dwPropID) {
+            case DSPROPERTY_EAXBUFFER_ALL:
+                if (cbPropData != sizeof(EAXBUFFER_REVERBPROPERTIES))
+                    return E_FAIL;
+
+                props = pPropData;
+
+                TRACE("setting reverb mix to %f\n", props->fMix);
+
+                buf->eax.reverb_mix = props->fMix;
+            break;
+
+            case DSPROPERTY_EAXBUFFER_REVERBMIX:
+                if (cbPropData != sizeof(float))
+                    return E_FAIL;
+
+                TRACE("setting reverb mix to %f\n", *(float*)pPropData);
+
+                buf->eax.reverb_mix = *(float*)pPropData;
+            break;
+
+            default:
+                return E_PROP_ID_UNSUPPORTED;
+        }
+
         return S_OK;
     }
 

From 510b4ca2dbcb0b8a858fc52d5e84949f82057ef8 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Fri, 27 Mar 2015 20:58:37 +0000
Subject: [PATCH 033/244] dsound: Add EAX init and free stubs.

---
 dlls/dsound/buffer.c         |  4 ++++
 dlls/dsound/dsound_private.h |  2 ++
 dlls/dsound/eax.c            | 28 +++++++++++++++++++++++++++-
 3 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index 5b098585b83..c5f18081e33 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1148,6 +1148,8 @@ HRESULT secondarybuffer_create(DirectSoundDevice *device, const DSBUFFERDESC *ds
 	}
 
         InitializeSRWLock(&dsb->lock);
+	if (dsb->device->eax.using_eax)
+		init_eax_buffer(dsb);
 
         /* register buffer */
         err = DirectSoundDevice_AddBuffer(device, dsb);
@@ -1189,6 +1191,8 @@ void secondarybuffer_destroy(IDirectSoundBufferImpl *This)
         free(This->filters);
     }
 
+    free_eax_buffer(This);
+
     TRACE("(%p) released\n", This);
 
     free(This);
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 6d5fb6ecfe1..ef2c1894d21 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -241,6 +241,8 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
 HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData);
+void free_eax_buffer(IDirectSoundBufferImpl *dsb);
+void init_eax_buffer(IDirectSoundBufferImpl *dsb);
 
 /* mixer.c */
 void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len);
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 03b6e0a9813..91438efc335 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,20 +92,46 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
-static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
+static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 {
     /* stub */
+}
+
+static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
+{
+    int i;
+
+    for (i = 0; i < dev->nrofbuffers; i++) {
+        ReverbUpdate(dev->buffers[i]);
+    }
+
     return TRUE;
 }
 
+void init_eax_buffer(IDirectSoundBufferImpl *dsb)
+{
+    ReverbUpdate(dsb);
+}
+
 static void init_eax(DirectSoundDevice *dev)
 {
+    int i;
+
     dev->eax.using_eax = TRUE;
     dev->eax.environment = presets[0].environment;
     dev->eax.volume = presets[0].fVolume;
     dev->eax.damping = presets[0].fDamping;
     memcpy(&dev->eax.eax_props, &efx_presets[0], sizeof(dev->eax.eax_props));
     dev->eax.eax_props.flDecayTime = presets[0].fDecayTime_sec;
+
+    for (i = 0; i < dev->nrofbuffers; i++) {
+        init_eax_buffer(dev->buffers[i]);
+    }
+}
+
+void free_eax_buffer(IDirectSoundBufferImpl *dsb)
+{
+    /* stub */
 }
 
 HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,

From 841b57e6ab4ec5d02b68c37cbc6248c3d15b8741 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Fri, 27 Mar 2015 20:59:57 +0000
Subject: [PATCH 034/244] dsound: Feed data through EAX function.

---
 dlls/dsound/dsound_private.h | 1 +
 dlls/dsound/eax.c            | 5 +++++
 dlls/dsound/mixer.c          | 5 ++++-
 3 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index ef2c1894d21..b32bcb995a6 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -243,6 +243,7 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG cbPropData);
 void free_eax_buffer(IDirectSoundBufferImpl *dsb);
 void init_eax_buffer(IDirectSoundBufferImpl *dsb);
+void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count);
 
 /* mixer.c */
 void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len);
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 91438efc335..bf7efdc4f38 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,6 +92,11 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count)
+{
+    /* stub */
+}
+
 static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 {
     /* stub */
diff --git a/dlls/dsound/mixer.c b/dlls/dsound/mixer.c
index 068c55e07d1..3013e75ace4 100644
--- a/dlls/dsound/mixer.c
+++ b/dlls/dsound/mixer.c
@@ -513,7 +513,7 @@ static void putieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD ch
  */
 static void DSOUND_MixToTemporary(IDirectSoundBufferImpl *dsb, DWORD frames)
 {
-    BOOL using_filters = dsb->num_filters > 0;
+    BOOL using_filters = dsb->num_filters > 0 || dsb->device->eax.using_eax;
     UINT istride, ostride, size_bytes;
     DWORD channel, i;
     bitsputfunc put;
@@ -560,6 +560,9 @@ static void DSOUND_MixToTemporary(IDirectSoundBufferImpl *dsb, DWORD frames)
             }
         }
 
+        if (dsb->device->eax.using_eax)
+            process_eax_buffer(dsb, dsb->device->dsp_buffer, frames * dsb->mix_channels);
+
         istride = ostride;
         ostride = dsb->device->pwfx->nChannels * sizeof(float);
         for (i = 0; i < frames; i++) {

From 5c8951723edec227f4f9eb22ff9d4b87bd38b8ba Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Fri, 27 Mar 2015 21:06:42 +0000
Subject: [PATCH 035/244] dsound: Allocate EAX delay lines.

---
 dlls/dsound/dsound_eax.h | 16 +++++++
 dlls/dsound/eax.c        | 98 +++++++++++++++++++++++++++++++++++++++-
 2 files changed, 112 insertions(+), 2 deletions(-)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index 2ee83b94ff9..132f060db36 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -85,6 +85,9 @@ typedef struct {
 
 #define EAX_REVERBMIX_USEDISTANCE -1.0f
 
+#define AL_EAXREVERB_MAX_REFLECTIONS_DELAY       (0.3f)
+#define AL_EAXREVERB_MAX_LATE_REVERB_DELAY       (0.1f)
+
 typedef struct {
     float flDensity;
     float flDiffusion;
@@ -111,6 +114,12 @@ typedef struct {
     int   iDecayHFLimit;
 } EFXEAXREVERBPROPERTIES, *LPEFXEAXREVERBPROPERTIES;
 
+typedef struct DelayLine
+{
+    unsigned int Mask;
+    float *Line;
+} DelayLine;
+
 typedef struct {
     BOOL using_eax;
     unsigned long environment;
@@ -121,6 +130,13 @@ typedef struct {
 
 typedef struct {
     float reverb_mix;
+
+    float *SampleBuffer;
+    unsigned int TotalSamples;
+
+    DelayLine Delay;
+
+    unsigned int Offset;
 } eax_buffer_info;
 
 #ifdef __cplusplus
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index bf7efdc4f38..53d78240b0e 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,14 +92,99 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+static unsigned int fastf2u(float f)
+{
+    return (unsigned int)f;
+}
+
 void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count)
 {
     /* stub */
 }
 
+static unsigned int NextPowerOf2(unsigned int value)
+{
+    if (value > 0)
+    {
+        value--;
+        value |= value>>1;
+        value |= value>>2;
+        value |= value>>4;
+        value |= value>>8;
+        value |= value>>16;
+    }
+    return value+1;
+}
+
+static unsigned int CalcLineLength(float length, unsigned int offset, unsigned int frequency, DelayLine *Delay)
+{
+    unsigned int samples;
+
+    /* All line lengths are powers of 2, calculated from their lengths, with
+     * an additional sample in case of rounding errors. */
+    samples = NextPowerOf2(fastf2u(length * frequency) + 1);
+    /* All lines share a single sample buffer. */
+    Delay->Mask = samples - 1;
+    Delay->Line = (float*)offset;
+    /* Return the sample count for accumulation. */
+    return samples;
+}
+
+static void RealizeLineOffset(float *sampleBuffer, DelayLine *Delay)
+{
+    Delay->Line = &sampleBuffer[(unsigned int)Delay->Line];
+}
+
+static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
+{
+    unsigned int totalSamples, index;
+    float length;
+    float *newBuffer = NULL;
+
+    /* All delay line lengths are calculated to accomodate the full range of
+     * lengths given their respective paramters. */
+    totalSamples = 0;
+
+    /* The initial delay is the sum of the reflections and late reverb
+     * delays. */
+    length = AL_EAXREVERB_MAX_REFLECTIONS_DELAY +
+             AL_EAXREVERB_MAX_LATE_REVERB_DELAY;
+    totalSamples += CalcLineLength(length, totalSamples, frequency,
+                                   &dsb->eax.Delay);
+
+    if (totalSamples != dsb->eax.TotalSamples)
+    {
+        TRACE("New reverb buffer length: %u samples (%f sec)\n", totalSamples, totalSamples/(float)frequency);
+
+        if (dsb->eax.SampleBuffer)
+            newBuffer = HeapReAlloc(GetProcessHeap(), 0, dsb->eax.SampleBuffer, sizeof(float) * totalSamples);
+        else
+            newBuffer = HeapAlloc(GetProcessHeap(), 0, sizeof(float) * totalSamples);
+
+        if (newBuffer == NULL)
+            return FALSE;
+        dsb->eax.SampleBuffer = newBuffer;
+        dsb->eax.TotalSamples = totalSamples;
+    }
+
+    /* Update all delays to reflect the new sample buffer. */
+    RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Delay);
+
+    /* Clear the sample buffer. */
+    for (index = 0; index < dsb->eax.TotalSamples; index++)
+        dsb->eax.SampleBuffer[index] = 0.0f;
+
+    return TRUE;
+}
+
 static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 {
-    /* stub */
+    /* avoid segfaults in mixing thread when we recalculate the line offsets */
+    EnterCriticalSection(&dsb->device->mixlock);
+
+    AllocLines(dsb->device->pwfx->nSamplesPerSec, dsb);
+
+    LeaveCriticalSection(&dsb->device->mixlock);
 }
 
 static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
@@ -115,6 +200,14 @@ static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
 
 void init_eax_buffer(IDirectSoundBufferImpl *dsb)
 {
+    dsb->eax.TotalSamples = 0;
+    dsb->eax.SampleBuffer = NULL;
+
+    dsb->eax.Delay.Mask = 0;
+    dsb->eax.Delay.Line = NULL;
+
+    dsb->eax.Offset = 0;
+
     ReverbUpdate(dsb);
 }
 
@@ -136,7 +229,8 @@ static void init_eax(DirectSoundDevice *dev)
 
 void free_eax_buffer(IDirectSoundBufferImpl *dsb)
 {
-    /* stub */
+    if (dsb->eax.SampleBuffer)
+        HeapFree(GetProcessHeap(), 0, dsb->eax.SampleBuffer);
 }
 
 HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,

From b7d4b5ea94ed290b4d48f85abfab8bc5135d1401 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 15:38:15 +0000
Subject: [PATCH 036/244] dsound: Add EAX VerbPass stub.

---
 dlls/dsound/eax.c | 37 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 36 insertions(+), 1 deletion(-)

diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 53d78240b0e..167d0d1242c 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,6 +92,14 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
+{
+    /* stub */
+
+    /* Step all delays forward one sample. */
+    dsb->eax.Offset++;
+}
+
 static unsigned int fastf2u(float f)
 {
     return (unsigned int)f;
@@ -99,7 +107,34 @@ static unsigned int fastf2u(float f)
 
 void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count)
 {
-    /* stub */
+    int i;
+    float* out;
+    float gain;
+
+    if (dsb->device->eax.volume == 0.0f)
+        return;
+
+    if (dsb->mix_channels > 1) {
+        WARN("EAX not yet supported for non-mono sources\n");
+        return;
+    }
+
+    out = HeapAlloc(GetProcessHeap(), 0, sizeof(float)*count*4);
+
+    for (i = 0; i < count; i++) {
+        VerbPass(dsb, buf[i], &out[i*4]);
+    }
+
+    if (dsb->eax.reverb_mix == EAX_REVERBMIX_USEDISTANCE)
+        gain = 1.0f; /* FIXME - should be calculated from distance */
+    else
+        gain = dsb->eax.reverb_mix;
+
+    for (i = 0; i < count; i++) {
+        buf[i] += gain * out[i*4];
+    }
+
+    HeapFree(GetProcessHeap(), 0, out);
 }
 
 static unsigned int NextPowerOf2(unsigned int value)

From 2639f11e95af71cd7c7133feca130f3223b2ae20 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 17:57:38 +0000
Subject: [PATCH 037/244] dsound: Implement EAX lowpass filter.

---
 dlls/dsound/dsound_eax.h |  7 ++++++
 dlls/dsound/eax.c        | 48 +++++++++++++++++++++++++++++++++++++++-
 2 files changed, 54 insertions(+), 1 deletion(-)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index 132f060db36..82b140848d7 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -120,6 +120,11 @@ typedef struct DelayLine
     float *Line;
 } DelayLine;
 
+typedef struct {
+    float coeff;
+    float history[2];
+} FILTER;
+
 typedef struct {
     BOOL using_eax;
     unsigned long environment;
@@ -134,6 +139,8 @@ typedef struct {
     float *SampleBuffer;
     unsigned int TotalSamples;
 
+    FILTER LpFilter;
+
     DelayLine Delay;
 
     unsigned int Offset;
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 167d0d1242c..b71af333229 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,9 +92,24 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
+{
+    float *history = &iir->history[offset*2];
+    float a = iir->coeff;
+    float output = input;
+
+    output = output + (history[0]-output)*a;
+    history[0] = output;
+    output = output + (history[1]-output)*a;
+    history[1] = output;
+
+    return output;
+}
+
 static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
 {
-    /* stub */
+    /* Low-pass filter the incoming sample. */
+    in = lpFilter2P(&dsb->eax.LpFilter, 0, in);
 
     /* Step all delays forward one sample. */
     dsb->eax.Offset++;
@@ -137,6 +152,27 @@ void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count)
     HeapFree(GetProcessHeap(), 0, out);
 }
 
+static float lpCoeffCalc(float g, float cw)
+{
+    float a = 0.0f;
+
+    if (g < 0.9999f) /* 1-epsilon */
+    {
+        /* Be careful with gains < 0.001, as that causes the coefficient head
+         * towards 1, which will flatten the signal */
+        if (g < 0.001f) g = 0.001f;
+        a = (1 - g*cw - sqrtf(2*g*(1-cw) - g*g*(1 - cw*cw))) /
+            (1 - g);
+    }
+
+    return a;
+}
+
+static float CalcI3DL2HFreq(float hfRef, unsigned int frequency)
+{
+    return cosf(M_PI*2.0f * hfRef / frequency);
+}
+
 static unsigned int NextPowerOf2(unsigned int value)
 {
     if (value > 0)
@@ -214,12 +250,18 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
 
 static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 {
+    float cw;
+
     /* avoid segfaults in mixing thread when we recalculate the line offsets */
     EnterCriticalSection(&dsb->device->mixlock);
 
     AllocLines(dsb->device->pwfx->nSamplesPerSec, dsb);
 
     LeaveCriticalSection(&dsb->device->mixlock);
+
+    cw = CalcI3DL2HFreq(dsb->device->eax.eax_props.flHFReference, dsb->device->pwfx->nSamplesPerSec);
+
+    dsb->eax.LpFilter.coeff = lpCoeffCalc(dsb->device->eax.eax_props.flGainHF, cw);
 }
 
 static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
@@ -238,6 +280,10 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
     dsb->eax.TotalSamples = 0;
     dsb->eax.SampleBuffer = NULL;
 
+    dsb->eax.LpFilter.coeff = 0.0f;
+    dsb->eax.LpFilter.history[0] = 0.0f;
+    dsb->eax.LpFilter.history[1] = 0.0f;
+
     dsb->eax.Delay.Mask = 0;
     dsb->eax.Delay.Line = NULL;
 

From cb79cfe479dde2b45e3618d61279679cb4dfb215 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 18:00:10 +0000
Subject: [PATCH 038/244] dsound: Add delay line EAX functions.

---
 dlls/dsound/dsound_eax.h |  1 +
 dlls/dsound/eax.c        | 27 +++++++++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index 82b140848d7..bd002d7ad58 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -142,6 +142,7 @@ typedef struct {
     FILTER LpFilter;
 
     DelayLine Delay;
+    unsigned int DelayTap[2];
 
     unsigned int Offset;
 } eax_buffer_info;
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index b71af333229..4756049ddb7 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -106,11 +106,26 @@ static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
     return output;
 }
 
+static void DelayLineIn(DelayLine *Delay, unsigned int offset, float in)
+{
+    Delay->Line[offset&Delay->Mask] = in;
+}
+
+static float DelayLineOut(DelayLine *Delay, unsigned int offset)
+{
+    return Delay->Line[offset&Delay->Mask];
+}
+
 static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
 {
     /* Low-pass filter the incoming sample. */
     in = lpFilter2P(&dsb->eax.LpFilter, 0, in);
 
+    /* Feed the initial delay line. */
+    DelayLineIn(&dsb->eax.Delay, dsb->eax.Offset, in);
+
+    in = DelayLineOut(&dsb->eax.Delay, dsb->eax.Offset - dsb->eax.DelayTap[0]);
+
     /* Step all delays forward one sample. */
     dsb->eax.Offset++;
 }
@@ -152,6 +167,12 @@ void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count)
     HeapFree(GetProcessHeap(), 0, out);
 }
 
+static void UpdateDelayLine(float earlyDelay, float lateDelay, unsigned int frequency, eax_buffer_info *State)
+{
+    State->DelayTap[0] = fastf2u(earlyDelay * frequency);
+    State->DelayTap[1] = fastf2u((earlyDelay + lateDelay) * frequency);
+}
+
 static float lpCoeffCalc(float g, float cw)
 {
     float a = 0.0f;
@@ -262,6 +283,10 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
     cw = CalcI3DL2HFreq(dsb->device->eax.eax_props.flHFReference, dsb->device->pwfx->nSamplesPerSec);
 
     dsb->eax.LpFilter.coeff = lpCoeffCalc(dsb->device->eax.eax_props.flGainHF, cw);
+
+    UpdateDelayLine(dsb->device->eax.eax_props.flReflectionsDelay,
+                    dsb->device->eax.eax_props.flLateReverbDelay,
+                    dsb->device->pwfx->nSamplesPerSec, &dsb->eax);
 }
 
 static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
@@ -286,6 +311,8 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
 
     dsb->eax.Delay.Mask = 0;
     dsb->eax.Delay.Line = NULL;
+    dsb->eax.DelayTap[0] = 0;
+    dsb->eax.DelayTap[1] = 0;
 
     dsb->eax.Offset = 0;
 

From fa9a0e9e7482aa0997c03fae2ee61cda3d94ebd4 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 18:09:34 +0000
Subject: [PATCH 039/244] dsound: Implement EAX early reflections.

---
 dlls/dsound/dsound_eax.h |   7 +++
 dlls/dsound/eax.c        | 114 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 121 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index bd002d7ad58..184f7cec3c1 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -144,6 +144,13 @@ typedef struct {
     DelayLine Delay;
     unsigned int DelayTap[2];
 
+    struct {
+        float Gain;
+        float Coeff[4];
+        DelayLine Delay[4];
+        unsigned int Offset[4];
+    } Early;
+
     unsigned int Offset;
 } eax_buffer_info;
 
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 4756049ddb7..6efdd56512c 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,6 +92,11 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+static const float EARLY_LINE_LENGTH[4] =
+{
+    0.0015f, 0.0045f, 0.0135f, 0.0405f
+};
+
 static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
 {
     float *history = &iir->history[offset*2];
@@ -116,6 +121,62 @@ static float DelayLineOut(DelayLine *Delay, unsigned int offset)
     return Delay->Line[offset&Delay->Mask];
 }
 
+static float AttenuatedDelayLineOut(DelayLine *Delay, unsigned int offset, float coeff)
+{
+    return coeff * Delay->Line[offset&Delay->Mask];
+}
+
+static float EarlyDelayLineOut(IDirectSoundBufferImpl* dsb, unsigned int index)
+{
+    return AttenuatedDelayLineOut(&dsb->eax.Early.Delay[index],
+                                  dsb->eax.Offset - dsb->eax.Early.Offset[index],
+                                  dsb->eax.Early.Coeff[index]);
+}
+
+static void EarlyReflection(IDirectSoundBufferImpl* dsb, float in, float *out)
+{
+    float d[4], v, f[4];
+
+    /* Obtain the decayed results of each early delay line. */
+    d[0] = EarlyDelayLineOut(dsb, 0);
+    d[1] = EarlyDelayLineOut(dsb, 1);
+    d[2] = EarlyDelayLineOut(dsb, 2);
+    d[3] = EarlyDelayLineOut(dsb, 3);
+
+    /* The following uses a lossless scattering junction from waveguide
+     * theory.  It actually amounts to a householder mixing matrix, which
+     * will produce a maximally diffuse response, and means this can probably
+     * be considered a simple feed-back delay network (FDN).
+     *          N
+     *         ---
+     *         \
+     * v = 2/N /   d_i
+     *         ---
+     *         i=1
+     */
+    v = (d[0] + d[1] + d[2] + d[3]) * 0.5f;
+    /* The junction is loaded with the input here. */
+    v += in;
+
+    /* Calculate the feed values for the delay lines. */
+    f[0] = v - d[0];
+    f[1] = v - d[1];
+    f[2] = v - d[2];
+    f[3] = v - d[3];
+
+    /* Re-feed the delay lines. */
+    DelayLineIn(&dsb->eax.Early.Delay[0], dsb->eax.Offset, f[0]);
+    DelayLineIn(&dsb->eax.Early.Delay[1], dsb->eax.Offset, f[1]);
+    DelayLineIn(&dsb->eax.Early.Delay[2], dsb->eax.Offset, f[2]);
+    DelayLineIn(&dsb->eax.Early.Delay[3], dsb->eax.Offset, f[3]);
+
+    /* Output the results of the junction for all four channels. */
+    out[0] = dsb->eax.Early.Gain * f[0];
+    out[1] = dsb->eax.Early.Gain * f[1];
+    out[2] = dsb->eax.Early.Gain * f[2];
+    out[3] = dsb->eax.Early.Gain * f[3];
+}
+
 static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
 {
     /* Low-pass filter the incoming sample. */
@@ -124,7 +185,9 @@ static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
     /* Feed the initial delay line. */
     DelayLineIn(&dsb->eax.Delay, dsb->eax.Offset, in);
 
+    /* Calculate the early reflection from the first delay tap. */
     in = DelayLineOut(&dsb->eax.Delay, dsb->eax.Offset - dsb->eax.DelayTap[0]);
+    EarlyReflection(dsb, in, out);
 
     /* Step all delays forward one sample. */
     dsb->eax.Offset++;
@@ -173,6 +236,27 @@ static void UpdateDelayLine(float earlyDelay, float lateDelay, unsigned int freq
     State->DelayTap[1] = fastf2u((earlyDelay + lateDelay) * frequency);
 }
 
+static float CalcDecayCoeff(float length, float decayTime)
+{
+    return powf(0.001f/*-60 dB*/, length/decayTime);
+}
+
+static void UpdateEarlyLines(float reverbGain, float earlyGain, float lateDelay, eax_buffer_info *State)
+{
+    unsigned int index;
+
+    /* Calculate the early reflections gain (from the master effect gain, and
+     * reflections gain parameters) with a constant attenuation of 0.5. */
+    State->Early.Gain = 0.5f * reverbGain * earlyGain;
+
+    /* Calculate the gain (coefficient) for each early delay line using the
+     * late delay time.  This expands the early reflections to the start of
+     * the late reverb. */
+    for(index = 0; index < 4; index++)
+        State->Early.Coeff[index] = CalcDecayCoeff(EARLY_LINE_LENGTH[index],
+                                                   lateDelay);
+}
+
 static float lpCoeffCalc(float g, float cw)
 {
     float a = 0.0f;
@@ -244,6 +328,11 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
     totalSamples += CalcLineLength(length, totalSamples, frequency,
                                    &dsb->eax.Delay);
 
+    /* The early reflection lines. */
+    for (index = 0; index < 4; index++)
+        totalSamples += CalcLineLength(EARLY_LINE_LENGTH[index], totalSamples,
+                                       frequency, &dsb->eax.Early.Delay[index]);
+
     if (totalSamples != dsb->eax.TotalSamples)
     {
         TRACE("New reverb buffer length: %u samples (%f sec)\n", totalSamples, totalSamples/(float)frequency);
@@ -261,6 +350,10 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
 
     /* Update all delays to reflect the new sample buffer. */
     RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Delay);
+    for(index = 0; index < 4; index++)
+    {
+        RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Early.Delay[index]);
+    }
 
     /* Clear the sample buffer. */
     for (index = 0; index < dsb->eax.TotalSamples; index++)
@@ -271,6 +364,7 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
 
 static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 {
+    unsigned int index;
     float cw;
 
     /* avoid segfaults in mixing thread when we recalculate the line offsets */
@@ -280,6 +374,11 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 
     LeaveCriticalSection(&dsb->device->mixlock);
 
+    for(index = 0; index < 4; index++)
+    {
+        dsb->eax.Early.Offset[index] = fastf2u(EARLY_LINE_LENGTH[index] * dsb->device->pwfx->nSamplesPerSec);
+    }
+
     cw = CalcI3DL2HFreq(dsb->device->eax.eax_props.flHFReference, dsb->device->pwfx->nSamplesPerSec);
 
     dsb->eax.LpFilter.coeff = lpCoeffCalc(dsb->device->eax.eax_props.flGainHF, cw);
@@ -287,6 +386,10 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
     UpdateDelayLine(dsb->device->eax.eax_props.flReflectionsDelay,
                     dsb->device->eax.eax_props.flLateReverbDelay,
                     dsb->device->pwfx->nSamplesPerSec, &dsb->eax);
+
+    UpdateEarlyLines(dsb->device->eax.eax_props.flGain,
+                    dsb->device->eax.eax_props.flReflectionsGain,
+                    dsb->device->eax.eax_props.flLateReverbDelay, &dsb->eax);
 }
 
 static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
@@ -302,6 +405,8 @@ static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
 
 void init_eax_buffer(IDirectSoundBufferImpl *dsb)
 {
+    unsigned int index;
+
     dsb->eax.TotalSamples = 0;
     dsb->eax.SampleBuffer = NULL;
 
@@ -314,6 +419,15 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
     dsb->eax.DelayTap[0] = 0;
     dsb->eax.DelayTap[1] = 0;
 
+    dsb->eax.Early.Gain = 0.0f;
+    for(index = 0; index < 4; index++)
+    {
+        dsb->eax.Early.Coeff[index] = 0.0f;
+        dsb->eax.Early.Delay[index].Mask = 0;
+        dsb->eax.Early.Delay[index].Line = NULL;
+        dsb->eax.Early.Offset[index] = 0;
+    }
+
     dsb->eax.Offset = 0;
 
     ReverbUpdate(dsb);

From 78ae5110c392f8de652afd6691deb4ca2258a23f Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 18:19:17 +0000
Subject: [PATCH 040/244] dsound: Implement EAX decorrelator.

---
 dlls/dsound/dsound_eax.h |  3 +++
 dlls/dsound/eax.c        | 46 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 49 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index 184f7cec3c1..c33a2ff8cb3 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -151,6 +151,9 @@ typedef struct {
         unsigned int Offset[4];
     } Early;
 
+    DelayLine Decorrelator;
+    unsigned int DecoTap[3];
+
     unsigned int Offset;
 } eax_buffer_info;
 
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 6efdd56512c..e73d6ab6d75 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -92,11 +92,21 @@ static const EFXEAXREVERBPROPERTIES efx_presets[] = {
     { 0.0625f, 0.5000f, 0.3162f, 0.8404f, 1.0000f, 7.5600f, 0.9100f, 1.0000f, 0.4864f, 0.0200f, { 0.0000f, 0.0000f, 0.0000f }, 2.4378f, 0.0300f, { 0.0000f, 0.0000f, 0.0000f }, 0.2500f, 0.0000f, 4.0000f, 1.0000f, 0.9943f, 5000.0000f, 250.0000f, 0.0000f, 0x0 } /* psychotic */
 };
 
+static const float DECO_FRACTION = 0.15f;
+static const float DECO_MULTIPLIER = 2.0f;
+
 static const float EARLY_LINE_LENGTH[4] =
 {
     0.0015f, 0.0045f, 0.0135f, 0.0405f
 };
 
+static const float LATE_LINE_LENGTH[4] =
+{
+    0.0211f, 0.0311f, 0.0461f, 0.0680f
+};
+
+static const float LATE_LINE_MULTIPLIER = 4.0f;
+
 static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
 {
     float *history = &iir->history[offset*2];
@@ -273,6 +283,26 @@ static float lpCoeffCalc(float g, float cw)
     return a;
 }
 
+static void UpdateDecorrelator(float density, unsigned int frequency, eax_buffer_info *State)
+{
+    unsigned int index;
+    float length;
+
+    /* The late reverb inputs are decorrelated to smooth the reverb tail and
+     * reduce harsh echos.  The first tap occurs immediately, while the
+     * remaining taps are delayed by multiples of a fraction of the smallest
+     * cyclical delay time.
+     *
+     * offset[index] = (FRACTION (MULTIPLIER^index)) smallest_delay
+     */
+    for (index = 0; index < 3; index++)
+    {
+        length = (DECO_FRACTION * powf(DECO_MULTIPLIER, (float)index)) *
+                 LATE_LINE_LENGTH[0] * (1.0f + (density * LATE_LINE_MULTIPLIER));
+        State->DecoTap[index] = fastf2u(length * frequency);
+    }
+}
+
 static float CalcI3DL2HFreq(float hfRef, unsigned int frequency)
 {
     return cosf(M_PI*2.0f * hfRef / frequency);
@@ -333,6 +363,13 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
         totalSamples += CalcLineLength(EARLY_LINE_LENGTH[index], totalSamples,
                                        frequency, &dsb->eax.Early.Delay[index]);
 
+    /* The decorrelator line is calculated from the lowest reverb density (a
+     * parameter value of 1). */
+    length = (DECO_FRACTION * DECO_MULTIPLIER * DECO_MULTIPLIER) *
+             LATE_LINE_LENGTH[0] * (1.0f + LATE_LINE_MULTIPLIER);
+    totalSamples += CalcLineLength(length, totalSamples, frequency,
+                                   &dsb->eax.Decorrelator);
+
     if (totalSamples != dsb->eax.TotalSamples)
     {
         TRACE("New reverb buffer length: %u samples (%f sec)\n", totalSamples, totalSamples/(float)frequency);
@@ -350,6 +387,7 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
 
     /* Update all delays to reflect the new sample buffer. */
     RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Delay);
+    RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Decorrelator);
     for(index = 0; index < 4; index++)
     {
         RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Early.Delay[index]);
@@ -390,6 +428,8 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
     UpdateEarlyLines(dsb->device->eax.eax_props.flGain,
                     dsb->device->eax.eax_props.flReflectionsGain,
                     dsb->device->eax.eax_props.flLateReverbDelay, &dsb->eax);
+
+    UpdateDecorrelator(dsb->device->eax.eax_props.flDensity, dsb->device->pwfx->nSamplesPerSec, &dsb->eax);
 }
 
 static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
@@ -428,6 +468,12 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
         dsb->eax.Early.Offset[index] = 0;
     }
 
+    dsb->eax.Decorrelator.Mask = 0;
+    dsb->eax.Decorrelator.Line = NULL;
+    dsb->eax.DecoTap[0] = 0;
+    dsb->eax.DecoTap[1] = 0;
+    dsb->eax.DecoTap[2] = 0;
+
     dsb->eax.Offset = 0;
 
     ReverbUpdate(dsb);

From f3efc0e4bc844517ae2b6825ae7e8fd87210cfb3 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 18:21:02 +0000
Subject: [PATCH 041/244] dsound: Implement EAX late reverb.

---
 dlls/dsound/dsound_eax.h |  13 ++
 dlls/dsound/eax.c        | 256 ++++++++++++++++++++++++++++++++++++++-
 2 files changed, 268 insertions(+), 1 deletion(-)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index c33a2ff8cb3..fac4d9b6d57 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -154,6 +154,19 @@ typedef struct {
     DelayLine Decorrelator;
     unsigned int DecoTap[3];
 
+    struct {
+        float Gain;
+        float DensityGain;
+        float MixCoeff;
+
+        float Coeff[4];
+        DelayLine Delay[4];
+        unsigned int Offset[4];
+
+        float LpCoeff[4];
+        float LpSample[4];
+    } Late;
+
     unsigned int Offset;
 } eax_buffer_info;
 
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index e73d6ab6d75..e8f84022db4 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -107,6 +107,8 @@ static const float LATE_LINE_LENGTH[4] =
 
 static const float LATE_LINE_MULTIPLIER = 4.0f;
 
+#define SPEEDOFSOUNDMETRESPERSEC 343.3f
+
 static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
 {
     float *history = &iir->history[offset*2];
@@ -121,6 +123,11 @@ static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
     return output;
 }
 
+static float lerp(float val1, float val2, float mu)
+{
+    return val1 + (val2-val1)*mu;
+}
+
 static void DelayLineIn(DelayLine *Delay, unsigned int offset, float in)
 {
     Delay->Line[offset&Delay->Mask] = in;
@@ -187,8 +194,85 @@ static void EarlyReflection(IDirectSoundBufferImpl* dsb, float in, float *out)
     out[3] = dsb->eax.Early.Gain * f[3];
 }
 
+static float LateDelayLineOut(IDirectSoundBufferImpl* dsb, unsigned int index)
+{
+    return AttenuatedDelayLineOut(&dsb->eax.Late.Delay[index],
+                                  dsb->eax.Offset - dsb->eax.Late.Offset[index],
+                                  dsb->eax.Late.Coeff[index]);
+}
+
+static float LateLowPassInOut(IDirectSoundBufferImpl* dsb, unsigned int index, float in)
+{
+    in = lerp(in, dsb->eax.Late.LpSample[index], dsb->eax.Late.LpCoeff[index]);
+    dsb->eax.Late.LpSample[index] = in;
+    return in;
+}
+
+static void LateReverb(IDirectSoundBufferImpl* dsb, const float *in, float *out)
+{
+    float d[4], f[4];
+
+    /* Obtain the decayed results of the cyclical delay lines, and add the
+     * corresponding input channels.  Then pass the results through the
+     * low-pass filters. */
+
+    /* This is where the feed-back cycles from line 0 to 1 to 3 to 2 and back
+     * to 0. */
+    d[0] = LateLowPassInOut(dsb, 2, in[2] + LateDelayLineOut(dsb, 2));
+    d[1] = LateLowPassInOut(dsb, 0, in[0] + LateDelayLineOut(dsb, 0));
+    d[2] = LateLowPassInOut(dsb, 3, in[3] + LateDelayLineOut(dsb, 3));
+    d[3] = LateLowPassInOut(dsb, 1, in[1] + LateDelayLineOut(dsb, 1));
+
+    /* Late reverb is done with a modified feed-back delay network (FDN)
+     * topology.  Four input lines are each fed through their own all-pass
+     * filter and then into the mixing matrix.  The four outputs of the
+     * mixing matrix are then cycled back to the inputs.  Each output feeds
+     * a different input to form a circlular feed cycle.
+     *
+     * The mixing matrix used is a 4D skew-symmetric rotation matrix derived
+     * using a single unitary rotational parameter:
+     *
+     *  [  d,  a,  b,  c ]          1 = a^2 + b^2 + c^2 + d^2
+     *  [ -a,  d,  c, -b ]
+     *  [ -b, -c,  d,  a ]
+     *  [ -c,  b, -a,  d ]
+     *
+     * The rotation is constructed from the effect's diffusion parameter,
+     * yielding:  1 = x^2 + 3 y^2; where a, b, and c are the coefficient y
+     * with differing signs, and d is the coefficient x.  The matrix is thus:
+     *
+     *  [  x,  y, -y,  y ]          n = sqrt(matrix_order - 1)
+     *  [ -y,  x,  y,  y ]          t = diffusion_parameter * atan(n)
+     *  [  y, -y,  x,  y ]          x = cos(t)
+     *  [ -y, -y, -y,  x ]          y = sin(t) / n
+     *
+     * To reduce the number of multiplies, the x coefficient is applied with
+     * the cyclical delay line coefficients.  Thus only the y coefficient is
+     * applied when mixing, and is modified to be:  y / x.
+     */
+    f[0] = d[0] + (dsb->eax.Late.MixCoeff * (         d[1] + -d[2] + d[3]));
+    f[1] = d[1] + (dsb->eax.Late.MixCoeff * (-d[0]         +  d[2] + d[3]));
+    f[2] = d[2] + (dsb->eax.Late.MixCoeff * ( d[0] + -d[1]         + d[3]));
+    f[3] = d[3] + (dsb->eax.Late.MixCoeff * (-d[0] + -d[1] + -d[2]       ));
+
+    /* Output the results of the matrix for all four channels, attenuated by
+     * the late reverb gain (which is attenuated by the 'x' mix coefficient). */
+    out[0] = dsb->eax.Late.Gain * f[0];
+    out[1] = dsb->eax.Late.Gain * f[1];
+    out[2] = dsb->eax.Late.Gain * f[2];
+    out[3] = dsb->eax.Late.Gain * f[3];
+
+    /* Re-feed the cyclical delay lines. */
+    DelayLineIn(&dsb->eax.Late.Delay[0], dsb->eax.Offset, f[0]);
+    DelayLineIn(&dsb->eax.Late.Delay[1], dsb->eax.Offset, f[1]);
+    DelayLineIn(&dsb->eax.Late.Delay[2], dsb->eax.Offset, f[2]);
+    DelayLineIn(&dsb->eax.Late.Delay[3], dsb->eax.Offset, f[3]);
+}
+
 static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
 {
+    float feed, late[4], taps[4];
+
     /* Low-pass filter the incoming sample. */
     in = lpFilter2P(&dsb->eax.LpFilter, 0, in);
 
@@ -199,6 +283,25 @@ static void VerbPass(IDirectSoundBufferImpl* dsb, float in, float* out)
     in = DelayLineOut(&dsb->eax.Delay, dsb->eax.Offset - dsb->eax.DelayTap[0]);
     EarlyReflection(dsb, in, out);
 
+    /* Feed the decorrelator from the energy-attenuated output of the second
+     * delay tap. */
+    in = DelayLineOut(&dsb->eax.Delay, dsb->eax.Offset - dsb->eax.DelayTap[1]);
+    feed = in * dsb->eax.Late.DensityGain;
+    DelayLineIn(&dsb->eax.Decorrelator, dsb->eax.Offset, feed);
+
+    /* Calculate the late reverb from the decorrelator taps. */
+    taps[0] = feed;
+    taps[1] = DelayLineOut(&dsb->eax.Decorrelator, dsb->eax.Offset - dsb->eax.DecoTap[0]);
+    taps[2] = DelayLineOut(&dsb->eax.Decorrelator, dsb->eax.Offset - dsb->eax.DecoTap[1]);
+    taps[3] = DelayLineOut(&dsb->eax.Decorrelator, dsb->eax.Offset - dsb->eax.DecoTap[2]);
+    LateReverb(dsb, taps, late);
+
+    /* Mix early reflections and late reverb. */
+    out[0] += late[0];
+    out[1] += late[1];
+    out[2] += late[2];
+    out[3] += late[3];
+
     /* Step all delays forward one sample. */
     dsb->eax.Offset++;
 }
@@ -308,6 +411,95 @@ static float CalcI3DL2HFreq(float hfRef, unsigned int frequency)
     return cosf(M_PI*2.0f * hfRef / frequency);
 }
 
+static float CalcDensityGain(float a)
+{
+    return sqrtf(1.0f - (a * a));
+}
+
+static float CalcDampingCoeff(float hfRatio, float length, float decayTime, float decayCoeff, float cw)
+{
+    float coeff, g;
+
+    coeff = 0.0f;
+    if (hfRatio < 1.0f)
+    {
+        /* Calculate the low-pass coefficient by dividing the HF decay
+         * coefficient by the full decay coefficient. */
+        g = CalcDecayCoeff(length, decayTime * hfRatio) / decayCoeff;
+
+        /* Damping is done with a 1-pole filter, so g needs to be squared. */
+        g *= g;
+        coeff = lpCoeffCalc(g, cw);
+
+        /* Very low decay times will produce minimal output, so apply an
+         * upper bound to the coefficient. */
+        if (coeff > 0.98f) coeff = 0.98f;
+    }
+    return coeff;
+}
+
+static void UpdateLateLines(float reverbGain, float lateGain, float xMix, float density, float decayTime,
+                            float diffusion, float hfRatio, float cw, unsigned int frequency, eax_buffer_info *State)
+{
+    float length;
+    unsigned int index;
+
+    /* Calculate the late reverb gain (from the master effect gain, and late
+     * reverb gain parameters).  Since the output is tapped prior to the
+     * application of the next delay line coefficients, this gain needs to be
+     * attenuated by the 'x' mixing matrix coefficient as well.
+     */
+    State->Late.Gain = reverbGain * lateGain * xMix;
+
+    /* To compensate for changes in modal density and decay time of the late
+     * reverb signal, the input is attenuated based on the maximal energy of
+     * the outgoing signal.  This approximation is used to keep the apparent
+     * energy of the signal equal for all ranges of density and decay time.
+     *
+     * The average length of the cyclcical delay lines is used to calculate
+     * the attenuation coefficient.
+     */
+    length = (LATE_LINE_LENGTH[0] + LATE_LINE_LENGTH[1] +
+              LATE_LINE_LENGTH[2] + LATE_LINE_LENGTH[3]) / 4.0f;
+    length *= 1.0f + (density * LATE_LINE_MULTIPLIER);
+    State->Late.DensityGain = CalcDensityGain(CalcDecayCoeff(length,
+                                                             decayTime));
+
+    for(index = 0; index < 4; index++)
+    {
+        /* Calculate the length (in seconds) of each cyclical delay line. */
+        length = LATE_LINE_LENGTH[index] * (1.0f + (density * LATE_LINE_MULTIPLIER));
+
+        /* Calculate the delay offset for each cyclical delay line. */
+        State->Late.Offset[index] = fastf2u(length * frequency);
+
+        /* Calculate the gain (coefficient) for each cyclical line. */
+        State->Late.Coeff[index] = CalcDecayCoeff(length, decayTime);
+
+        /* Calculate the damping coefficient for each low-pass filter. */
+        State->Late.LpCoeff[index] = CalcDampingCoeff(hfRatio, length, decayTime,
+                             State->Late.Coeff[index], cw);
+
+        /* Attenuate the cyclical line coefficients by the mixing coefficient
+         * (x). */
+        State->Late.Coeff[index] *= xMix;
+    }
+}
+
+static void CalcMatrixCoeffs(float diffusion, float *x, float *y)
+{
+    float n, t;
+
+    /* The matrix is of order 4, so n is sqrt (4 - 1). */
+    n = sqrtf(3.0f);
+    t = diffusion * atanf(n);
+
+    /* Calculate the first mixing matrix coefficient. */
+    *x = cosf(t);
+    /* Calculate the second mixing matrix coefficient. */
+    *y = sinf(t) / n;
+}
+
 static unsigned int NextPowerOf2(unsigned int value)
 {
     if (value > 0)
@@ -370,6 +562,14 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
     totalSamples += CalcLineLength(length, totalSamples, frequency,
                                    &dsb->eax.Decorrelator);
 
+    /* The late delay lines are calculated from the lowest reverb density. */
+    for (index = 0; index < 4; index++)
+    {
+        length = LATE_LINE_LENGTH[index] * (1.0f + LATE_LINE_MULTIPLIER);
+        totalSamples += CalcLineLength(length, totalSamples, frequency,
+                                       &dsb->eax.Late.Delay[index]);
+    }
+
     if (totalSamples != dsb->eax.TotalSamples)
     {
         TRACE("New reverb buffer length: %u samples (%f sec)\n", totalSamples, totalSamples/(float)frequency);
@@ -391,6 +591,7 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
     for(index = 0; index < 4; index++)
     {
         RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Early.Delay[index]);
+        RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Late.Delay[index]);
     }
 
     /* Clear the sample buffer. */
@@ -400,10 +601,35 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
     return TRUE;
 }
 
+static inline float CalcDecayLength(float coeff, float decayTime)
+{
+    return log10f(coeff) * decayTime / log10f(0.001f)/*-60 dB*/;
+}
+
+static float CalcLimitedHfRatio(float hfRatio, float airAbsorptionGainHF, float decayTime)
+{
+    float limitRatio;
+
+    /* Find the attenuation due to air absorption in dB (converting delay
+     * time to meters using the speed of sound).  Then reversing the decay
+     * equation, solve for HF ratio.  The delay length is cancelled out of
+     * the equation, so it can be calculated once for all lines.
+     */
+    limitRatio = 1.0f / (CalcDecayLength(airAbsorptionGainHF, decayTime) *
+                         SPEEDOFSOUNDMETRESPERSEC);
+    /* Using the limit calculated above, apply the upper bound to the HF
+     * ratio. Also need to limit the result to a minimum of 0.1, just like the
+     * HF ratio parameter. */
+    if (limitRatio < 0.1f) limitRatio = 0.1f;
+    else if (limitRatio > hfRatio) limitRatio = hfRatio;
+
+    return limitRatio;
+}
+
 static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
 {
     unsigned int index;
-    float cw;
+    float cw, hfRatio, x, y;
 
     /* avoid segfaults in mixing thread when we recalculate the line offsets */
     EnterCriticalSection(&dsb->device->mixlock);
@@ -430,6 +656,20 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
                     dsb->device->eax.eax_props.flLateReverbDelay, &dsb->eax);
 
     UpdateDecorrelator(dsb->device->eax.eax_props.flDensity, dsb->device->pwfx->nSamplesPerSec, &dsb->eax);
+
+    CalcMatrixCoeffs(dsb->device->eax.eax_props.flDiffusion, &x, &y);
+    dsb->eax.Late.MixCoeff = y / x;
+
+    hfRatio = dsb->device->eax.eax_props.flDecayHFRatio;
+
+    if (dsb->device->eax.eax_props.iDecayHFLimit && dsb->device->eax.eax_props.flAirAbsorptionGainHF < 1.0f) {
+        hfRatio = CalcLimitedHfRatio(hfRatio, dsb->device->eax.eax_props.flAirAbsorptionGainHF,
+                                     dsb->device->eax.eax_props.flDecayTime);
+    }
+
+    UpdateLateLines(dsb->device->eax.eax_props.flGain, dsb->device->eax.eax_props.flLateReverbGain,
+                    x, dsb->device->eax.eax_props.flDensity, dsb->device->eax.eax_props.flDecayTime,
+                    dsb->device->eax.eax_props.flDiffusion, hfRatio, cw, dsb->device->pwfx->nSamplesPerSec, &dsb->eax);
 }
 
 static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
@@ -474,6 +714,20 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
     dsb->eax.DecoTap[1] = 0;
     dsb->eax.DecoTap[2] = 0;
 
+    dsb->eax.Late.Gain = 0.0f;
+    dsb->eax.Late.DensityGain = 0.0f;
+    dsb->eax.Late.MixCoeff = 0.0f;
+    for(index = 0; index < 4; index++)
+    {
+        dsb->eax.Late.Coeff[index] = 0.0f;
+        dsb->eax.Late.Delay[index].Mask = 0;
+        dsb->eax.Late.Delay[index].Line = NULL;
+        dsb->eax.Late.Offset[index] = 0;
+
+        dsb->eax.Late.LpCoeff[index] = 0.0f;
+        dsb->eax.Late.LpSample[index] = 0.0f;
+    }
+
     dsb->eax.Offset = 0;
 
     ReverbUpdate(dsb);

From 9cdccf42b8c97c79ae0dfc926f6c149ff670e324 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 22 Mar 2015 18:21:18 +0000
Subject: [PATCH 042/244] dsound: Implement EAX late all-pass filter.

---
 dlls/dsound/dsound_eax.h |  5 ++++
 dlls/dsound/eax.c        | 55 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 60 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index fac4d9b6d57..a650108f570 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -157,8 +157,13 @@ typedef struct {
     struct {
         float Gain;
         float DensityGain;
+        float ApFeedCoeff;
         float MixCoeff;
 
+        float ApCoeff[4];
+        DelayLine ApDelay[4];
+        unsigned int ApOffset[4];
+
         float Coeff[4];
         DelayLine Delay[4];
         unsigned int Offset[4];
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index e8f84022db4..5f2b8ef07e2 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -100,6 +100,11 @@ static const float EARLY_LINE_LENGTH[4] =
     0.0015f, 0.0045f, 0.0135f, 0.0405f
 };
 
+static const float ALLPASS_LINE_LENGTH[4] =
+{
+    0.0151f, 0.0167f, 0.0183f, 0.0200f,
+};
+
 static const float LATE_LINE_LENGTH[4] =
 {
     0.0211f, 0.0311f, 0.0461f, 0.0680f
@@ -194,6 +199,28 @@ static void EarlyReflection(IDirectSoundBufferImpl* dsb, float in, float *out)
     out[3] = dsb->eax.Early.Gain * f[3];
 }
 
+static float AllpassInOut(DelayLine *Delay, unsigned int outOffset, unsigned int inOffset, float in, float feedCoeff, float coeff)
+{
+    float out, feed;
+
+    out = DelayLineOut(Delay, outOffset);
+    feed = feedCoeff * in;
+    DelayLineIn(Delay, inOffset, (feedCoeff * (out - feed)) + in);
+
+    /* The time-based attenuation is only applied to the delay output to
+     * keep it from affecting the feed-back path (which is already controlled
+     * by the all-pass feed coefficient). */
+    return (coeff * out) - feed;
+}
+
+static float LateAllPassInOut(IDirectSoundBufferImpl* dsb, unsigned int index, float in)
+{
+    return AllpassInOut(&dsb->eax.Late.ApDelay[index],
+                        dsb->eax.Offset - dsb->eax.Late.ApOffset[index],
+                        dsb->eax.Offset, in, dsb->eax.Late.ApFeedCoeff,
+                        dsb->eax.Late.ApCoeff[index]);
+}
+
 static float LateDelayLineOut(IDirectSoundBufferImpl* dsb, unsigned int index)
 {
     return AttenuatedDelayLineOut(&dsb->eax.Late.Delay[index],
@@ -223,6 +250,14 @@ static void LateReverb(IDirectSoundBufferImpl* dsb, const float *in, float *out)
     d[2] = LateLowPassInOut(dsb, 3, in[3] + LateDelayLineOut(dsb, 3));
     d[3] = LateLowPassInOut(dsb, 1, in[1] + LateDelayLineOut(dsb, 1));
 
+    /* To help increase diffusion, run each line through an all-pass filter.
+     * When there is no diffusion, the shortest all-pass filter will feed the
+     * shortest delay line. */
+    d[0] = LateAllPassInOut(dsb, 0, d[0]);
+    d[1] = LateAllPassInOut(dsb, 1, d[1]);
+    d[2] = LateAllPassInOut(dsb, 2, d[2]);
+    d[3] = LateAllPassInOut(dsb, 3, d[3]);
+
     /* Late reverb is done with a modified feed-back delay network (FDN)
      * topology.  Four input lines are each fed through their own all-pass
      * filter and then into the mixing matrix.  The four outputs of the
@@ -465,8 +500,15 @@ static void UpdateLateLines(float reverbGain, float lateGain, float xMix, float
     State->Late.DensityGain = CalcDensityGain(CalcDecayCoeff(length,
                                                              decayTime));
 
+    /* Calculate the all-pass feed-back and feed-forward coefficient. */
+    State->Late.ApFeedCoeff = 0.5f * powf(diffusion, 2.0f);
+
     for(index = 0; index < 4; index++)
     {
+        /* Calculate the gain (coefficient) for each all-pass line. */
+        State->Late.ApCoeff[index] = CalcDecayCoeff(ALLPASS_LINE_LENGTH[index],
+                                                    decayTime);
+
         /* Calculate the length (in seconds) of each cyclical delay line. */
         length = LATE_LINE_LENGTH[index] * (1.0f + (density * LATE_LINE_MULTIPLIER));
 
@@ -562,6 +604,11 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
     totalSamples += CalcLineLength(length, totalSamples, frequency,
                                    &dsb->eax.Decorrelator);
 
+    /* The late all-pass lines. */
+    for(index = 0;index < 4;index++)
+        totalSamples += CalcLineLength(ALLPASS_LINE_LENGTH[index], totalSamples,
+                                       frequency, &dsb->eax.Late.ApDelay[index]);
+
     /* The late delay lines are calculated from the lowest reverb density. */
     for (index = 0; index < 4; index++)
     {
@@ -591,6 +638,7 @@ static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
     for(index = 0; index < 4; index++)
     {
         RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Early.Delay[index]);
+        RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Late.ApDelay[index]);
         RealizeLineOffset(dsb->eax.SampleBuffer, &dsb->eax.Late.Delay[index]);
     }
 
@@ -641,6 +689,7 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
     for(index = 0; index < 4; index++)
     {
         dsb->eax.Early.Offset[index] = fastf2u(EARLY_LINE_LENGTH[index] * dsb->device->pwfx->nSamplesPerSec);
+        dsb->eax.Late.ApOffset[index] = fastf2u(ALLPASS_LINE_LENGTH[index] * dsb->device->pwfx->nSamplesPerSec);
     }
 
     cw = CalcI3DL2HFreq(dsb->device->eax.eax_props.flHFReference, dsb->device->pwfx->nSamplesPerSec);
@@ -716,9 +765,15 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
 
     dsb->eax.Late.Gain = 0.0f;
     dsb->eax.Late.DensityGain = 0.0f;
+    dsb->eax.Late.ApFeedCoeff = 0.0f;
     dsb->eax.Late.MixCoeff = 0.0f;
     for(index = 0; index < 4; index++)
     {
+        dsb->eax.Late.ApCoeff[index] = 0.0f;
+        dsb->eax.Late.ApDelay[index].Mask = 0;
+        dsb->eax.Late.ApDelay[index].Line = NULL;
+        dsb->eax.Late.ApOffset[index] = 0;
+
         dsb->eax.Late.Coeff[index] = 0.0f;
         dsb->eax.Late.Delay[index].Mask = 0;
         dsb->eax.Late.Delay[index].Line = NULL;

From f3a2a3dfed74fea1285e9acc86425016ccf84665 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 4 Apr 2015 21:09:18 +0200
Subject: [PATCH 043/244] dsound: Various improvements to EAX support.

The previous version had several problems (see wine-staging bug 195):
* IDirectSoundBufferImpl_Duplicate doesn't initialize EAX properties
* Various race-conditions between initializing EAX and setting buffer properties
* Missing locks while iterating through the list of sound buffers

To fix problems 2 and 3 it might seem useful to introduce additional locking,
but testing reveals that it slows down the mixer thread too much. Some applications
use a huge amount of buffers, and its a waste of time to update them all immediately.
Thats why this patch adds a 'reverb_update' variable, the mixer thread will
update it later when necessary (-> much faster). Moreover, to avoid unnecessary
locking, we initialize the EAX-specific properties always (for both the device and
the buffers).
---
 dlls/dsound/buffer.c         |  4 ++-
 dlls/dsound/dsound.c         |  2 ++
 dlls/dsound/dsound_eax.h     |  1 +
 dlls/dsound/dsound_private.h |  1 +
 dlls/dsound/eax.c            | 68 ++++++++++++++++--------------------
 5 files changed, 37 insertions(+), 39 deletions(-)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index c5f18081e33..365cecd0683 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1219,7 +1219,7 @@ HRESULT IDirectSoundBufferImpl_Duplicate(
     VOID *committedbuff;
     TRACE("(%p,%p,%p)\n", device, ppdsb, pdsb);
 
-    dsb = malloc(sizeof(*dsb));
+    dsb = calloc(1, sizeof(*dsb));
     if (dsb == NULL) {
         WARN("out of memory\n");
         *ppdsb = NULL;
@@ -1267,6 +1267,8 @@ HRESULT IDirectSoundBufferImpl_Duplicate(
 
     InitializeSRWLock(&dsb->lock);
 
+    init_eax_buffer(dsb); /* FIXME: should we duplicate EAX properties? */
+
     /* register buffer */
     hres = DirectSoundDevice_AddBuffer(device, dsb);
     if (hres != DS_OK) {
diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index f724f1a99ed..d4fd35f3243 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -181,6 +181,8 @@ static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
 
     InitializeSRWLock(&device->buffer_list_lock);
 
+    init_eax_device(device);
+
    *ppDevice = device;
 
     return DS_OK;
diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index a650108f570..a555a75e458 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -134,6 +134,7 @@ typedef struct {
 } eax_info;
 
 typedef struct {
+    BOOL reverb_update;
     float reverb_mix;
 
     float *SampleBuffer;
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index b32bcb995a6..2d413df024b 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -241,6 +241,7 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
 HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData);
+void init_eax_device(DirectSoundDevice *dev);
 void free_eax_buffer(IDirectSoundBufferImpl *dsb);
 void init_eax_buffer(IDirectSoundBufferImpl *dsb);
 void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count);
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 5f2b8ef07e2..2244565897b 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -114,6 +114,8 @@ static const float LATE_LINE_MULTIPLIER = 4.0f;
 
 #define SPEEDOFSOUNDMETRESPERSEC 343.3f
 
+static void ReverbUpdate(IDirectSoundBufferImpl *dsb);
+
 static float lpFilter2P(FILTER *iir, unsigned int offset, float input)
 {
     float *history = &iir->history[offset*2];
@@ -360,6 +362,11 @@ void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count)
         return;
     }
 
+    if (dsb->eax.reverb_update) {
+        dsb->eax.reverb_update = FALSE;
+        ReverbUpdate(dsb);
+    }
+
     out = HeapAlloc(GetProcessHeap(), 0, sizeof(float)*count*4);
 
     for (i = 0; i < count; i++) {
@@ -565,14 +572,14 @@ static unsigned int CalcLineLength(float length, unsigned int offset, unsigned i
     samples = NextPowerOf2(fastf2u(length * frequency) + 1);
     /* All lines share a single sample buffer. */
     Delay->Mask = samples - 1;
-    Delay->Line = (float*)offset;
+    Delay->Line = (float *)(ULONG_PTR)offset;
     /* Return the sample count for accumulation. */
     return samples;
 }
 
 static void RealizeLineOffset(float *sampleBuffer, DelayLine *Delay)
 {
-    Delay->Line = &sampleBuffer[(unsigned int)Delay->Line];
+    Delay->Line = &sampleBuffer[(unsigned int)(ULONG_PTR)Delay->Line];
 }
 
 static BOOL AllocLines(unsigned int frequency, IDirectSoundBufferImpl *dsb)
@@ -679,13 +686,9 @@ static void ReverbUpdate(IDirectSoundBufferImpl *dsb)
     unsigned int index;
     float cw, hfRatio, x, y;
 
-    /* avoid segfaults in mixing thread when we recalculate the line offsets */
-    EnterCriticalSection(&dsb->device->mixlock);
-
+    /* only called from the mixer thread, no race-conditions possible */
     AllocLines(dsb->device->pwfx->nSamplesPerSec, dsb);
 
-    LeaveCriticalSection(&dsb->device->mixlock);
-
     for(index = 0; index < 4; index++)
     {
         dsb->eax.Early.Offset[index] = fastf2u(EARLY_LINE_LENGTH[index] * dsb->device->pwfx->nSamplesPerSec);
@@ -725,19 +728,33 @@ static BOOL ReverbDeviceUpdate(DirectSoundDevice *dev)
 {
     int i;
 
+    AcquireSRWLockShared(&dev->buffer_list_lock);
     for (i = 0; i < dev->nrofbuffers; i++) {
-        ReverbUpdate(dev->buffers[i]);
+        dev->buffers[i]->eax.reverb_update = TRUE;
     }
+    ReleaseSRWLockShared(&dev->buffer_list_lock);
 
     return TRUE;
 }
 
+void init_eax_device(DirectSoundDevice *dev)
+{
+    dev->eax.environment = presets[0].environment;
+    dev->eax.volume = presets[0].fVolume;
+    dev->eax.damping = presets[0].fDamping;
+    memcpy(&dev->eax.eax_props, &efx_presets[0], sizeof(dev->eax.eax_props));
+    dev->eax.eax_props.flDecayTime = presets[0].fDecayTime_sec;
+}
+
 void init_eax_buffer(IDirectSoundBufferImpl *dsb)
 {
     unsigned int index;
 
-    dsb->eax.TotalSamples = 0;
+    dsb->eax.reverb_update = TRUE;
+    dsb->eax.reverb_mix = EAX_REVERBMIX_USEDISTANCE;
+
     dsb->eax.SampleBuffer = NULL;
+    dsb->eax.TotalSamples = 0;
 
     dsb->eax.LpFilter.coeff = 0.0f;
     dsb->eax.LpFilter.history[0] = 0.0f;
@@ -784,24 +801,6 @@ void init_eax_buffer(IDirectSoundBufferImpl *dsb)
     }
 
     dsb->eax.Offset = 0;
-
-    ReverbUpdate(dsb);
-}
-
-static void init_eax(DirectSoundDevice *dev)
-{
-    int i;
-
-    dev->eax.using_eax = TRUE;
-    dev->eax.environment = presets[0].environment;
-    dev->eax.volume = presets[0].fVolume;
-    dev->eax.damping = presets[0].fDamping;
-    memcpy(&dev->eax.eax_props, &efx_presets[0], sizeof(dev->eax.eax_props));
-    dev->eax.eax_props.flDecayTime = presets[0].fDecayTime_sec;
-
-    for (i = 0; i < dev->nrofbuffers; i++) {
-        init_eax_buffer(dev->buffers[i]);
-    }
 }
 
 void free_eax_buffer(IDirectSoundBufferImpl *dsb)
@@ -821,9 +820,7 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
 
     if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
         EAX_REVERBPROPERTIES *props;
-
-        if (!buf->device->eax.using_eax)
-            init_eax(buf->device);
+        buf->device->eax.using_eax = TRUE;
 
         switch (dwPropID) {
             case DSPROPERTY_EAX_ALL:
@@ -883,9 +880,7 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         return S_OK;
     } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
         EAXBUFFER_REVERBPROPERTIES *props;
-
-        if (!buf->device->eax.using_eax)
-            init_eax(buf->device);
+        buf->device->eax.using_eax = TRUE;
 
         switch (dwPropID) {
             case DSPROPERTY_EAXBUFFER_ALL:
@@ -928,8 +923,7 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
 
     if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
-        if (!buf->device->eax.using_eax)
-            init_eax(buf->device);
+        buf->device->eax.using_eax = TRUE;
 
         switch (dwPropID) {
             case DSPROPERTY_EAX_ALL:
@@ -1012,9 +1006,7 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         return S_OK;
     } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
         EAXBUFFER_REVERBPROPERTIES *props;
-
-        if (!buf->device->eax.using_eax)
-            init_eax(buf->device);
+        buf->device->eax.using_eax = TRUE;
 
         switch (dwPropID) {
             case DSPROPERTY_EAXBUFFER_ALL:

From 77e5feac14de6abcca1e925e1a6a2b51bc40c1c8 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sun, 5 Apr 2015 19:13:18 +0200
Subject: [PATCH 044/244] dsound: Allow disabling of EAX support in the
 registry.

Based on a patch by Mark Harmstone.
---
 dlls/dsound/buffer.c         | 16 ++++++----------
 dlls/dsound/dsound_main.c    |  8 ++++++++
 dlls/dsound/dsound_private.h |  3 ++-
 dlls/dsound/eax.c            | 28 ++++++++++++++++++++++++++++
 4 files changed, 44 insertions(+), 11 deletions(-)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index 365cecd0683..2f0a12298a8 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -34,6 +34,7 @@
 #include "dsconf.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 /*******************************************************************************
  *		IDirectSoundNotify
@@ -1376,16 +1377,11 @@ static HRESULT WINAPI IKsPropertySetImpl_QuerySupport(IKsPropertySet *iface, REF
 
     TRACE("(%p,%s,%ld,%p)\n",This,debugstr_guid(guidPropSet),dwPropID,pTypeSupport);
 
-    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
-        if (dwPropID <= DSPROPERTY_EAX_DAMPING) {
-            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
-            return S_OK;
-        }
-    } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
-        if (dwPropID <= DSPROPERTY_EAXBUFFER_REVERBMIX) {
-            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
-            return S_OK;
-        }
+    if (EAX_QuerySupport(guidPropSet, dwPropID, pTypeSupport)) {
+        static int once;
+        if (!once++)
+            FIXME_(winediag)("EAX sound effects are enabled - try to disable it if your app crashes unexpectedly\n");
+        return S_OK;
     }
 
     return E_PROP_ID_UNSUPPORTED;
diff --git a/dlls/dsound/dsound_main.c b/dlls/dsound/dsound_main.c
index 96e5fe2487e..d785e905527 100644
--- a/dlls/dsound/dsound_main.c
+++ b/dlls/dsound/dsound_main.c
@@ -84,6 +84,10 @@ const WCHAR wine_vxd_drv[] = L"winemm.vxd";
 /* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
 int ds_hel_buflen = 32768 * 2;
 int ds_hq_buffers_max = 4;
+BOOL ds_eax_enabled = FALSE;
+
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
 
 /*
  * Get a config key from either the app-specific or the default config
@@ -138,11 +142,15 @@ void setup_dsound_options(void)
     if (!get_config_key( hkey, appkey, "HQBuffersMax", buffer, MAX_PATH ))
         ds_hq_buffers_max = atoi(buffer);
 
+    if (!get_config_key( hkey, appkey, "EAXEnabled", buffer, MAX_PATH ))
+        ds_eax_enabled = IS_OPTION_TRUE( buffer[0] );
+
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
     TRACE("ds_hel_buflen = %d\n", ds_hel_buflen);
     TRACE("ds_hq_buffers_max = %d\n", ds_hq_buffers_max);
+    TRACE("ds_eax_enabled = %u\n", ds_eax_enabled);
 }
 
 static const char * get_device_id(LPCGUID pGuid)
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 2d413df024b..b24b013596b 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -35,9 +35,9 @@
 
 #define DS_MAX_CHANNELS 6
 
-
 extern int ds_hel_buflen;
 extern int ds_hq_buffers_max;
+extern BOOL ds_eax_enabled;
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
@@ -235,6 +235,7 @@ LONG capped_refcount_dec(LONG *ref);
 HRESULT DSOUND_FullDuplexCreate(REFIID riid, void **ppv);
 
 /* eax.c */
+BOOL WINAPI EAX_QuerySupport(REFGUID guidPropSet, ULONG dwPropID, ULONG *pTypeSupport);
 HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData, ULONG *pcbReturned);
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 2244565897b..3e15ac59480 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -809,6 +809,28 @@ void free_eax_buffer(IDirectSoundBufferImpl *dsb)
         HeapFree(GetProcessHeap(), 0, dsb->eax.SampleBuffer);
 }
 
+BOOL WINAPI EAX_QuerySupport(REFGUID guidPropSet, ULONG dwPropID, ULONG *pTypeSupport)
+{
+    TRACE("(%s,%ld,%p)\n", debugstr_guid(guidPropSet), dwPropID, pTypeSupport);
+
+    if (!ds_eax_enabled)
+        return FALSE;
+
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
+        if (dwPropID <= DSPROPERTY_EAX_DAMPING) {
+            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
+            return TRUE;
+        }
+    } else if (IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet)) {
+        if (dwPropID <= DSPROPERTY_EAXBUFFER_REVERBMIX) {
+            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
 HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
         ULONG cbPropData, ULONG *pcbReturned)
@@ -816,6 +838,9 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
     TRACE("(buf=%p,guidPropSet=%s,dwPropID=%lu,pInstanceData=%p,cbInstanceData=%lu,pPropData=%p,cbPropData=%lu,pcbReturned=%p)\n",
         buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
 
+    if (!ds_eax_enabled)
+        return E_PROP_ID_UNSUPPORTED;
+
     *pcbReturned = 0;
 
     if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
@@ -922,6 +947,9 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
     TRACE("(%p,%s,%lu,%p,%lu,%p,%lu)\n",
         buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
 
+    if (!ds_eax_enabled)
+        return E_PROP_ID_UNSUPPORTED;
+
     if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet)) {
         buf->device->eax.using_eax = TRUE;
 

From b18ad563d0d1416abb4be7e77decf3666e888f7d Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@wine-staging.com>
Date: Mon, 5 Oct 2015 21:56:15 -0600
Subject: [PATCH 045/244] dsound: Add stub support for
 DSPROPSETID_EAX20_ListenerProperties.

---
 dlls/dsound/dsound_eax.h | 21 +++++++++++++++++++++
 dlls/dsound/eax.c        | 11 +++++++++++
 2 files changed, 32 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index a555a75e458..fe85179bf01 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -28,6 +28,7 @@ extern "C" {
 
 DEFINE_GUID(DSPROPSETID_EAX_ReverbProperties, 0x4a4e6fc1, 0xc341, 0x11d1, 0xb7, 0x3a, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
 DEFINE_GUID(DSPROPSETID_EAXBUFFER_ReverbProperties, 0x4a4e6fc0, 0xc341, 0x11d1, 0xb7, 0x3a, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
+DEFINE_GUID(DSPROPSETID_EAX20_ListenerProperties, 0x306a6a8, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22);
 
 typedef enum {
     DSPROPERTY_EAX_ALL,
@@ -83,6 +84,26 @@ typedef struct {
     float fMix;
 } EAXBUFFER_REVERBPROPERTIES;
 
+typedef enum
+{
+    DSPROPERTY_EAX20LISTENER_NONE,
+    DSPROPERTY_EAX20LISTENER_ALLPARAMETERS,
+    DSPROPERTY_EAX20LISTENER_ROOM,
+    DSPROPERTY_EAX20LISTENER_ROOMHF,
+    DSPROPERTY_EAX20LISTENER_ROOMROLLOFFFACTOR,
+    DSPROPERTY_EAX20LISTENER_DECAYTIME,
+    DSPROPERTY_EAX20LISTENER_DECAYHFRATIO,
+    DSPROPERTY_EAX20LISTENER_REFLECTIONS,
+    DSPROPERTY_EAX20LISTENER_REFLECTIONSDELAY,
+    DSPROPERTY_EAX20LISTENER_REVERB,
+    DSPROPERTY_EAX20LISTENER_REVERBDELAY,
+    DSPROPERTY_EAX20LISTENER_ENVIRONMENT,
+    DSPROPERTY_EAX20LISTENER_ENVIRONMENTSIZE,
+    DSPROPERTY_EAX20LISTENER_ENVIRONMENTDIFFUSION,
+    DSPROPERTY_EAX20LISTENER_AIRABSORPTIONHF,
+    DSPROPERTY_EAX20LISTENER_FLAGS
+} DSPROPERTY_EAX20_LISTENERPROPERTY;
+
 #define EAX_REVERBMIX_USEDISTANCE -1.0f
 
 #define AL_EAXREVERB_MAX_REFLECTIONS_DELAY       (0.3f)
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 3e15ac59480..ed8dd204759 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -826,6 +826,11 @@ BOOL WINAPI EAX_QuerySupport(REFGUID guidPropSet, ULONG dwPropID, ULONG *pTypeSu
             *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
             return TRUE;
         }
+    } else if (IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet)) {
+        if (dwPropID <= DSPROPERTY_EAX20LISTENER_FLAGS) {
+            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
+            return TRUE;
+        }
     }
 
     return FALSE;
@@ -933,6 +938,9 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         }
 
         return S_OK;
+    } else if (IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet)) {
+        FIXME("Unsupported DSPROPSETID_EAX20_ListenerProperties: %ld\n", dwPropID);
+        return E_PROP_ID_UNSUPPORTED;
     }
 
     return E_PROP_ID_UNSUPPORTED;
@@ -1062,6 +1070,9 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
         }
 
         return S_OK;
+    } else if (IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet)) {
+        FIXME("Unsupported DSPROPSETID_EAX20_ListenerProperties: %ld\n", dwPropID);
+        return E_PROP_ID_UNSUPPORTED;
     }
 
     return E_PROP_ID_UNSUPPORTED;

From f14a4a77de2e46bc01eb7e1f58f6037f9c72bc63 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@wine-staging.com>
Date: Wed, 7 Oct 2015 19:31:53 -0600
Subject: [PATCH 046/244] dsound: Add stub support for
 DSPROPSETID_EAX20_BufferProperties.

---
 dlls/dsound/dsound_eax.h | 20 ++++++++++++++++++++
 dlls/dsound/eax.c        | 16 ++++++++++++++++
 2 files changed, 36 insertions(+)

diff --git a/dlls/dsound/dsound_eax.h b/dlls/dsound/dsound_eax.h
index fe85179bf01..09563a0d615 100644
--- a/dlls/dsound/dsound_eax.h
+++ b/dlls/dsound/dsound_eax.h
@@ -29,6 +29,7 @@ extern "C" {
 DEFINE_GUID(DSPROPSETID_EAX_ReverbProperties, 0x4a4e6fc1, 0xc341, 0x11d1, 0xb7, 0x3a, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
 DEFINE_GUID(DSPROPSETID_EAXBUFFER_ReverbProperties, 0x4a4e6fc0, 0xc341, 0x11d1, 0xb7, 0x3a, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
 DEFINE_GUID(DSPROPSETID_EAX20_ListenerProperties, 0x306a6a8, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22);
+DEFINE_GUID(DSPROPSETID_EAX20_BufferProperties, 0x306a6a7, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22);
 
 typedef enum {
     DSPROPERTY_EAX_ALL,
@@ -104,6 +105,25 @@ typedef enum
     DSPROPERTY_EAX20LISTENER_FLAGS
 } DSPROPERTY_EAX20_LISTENERPROPERTY;
 
+typedef enum
+{
+    DSPROPERTY_EAX20BUFFER_NONE,
+    DSPROPERTY_EAX20BUFFER_ALLPARAMETERS,
+    DSPROPERTY_EAX20BUFFER_DIRECT,
+    DSPROPERTY_EAX20BUFFER_DIRECTHF,
+    DSPROPERTY_EAX20BUFFER_ROOM,
+    DSPROPERTY_EAX20BUFFER_ROOMHF,
+    DSPROPERTY_EAX20BUFFER_ROOMROLLOFFFACTOR,
+    DSPROPERTY_EAX20BUFFER_OBSTRUCTION,
+    DSPROPERTY_EAX20BUFFER_OBSTRUCTIONLFRATIO,
+    DSPROPERTY_EAX20BUFFER_OCCLUSION,
+    DSPROPERTY_EAX20BUFFER_OCCLUSIONLFRATIO,
+    DSPROPERTY_EAX20BUFFER_OCCLUSIONROOMRATIO,
+    DSPROPERTY_EAX20BUFFER_OUTSIDEVOLUMEHF,
+    DSPROPERTY_EAX20BUFFER_AIRABSORPTIONFACTOR,
+    DSPROPERTY_EAX20BUFFER_FLAGS
+} DSPROPERTY_EAX20_BUFFERPROPERTY;
+
 #define EAX_REVERBMIX_USEDISTANCE -1.0f
 
 #define AL_EAXREVERB_MAX_REFLECTIONS_DELAY       (0.3f)
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index ed8dd204759..9237aa055e0 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -831,8 +831,14 @@ BOOL WINAPI EAX_QuerySupport(REFGUID guidPropSet, ULONG dwPropID, ULONG *pTypeSu
             *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
             return TRUE;
         }
+    } else if (IsEqualGUID(&DSPROPSETID_EAX20_BufferProperties, guidPropSet)) {
+        if (dwPropID <= DSPROPERTY_EAX20BUFFER_FLAGS) {
+            *pTypeSupport = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
+            return TRUE;
+        }
     }
 
+    FIXME("(%s,%ld,%p)\n", debugstr_guid(guidPropSet), dwPropID, pTypeSupport);
     return FALSE;
 }
 
@@ -941,8 +947,13 @@ HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
     } else if (IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet)) {
         FIXME("Unsupported DSPROPSETID_EAX20_ListenerProperties: %ld\n", dwPropID);
         return E_PROP_ID_UNSUPPORTED;
+    } else if (IsEqualGUID(&DSPROPSETID_EAX20_BufferProperties, guidPropSet)) {
+        FIXME("Unsupported DSPROPSETID_EAX20_BufferProperties: %ld\n", dwPropID);
+        return E_PROP_ID_UNSUPPORTED;
     }
 
+    FIXME("(buf=%p,guidPropSet=%s,dwPropID=%ld,pInstanceData=%p,cbInstanceData=%ld,pPropData=%p,cbPropData=%ld,pcbReturned=%p)\n",
+        buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -1073,7 +1084,12 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
     } else if (IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet)) {
         FIXME("Unsupported DSPROPSETID_EAX20_ListenerProperties: %ld\n", dwPropID);
         return E_PROP_ID_UNSUPPORTED;
+    } else if (IsEqualGUID(&DSPROPSETID_EAX20_BufferProperties, guidPropSet)) {
+        FIXME("Unsupported DSPROPSETID_EAX20_BufferProperties: %ld\n", dwPropID);
+        return E_PROP_ID_UNSUPPORTED;
     }
 
+    FIXME("(%p,%s,%ld,%p,%ld,%p,%ld)\n",
+        buf, debugstr_guid(guidPropSet), dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
     return E_PROP_ID_UNSUPPORTED;
 }

From 95bc8f32b27295e1ce16e47ada612740266be1a6 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 1 Jan 2021 13:32:48 +1100
Subject: [PATCH 047/244] dsound: Enable EAX by default

---
 dlls/dsound/dsound_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/dsound/dsound_main.c b/dlls/dsound/dsound_main.c
index d785e905527..d0655585421 100644
--- a/dlls/dsound/dsound_main.c
+++ b/dlls/dsound/dsound_main.c
@@ -84,7 +84,7 @@ const WCHAR wine_vxd_drv[] = L"winemm.vxd";
 /* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
 int ds_hel_buflen = 32768 * 2;
 int ds_hq_buffers_max = 4;
-BOOL ds_eax_enabled = FALSE;
+BOOL ds_eax_enabled = TRUE;
 
 #define IS_OPTION_TRUE(ch) \
     ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')

From 1e76d765755936ffe90ebb2953ed1c756ddc8d81 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 25 Jan 2021 19:14:32 +1100
Subject: [PATCH 048/244] dsound: Fake success for EAX Set
 Buffer/ListenerProperties

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=50551
---
 dlls/dsound/buffer.c | 3 ++-
 dlls/dsound/eax.c    | 8 ++++----
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index 2f0a12298a8..9bb87c56f8d 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -1364,7 +1364,8 @@ static HRESULT WINAPI IKsPropertySetImpl_Set(IKsPropertySet *iface, REFGUID guid
 
     TRACE("(%p,%s,%ld,%p,%ld,%p,%ld)\n",This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData);
 
-    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet))
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet) ||
+        IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAX20_BufferProperties, guidPropSet))
         return EAX_Set(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
 
     return E_PROP_ID_UNSUPPORTED;
diff --git a/dlls/dsound/eax.c b/dlls/dsound/eax.c
index 9237aa055e0..7034b5fca07 100644
--- a/dlls/dsound/eax.c
+++ b/dlls/dsound/eax.c
@@ -1082,11 +1082,11 @@ HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
 
         return S_OK;
     } else if (IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet)) {
-        FIXME("Unsupported DSPROPSETID_EAX20_ListenerProperties: %ld\n", dwPropID);
-        return E_PROP_ID_UNSUPPORTED;
+        FIXME("Unsupported DSPROPSETID_EAX20_ListenerProperties: %ld - Faking Success\n", dwPropID);
+        return S_OK;
     } else if (IsEqualGUID(&DSPROPSETID_EAX20_BufferProperties, guidPropSet)) {
-        FIXME("Unsupported DSPROPSETID_EAX20_BufferProperties: %ld\n", dwPropID);
-        return E_PROP_ID_UNSUPPORTED;
+        FIXME("Unsupported DSPROPSETID_EAX20_BufferProperties: %ld - Faking Success\n", dwPropID);
+        return S_OK;
     }
 
     FIXME("(%p,%s,%ld,%p,%ld,%p,%ld)\n",

From 4db5fdeacde4a5662493db8e6b104019ed350502 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 23 May 2024 14:25:57 +1000
Subject: [PATCH 049/244] dxgi: Semi-stub IDXGISwapChain::GetFrameStatistics.

Not completely correct but does allow improved framerates.  Mileage will vary.
---
 dlls/dxgi/swapchain.c | 89 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 85 insertions(+), 4 deletions(-)

diff --git a/dlls/dxgi/swapchain.c b/dlls/dxgi/swapchain.c
index 4797fcecd8d..4111a488407 100644
--- a/dlls/dxgi/swapchain.c
+++ b/dlls/dxgi/swapchain.c
@@ -587,12 +587,66 @@ static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetContainingOutput(IDXGISwapCh
     return dxgi_get_output_from_window(swapchain->factory, window, output);
 }
 
+static int get_display_frequency(void)
+{
+    DEVMODEW mode;
+    BOOL ret;
+
+    memset(&mode, 0, sizeof(mode));
+    mode.dmSize = sizeof(mode);
+    ret = EnumDisplaySettingsExW(NULL, ENUM_CURRENT_SETTINGS, &mode, 0);
+    if (ret && mode.dmFields & DM_DISPLAYFREQUENCY && mode.dmDisplayFrequency)
+    {
+        return mode.dmDisplayFrequency;
+    }
+    else
+    {
+        WARN("Failed to query display frequency, returning a fallback value.\n");
+        return 60;
+    }
+}
+
+static LARGE_INTEGER get_perf_req(void)
+{
+    LARGE_INTEGER performance_frequency;
+
+    QueryPerformanceFrequency(&performance_frequency);
+    return performance_frequency;
+}
+
 static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetFrameStatistics(IDXGISwapChain4 *iface,
         DXGI_FRAME_STATISTICS *stats)
 {
-    FIXME("iface %p, stats %p stub!\n", iface, stats);
+    struct d3d11_swapchain *swapchain = d3d11_swapchain_from_IDXGISwapChain4(iface);
+    HRESULT hr = S_OK;
+    static BOOL once = 0;
+    const LARGE_INTEGER performance_frequency = get_perf_req();
+    int display_frequency = get_display_frequency();
 
-    return E_NOTIMPL;
+    LARGE_INTEGER count;
+    TRACE("iface %p, stats %p Semi-stub\n", iface, stats);
+
+    if (!stats)
+        return E_INVALIDARG;
+
+    QueryPerformanceCounter(&count);
+
+    stats->PresentCount          = swapchain->present_count;
+    stats->PresentRefreshCount   = 0;
+    stats->SyncRefreshCount      = 0;
+    stats->SyncQPCTime.QuadPart  = count.QuadPart;
+    stats->SyncGPUTime.QuadPart  = 0;
+
+    stats->PresentRefreshCount =  performance_frequency.QuadPart / display_frequency;
+    stats->SyncRefreshCount = display_frequency;
+
+    if(!once)
+    {
+        once++;
+        hr = DXGI_ERROR_FRAME_STATISTICS_DISJOINT;
+    }
+
+    return hr;
 }
 
 static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetLastPresentCount(IDXGISwapChain4 *iface,
@@ -2704,9 +2758,36 @@ static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetContainingOutput(IDXGISwapCh
 static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetFrameStatistics(IDXGISwapChain4 *iface,
         DXGI_FRAME_STATISTICS *stats)
 {
-    FIXME("iface %p, stats %p stub!\n", iface, stats);
+    struct d3d12_swapchain *swapchain = d3d12_swapchain_from_IDXGISwapChain4(iface);
+    HRESULT hr = S_OK;
+    static BOOL once = 0;
+    const LARGE_INTEGER performance_frequency = get_perf_req();
+    int display_frequency = get_display_frequency();
 
-    return E_NOTIMPL;
+    LARGE_INTEGER count;
+    TRACE("iface %p, stats %p Semi-stub\n", iface, stats);
+
+    if (!stats)
+        return E_INVALIDARG;
+
+    QueryPerformanceCounter(&count);
+
+    stats->PresentCount          = swapchain->frame_number;
+    stats->PresentRefreshCount   = 0;
+    stats->SyncRefreshCount      = 0;
+    stats->SyncQPCTime.QuadPart  = count.QuadPart;
+    stats->SyncGPUTime.QuadPart  = 0;
+
+    stats->PresentRefreshCount =  performance_frequency.QuadPart / display_frequency;
+    stats->SyncRefreshCount = display_frequency;
+
+    if(!once)
+    {
+        once++;
+        hr = DXGI_ERROR_FRAME_STATISTICS_DISJOINT;
+    }
+
+    return hr;
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_swapchain_GetLastPresentCount(IDXGISwapChain4 *iface,

From f13cb2f076f25617d78f225fc36db2427a6b7fbb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 9 Jan 2016 16:57:49 +0100
Subject: [PATCH 050/244] explorer: Create CurrentControlSet\Control\Video
 registry key as non-volatile.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Michael Müller <michael@fds-team.de>
---
 dlls/advapi32/tests/registry.c | 7 +++++++
 programs/explorer/desktop.c    | 5 +++++
 2 files changed, 12 insertions(+)

diff --git a/dlls/advapi32/tests/registry.c b/dlls/advapi32/tests/registry.c
index 119e287c5db..fec72acfa40 100644
--- a/dlls/advapi32/tests/registry.c
+++ b/dlls/advapi32/tests/registry.c
@@ -1338,6 +1338,13 @@ static void test_reg_create_key(void)
     RegDeleteKeyA(hkey1, "");
     RegCloseKey(hkey1);
 
+    /* System\CurrentControlSet\Control\Video should be non-volatile */
+    ret = RegCreateKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Video\\Wine",
+                          0, NULL, 0, KEY_NOTIFY, NULL, &hkey1, NULL);
+    ok(ret == ERROR_SUCCESS, "RegCreateKeyExA failed with error %lx\n", ret);
+    RegDeleteKeyA(hkey1, "");
+    RegCloseKey(hkey1);
+
     /* WOW64 flags - open an existing key */
     hkey1 = NULL;
     ret = RegCreateKeyExA(HKEY_LOCAL_MACHINE, "Software", 0, NULL, 0, KEY_READ|KEY_WOW64_32KEY, NULL, &hkey1, NULL);
diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index f4edba3f7fa..8caaa734c6e 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -996,6 +996,7 @@ static BOOL get_no_tray_items_display(void)
 static void load_graphics_driver( const WCHAR *driver, GUID *guid )
 {
     static const WCHAR device_keyW[] = L"System\\CurrentControlSet\\Control\\Video\\{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\0000";
+    static const WCHAR video_keyW[]  = L"System\\CurrentControlSet\\Control\\Video\\0000";
 
     WCHAR buffer[MAX_PATH], libname[32], *name, *next;
     WCHAR key[ARRAY_SIZE( device_keyW ) + 39];
@@ -1052,6 +1053,10 @@ static void load_graphics_driver( const WCHAR *driver, GUID *guid )
 
     TRACE( "display %s driver %s\n", debugstr_guid(guid), debugstr_w(libname) );
 
+    /* create video key first without REG_OPTION_VOLATILE attribute */
+    if (!RegCreateKeyExW( HKEY_LOCAL_MACHINE, video_keyW, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkey, NULL ))
+        RegCloseKey( hkey );
+
     swprintf( key, ARRAY_SIZE(key), device_keyW, guid->Data1, guid->Data2, guid->Data3,
               guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
               guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7] );

From 5b3569344bb1a3dc8549c5245629bef0ff042597 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 20 Dec 2014 23:10:38 +0100
Subject: [PATCH 055/244] Add licenses for fonts as separate files.

---
 COPYING.arial |  65 +++++
 COPYING.cour  |  65 +++++
 COPYING.msyh  | 674 ++++++++++++++++++++++++++++++++++++++++++++++++++
 COPYING.times |  65 +++++
 LICENSE       |  24 ++
 5 files changed, 893 insertions(+)
 create mode 100644 COPYING.arial
 create mode 100644 COPYING.cour
 create mode 100644 COPYING.msyh
 create mode 100644 COPYING.times

diff --git a/COPYING.arial b/COPYING.arial
new file mode 100644
index 00000000000..b75642825ba
--- /dev/null
+++ b/COPYING.arial
@@ -0,0 +1,65 @@
+LICENSE AGREEMENT AND LIMITED PRODUCT WARRANTY
+LIBERATION FONT SOFTWARE
+
+This agreement governs the use of the Software and any updates to the Software,
+regardless of the delivery mechanism. Subject to the following terms, Red Hat,
+Inc. ("Red Hat") grants to the user ("Client") a license to this work pursuant
+to the GNU General Public License v.2 with the exceptions set forth below and
+such other terms as are set forth in this End User License Agreement.
+
+ 1. The Software and License Exception. LIBERATION font software  (the
+"Software") consists of TrueType-OpenType formatted font software for rendering
+LIBERATION typefaces in sans-serif, serif, and monospaced character styles. You
+are licensed to use, modify, copy, and distribute the Software pursuant to the
+GNU General Public License v.2 with the following exceptions:
+
+  (a) As a special exception, if you create a document which uses this font,
+and embed this font or unaltered portions of this font into the document, this
+font does not by itself cause the resulting document to be covered by the GNU
+General Public License. This exception does not however invalidate any other
+reasons why the document might be covered by the GNU General Public License. If
+you modify this font, you may extend this exception to your version of the
+font, but you are not obligated to do so. If you do not wish to do so, delete
+this exception statement from your version.
+
+  (b) As a further exception, any distribution of the object code of the
+Software in a physical product must provide you the right to access and modify
+the source code for the Software and to reinstall that modified version of the
+Software in object code form on the same physical product on which you received
+it.
+
+ 2. Intellectual Property Rights. The Software and each of its components,
+including the source code, documentation, appearance, structure and
+organization are owned by Red Hat and others and are protected under copyright
+and other laws. Title to the Software and any component, or to any copy,
+modification, or merged portion shall remain with the aforementioned, subject
+to the applicable license. The "LIBERATION" trademark is a trademark of Red
+Hat, Inc. in the U.S. and other countries. This agreement does not permit
+Client to distribute modified versions of the Software using Red Hat's
+trademarks. If Client makes a redistribution of a modified version of the
+Software, then Client must modify the files names to remove any reference to
+the Red Hat trademarks and must not use the Red Hat trademarks in any way to
+reference or promote the modified Software.
+
+ 3. Limited Warranty. To the maximum extent permitted under applicable law, the
+Software is provided and licensed "as is" without warranty of any kind,
+expressed or implied, including the implied warranties of merchantability,
+non-infringement or fitness for a particular purpose. Red Hat does not warrant
+that the functions contained in the Software will meet Client's requirements or
+that the operation of the Software will be entirely error free or appear
+precisely as described in the accompanying documentation.
+
+ 4. Limitation of Remedies and Liability. To the maximum extent permitted by
+applicable law, Red Hat or any Red Hat authorized dealer will not be liable to
+Client for any incidental or consequential damages, including lost profits or
+lost savings arising out of the use or inability to use the Software, even if
+Red Hat or such dealer has been advised of the possibility of such damages.
+
+ 5. General. If any provision of this agreement is held to be unenforceable,
+that shall not affect the enforceability of the remaining provisions. This
+agreement shall be governed by the laws of the State of North Carolina and of
+the United States, without regard to any conflict of laws provisions, except
+that the United Nations Convention on the International Sale of Goods shall not
+apply.
+Copyright © 2007-2011 Red Hat, Inc. All rights reserved. LIBERATION is a
+trademark of Red Hat, Inc.
diff --git a/COPYING.cour b/COPYING.cour
new file mode 100644
index 00000000000..b75642825ba
--- /dev/null
+++ b/COPYING.cour
@@ -0,0 +1,65 @@
+LICENSE AGREEMENT AND LIMITED PRODUCT WARRANTY
+LIBERATION FONT SOFTWARE
+
+This agreement governs the use of the Software and any updates to the Software,
+regardless of the delivery mechanism. Subject to the following terms, Red Hat,
+Inc. ("Red Hat") grants to the user ("Client") a license to this work pursuant
+to the GNU General Public License v.2 with the exceptions set forth below and
+such other terms as are set forth in this End User License Agreement.
+
+ 1. The Software and License Exception. LIBERATION font software  (the
+"Software") consists of TrueType-OpenType formatted font software for rendering
+LIBERATION typefaces in sans-serif, serif, and monospaced character styles. You
+are licensed to use, modify, copy, and distribute the Software pursuant to the
+GNU General Public License v.2 with the following exceptions:
+
+  (a) As a special exception, if you create a document which uses this font,
+and embed this font or unaltered portions of this font into the document, this
+font does not by itself cause the resulting document to be covered by the GNU
+General Public License. This exception does not however invalidate any other
+reasons why the document might be covered by the GNU General Public License. If
+you modify this font, you may extend this exception to your version of the
+font, but you are not obligated to do so. If you do not wish to do so, delete
+this exception statement from your version.
+
+  (b) As a further exception, any distribution of the object code of the
+Software in a physical product must provide you the right to access and modify
+the source code for the Software and to reinstall that modified version of the
+Software in object code form on the same physical product on which you received
+it.
+
+ 2. Intellectual Property Rights. The Software and each of its components,
+including the source code, documentation, appearance, structure and
+organization are owned by Red Hat and others and are protected under copyright
+and other laws. Title to the Software and any component, or to any copy,
+modification, or merged portion shall remain with the aforementioned, subject
+to the applicable license. The "LIBERATION" trademark is a trademark of Red
+Hat, Inc. in the U.S. and other countries. This agreement does not permit
+Client to distribute modified versions of the Software using Red Hat's
+trademarks. If Client makes a redistribution of a modified version of the
+Software, then Client must modify the files names to remove any reference to
+the Red Hat trademarks and must not use the Red Hat trademarks in any way to
+reference or promote the modified Software.
+
+ 3. Limited Warranty. To the maximum extent permitted under applicable law, the
+Software is provided and licensed "as is" without warranty of any kind,
+expressed or implied, including the implied warranties of merchantability,
+non-infringement or fitness for a particular purpose. Red Hat does not warrant
+that the functions contained in the Software will meet Client's requirements or
+that the operation of the Software will be entirely error free or appear
+precisely as described in the accompanying documentation.
+
+ 4. Limitation of Remedies and Liability. To the maximum extent permitted by
+applicable law, Red Hat or any Red Hat authorized dealer will not be liable to
+Client for any incidental or consequential damages, including lost profits or
+lost savings arising out of the use or inability to use the Software, even if
+Red Hat or such dealer has been advised of the possibility of such damages.
+
+ 5. General. If any provision of this agreement is held to be unenforceable,
+that shall not affect the enforceability of the remaining provisions. This
+agreement shall be governed by the laws of the State of North Carolina and of
+the United States, without regard to any conflict of laws provisions, except
+that the United Nations Convention on the International Sale of Goods shall not
+apply.
+Copyright © 2007-2011 Red Hat, Inc. All rights reserved. LIBERATION is a
+trademark of Red Hat, Inc.
diff --git a/COPYING.msyh b/COPYING.msyh
new file mode 100644
index 00000000000..94a9ed024d3
--- /dev/null
+++ b/COPYING.msyh
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/COPYING.times b/COPYING.times
new file mode 100644
index 00000000000..b75642825ba
--- /dev/null
+++ b/COPYING.times
@@ -0,0 +1,65 @@
+LICENSE AGREEMENT AND LIMITED PRODUCT WARRANTY
+LIBERATION FONT SOFTWARE
+
+This agreement governs the use of the Software and any updates to the Software,
+regardless of the delivery mechanism. Subject to the following terms, Red Hat,
+Inc. ("Red Hat") grants to the user ("Client") a license to this work pursuant
+to the GNU General Public License v.2 with the exceptions set forth below and
+such other terms as are set forth in this End User License Agreement.
+
+ 1. The Software and License Exception. LIBERATION font software  (the
+"Software") consists of TrueType-OpenType formatted font software for rendering
+LIBERATION typefaces in sans-serif, serif, and monospaced character styles. You
+are licensed to use, modify, copy, and distribute the Software pursuant to the
+GNU General Public License v.2 with the following exceptions:
+
+  (a) As a special exception, if you create a document which uses this font,
+and embed this font or unaltered portions of this font into the document, this
+font does not by itself cause the resulting document to be covered by the GNU
+General Public License. This exception does not however invalidate any other
+reasons why the document might be covered by the GNU General Public License. If
+you modify this font, you may extend this exception to your version of the
+font, but you are not obligated to do so. If you do not wish to do so, delete
+this exception statement from your version.
+
+  (b) As a further exception, any distribution of the object code of the
+Software in a physical product must provide you the right to access and modify
+the source code for the Software and to reinstall that modified version of the
+Software in object code form on the same physical product on which you received
+it.
+
+ 2. Intellectual Property Rights. The Software and each of its components,
+including the source code, documentation, appearance, structure and
+organization are owned by Red Hat and others and are protected under copyright
+and other laws. Title to the Software and any component, or to any copy,
+modification, or merged portion shall remain with the aforementioned, subject
+to the applicable license. The "LIBERATION" trademark is a trademark of Red
+Hat, Inc. in the U.S. and other countries. This agreement does not permit
+Client to distribute modified versions of the Software using Red Hat's
+trademarks. If Client makes a redistribution of a modified version of the
+Software, then Client must modify the files names to remove any reference to
+the Red Hat trademarks and must not use the Red Hat trademarks in any way to
+reference or promote the modified Software.
+
+ 3. Limited Warranty. To the maximum extent permitted under applicable law, the
+Software is provided and licensed "as is" without warranty of any kind,
+expressed or implied, including the implied warranties of merchantability,
+non-infringement or fitness for a particular purpose. Red Hat does not warrant
+that the functions contained in the Software will meet Client's requirements or
+that the operation of the Software will be entirely error free or appear
+precisely as described in the accompanying documentation.
+
+ 4. Limitation of Remedies and Liability. To the maximum extent permitted by
+applicable law, Red Hat or any Red Hat authorized dealer will not be liable to
+Client for any incidental or consequential damages, including lost profits or
+lost savings arising out of the use or inability to use the Software, even if
+Red Hat or such dealer has been advised of the possibility of such damages.
+
+ 5. General. If any provision of this agreement is held to be unenforceable,
+that shall not affect the enforceability of the remaining provisions. This
+agreement shall be governed by the laws of the State of North Carolina and of
+the United States, without regard to any conflict of laws provisions, except
+that the United Nations Convention on the International Sale of Goods shall not
+apply.
+Copyright © 2007-2011 Red Hat, Inc. All rights reserved. LIBERATION is a
+trademark of Red Hat, Inc.
diff --git a/LICENSE b/LICENSE
index 58d15edce07..6d78311171f 100644
--- a/LICENSE
+++ b/LICENSE
@@ -15,3 +15,27 @@ A copy of the GNU Lesser General Public License is included in the
 Wine distribution in the file COPYING.LIB. If you did not receive this
 copy, write to the Free Software Foundation, Inc., 51 Franklin St,
 Fifth Floor, Boston, MA 02110-1301, USA.
+
+-----------------------------------------------------------------------
+
+Exceptions (for Wine Staging):
+
+The following files are shipped with Wine Staging, but are not linked to
+the rest of the project in any way. They are simply installed for
+end-user convenience and use a different license as explained below.
+
+    * fonts/arial.ttf and fonts/arial.sfd
+      The Liberation Sans font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.arial.
+
+    * fonts/times.ttf and fonts/times.sfd
+      The Liberation Serif font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.times.
+
+    * fonts/cour.ttf and fonts/cour.sfd
+      The Liberation Mono font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.cour.
+
+    * fonts/msyh.ttf and fonts/msyh.sfd
+      The WenQuanYi Micro Hei font is licensed under both the APACHE 2
+      license and GPLv3. See COPYING.msyh for GPLv3.

From 88369c082ae9befa47cbcc18b37fa683271dfd09 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Sun, 5 Mar 2017 13:18:21 +0800
Subject: [PATCH 056/244] gdiplus: Remove ceilf/floorf calls from bilinear
 scaler. (v2)

This improves performance by about 55%.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/gdiplus/graphics.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/dlls/gdiplus/graphics.c b/dlls/gdiplus/graphics.c
index 624e16c4983..635dc71266b 100644
--- a/dlls/gdiplus/graphics.c
+++ b/dlls/gdiplus/graphics.c
@@ -655,7 +655,7 @@ static ARGB blend_colors(ARGB start, ARGB end, REAL position)
     INT start_a, end_a, final_a;
     INT pos;
 
-    pos = gdip_round(position * 0xff);
+    pos = (INT)(position * 255.0f + 0.5f);
 
     start_a = ((start >> 24) & 0xff) * (pos ^ 0xff);
     end_a = ((end >> 24) & 0xff) * pos;
@@ -1061,6 +1061,11 @@ static ARGB sample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT wi
     return ((DWORD*)(bits))[(x - src_rect->X) + (y - src_rect->Y) * src_rect->Width];
 }
 
+static FORCEINLINE int positive_ceilf(float f)
+{
+    return f - (int)f > 0.0f ? f + 1.0f : f;
+}
+
 static ARGB resample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT width,
     UINT height, GpPointF *point, GDIPCONST GpImageAttributes *attributes,
     InterpolationMode interpolation, PixelOffsetMode offset_mode)
@@ -1081,12 +1086,12 @@ static ARGB resample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT
         ARGB top, bottom;
         float x_offset;
 
-        leftxf = floorf(point->X);
-        leftx = (INT)leftxf;
-        rightx = (INT)ceilf(point->X);
-        topyf = floorf(point->Y);
-        topy = (INT)topyf;
-        bottomy = (INT)ceilf(point->Y);
+        leftx = (INT)point->X;
+        leftxf = (REAL)leftx;
+        rightx = positive_ceilf(point->X);
+        topy = (INT)point->Y;
+        topyf = (REAL)topy;
+        bottomy = positive_ceilf(point->Y);
 
         if (leftx == rightx && topy == bottomy)
             return sample_bitmap_pixel(src_rect, bits, width, height,

From 047d7c85c0c8649cd27d43dbd8adf553f14d7fa3 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Sun, 5 Mar 2017 14:34:51 +0800
Subject: [PATCH 057/244] gdiplus: Prefer using pre-multiplied ARGB data in the
 scaler.

This further improves performance by about 20%.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/gdiplus/graphics.c | 94 +++++++++++++++++++++++++++++++++++++++--
 1 file changed, 91 insertions(+), 3 deletions(-)

diff --git a/dlls/gdiplus/graphics.c b/dlls/gdiplus/graphics.c
index 635dc71266b..8343c218e68 100644
--- a/dlls/gdiplus/graphics.c
+++ b/dlls/gdiplus/graphics.c
@@ -650,6 +650,17 @@ static GpStatus alpha_blend_pixels(GpGraphics *graphics, INT dst_x, INT dst_y,
     return alpha_blend_pixels_hrgn(graphics, dst_x, dst_y, src, src_width, src_height, src_stride, NULL, fmt);
 }
 
+/* NOTE: start and end pixels must be in pre-multiplied ARGB format */
+static FORCEINLINE ARGB blend_colors_premult(ARGB start, ARGB end, REAL position)
+{
+    UINT pos = position * 255.0f + 0.5f;
+    return
+        (((((start >> 24)       ) << 8) + (((end >> 24)       ) - ((start >> 24)       )) * pos) >> 8) << 24 |
+        (((((start >> 16) & 0xff) << 8) + (((end >> 16) & 0xff) - ((start >> 16) & 0xff)) * pos) >> 8) << 16 |
+        (((((start >>  8) & 0xff) << 8) + (((end >>  8) & 0xff) - ((start >>  8) & 0xff)) * pos) >> 8) <<  8 |
+        (((((start      ) & 0xff) << 8) + (((end      ) & 0xff) - ((start      ) & 0xff)) * pos) >> 8);
+}
+
 static ARGB blend_colors(ARGB start, ARGB end, REAL position)
 {
     INT start_a, end_a, final_a;
@@ -1135,6 +1146,75 @@ static ARGB resample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT
     }
 }
 
+static ARGB resample_bitmap_pixel_premult(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT width,
+    UINT height, GpPointF *point, GDIPCONST GpImageAttributes *attributes,
+    InterpolationMode interpolation, PixelOffsetMode offset_mode)
+{
+    static int fixme;
+
+    switch (interpolation)
+    {
+    default:
+        if (!fixme++)
+            FIXME("Unimplemented interpolation %i\n", interpolation);
+        /* fall-through */
+    case InterpolationModeBilinear:
+    {
+        REAL leftxf, topyf;
+        INT leftx, rightx, topy, bottomy;
+        ARGB topleft, topright, bottomleft, bottomright;
+        ARGB top, bottom;
+        float x_offset;
+
+        leftx = (INT)point->X;
+        leftxf = (REAL)leftx;
+        rightx = positive_ceilf(point->X);
+        topy = (INT)point->Y;
+        topyf = (REAL)topy;
+        bottomy = positive_ceilf(point->Y);
+
+        if (leftx == rightx && topy == bottomy)
+            return sample_bitmap_pixel(src_rect, bits, width, height,
+                leftx, topy, attributes);
+
+        topleft = sample_bitmap_pixel(src_rect, bits, width, height,
+            leftx, topy, attributes);
+        topright = sample_bitmap_pixel(src_rect, bits, width, height,
+            rightx, topy, attributes);
+        bottomleft = sample_bitmap_pixel(src_rect, bits, width, height,
+            leftx, bottomy, attributes);
+        bottomright = sample_bitmap_pixel(src_rect, bits, width, height,
+            rightx, bottomy, attributes);
+
+        x_offset = point->X - leftxf;
+        top = blend_colors_premult(topleft, topright, x_offset);
+        bottom = blend_colors_premult(bottomleft, bottomright, x_offset);
+
+        return blend_colors_premult(top, bottom, point->Y - topyf);
+    }
+    case InterpolationModeNearestNeighbor:
+    {
+        FLOAT pixel_offset;
+        switch (offset_mode)
+        {
+        default:
+        case PixelOffsetModeNone:
+        case PixelOffsetModeHighSpeed:
+            pixel_offset = 0.5;
+            break;
+
+        case PixelOffsetModeHalf:
+        case PixelOffsetModeHighQuality:
+            pixel_offset = 0.0;
+            break;
+        }
+        return sample_bitmap_pixel(src_rect, bits, width, height,
+            floorf(point->X + pixel_offset), point->Y + pixel_offset, attributes);
+    }
+
+    }
+}
+
 static REAL intersect_line_scanline(const GpPointF *p1, const GpPointF *p2, REAL y)
 {
     return (p1->X - p2->X) * (p2->Y - y) / (p2->Y - p1->Y) + p2->X;
@@ -3328,8 +3408,10 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
             lockeddata.Scan0 = src_data;
             if (!do_resampling && bitmap->format == PixelFormat32bppPARGB)
                 lockeddata.PixelFormat = apply_image_attributes(imageAttributes, NULL, 0, 0, 0, ColorAdjustTypeBitmap, bitmap->format);
-            else
+            else if (imageAttributes != &defaultImageAttributes)
                 lockeddata.PixelFormat = PixelFormat32bppARGB;
+            else
+                lockeddata.PixelFormat = PixelFormat32bppPARGB;
 
             stat = GdipBitmapLockBits(bitmap, &src_area, ImageLockModeRead|ImageLockModeUserInputBuf,
                 lockeddata.PixelFormat, &lockeddata);
@@ -3397,8 +3479,14 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
                     {
                         if (src_pointf.X >= srcx && src_pointf.X < srcx + srcwidth &&
                             src_pointf.Y >= srcy && src_pointf.Y < srcy + srcheight)
-                            *dst_color = resample_bitmap_pixel(&src_area, src_data, bitmap->width, bitmap->height, &src_pointf,
-                                                               imageAttributes, interpolation, offset_mode);
+                        {
+                            if (lockeddata.PixelFormat != PixelFormat32bppPARGB)
+                                *dst_color = resample_bitmap_pixel(&src_area, src_data, bitmap->width, bitmap->height, &src_pointf,
+                                                                   imageAttributes, interpolation, offset_mode);
+                            else
+                                *dst_color = resample_bitmap_pixel_premult(&src_area, src_data, bitmap->width, bitmap->height, &src_pointf,
+                                                                           imageAttributes, interpolation, offset_mode);
+                        }
                         dst_color++;
                     }
                 }

From d1a2bda9a16633f579c68bd0fb1b94dbb8496bc8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Mon, 5 Sep 2016 15:31:29 +0200
Subject: [PATCH 058/244] inseng: Implement CIF reader and download functions.

FIXME: Needs splitting.
---
 dlls/inseng/Makefile.in      |    4 +-
 dlls/inseng/icif.c           | 1745 ++++++++++++++++++++++++++++++++++
 dlls/inseng/inf.c            |  443 +++++++++
 dlls/inseng/inseng.spec      |    4 +-
 dlls/inseng/inseng_main.c    |  989 ++++++++++++++++++-
 dlls/inseng/inseng_private.h |   79 ++
 include/inseng.idl           |  276 +++++-
 7 files changed, 3488 insertions(+), 52 deletions(-)
 create mode 100644 dlls/inseng/icif.c
 create mode 100644 dlls/inseng/inf.c
 create mode 100644 dlls/inseng/inseng_private.h

diff --git a/dlls/inseng/Makefile.in b/dlls/inseng/Makefile.in
index 40eda55661a..72fa3533930 100644
--- a/dlls/inseng/Makefile.in
+++ b/dlls/inseng/Makefile.in
@@ -1,8 +1,10 @@
 MODULE    = inseng.dll
-IMPORTS   = uuid ole32 advapi32
+IMPORTS   = uuid ole32 advapi32 urlmon shlwapi
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
 SOURCES = \
+	icif.c \
+	inf.c \
 	inseng_classes.idl \
 	inseng_main.c
diff --git a/dlls/inseng/icif.c b/dlls/inseng/icif.c
new file mode 100644
index 00000000000..27f6f6dfd93
--- /dev/null
+++ b/dlls/inseng/icif.c
@@ -0,0 +1,1745 @@
+/*
+ * Copyright 2016 Michael Müller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+
+
+
+#include <stdarg.h>
+#include <string.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "ole2.h"
+#include "rpcproxy.h"
+#include "inseng.h"
+
+#include "inseng_private.h"
+
+#include "wine/list.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(inseng);
+
+#define DEFAULT_INSTALLER_DESC "Active Setup Installation"
+
+struct cifgroup
+{
+    ICifGroup ICifGroup_iface;
+
+    struct list entry;
+
+    ICifFile *parent;
+
+    char *id;
+    char *description;
+    DWORD priority;
+};
+
+struct ciffenum_components
+{
+    IEnumCifComponents IEnumCifComponents_iface;
+    LONG ref;
+
+    ICifFile *file;
+    struct list *start;
+    struct list *position;
+
+    char *group_id;
+};
+
+struct ciffenum_groups
+{
+    IEnumCifGroups IEnumCifGroups_iface;
+    LONG ref;
+
+    ICifFile *file;
+    struct list *start;
+    struct list *position;
+};
+
+struct url_info
+{
+    struct list entry;
+    INT index;
+    char *url;
+    DWORD flags;
+};
+
+struct dependency_info
+{
+    struct list entry;
+    char *id;
+    char *type;
+};
+
+struct cifcomponent
+{
+    ICifComponent ICifComponent_iface;
+
+    struct list entry;
+
+    ICifFile *parent;
+
+    char *id;
+    char *guid;
+    char *description;
+    char *details;
+    char *group;
+
+
+    DWORD version;
+    DWORD build;
+    char *patchid;
+
+    char *locale;
+    char *key_uninstall;
+
+    DWORD size_win;
+    DWORD size_app;
+    DWORD size_download;
+    DWORD size_extracted;
+
+    char *key_success;
+    char *key_progress;
+    char *key_cancel;
+
+    DWORD as_aware;
+    DWORD reboot;
+    DWORD admin;
+    DWORD visibleui;
+
+    DWORD priority;
+    DWORD platform;
+
+    struct list dependencies;
+    struct list urls;
+
+    /* mode */
+    /* det version */
+    /* one component */
+    /* custom data */
+
+    /* in memory state */
+    DWORD queue_state;
+    DWORD current_priority;
+    DWORD size_actual_download;
+    BOOL downloaded;
+    BOOL installed;
+};
+
+struct ciffile
+{
+    ICifFile ICifFile_iface;
+    LONG ref;
+
+    struct list components;
+    struct list groups;
+
+    char *name;
+};
+
+static inline struct ciffile *impl_from_ICiffile(ICifFile *iface)
+{
+    return CONTAINING_RECORD(iface, struct ciffile, ICifFile_iface);
+}
+
+static inline struct cifcomponent *impl_from_ICifComponent(ICifComponent *iface)
+{
+    return CONTAINING_RECORD(iface, struct cifcomponent, ICifComponent_iface);
+}
+
+static inline struct cifgroup *impl_from_ICifGroup(ICifGroup *iface)
+{
+    return CONTAINING_RECORD(iface, struct cifgroup, ICifGroup_iface);
+}
+
+static inline struct ciffenum_components *impl_from_IEnumCifComponents(IEnumCifComponents *iface)
+{
+    return CONTAINING_RECORD(iface, struct ciffenum_components, IEnumCifComponents_iface);
+}
+
+static inline struct ciffenum_groups *impl_from_IEnumCifGroups(IEnumCifGroups *iface)
+{
+    return CONTAINING_RECORD(iface, struct ciffenum_groups, IEnumCifGroups_iface);
+}
+
+static HRESULT enum_components_create(ICifFile *file, struct list *start, char *group_id, IEnumCifComponents **iface);
+
+static HRESULT copy_substring_null(char *dest, int max_len, char *src)
+{
+    if (!src)
+        return E_FAIL;
+
+    if (max_len <= 0)
+        return S_OK;
+
+    if (!dest)
+        return E_FAIL;
+
+    while (*src && max_len-- > 1)
+        *dest++ = *src++;
+    *dest = 0;
+
+    return S_OK;
+}
+
+static void url_entry_free(struct url_info *url)
+{
+    heap_free(url->url);
+    heap_free(url);
+}
+
+static void dependency_entry_free(struct dependency_info *dependency)
+{
+    heap_free(dependency->id);
+    heap_free(dependency);
+}
+
+static void component_free(struct cifcomponent *comp)
+{
+    struct dependency_info *dependency, *dependency_next;
+    struct url_info *url, *url_next;
+
+    heap_free(comp->id);
+    heap_free(comp->guid);
+    heap_free(comp->description);
+    heap_free(comp->details);
+    heap_free(comp->group);
+
+    heap_free(comp->patchid);
+
+    heap_free(comp->locale);
+    heap_free(comp->key_uninstall);
+
+    heap_free(comp->key_success);
+    heap_free(comp->key_progress);
+    heap_free(comp->key_cancel);
+
+    LIST_FOR_EACH_ENTRY_SAFE(dependency, dependency_next, &comp->dependencies, struct dependency_info, entry)
+    {
+        list_remove(&dependency->entry);
+        dependency_entry_free(dependency);
+    }
+
+    LIST_FOR_EACH_ENTRY_SAFE(url, url_next, &comp->urls, struct url_info, entry)
+    {
+        list_remove(&url->entry);
+        url_entry_free(url);
+    }
+
+    heap_free(comp);
+}
+
+static void group_free(struct cifgroup *group)
+{
+    heap_free(group->id);
+    heap_free(group->description);
+    heap_free(group);
+}
+
+static HRESULT WINAPI group_GetID(ICifGroup *iface, char *id, DWORD size)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->id);
+}
+
+static HRESULT WINAPI group_GetDescription(ICifGroup *iface, char *desc, DWORD size)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, desc, size);
+
+    return copy_substring_null(desc, size, This->description);
+}
+
+static DWORD WINAPI group_GetPriority(ICifGroup *iface)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->priority;
+}
+
+static HRESULT WINAPI group_EnumComponents(ICifGroup *iface, IEnumCifComponents **enum_components, DWORD filter, LPVOID pv)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+    struct ciffile *file;
+
+    TRACE("(%p)->(%p, %#lx, %p)\n", This, enum_components, filter, pv);
+
+    if (filter)
+        FIXME("filter (%#lx) not supported\n", filter);
+    if (pv)
+        FIXME("how to handle pv (%p)?\n", pv);
+
+    file = impl_from_ICiffile(This->parent);
+    return enum_components_create(This->parent, &file->components, This->id, enum_components);
+}
+
+static DWORD WINAPI group_GetCurrentPriority(ICifGroup *iface)
+{
+    struct cifgroup *This = impl_from_ICifGroup(iface);
+
+    FIXME("(%p): stub\n", This);
+
+    return 0;
+}
+
+static const ICifGroupVtbl cifgroupVtbl =
+{
+    group_GetID,
+    group_GetDescription,
+    group_GetPriority,
+    group_EnumComponents,
+    group_GetCurrentPriority,
+};
+
+void component_set_actual_download_size(ICifComponent *iface, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    This->size_actual_download = size;
+}
+
+void component_set_downloaded(ICifComponent *iface, BOOL value)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    This->downloaded = value;
+}
+
+void component_set_installed(ICifComponent *iface, BOOL value)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    This->installed = value;
+}
+
+char *component_get_id(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    return This->id;
+}
+
+static HRESULT WINAPI component_GetID(ICifComponent *iface, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->id);
+}
+
+static HRESULT WINAPI component_GetGUID(ICifComponent *iface, char *guid, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, guid, size);
+
+    return copy_substring_null(guid, size, This->guid);
+}
+
+static HRESULT WINAPI component_GetDescription(ICifComponent *iface, char *desc, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, desc, size);
+
+    return copy_substring_null(desc, size, This->description);
+}
+
+static HRESULT WINAPI component_GetDetails(ICifComponent *iface, char *details, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, details, size);
+
+    return copy_substring_null(details, size, This->details);
+}
+
+static HRESULT WINAPI component_GetUrl(ICifComponent *iface, UINT index, char *url, DWORD size, DWORD *flags)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+    struct url_info *entry;
+
+    TRACE("(%p)->(%u, %p, %lu, %p)\n", This, index, url, size, flags);
+
+    /* FIXME: check how functions behaves for url == NULL */
+
+    if (!flags)
+        return E_FAIL;
+
+    LIST_FOR_EACH_ENTRY(entry, &This->urls, struct url_info, entry)
+    {
+        if (entry->index != index)
+            continue;
+
+        *flags = entry->flags;
+        return copy_substring_null(url, size, entry->url);
+    }
+
+    return E_FAIL;
+}
+
+static HRESULT WINAPI component_GetFileExtractList(ICifComponent *iface, UINT index, char *list, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %lu): stub\n", This, index, list, size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetUrlCheckRange(ICifComponent *iface, UINT index, DWORD *min, DWORD *max)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %p): stub\n", This, index, min, max);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetCommand(ICifComponent *iface, UINT index, char *cmd, DWORD cmd_size, char *switches, DWORD switch_size, DWORD *type)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %lu, %p, %lu, %p): stub\n", This, index, cmd, cmd_size, switches, switch_size, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetVersion(ICifComponent *iface, DWORD *version, DWORD *build)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, version, build);
+
+    if (!version || !build)
+        return E_FAIL;
+
+    *version = This->version;
+    *build = This->build;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI component_GetLocale(ICifComponent *iface, char *locale, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, locale, size);
+
+    return copy_substring_null(locale, size, This->locale);
+}
+
+static HRESULT WINAPI component_GetUninstallKey(ICifComponent *iface, char *key, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, key, size);
+
+    return copy_substring_null(key, size, This->key_uninstall);
+}
+
+static HRESULT WINAPI component_GetInstalledSize(ICifComponent *iface, DWORD *win, DWORD *app)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, win, app);
+
+    if (!win || !app)
+        return E_FAIL;
+
+    *win = This->size_win;
+    *app = This->size_app;
+
+    return S_OK;
+}
+
+static DWORD WINAPI component_GetDownloadSize(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->size_download;
+}
+
+static DWORD WINAPI component_GetExtractSize(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->size_extracted;
+}
+
+static HRESULT WINAPI component_GetSuccessKey(ICifComponent *iface, char *key, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, key, size);
+
+    return copy_substring_null(key, size, This->key_success);
+}
+
+static HRESULT WINAPI component_GetProgressKeys(ICifComponent *iface, char *progress, DWORD progress_size,
+                                                char *cancel, DWORD cancel_size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %lu, %p, %lu): semi-stub\n", This, progress, progress_size, cancel, cancel_size);
+
+    hr = copy_substring_null(progress, progress_size, This->key_progress);
+    if (hr != S_OK) return hr;
+
+    if (cancel_size > 0 && cancel)
+        *cancel = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI component_IsActiveSetupAware(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->as_aware ? S_OK : S_FALSE;
+}
+
+static HRESULT WINAPI component_IsRebootRequired(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->reboot ? S_OK : S_FALSE;
+}
+
+static HRESULT WINAPI component_RequiresAdminRights(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->admin ? S_OK : S_FALSE;
+}
+
+static DWORD WINAPI component_GetPriority(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->priority;
+}
+
+static HRESULT WINAPI component_GetDependency(ICifComponent *iface, UINT index, char *id, DWORD id_size, char *type, DWORD *ver, DWORD *build)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+    struct dependency_info *entry;
+    ICifComponent *dependency;
+    int pos = 0;
+
+    TRACE("(%p)->(%u, %p, %lu, %p, %p, %p)\n", This, index, id, id_size, type, ver, build);
+
+    if (!id || !ver || !build)
+        return E_FAIL;
+
+    LIST_FOR_EACH_ENTRY(entry, &This->dependencies, struct dependency_info, entry)
+    {
+        if (pos++ < index)
+            continue;
+
+        if (ICifFile_FindComponent(This->parent, entry->id, &dependency) == S_OK)
+        {
+            ICifComponent_GetVersion(dependency, ver, build);
+        }
+        else
+        {
+            *ver = -1;
+            *build = -1;
+        }
+
+        if (entry->type)
+            *type = *entry->type;
+        else
+            *type = 'I';
+
+        return copy_substring_null(id, id_size, entry->id);
+    }
+
+    return E_FAIL;
+}
+
+static DWORD WINAPI component_GetPlatform(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->platform;
+}
+
+static HRESULT WINAPI component_GetMode(ICifComponent *iface, UINT index, char *mode, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %lu): stub\n", This, index, mode, size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetGroup(ICifComponent *iface, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->group);
+}
+
+static HRESULT WINAPI component_IsUIVisible(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->visibleui ? S_OK : S_FALSE;
+}
+
+static HRESULT WINAPI component_GetPatchID(ICifComponent *iface, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, id, size);
+
+    return copy_substring_null(id, size, This->patchid);
+}
+
+static HRESULT WINAPI component_GetDetVersion(ICifComponent *iface, char *dll, DWORD dll_size, char *entry, DWORD entry_size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%p, %lu, %p, %lu): stub\n", This, dll, dll_size, entry, entry_size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetTreatAsOneComponents(ICifComponent *iface, UINT index, char *id, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%u, %p, %lu): stub\n", This, index, id, size);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI component_GetCustomData(ICifComponent *iface, char *key, char *data, DWORD size)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%s, %p, %lu): stub\n", This, debugstr_a(key), data, size);
+
+    return E_NOTIMPL;
+}
+
+static DWORD WINAPI component_IsComponentInstalled(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->installed;
+}
+
+static HRESULT WINAPI component_IsComponentDownloaded(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->downloaded ? S_OK : S_FALSE;
+}
+
+static DWORD WINAPI component_IsThisVersionInstalled(ICifComponent *iface, DWORD version, DWORD build, DWORD *ret_version, DWORD *ret_build)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    FIXME("(%p)->(%lu, %lu, %p, %p): stub\n", This, version, build, ret_version, ret_build);
+
+    return 0;
+}
+
+static DWORD WINAPI component_GetInstallQueueState(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->queue_state;
+}
+
+static HRESULT WINAPI component_SetInstallQueueState(ICifComponent *iface, DWORD state)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%lu)\n", This, state);
+
+    This->queue_state = state;
+    return S_OK;
+}
+
+static DWORD WINAPI component_GetActualDownloadSize(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->size_download;
+}
+
+static DWORD WINAPI component_GetCurrentPriority(ICifComponent *iface)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)\n", This);
+
+    return This->current_priority;
+}
+
+
+static HRESULT WINAPI component_SetCurrentPriority(ICifComponent *iface, DWORD priority)
+{
+    struct cifcomponent *This = impl_from_ICifComponent(iface);
+
+    TRACE("(%p)->(%lu)\n", This, priority);
+
+    This->current_priority = priority;
+    return S_OK;
+}
+
+static const ICifComponentVtbl cifcomponentVtbl =
+{
+    component_GetID,
+    component_GetGUID,
+    component_GetDescription,
+    component_GetDetails,
+    component_GetUrl,
+    component_GetFileExtractList,
+    component_GetUrlCheckRange,
+    component_GetCommand,
+    component_GetVersion,
+    component_GetLocale,
+    component_GetUninstallKey,
+    component_GetInstalledSize,
+    component_GetDownloadSize,
+    component_GetExtractSize,
+    component_GetSuccessKey,
+    component_GetProgressKeys,
+    component_IsActiveSetupAware,
+    component_IsRebootRequired,
+    component_RequiresAdminRights,
+    component_GetPriority,
+    component_GetDependency,
+    component_GetPlatform,
+    component_GetMode,
+    component_GetGroup,
+    component_IsUIVisible,
+    component_GetPatchID,
+    component_GetDetVersion,
+    component_GetTreatAsOneComponents,
+    component_GetCustomData,
+    component_IsComponentInstalled,
+    component_IsComponentDownloaded,
+    component_IsThisVersionInstalled,
+    component_GetInstallQueueState,
+    component_SetInstallQueueState,
+    component_GetActualDownloadSize,
+    component_GetCurrentPriority,
+    component_SetCurrentPriority,
+};
+
+static HRESULT WINAPI enum_components_QueryInterface(IEnumCifComponents *iface, REFIID riid, void **ppv)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IEnumCifComponents_iface;
+    }
+    /*
+    else if (IsEqualGUID(&IID_IEnumCifComponents, riid))
+    {
+        TRACE("(%p)->(IID_ICifFile %p)\n", This, ppv);
+        *ppv = &This->IEnumCifComponents_iface;
+    }
+    */
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI enum_components_AddRef(IEnumCifComponents *iface)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI enum_components_Release(IEnumCifComponents *iface)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref)
+    {
+        ICifFile_Release(This->file);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI enum_components_Next(IEnumCifComponents *iface, ICifComponent **component)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+    struct cifcomponent *comp;
+
+    TRACE("(%p)->(%p)\n", This, component);
+
+    if (!component)
+        return E_FAIL;
+
+    if (!This->position)
+    {
+        *component = NULL;
+        return E_FAIL;
+    }
+
+    do
+    {
+        This->position = list_next(This->start, This->position);
+        if (!This->position)
+        {
+            *component = NULL;
+            return E_FAIL;
+        }
+
+        comp = CONTAINING_RECORD(This->position, struct cifcomponent, entry);
+    } while (This->group_id && (!comp->group || strcmp(This->group_id, comp->group)));
+
+    *component = &comp->ICifComponent_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI enum_components_Reset(IEnumCifComponents *iface)
+{
+    struct ciffenum_components *This = impl_from_IEnumCifComponents(iface);
+
+    TRACE("(%p)\n", This);
+
+    This->position = This->start;
+    return S_OK;
+}
+
+static const IEnumCifComponentsVtbl enum_componentsVtbl =
+{
+    enum_components_QueryInterface,
+    enum_components_AddRef,
+    enum_components_Release,
+    enum_components_Next,
+    enum_components_Reset,
+};
+
+static HRESULT enum_components_create(ICifFile *file, struct list *start, char *group_id, IEnumCifComponents **iface)
+{
+    struct ciffenum_components *enumerator;
+
+    enumerator = heap_alloc_zero(sizeof(*enumerator));
+    if (!enumerator) return E_OUTOFMEMORY;
+
+    enumerator->IEnumCifComponents_iface.lpVtbl = &enum_componentsVtbl;
+    enumerator->ref      = 1;
+    enumerator->file     = file;
+    enumerator->start    = start;
+    enumerator->position = start;
+    enumerator->group_id = group_id;
+
+    ICifFile_AddRef(file);
+
+    *iface = &enumerator->IEnumCifComponents_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI enum_groups_QueryInterface(IEnumCifGroups *iface, REFIID riid, void **ppv)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IEnumCifGroups_iface;
+    }
+    /*
+    else if (IsEqualGUID(&IID_IEnumCifGroups, riid))
+    {
+        TRACE("(%p)->(IID_ICifFile %p)\n", This, ppv);
+        *ppv = &This->IEnumCifGroups_iface;
+    }
+    */
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI enum_groups_AddRef(IEnumCifGroups *iface)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI enum_groups_Release(IEnumCifGroups *iface)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref)
+    {
+        ICifFile_Release(This->file);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI enum_groups_Next(IEnumCifGroups *iface, ICifGroup **group)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+    struct cifgroup *gp;
+
+    TRACE("(%p)->(%p)\n", This, group);
+
+    if (!This->position || !group)
+        return E_FAIL;
+
+    This->position = list_next(This->start, This->position);
+
+    if (!This->position)
+        return E_FAIL;
+
+    gp = CONTAINING_RECORD(This->position, struct cifgroup, entry);
+    *group = &gp->ICifGroup_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI enum_groups_Reset(IEnumCifGroups *iface)
+{
+    struct ciffenum_groups *This = impl_from_IEnumCifGroups(iface);
+
+    TRACE("(%p)\n", This);
+
+    This->position = This->start;
+    return S_OK;
+}
+
+static const IEnumCifGroupsVtbl enum_groupsVtbl =
+{
+    enum_groups_QueryInterface,
+    enum_groups_AddRef,
+    enum_groups_Release,
+    enum_groups_Next,
+    enum_groups_Reset,
+};
+
+static HRESULT enum_groups_create(ICifFile *file, struct list *start, IEnumCifGroups **iface)
+{
+    struct ciffenum_groups *enumerator;
+
+    enumerator = heap_alloc_zero(sizeof(*enumerator));
+    if (!enumerator) return E_OUTOFMEMORY;
+
+    enumerator->IEnumCifGroups_iface.lpVtbl = &enum_groupsVtbl;
+    enumerator->ref      = 1;
+    enumerator->file     = file;
+    enumerator->start    = start;
+    enumerator->position = start;
+
+    ICifFile_AddRef(file);
+
+    *iface = &enumerator->IEnumCifGroups_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI ciffile_QueryInterface(ICifFile *iface, REFIID riid, void **ppv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->ICifFile_iface;
+    }
+    else if (IsEqualGUID(&IID_ICifFile, riid))
+    {
+        TRACE("(%p)->(IID_ICifFile %p)\n", This, ppv);
+        *ppv = &This->ICifFile_iface;
+    }
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI ciffile_AddRef(ICifFile *iface)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI ciffile_Release(ICifFile *iface)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref)
+    {
+        struct cifcomponent *comp, *comp_next;
+        struct cifgroup *group, *group_next;
+
+        heap_free(This->name);
+
+        LIST_FOR_EACH_ENTRY_SAFE(comp, comp_next, &This->components, struct cifcomponent, entry)
+        {
+            list_remove(&comp->entry);
+            component_free(comp);
+        }
+
+        LIST_FOR_EACH_ENTRY_SAFE(group, group_next, &This->groups, struct cifgroup, entry)
+        {
+            list_remove(&group->entry);
+            group_free(group);
+        }
+
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI ciffile_EnumComponents(ICifFile *iface, IEnumCifComponents **enum_components, DWORD filter, void *pv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    TRACE("(%p)->(%p, %#lx, %p)\n", This, enum_components, filter, pv);
+
+    if (filter)
+        FIXME("filter (%#lx) not supported\n", filter);
+    if (pv)
+        FIXME("how to handle pv (%p)?\n", pv);
+
+    return enum_components_create(iface, &This->components, NULL, enum_components);
+}
+
+static HRESULT WINAPI ciffile_FindComponent(ICifFile *iface, const char *id, ICifComponent **component)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    struct cifcomponent *comp;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_a(id), component);
+
+    LIST_FOR_EACH_ENTRY(comp, &This->components, struct cifcomponent, entry)
+    {
+        if (strcmp(comp->id, id) != 0)
+            continue;
+
+        *component = &comp->ICifComponent_iface;
+        return S_OK;
+    }
+
+    return E_FAIL;
+}
+
+static HRESULT WINAPI ciffile_EnumGroups(ICifFile *iface, IEnumCifGroups **enum_groups, DWORD filter, void *pv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    TRACE("(%p)->(%p, %#lx, %p)\n", This, enum_groups, filter, pv);
+
+    if (filter)
+        FIXME("filter (%#lx) not supported\n", filter);
+    if (pv)
+        FIXME("how to handle pv (%p)?\n", pv);
+
+    return enum_groups_create(iface, &This->groups, enum_groups);
+}
+
+static HRESULT WINAPI ciffile_FindGroup(ICifFile *iface, const char *id, ICifGroup **group)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+    struct cifgroup *gp;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_a(id), group);
+
+    LIST_FOR_EACH_ENTRY(gp, &This->groups, struct cifgroup, entry)
+    {
+        if (strcmp(gp->id, id) != 0)
+            continue;
+
+        *group = &gp->ICifGroup_iface;
+        return S_OK;
+    }
+
+    return E_FAIL;
+}
+
+static HRESULT WINAPI ciffile_EnumModes(ICifFile *iface, IEnumCifModes **cuf_modes, DWORD filter, void *pv)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    FIXME("(%p)->(%p, %lu, %p): stub\n", This, cuf_modes, filter, pv);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ciffile_FindMode(ICifFile *iface, const char *id, ICifMode **mode)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    FIXME("(%p)->(%s, %p): stub\n", This, debugstr_a(id), mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ciffile_GetDescription(ICifFile *iface, char *desc, DWORD size)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    TRACE("(%p)->(%p, %lu)\n", This, desc, size);
+
+    return copy_substring_null(desc, size, This->name);
+}
+
+static HRESULT WINAPI ciffile_GetDetDlls(ICifFile *iface, char *dlls, DWORD size)
+{
+    struct ciffile *This = impl_from_ICiffile(iface);
+
+    FIXME("(%p)->(%p, %lu): stub\n", This, dlls, size);
+
+    return E_NOTIMPL;
+}
+
+static const ICifFileVtbl ciffileVtbl =
+{
+    ciffile_QueryInterface,
+    ciffile_AddRef,
+    ciffile_Release,
+    ciffile_EnumComponents,
+    ciffile_FindComponent,
+    ciffile_EnumGroups,
+    ciffile_FindGroup,
+    ciffile_EnumModes,
+    ciffile_FindMode,
+    ciffile_GetDescription,
+    ciffile_GetDetDlls,
+};
+
+static BOOL copy_string(char **dest, const char *source)
+{
+    if (!source)
+    {
+        *dest = NULL;
+        return TRUE;
+    }
+
+    *dest = strdupA(source);
+    if (!dest) return FALSE;
+    return TRUE;
+}
+
+static BOOL section_get_str(struct inf_section *inf_sec, const char *key, char **value, const char *def)
+{
+    struct inf_value *inf_val;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val) return copy_string(value, def);
+
+    *value = inf_value_get_value(inf_val);
+    if (!*value) return FALSE;
+
+    return TRUE;
+}
+
+static char *next_part(char **str, BOOL strip_quotes)
+{
+    char *start = *str;
+    char *next = *str;
+
+    while (*next && *next != ',')
+        next++;
+
+    if (!*next)
+    {
+        *str = trim(start, NULL, strip_quotes);
+        return NULL;
+    }
+
+    *next = 0;
+    *str = trim(start, NULL, strip_quotes);
+    return ++next;
+}
+
+static BOOL value_get_str_field(struct inf_value *inf_val, int field, char **value, const char *def)
+{
+    char *line, *str, *next;
+    int i = 0;
+
+    line = inf_value_get_value(inf_val);
+    if (!line) return FALSE;
+
+    str = line;
+    do
+    {
+        i++;
+        next = next_part(&str, TRUE);
+
+        if (field == i)
+        {
+            BOOL ret = copy_string(value, str);
+            heap_free(line);
+            return ret;
+        }
+
+        str = next;
+    } while (str);
+
+    return copy_string(value, def);
+}
+
+/*
+static BOOL section_get_str_field(struct inf_section *inf_sec, const char *key, int field, char **value, const char *def)
+{
+    struct inf_value *inf_val;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val) return copy_string(value, def);
+
+    return value_get_str_field(inf_val, field, value, def);
+}
+*/
+
+static BOOL section_get_dword(struct inf_section *inf_sec, const char *key, DWORD *value, DWORD def)
+{
+    struct inf_value *inf_val;
+    char *str;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val)
+    {
+        *value = def;
+        return TRUE;
+    }
+
+    str = inf_value_get_value(inf_val);
+    if (!str) return FALSE;
+
+    *value = atoi(str);
+    heap_free(str);
+
+    return TRUE;
+}
+
+static BOOL value_get_dword_field(struct inf_value *inf_val, int field, DWORD *value, DWORD def)
+{
+    char *value_str;
+    BOOL ret;
+
+    ret = value_get_str_field(inf_val, field, &value_str, NULL);
+    if (!ret) return FALSE;
+    if (!value_str)
+    {
+        *value = def;
+        return TRUE;
+    }
+
+    *value = atoi(value_str);
+    heap_free(value_str);
+
+    return TRUE;
+}
+
+static BOOL section_get_dword_field(struct inf_section *inf_sec, const char *key, int field, DWORD *value, DWORD def)
+{
+    struct inf_value *inf_val;
+
+    inf_val = inf_get_value(inf_sec, key);
+    if (!inf_val)
+    {
+        *value = def;
+        return TRUE;
+    }
+
+    return value_get_dword_field(inf_val, field, value, def);
+}
+
+static HRESULT process_version(struct ciffile *file, struct inf_section *section)
+{
+    if (!section_get_str(section, "DisplayName", &file->name, DEFAULT_INSTALLER_DESC))
+        return E_OUTOFMEMORY;
+
+    return S_OK;
+}
+
+static BOOL read_version_entry(struct inf_section *section, DWORD *ret_ver, DWORD *ret_build)
+{
+    DWORD version = 0;
+    DWORD build = 0;
+    char *line, *str, *next;
+
+    if (!section_get_str(section, "Version", &line, NULL))
+        return FALSE;
+    if (!line) goto done;
+
+    str = line;
+
+    next = next_part(&str, TRUE);
+    version |= atoi(str) << 16;
+    if (!next) goto done;
+    str = next;
+
+    next = next_part(&str, TRUE);
+    version |= atoi(str) & 0xffff;
+    if (!next) goto done;
+    str = next;
+
+    next = next_part(&str, TRUE);
+    build |= atoi(str) << 16;
+    if (!next) goto done;
+    str = next;
+
+    next_part(&str, TRUE);
+    build |= atoi(str) & 0xffff;
+
+done:
+    heap_free(line);
+    *ret_ver = version;
+    *ret_build = build;
+    return TRUE;
+}
+
+static BOOL read_platform_entry(struct inf_section *section, DWORD *ret_platform)
+{
+    DWORD platform = PLATFORM_ALL;
+    char *line, *str, *next;
+
+    if (!section_get_str(section, "Platform", &line, NULL))
+        return FALSE;
+    if (!line) goto done;
+
+    platform = 0;
+    str = line;
+    do
+    {
+        next = next_part(&str, TRUE);
+
+        if (strcasecmp(str, "Win95") == 0)
+            platform |= PLATFORM_WIN98;
+        else if (strcasecmp(str, "Win98") == 0)
+            platform |= PLATFORM_WIN98;
+        else if (strcasecmp(str, "NT4") == 0)
+            platform |= PLATFORM_NT4;
+        else if (strcasecmp(str, "NT5") == 0)
+            platform |= PLATFORM_NT5;
+        else if (strcasecmp(str, "NT4Alpha") == 0)
+            platform |= PLATFORM_NT4;
+        else if (strcasecmp(str, "NT5Alpha") == 0)
+            platform |= PLATFORM_NT5;
+        else if (strcasecmp(str, "Millen") == 0)
+            platform |= PLATFORM_MILLEN;
+        else
+            FIXME("Unknown platform: %s\n", debugstr_a(str));
+
+        str = next;
+    } while (str);
+
+done:
+    heap_free(line);
+    *ret_platform = platform;
+    return TRUE;
+}
+
+static BOOL read_dependencies(struct cifcomponent *component, struct inf_section *section)
+{
+    struct dependency_info *dependency;
+    char *line, *str, *next;
+    BOOL ret = TRUE;
+
+    if (!section_get_str(section, "Dependencies", &line, NULL))
+        return E_OUTOFMEMORY;
+    if (!line) goto done;
+
+    ret = FALSE;
+    str = line;
+    do
+    {
+        next = next_part(&str, TRUE);
+
+        dependency = heap_alloc_zero(sizeof(*dependency));
+        if (!dependency) goto done;
+
+        dependency->id = strdupA(str);
+        if (!dependency->id)
+        {
+            heap_free(dependency);
+            goto done;
+        }
+
+        dependency->type = strstr(dependency->id, ":");
+        if (dependency->type) *dependency->type++ = 0;
+
+        list_add_tail(&component->dependencies, &dependency->entry);
+
+        str = next;
+    } while (str);
+
+    ret = TRUE;
+
+done:
+    heap_free(line);
+    return ret;
+}
+
+static BOOL read_urls(struct cifcomponent *component, struct inf_section *section)
+{
+    struct inf_value *inf_value = NULL;
+    struct url_info *url_entry;
+    char *str, *next;
+    int index;
+
+    while (inf_section_next_value(section, &inf_value))
+    {
+        str = inf_value_get_key(inf_value);
+        if (!str) return E_OUTOFMEMORY;
+
+        if (strncasecmp(str, "URL", 3))
+            goto next;
+
+        if (!str[3])
+            goto next;
+
+        index = strtol(str+3, &next, 10);
+        if (next == str+3 || *next != 0 || index < 1)
+            goto next;
+        index--;
+
+        url_entry = heap_alloc_zero(sizeof(*url_entry));
+        if (!url_entry) goto error;
+
+        url_entry->index = index;
+
+        if (!value_get_str_field(inf_value, 1, &url_entry->url, NULL))
+            goto error;
+        if (!url_entry->url || !*url_entry->url)
+        {
+            url_entry_free(url_entry);
+            goto next;
+        }
+
+        if (!value_get_dword_field(inf_value, 2, &url_entry->flags, 0))
+            goto error;
+
+        list_add_tail(&component->urls, &url_entry->entry);
+
+    next:
+        heap_free(str);
+    }
+
+    return TRUE;
+
+error:
+    heap_free(str);
+    url_entry_free(url_entry);
+    return FALSE;
+};
+
+void add_component_by_priority(struct ciffile *file, struct cifcomponent *component)
+{
+    struct cifcomponent *entry;
+
+    LIST_FOR_EACH_ENTRY(entry, &file->components, struct cifcomponent, entry)
+    {
+        if (entry->priority > component->priority)
+            continue;
+
+        list_add_before(&entry->entry, &component->entry);
+        return;
+    }
+
+    list_add_tail(&file->components, &component->entry);
+}
+
+static HRESULT process_component(struct ciffile *file, struct inf_section *section, const char *section_name)
+{
+    struct cifcomponent *component;
+    HRESULT hr = E_OUTOFMEMORY;
+
+    component = heap_alloc_zero(sizeof(*component));
+    if (!component) return E_OUTOFMEMORY;
+
+    component->ICifComponent_iface.lpVtbl = &cifcomponentVtbl;
+    component->parent = &file->ICifFile_iface;
+
+    list_init(&component->urls);
+    list_init(&component->dependencies);
+
+    component->queue_state = ActionNone;
+
+    component->id = strdupA(section_name);
+    if (!component->id) goto error;
+
+    if (!section_get_str(section, "DisplayName", &component->description, NULL))
+        goto error;
+    if (!section_get_str(section, "GUID", &component->guid, NULL))
+        goto error;
+    if (!section_get_str(section, "Details", &component->details, NULL))
+        goto error;
+    if (!section_get_str(section, "Group", &component->group, NULL))
+        goto error;
+    if (!section_get_str(section, "Locale", &component->locale, "en"))
+        goto error;
+    if (!section_get_str(section, "PatchID", &component->patchid, NULL))
+        goto error;
+
+    if (!section_get_dword_field(section, "Size", 1, &component->size_download, 0))
+        goto error;
+    if (!section_get_dword_field(section, "Size", 2, &component->size_extracted, 0))
+        goto error;
+    if (!section_get_dword_field(section, "InstalledSize", 1, &component->size_app, 0))
+        goto error;
+    if (!section_get_dword_field(section, "InstalledSize", 2, &component->size_win, 0))
+        goto error;
+
+    if (!section_get_str(section, "SuccessKey", &component->key_success, NULL))
+        goto error;
+    if (!section_get_str(section, "CancelKey", &component->key_cancel, NULL))
+        goto error;
+    if (!section_get_str(section, "ProgressKey", &component->key_progress, NULL))
+        goto error;
+    if (!section_get_str(section, "UninstallKey", &component->key_uninstall, NULL))
+        goto error;
+    if (!section_get_dword(section, "Reboot", &component->reboot, 0))
+        goto error;
+    if (!section_get_dword(section, "AdminCheck", &component->admin, 0))
+        goto error;
+    if (!section_get_dword(section, "UIVisible", &component->visibleui, 1))
+        goto error;
+    if (!section_get_dword(section, "ActiveSetupAware", &component->as_aware, 0))
+        goto error;
+    if (!section_get_dword(section, "Priority", &component->priority, 0))
+        goto error;
+
+    if (!read_version_entry(section, &component->version, &component->build))
+        goto error;
+    if (!read_platform_entry(section, &component->platform))
+        goto error;
+    if (!read_urls(component, section))
+        goto error;
+    if (!read_dependencies(component, section))
+        goto error;
+
+    component->current_priority = component->priority;
+
+    add_component_by_priority(file, component);
+    return S_OK;
+
+error:
+    component_free(component);
+    return hr;
+}
+
+static HRESULT process_group(struct ciffile *file, struct inf_section *section, const char *section_name)
+{
+    struct cifgroup *group;
+    HRESULT hr = E_OUTOFMEMORY;
+
+    group = heap_alloc_zero(sizeof(*group));
+    if (!group) return E_OUTOFMEMORY;
+
+    group->ICifGroup_iface.lpVtbl = &cifgroupVtbl;
+    group->parent = &file->ICifFile_iface;
+
+    group->id = strdupA(section_name);
+    if (!group->id) goto error;
+
+    if (!section_get_str(section, "DisplayName", &group->description, NULL))
+        goto error;
+    if (!section_get_dword(section, "Priority", &group->priority, 0))
+        goto error;
+
+    list_add_head(&file->groups, &group->entry);
+    return S_OK;
+
+error:
+    group_free(group);
+    return hr;
+}
+
+static HRESULT process_section(struct ciffile *file, struct inf_section *section, const char *section_name)
+{
+    HRESULT hr = S_OK;
+    char *type;
+
+    if (!section_get_str(section, "SectionType", &type, "Component"))
+        return E_OUTOFMEMORY;
+
+    if (!strcasecmp(type, "Component"))
+        hr = process_component(file, section, section_name);
+    else if (strcasecmp(type, "Group") == 0)
+        hr = process_group(file, section, section_name);
+    else
+        FIXME("Don't know how to process %s\n", debugstr_a(type));
+
+    heap_free(type);
+    return hr;
+}
+
+static HRESULT process_inf(struct ciffile *file, struct inf_file *inf)
+{
+    struct inf_section *section = NULL;
+    char *section_name;
+    HRESULT hr = S_OK;
+
+    while (SUCCEEDED(hr) && inf_next_section(inf, &section))
+    {
+        section_name = inf_section_get_name(section);
+        if (!section_name) return E_OUTOFMEMORY;
+
+        TRACE("start processing section %s\n", debugstr_a(section_name));
+
+        if (!strcasecmp(section_name, "Strings") ||
+            !strncasecmp(section_name, "Strings.", strlen("Strings.")))
+        {
+            /* Ignore string sections */
+        }
+        else if (strcasecmp(section_name, "Version") == 0)
+            hr = process_version(file, section);
+        else
+            hr = process_section(file, section, section_name);
+
+        TRACE("Finished processing section %s, hr %#lx.\n", debugstr_a(section_name), hr);
+        heap_free(section_name);
+    }
+
+    /* In case there was no version section, set the default installer description */
+    if (SUCCEEDED(hr) && !file->name)
+    {
+        file->name = strdupA(DEFAULT_INSTALLER_DESC);
+        if (!file->name) hr = E_OUTOFMEMORY;
+    }
+
+    return hr;
+}
+
+static HRESULT load_ciffile(const char *path, ICifFile **icif)
+{
+    struct inf_file *inf = NULL;
+    struct ciffile *file;
+    HRESULT hr = E_FAIL;
+
+    file = heap_alloc_zero(sizeof(*file));
+    if(!file) return E_OUTOFMEMORY;
+
+    file->ICifFile_iface.lpVtbl = &ciffileVtbl;
+    file->ref = 1;
+
+    list_init(&file->components);
+    list_init(&file->groups);
+
+    hr = inf_load(path, &inf);
+    if (FAILED(hr)) goto error;
+
+    hr = process_inf(file, inf);
+    if (FAILED(hr)) goto error;
+
+    *icif = &file->ICifFile_iface;
+    return S_OK;
+
+error:
+    if (inf) inf_free(inf);
+    ICifFile_Release(&file->ICifFile_iface);
+    return hr;
+}
+
+HRESULT WINAPI GetICifFileFromFile(ICifFile **icif, const char *path)
+{
+    TRACE("(%p, %s)\n", icif, debugstr_a(path));
+
+    return load_ciffile(path, icif);
+}
+
+
+HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **icif, const char *path)
+{
+    FIXME("(%p, %s): stub\n", icif, debugstr_a(path));
+
+    return E_NOTIMPL;
+}
diff --git a/dlls/inseng/inf.c b/dlls/inseng/inf.c
new file mode 100644
index 00000000000..bead72c082c
--- /dev/null
+++ b/dlls/inseng/inf.c
@@ -0,0 +1,443 @@
+/*
+ * Copyright 2016 Michael Müller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <string.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+
+#include "inseng_private.h"
+
+#include "wine/list.h"
+
+struct inf_value
+{
+    struct list entry;
+    char *key;
+    char *value;
+
+    struct inf_section *section;
+};
+
+struct inf_section
+{
+    struct list entry;
+    char *name;
+    struct list values;
+
+    struct inf_file *file;
+};
+
+struct inf_file
+{
+    char *content;
+    DWORD size;
+    struct list sections;
+};
+
+static void inf_value_free(struct inf_value *value)
+{
+    heap_free(value);
+}
+
+static void inf_section_free(struct inf_section *section)
+{
+    struct inf_value *val, *val_next;
+    LIST_FOR_EACH_ENTRY_SAFE(val, val_next, &section->values, struct inf_value, entry)
+    {
+        list_remove(&val->entry);
+        inf_value_free(val);
+    }
+
+    heap_free(section);
+}
+
+static const char *get_substitution(struct inf_file *inf, const char *name, int len)
+{
+    struct inf_section *sec;
+    struct inf_value *value = NULL;
+
+    sec = inf_get_section(inf, "Strings");
+    if (!sec) return NULL;
+
+    while (inf_section_next_value(sec, &value))
+    {
+        if (strlen(value->key) == len && !strncasecmp(value->key, name, len))
+            return value->value;
+    }
+
+    return NULL;
+}
+
+static int expand_variables_buffer(struct inf_file *inf, const char *str, char *output)
+{
+    const char *p, *var_start = NULL;
+    int var_len = 0, len = 0;
+    const char *substitution;
+
+    for (p = str; *p; p++)
+    {
+        if (*p != '%')
+        {
+            if (var_start)
+                var_len++;
+            else
+            {
+                if (output)
+                    *output++ = *p;
+                len++;
+            }
+
+            continue;
+        }
+
+        if (!var_start)
+        {
+            var_start = p;
+            var_len = 0;
+
+            continue;
+        }
+
+        if (!var_len)
+        {
+            /* just an escaped % */
+            if (output)
+                *output++ = '%';
+            len += 1;
+
+            var_start = NULL;
+            continue;
+        }
+
+        substitution = get_substitution(inf, var_start + 1, var_len);
+        if (!substitution)
+        {
+            if (output)
+            {
+                memcpy(output, var_start, var_len + 2);
+                output += var_len + 2;
+            }
+            len += var_len + 2;
+        }
+        else
+        {
+            int sub_len = strlen(substitution);
+
+            if (output)
+            {
+                memcpy(output, substitution, sub_len);
+                output += sub_len;
+            }
+            len += sub_len;
+        }
+
+         var_start = NULL;
+    }
+
+    if (output) *output = 0;
+    return len + 1;
+}
+
+static char *expand_variables(struct inf_file *inf, const char *str)
+{
+    char *buffer;
+    int len;
+
+    len = expand_variables_buffer(inf, str, NULL);
+    buffer = heap_alloc(len);
+    if (!len) return NULL;
+
+    expand_variables_buffer(inf, str, buffer);
+    return buffer;
+}
+
+void inf_free(struct inf_file *inf)
+{
+    struct inf_section *sec, *sec_next;
+    LIST_FOR_EACH_ENTRY_SAFE(sec, sec_next, &inf->sections, struct inf_section, entry)
+    {
+        list_remove(&sec->entry);
+        inf_section_free(sec);
+    }
+
+    heap_free(inf->content);
+    heap_free(inf);
+}
+
+BOOL inf_next_section(struct inf_file *inf, struct inf_section **sec)
+{
+    struct list *next_entry, *cur_position;
+
+    if (*sec)
+        cur_position = &(*sec)->entry;
+    else
+        cur_position = &inf->sections;
+
+    next_entry = list_next(&inf->sections, cur_position);
+    if (!next_entry) return FALSE;
+
+    *sec = CONTAINING_RECORD(next_entry, struct inf_section, entry);
+    return TRUE;
+}
+
+struct inf_section *inf_get_section(struct inf_file *inf, const char *name)
+{
+    struct inf_section *sec = NULL;
+
+    while (inf_next_section(inf, &sec))
+    {
+        if (!strcasecmp(sec->name, name))
+            return sec;
+    }
+
+    return NULL;
+}
+
+char *inf_section_get_name(struct inf_section *section)
+{
+    return strdupA(section->name);
+}
+
+BOOL inf_section_next_value(struct inf_section *sec, struct inf_value **value)
+{
+    struct list *next_entry, *cur_position;
+
+    if (*value)
+        cur_position = &(*value)->entry;
+    else
+        cur_position = &sec->values;
+
+    next_entry = list_next(&sec->values, cur_position);
+    if (!next_entry) return FALSE;
+
+    *value = CONTAINING_RECORD(next_entry, struct inf_value, entry);
+    return TRUE;
+}
+
+struct inf_value *inf_get_value(struct inf_section *sec, const char *key)
+{
+    struct inf_value *value = NULL;
+
+    while (inf_section_next_value(sec, &value))
+    {
+        if (!strcasecmp(value->key, key))
+            return value;
+    }
+
+    return NULL;
+}
+
+char *inf_value_get_key(struct inf_value *value)
+{
+    return strdupA(value->key);
+}
+
+char *inf_value_get_value(struct inf_value *value)
+{
+    return expand_variables(value->section->file, value->value);
+}
+
+char *trim(char *str, char **last_chr, BOOL strip_quotes)
+{
+    char *last;
+
+    for (; *str; str++)
+    {
+        if (*str != '\t' && *str != ' ')
+            break;
+    }
+
+    if (!*str)
+    {
+        if (last_chr) *last_chr = str;
+        return str;
+    }
+
+    last = str + strlen(str) - 1;
+
+    for (; last > str; last--)
+    {
+        if (*last != '\t' && *last != ' ')
+            break;
+        *last = 0;
+    }
+
+    if (strip_quotes && last != str)
+    {
+        if (*last == '"' && *str == '"')
+        {
+            str++;
+            *last = 0;
+        }
+    }
+
+    if (last_chr) *last_chr = last;
+    return str;
+}
+
+static char *get_next_line(char **str, char **last_chr)
+{
+    BOOL in_next_line = FALSE;
+    char *start, *next;
+
+    start = *str;
+    if (!start || !*start) return NULL;
+
+    for (next = start; *next; next++)
+    {
+        if (*next == '\n' || *next == '\r')
+        {
+            *next = 0;
+            in_next_line = TRUE;
+        }
+        else if (in_next_line)
+        {
+            break;
+        }
+    }
+
+    *str = next;
+    return trim(start, last_chr, FALSE);
+}
+
+/* This function only fails in case of an memory allocation error
+ * and does not touch section in case the parsing failed. */
+static HRESULT inf_section_parse(struct inf_file *inf, char *line, char *last_chr, struct inf_section **section)
+{
+    struct inf_section *sec;
+    char *comment;
+    char *name;
+
+    if (*line != '[')
+        return S_OK;
+
+    line++;
+
+    comment = strchr(line, ';');
+    if (comment)
+    {
+        *comment = 0;
+        line = trim(line, &last_chr, FALSE);
+    }
+
+    if (*last_chr != ']')
+        return S_OK;
+
+    *last_chr = 0;
+    name = trim(line, NULL, FALSE);
+    if (!name) return S_OK;
+
+    sec = heap_alloc_zero(sizeof(*sec));
+    if (!sec) return E_OUTOFMEMORY;
+
+    sec->name = name;
+    sec->file = inf;
+    list_init(&sec->values);
+
+    list_add_tail(&inf->sections, &sec->entry);
+
+    *section = sec;
+    return S_OK;
+}
+
+static HRESULT inf_value_parse(struct inf_section *sec, char *line)
+{
+    struct inf_value *key_val;
+    char *key, *value, *del;
+
+    del = strchr(line, '=');
+    if (!del) return S_OK;
+
+    *del = 0;
+    key = line;
+    value = del + 1;
+
+    key = trim(key, NULL, FALSE);
+    value = trim(value, NULL, TRUE);
+
+    key_val = heap_alloc_zero(sizeof(*key_val));
+    if (!key_val) return E_OUTOFMEMORY;
+
+    key_val->key = key;
+    key_val->value = value;
+    key_val->section = sec;
+
+    list_add_tail(&sec->values, &key_val->entry);
+    return S_OK;
+}
+
+static HRESULT inf_process_content(struct inf_file *inf)
+{
+    struct inf_section *section = NULL;
+    char *content = inf->content;
+    char *line, *last_chr;
+    HRESULT hr = S_OK;
+
+    while (SUCCEEDED(hr) && (line = get_next_line(&content, &last_chr)))
+    {
+        if (*line == '[')
+            hr = inf_section_parse(inf, line, last_chr, &section);
+        else if (strchr(line, '=') && section)
+            hr = inf_value_parse(section, line);
+    }
+
+    return hr;
+}
+
+HRESULT inf_load(const char *path, struct inf_file **inf_file)
+{
+    LARGE_INTEGER file_size;
+    struct inf_file *inf;
+    HRESULT hr = E_FAIL;
+    HANDLE file;
+    DWORD read;
+
+    file = CreateFileA(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE) return E_FAIL;
+
+    inf = heap_alloc_zero(sizeof(*inf));
+    if (!inf) goto error;
+
+    if (!GetFileSizeEx(file, &file_size))
+        goto error;
+
+    inf->size = file_size.QuadPart;
+
+    inf->content = heap_alloc_zero(inf->size);
+    if (!inf->content) goto error;
+
+    list_init(&inf->sections);
+
+    if (!ReadFile(file, inf->content, inf->size, &read, NULL) || read != inf->size)
+        goto error;
+
+    hr = inf_process_content(inf);
+    if (FAILED(hr)) goto error;
+
+    CloseHandle(file);
+    *inf_file = inf;
+    return S_OK;
+
+error:
+    if (inf) inf_free(inf);
+    CloseHandle(file);
+    return hr;
+}
diff --git a/dlls/inseng/inseng.spec b/dlls/inseng/inseng.spec
index 82c0b4d5fe1..7ae46fad3a7 100644
--- a/dlls/inseng/inseng.spec
+++ b/dlls/inseng/inseng.spec
@@ -7,6 +7,6 @@
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stub DownloadFile
-@ stub GetICifFileFromFile
-@ stub GetICifRWFileFromFile
+@ stdcall GetICifFileFromFile(ptr str)
+@ stdcall GetICifRWFileFromFile(ptr str)
 @ stub PurgeDownloadDirectory
diff --git a/dlls/inseng/inseng_main.c b/dlls/inseng/inseng_main.c
index f7ce3f173c2..ad6fe6b4de8 100644
--- a/dlls/inseng/inseng_main.c
+++ b/dlls/inseng/inseng_main.c
@@ -2,6 +2,7 @@
  *    INSENG Implementation
  *
  * Copyright 2006 Mike McCormack
+ * Copyright 2016 Michael Müller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -28,16 +29,68 @@
 #include "winuser.h"
 #include "ole2.h"
 #include "rpcproxy.h"
+#include "urlmon.h"
+#include "shlwapi.h"
 #include "initguid.h"
 #include "inseng.h"
 
+#include "inseng_private.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(inseng);
 
+enum thread_operation
+{
+    OP_DOWNLOAD,
+    OP_INSTALL
+};
+
+struct thread_info
+{
+    DWORD operation;
+    DWORD jobflags;
+    IEnumCifComponents *enum_comp;
+
+    DWORD download_size;
+    DWORD install_size;
+
+    DWORD downloaded_kb;
+    ULONGLONG download_start;
+};
+
 struct InstallEngine {
     IInstallEngine2 IInstallEngine2_iface;
+    IInstallEngineTiming IInstallEngineTiming_iface;
     LONG ref;
+
+    IInstallEngineCallback *callback;
+    char *baseurl;
+    char *downloaddir;
+    ICifFile *icif;
+    DWORD status;
+
+    /* used for the installation thread */
+    struct thread_info thread;
+};
+
+struct downloadcb
+{
+    IBindStatusCallback IBindStatusCallback_iface;
+    LONG ref;
+
+    WCHAR *file_name;
+    WCHAR *cache_file;
+
+    char *id;
+    char *display;
+
+    DWORD dl_size;
+    DWORD dl_previous_kb;
+
+    InstallEngine *engine;
+    HANDLE event_done;
+    HRESULT hr;
 };
 
 static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
@@ -45,6 +98,250 @@ static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
     return CONTAINING_RECORD(iface, InstallEngine, IInstallEngine2_iface);
 }
 
+static inline struct downloadcb *impl_from_IBindStatusCallback(IBindStatusCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct downloadcb, IBindStatusCallback_iface);
+}
+
+static inline InstallEngine *impl_from_IInstallEngineTiming(IInstallEngineTiming *iface)
+{
+    return CONTAINING_RECORD(iface, InstallEngine, IInstallEngineTiming_iface);
+}
+
+static HRESULT WINAPI downloadcb_QueryInterface(IBindStatusCallback *iface, REFIID riid, void **ppv)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IBindStatusCallback_iface;
+    }
+    else if (IsEqualGUID(&IID_IBindStatusCallback, riid))
+    {
+        TRACE("(%p)->(IID_IBindStatusCallback %p)\n", This, ppv);
+        *ppv = &This->IBindStatusCallback_iface;
+    }
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI downloadcb_AddRef(IBindStatusCallback *iface)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref = %ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI downloadcb_Release(IBindStatusCallback *iface)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref = %ld\n", This, ref);
+
+    if (!ref)
+    {
+        heap_free(This->file_name);
+        heap_free(This->cache_file);
+
+        IInstallEngine2_Release(&This->engine->IInstallEngine2_iface);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI downloadcb_OnStartBinding(IBindStatusCallback *iface, DWORD reserved, IBinding *pbind)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%lu %p)\n", This, reserved, pbind);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_GetPriority(IBindStatusCallback *iface, LONG *priority)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%p): stub\n", This, priority);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI downloadcb_OnLowResource(IBindStatusCallback *iface, DWORD reserved)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%lu): stub\n", This, reserved);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI downloadcb_OnProgress(IBindStatusCallback *iface, ULONG progress,
+        ULONG progress_max, ULONG status, const WCHAR *status_text)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("%p)->(%lu %lu %lu %s)\n", This, progress, progress_max, status, debugstr_w(status_text));
+
+    switch(status)
+    {
+        case BINDSTATUS_BEGINDOWNLOADDATA:
+            if (!This->engine->thread.download_start)
+                This->engine->thread.download_start = GetTickCount64();
+            /* fall-through */
+        case BINDSTATUS_DOWNLOADINGDATA:
+        case BINDSTATUS_ENDDOWNLOADDATA:
+            This->engine->thread.downloaded_kb = This->dl_previous_kb + progress / 1024;
+            if (This->engine->callback)
+            {
+                hr = IInstallEngineCallback_OnComponentProgress(This->engine->callback,
+                         This->id, INSTALLSTATUS_DOWNLOADING, This->display, NULL, progress / 1024, This->dl_size);
+            }
+            break;
+
+        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
+            This->cache_file = strdupW(status_text);
+            if (!This->cache_file)
+            {
+                ERR("Failed to allocate memory for cache file\n");
+                hr = E_OUTOFMEMORY;
+            }
+            break;
+
+        case BINDSTATUS_CONNECTING:
+        case BINDSTATUS_SENDINGREQUEST:
+        case BINDSTATUS_MIMETYPEAVAILABLE:
+        case BINDSTATUS_FINDINGRESOURCE:
+            break;
+
+        default:
+            FIXME("Unsupported status %lu\n", status);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI downloadcb_OnStopBinding(IBindStatusCallback *iface, HRESULT hresult, LPCWSTR szError)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%#lx %s)\n", This, hresult, debugstr_w(szError));
+
+    if (FAILED(hresult))
+    {
+        This->hr = hresult;
+        goto done;
+    }
+
+    if (!This->cache_file)
+    {
+        This->hr = E_FAIL;
+        goto done;
+    }
+
+    if (CopyFileW(This->cache_file, This->file_name, FALSE))
+        This->hr = S_OK;
+    else
+    {
+        ERR("CopyFile failed: %lu\n", GetLastError());
+        This->hr = E_FAIL;
+    }
+
+done:
+    SetEvent(This->event_done);
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_GetBindInfo(IBindStatusCallback *iface,
+        DWORD *grfBINDF, BINDINFO *pbindinfo)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%p %p)\n", This, grfBINDF, pbindinfo);
+
+    *grfBINDF = BINDF_PULLDATA | BINDF_NEEDFILE;
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_OnDataAvailable(IBindStatusCallback *iface,
+        DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%#lx %lu %p %p)\n", This, grfBSCF, dwSize, pformatetc, pstgmed);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_OnObjectAvailable(IBindStatusCallback *iface,
+        REFIID riid, IUnknown *punk)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_guid(riid), punk);
+
+    return E_NOTIMPL;
+}
+
+static const IBindStatusCallbackVtbl BindStatusCallbackVtbl =
+{
+    downloadcb_QueryInterface,
+    downloadcb_AddRef,
+    downloadcb_Release,
+    downloadcb_OnStartBinding,
+    downloadcb_GetPriority,
+    downloadcb_OnLowResource,
+    downloadcb_OnProgress,
+    downloadcb_OnStopBinding,
+    downloadcb_GetBindInfo,
+    downloadcb_OnDataAvailable,
+    downloadcb_OnObjectAvailable
+};
+
+static HRESULT downloadcb_create(InstallEngine *engine, HANDLE event, char *file_name, char *id,
+                                 char *display, DWORD dl_size, struct downloadcb **callback)
+{
+    struct downloadcb *cb;
+
+    cb = heap_alloc_zero(sizeof(*cb));
+    if (!cb) return E_OUTOFMEMORY;
+
+    cb->IBindStatusCallback_iface.lpVtbl = &BindStatusCallbackVtbl;
+    cb->ref = 1;
+    cb->hr = E_FAIL;
+    cb->id = id;
+    cb->display = display;
+    cb->engine = engine;
+    cb->dl_size = dl_size;
+    cb->dl_previous_kb = engine->thread.downloaded_kb;
+    cb->event_done = event;
+    cb->file_name = strAtoW(file_name);
+    if (!cb->file_name)
+    {
+        heap_free(cb);
+        return E_OUTOFMEMORY;
+    }
+
+    IInstallEngine2_AddRef(&engine->IInstallEngine2_iface);
+
+    *callback = cb;
+    return S_OK;
+}
+
 static HRESULT WINAPI InstallEngine_QueryInterface(IInstallEngine2 *iface, REFIID riid, void **ppv)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
@@ -58,13 +355,16 @@ static HRESULT WINAPI InstallEngine_QueryInterface(IInstallEngine2 *iface, REFII
     }else if(IsEqualGUID(&IID_IInstallEngine2, riid)) {
         TRACE("(%p)->(IID_IInstallEngine2 %p)\n", This, ppv);
         *ppv = &This->IInstallEngine2_iface;
+    }else if(IsEqualGUID(&IID_IInstallEngineTiming, riid)) {
+        TRACE("(%p)->(IID_IInstallEngineTiming %p)\n", This, ppv);
+        *ppv = &This->IInstallEngineTiming_iface;
     }else {
-        TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppv);
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
         *ppv = NULL;
         return E_NOINTERFACE;
     }
 
-    IUnknown_AddRef((IUnknown*)*ppv);
+    IUnknown_AddRef((IUnknown *)*ppv);
     return S_OK;
 }
 
@@ -85,181 +385,726 @@ static ULONG WINAPI InstallEngine_Release(IInstallEngine2 *iface)
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
-    if(!ref)
+    if (!ref)
+    {
+        if (This->icif)
+            ICifFile_Release(This->icif);
+
+        free(This->baseurl);
+        free(This->downloaddir);
         free(This);
+    }
 
     return ref;
 }
 
+static void set_status(InstallEngine *This, DWORD status)
+{
+    This->status = status;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, status, 0);
+}
+
+static HRESULT calc_sizes(IEnumCifComponents *enum_comp, DWORD operation, DWORD *size_download, DWORD *size_install)
+{
+    ICifComponent *comp;
+    DWORD download = 0;
+    DWORD install = 0;
+    HRESULT hr;
+
+    /* FIXME: what about inactive dependencies and how does
+     * INSTALLOPTIONS_FORCEDEPENDENCIES play into this ?*/
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) == S_FALSE)
+            download = ICifComponent_GetDownloadSize(comp);
+        /*
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) == S_FALSE)
+            install = ICifComponent_GetInstalledSize(comp);
+        */
+    }
+
+    *size_download = download;
+    *size_install = install;
+
+    return S_OK;
+}
+
+static HRESULT get_next_component(IEnumCifComponents *enum_comp, DWORD operation, ICifComponent **ret_comp)
+{
+    ICifComponent *comp;
+    HRESULT hr;
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) != S_FALSE)
+            continue;
+
+        *ret_comp = comp;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT get_url(ICifComponent *comp, int index, char **url, DWORD *flags)
+{
+    char *url_temp = NULL;
+    int size = MAX_PATH / 2;
+    HRESULT hr;
+
+    /* FIXME: should we add an internal get function to prevent this ugly code ? */
+
+    /* check if there is an url with such an index */
+    hr = ICifComponent_GetUrl(comp, index, NULL, 0, flags);
+    if (FAILED(hr))
+    {
+        *url = NULL;
+        *flags = 0;
+        return S_OK;
+    }
+
+    do
+    {
+        size *= 2;
+        heap_free(url_temp);
+        url_temp = heap_alloc(size);
+        if (!url_temp) return E_OUTOFMEMORY;
+
+        hr = ICifComponent_GetUrl(comp, index, url_temp, size, flags);
+        if (FAILED(hr))
+        {
+            heap_free(url_temp);
+            return hr;
+        }
+    }
+    while (strlen(url_temp) == size-1);
+
+    *url = url_temp;
+    return S_OK;
+}
+
+static char *combine_url(char *baseurl, char *url)
+{
+    int len_base = strlen(baseurl);
+    int len_url = strlen(url);
+    char *combined;
+
+    combined = heap_alloc(len_base + len_url + 2);
+    if (!combined) return NULL;
+
+    strcpy(combined, baseurl);
+    if (len_base && combined[len_base-1] != '/')
+        strcat(combined, "/");
+    strcat(combined, url);
+
+    return combined;
+}
+
+static HRESULT generate_moniker(char *baseurl, char *url, DWORD flags, IMoniker **moniker)
+{
+    WCHAR *urlW;
+    HRESULT hr;
+
+    if (flags & URLF_RELATIVEURL)
+    {
+        char *combined;
+        if (!baseurl)
+            return E_FAIL;
+
+        combined = combine_url(baseurl, url);
+        if (!combined) return E_OUTOFMEMORY;
+
+        urlW = strAtoW(combined);
+        heap_free(combined);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+    else
+    {
+        urlW = strAtoW(url);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+
+    hr = CreateURLMoniker(NULL, urlW, moniker);
+    heap_free(urlW);
+    return hr;
+}
+
+static char *merge_path(char *path1, char *path2)
+{
+    int len = strlen(path1) + strlen(path2) + 2;
+    char *combined = heap_alloc(len);
+
+    if (!combined) return NULL;
+    strcpy(combined, path1);
+    strcat(combined, "\\");
+    strcat(combined, path2);
+
+    return combined;
+}
+
+static HRESULT download_url(InstallEngine *This, char *id, char *display, char *url, DWORD flags, DWORD dl_size)
+{
+    struct downloadcb *callback = NULL;
+    char *filename    = NULL;
+    IUnknown *unk     = NULL;
+    IMoniker *mon     = NULL;
+    IBindCtx *bindctx = NULL;
+    HANDLE event      = NULL;
+    HRESULT hr;
+
+    if (!This->downloaddir)
+    {
+        WARN("No download directory set\n");
+        return E_FAIL;
+    }
+
+    hr = generate_moniker(This->baseurl, url, flags, &mon);
+    if (FAILED(hr))
+    {
+        FIXME("Failed to create moniker\n");
+        return hr;
+    }
+
+    event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!event)
+    {
+        IMoniker_Release(mon);
+        return E_FAIL;
+    }
+
+    filename = strrchr(url, '/');
+    if (!filename) filename = url;
+
+    filename = merge_path(This->downloaddir, filename);
+    if (!filename)
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+
+    hr = downloadcb_create(This, event, filename, id, display, dl_size, &callback);
+    if (FAILED(hr)) goto error;
+
+    hr = CreateAsyncBindCtx(0, &callback->IBindStatusCallback_iface, NULL, &bindctx);
+    if(FAILED(hr)) goto error;
+
+    hr = IMoniker_BindToStorage(mon, bindctx, NULL, &IID_IUnknown, (void**)&unk);
+    if (FAILED(hr)) goto error;
+    if (unk) IUnknown_Release(unk);
+
+    heap_free(filename);
+    IMoniker_Release(mon);
+    IBindCtx_Release(bindctx);
+
+    WaitForSingleObject(event, INFINITE);
+    hr = callback->hr;
+
+    CloseHandle(event);
+    IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    return hr;
+
+error:
+    if (mon) IMoniker_Release(mon);
+    if (event) CloseHandle(event);
+    if (callback) IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    if (bindctx) IBindCtx_Release(bindctx);
+    if (filename) heap_free(filename);
+    return hr;
+}
+
+static HRESULT process_component_dependencies(InstallEngine *This, ICifComponent *comp)
+{
+    char id[MAX_ID_LENGTH+1], type;
+    DWORD ver, build;
+    HRESULT hr;
+    int i;
+
+    for (i = 0;; i++)
+    {
+        hr = ICifComponent_GetDependency(comp, i, id, sizeof(id), &type, &ver, &build);
+        if (SUCCEEDED(hr))
+            FIXME("Can't handle dependencies yet: %s\n", debugstr_a(id));
+        else
+            break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT process_component(InstallEngine *This, ICifComponent *comp)
+{
+    DWORD size_dl, size_install, phase;
+    char display[MAX_DISPLAYNAME_LENGTH+1];
+    char id[MAX_ID_LENGTH+1];
+    HRESULT hr;
+    int i;
+
+    hr = ICifComponent_GetID(comp, id, sizeof(id));
+    if (FAILED(hr)) return hr;
+
+    TRACE("processing component %s\n", debugstr_a(id));
+
+    hr = ICifComponent_GetDescription(comp, display, sizeof(display));
+    if (FAILED(hr)) return hr;
+
+    size_dl      = (This->thread.operation == OP_DOWNLOAD) ? ICifComponent_GetDownloadSize(comp) : 0;
+    size_install = 0; /* (This->thread.operation == OP_INSTALL) ? ICifComponent_GetInstalledSize(comp) : 0; */
+
+    if (This->callback)
+    {
+        IInstallEngineCallback_OnStartComponent(This->callback, id, size_dl, size_install, display);
+        IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_INITIALIZING, display, NULL, 0, 0);
+        phase = INSTALLSTATUS_INITIALIZING;
+    }
+
+    hr = process_component_dependencies(This, comp);
+    if (FAILED(hr)) return hr;
+
+    if (This->thread.operation == OP_DOWNLOAD)
+    {
+        for (i = 0;; i++)
+        {
+            DWORD flags;
+            char *url;
+
+            phase = INSTALLSTATUS_DOWNLOADING;
+
+            hr = get_url(comp, i, &url, &flags);
+            if (FAILED(hr)) goto done;
+            if (!url) break;
+
+            TRACE("processing url %s\n", debugstr_a(url));
+
+            hr = download_url(This, id, display, url, flags, size_dl);
+            heap_free(url);
+            if (FAILED(hr))
+            {
+                DWORD retry = 0;
+
+                if (This->callback)
+                    IInstallEngineCallback_OnEngineProblem(This->callback, ENGINEPROBLEM_DOWNLOADFAIL, &retry);
+                if (!retry) goto done;
+
+                i--;
+                continue;
+            }
+
+            phase = INSTALLSTATUS_CHECKINGTRUST;
+            /* FIXME: check trust */
+            IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_CHECKINGTRUST, display, NULL, 0, 0);
+        }
+
+        component_set_downloaded(comp, TRUE);
+        phase = INSTALLSTATUS_DOWNLOADFINISHED;
+    }
+    else
+        FIXME("Installation not yet implemented\n");
+
+done:
+    IInstallEngineCallback_OnStopComponent(This->callback, id, hr, phase, display, 0);
+    return hr;
+}
+
+DWORD WINAPI thread_installation(LPVOID param)
+{
+    InstallEngine *This = param;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    if (This->callback)
+        IInstallEngineCallback_OnStartInstall(This->callback, This->thread.download_size, This->thread.install_size);
+
+    for (;;)
+    {
+        hr = get_next_component(This->thread.enum_comp, This->thread.operation, &comp);
+        if (FAILED(hr)) break;
+        if (hr == S_FALSE)
+        {
+            hr = S_OK;
+            break;
+        }
+
+        hr = process_component(This, comp);
+        if (FAILED(hr)) break;
+    }
+
+    if (This->callback)
+        IInstallEngineCallback_OnStopInstall(This->callback, hr, NULL, 0);
+
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    IInstallEngine2_Release(&This->IInstallEngine2_iface);
+
+    set_status(This, ENGINESTATUS_READY);
+    return 0;
+}
+
+static HRESULT start_installation(InstallEngine *This, DWORD operation, DWORD jobflags)
+{
+    HANDLE thread;
+    HRESULT hr;
+
+    This->thread.operation = operation;
+    This->thread.jobflags  = jobflags;
+    This->thread.downloaded_kb = 0;
+    This->thread.download_start = 0;
+
+    /* Windows sends the OnStartInstall event from a different thread,
+     * but OnStartInstall already contains the required download and install size.
+     * The only way to signal an error from the thread is to send an OnStopComponent /
+     * OnStopInstall signal which can only occur after OnStartInstall. We need to
+     * precompute the sizes here to be able inform the application about errors while
+     * calculating the required sizes. */
+
+    hr = ICifFile_EnumComponents(This->icif, &This->thread.enum_comp, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    hr = calc_sizes(This->thread.enum_comp, operation, &This->thread.download_size, &This->thread.install_size);
+    if (FAILED(hr)) goto error;
+
+    IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+
+    thread = CreateThread(NULL, 0, thread_installation, This, 0, NULL);
+    if (!thread)
+    {
+        IInstallEngine2_Release(&This->IInstallEngine2_iface);
+        hr = E_FAIL;
+        goto error;
+    }
+
+    CloseHandle(thread);
+    return S_OK;
+
+error:
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    return hr;
+}
+
 static HRESULT WINAPI InstallEngine_GetEngineStatus(IInstallEngine2 *iface, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, status);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, status);
+
+    if (!status)
+        return E_FAIL;
+
+    *status = This->status;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetCifFile(IInstallEngine2 *iface, const char *cab_name, const char *cif_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_DownloadComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%#lx)\n", This, flags);
+
+    /* The interface is not really threadsafe on windows, but we can at least prevent multiple installations */
+    if (InterlockedCompareExchange((LONG *)&This->status, ENGINESTATUS_INSTALLING, ENGINESTATUS_READY) != ENGINESTATUS_READY)
+        return E_FAIL;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, ENGINESTATUS_INSTALLING, 0);
+
+    return start_installation(This, OP_DOWNLOAD, flags);
 }
 
 static HRESULT WINAPI InstallEngine_InstallComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumInstallIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
+
+    FIXME("(%p)->(%u %p): stub\n", This, index, id);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumDownloadIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
-    return E_NOTIMPL;
+    IEnumCifComponents *enum_components;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%u %p)\n", This, index, id);
+
+    if (!This->icif || !id)
+        return E_FAIL;
+
+    hr = ICifFile_EnumComponents(This->icif, &enum_components, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    for (;;)
+    {
+        hr = IEnumCifComponents_Next(enum_components, &comp);
+        if (FAILED(hr)) goto done;
+
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        if (ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+
+        if (index == 0)
+        {
+            char *id_src = component_get_id(comp);
+            *id = CoTaskMemAlloc(strlen(id_src) + 1);
+
+            if (*id)
+                strcpy(*id, id_src);
+            else
+                hr = E_OUTOFMEMORY;
+            goto done;
+        }
+
+        index--;
+    }
+
+done:
+    IEnumCifComponents_Release(enum_components);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_IsComponentInstalled(IInstallEngine2 *iface, const char *id, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), status);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), status);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_RegisterInstallEngineCallback(IInstallEngine2 *iface, IInstallEngineCallback *callback)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, callback);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, callback);
+
+    This->callback = callback;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_UnregisterInstallEngineCallback(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
-    return E_NOTIMPL;
+
+    TRACE("(%p)\n", This);
+
+    This->callback = NULL;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetAction(IInstallEngine2 *iface, const char *id, DWORD action, DWORD priority)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %ld %ld)\n", This, debugstr_a(id), action, priority);
-    return E_NOTIMPL;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %lu %lu)\n", This, debugstr_a(id), action, priority);
+
+    if (!This->icif)
+        return E_FAIL; /* FIXME: check error code */
+
+    hr = ICifFile_FindComponent(This->icif, id, &comp);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetInstallQueueState(comp, action);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetCurrentPriority(comp, priority);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_GetSizes(IInstallEngine2 *iface, const char *id, COMPONENT_SIZES *sizes)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), sizes);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), sizes);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_LaunchExtraCommand(IInstallEngine2 *iface, const char *inf_name, const char *section)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(inf_name), debugstr_a(section));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(inf_name), debugstr_a(section));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_GetDisplayName(IInstallEngine2 *iface, const char *id, const char *name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(id), debugstr_a(name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(id), debugstr_a(name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetBaseUrl(IInstallEngine2 *iface, const char *base_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(base_name));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(base_name));
+
+    if (This->baseurl)
+        heap_free(This->baseurl);
+
+    This->baseurl = strdupA(base_name);
+    return This->baseurl ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetDownloadDir(IInstallEngine2 *iface, const char *download_dir)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(download_dir));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(download_dir));
+
+    if (This->downloaddir)
+        heap_free(This->downloaddir);
+
+    This->downloaddir = strdupA(download_dir);
+    return This->downloaddir ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallDrive(IInstallEngine2 *iface, char drive)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%c)\n", This, drive);
+
+    FIXME("(%p)->(%c): stub\n", This, drive);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallOptions(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetHWND(IInstallEngine2 *iface, HWND hwnd)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, hwnd);
+
+    FIXME("(%p)->(%p): stub\n", This, hwnd);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetIStream(IInstallEngine2 *iface, IStream *stream)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, stream);
+
+    FIXME("(%p)->(%p): stub\n", This, stream);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Abort(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Suspend(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Resume(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine2_SetLocalCif(IInstallEngine2 *iface, const char *cif)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(cif));
-    return E_NOTIMPL;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(cif));
+
+    if (This->icif)
+        ICifFile_Release(This->icif);
+
+    set_status(This, ENGINESTATUS_LOADING);
+
+    hr = GetICifFileFromFile(&This->icif, cif);
+    if (SUCCEEDED(hr))
+        set_status(This, ENGINESTATUS_READY);
+    else
+    {
+        This->icif = NULL;
+        set_status(This, ENGINESTATUS_NOTREADY);
+    }
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine2_GetICifFile(IInstallEngine2 *iface, ICifFile **cif_file)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, cif_file);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, cif_file);
+
+    if (!This->icif || !cif_file)
+        return E_FAIL;
+
+    ICifFile_AddRef(This->icif);
+    *cif_file = This->icif;
+    return S_OK;
 }
 
-static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
+static const IInstallEngine2Vtbl InstallEngine2Vtbl =
+{
     InstallEngine_QueryInterface,
     InstallEngine_AddRef,
     InstallEngine_Release,
@@ -289,6 +1134,70 @@ static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
     InstallEngine2_GetICifFile
 };
 
+static HRESULT WINAPI InstallEngineTiming_QueryInterface(IInstallEngineTiming *iface, REFIID riid, void **ppv)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_QueryInterface(&This->IInstallEngine2_iface, riid, ppv);
+}
+
+static ULONG WINAPI InstallEngineTiming_AddRef(IInstallEngineTiming *iface)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+}
+
+static ULONG WINAPI InstallEngineTiming_Release(IInstallEngineTiming *iface)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_Release(&This->IInstallEngine2_iface);
+}
+
+static HRESULT WINAPI InstallEngineTiming_GetRates(IInstallEngineTiming *iface, DWORD *download, DWORD *install)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+
+    FIXME("(%p)->(%p, %p): stub\n", This, download, install);
+
+    *download = 0;
+    *install = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI InstallEngineTiming_GetInstallProgress(IInstallEngineTiming *iface, INSTALLPROGRESS *progress)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    ULONGLONG elapsed;
+    static int once;
+
+    if (!once)
+        FIXME("(%p)->(%p): semi-stub\n", This, progress);
+    else
+        TRACE("(%p)->(%p): semi-stub\n", This, progress);
+
+    progress->dwDownloadKBRemaining = max(This->thread.download_size, This->thread.downloaded_kb) - This->thread.downloaded_kb;
+
+    elapsed = GetTickCount64() - This->thread.download_start;
+    if (This->thread.download_start && This->thread.downloaded_kb && elapsed > 100)
+        progress->dwDownloadSecsRemaining = (progress->dwDownloadKBRemaining * elapsed) / (This->thread.downloaded_kb * 1000);
+    else
+        progress->dwDownloadSecsRemaining = -1;
+
+    progress->dwInstallKBRemaining = 0;
+    progress->dwInstallSecsRemaining = -1;
+
+    return S_OK;
+}
+
+static const IInstallEngineTimingVtbl InstallEngineTimingVtbl =
+{
+    InstallEngineTiming_QueryInterface,
+    InstallEngineTiming_AddRef,
+    InstallEngineTiming_Release,
+    InstallEngineTiming_GetRates,
+    InstallEngineTiming_GetInstallProgress,
+};
+
 static HRESULT WINAPI ClassFactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppv)
 {
     *ppv = NULL;
@@ -333,12 +1242,14 @@ static HRESULT WINAPI InstallEngineCF_CreateInstance(IClassFactory *iface, IUnkn
 
     TRACE("(%p %s %p)\n", outer, debugstr_guid(riid), ppv);
 
-    engine = malloc(sizeof(*engine));
+    engine = calloc(1, sizeof(*engine));
     if(!engine)
         return E_OUTOFMEMORY;
 
     engine->IInstallEngine2_iface.lpVtbl = &InstallEngine2Vtbl;
+    engine->IInstallEngineTiming_iface.lpVtbl = &InstallEngineTimingVtbl;
     engine->ref = 1;
+    engine->status = ENGINESTATUS_NOTREADY;
 
     hres = IInstallEngine2_QueryInterface(&engine->IInstallEngine2_iface, riid, ppv);
     IInstallEngine2_Release(&engine->IInstallEngine2_iface);
diff --git a/dlls/inseng/inseng_private.h b/dlls/inseng/inseng_private.h
new file mode 100644
index 00000000000..49d4241d65e
--- /dev/null
+++ b/dlls/inseng/inseng_private.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Michael Müller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "ole2.h"
+#include "rpcproxy.h"
+#include "inseng.h"
+#include "wine/heap.h"
+
+
+static inline char *strdupA(const char *src)
+{
+    char *dest = heap_alloc(strlen(src) + 1);
+    if (dest) strcpy(dest, src);
+    return dest;
+}
+
+static inline WCHAR *strdupW(const WCHAR *src)
+{
+    WCHAR *dest;
+    if (!src) return NULL;
+    dest = HeapAlloc(GetProcessHeap(), 0, (lstrlenW(src) + 1) * sizeof(WCHAR));
+    if (dest) lstrcpyW(dest, src);
+    return dest;
+}
+
+static inline LPWSTR strAtoW(const char *str)
+{
+    LPWSTR ret = NULL;
+
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
+        if ((ret = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR))))
+            MultiByteToWideChar(CP_ACP, 0, str, -1, ret, len);
+    }
+
+    return ret;
+}
+
+struct inf_value;
+struct inf_section;
+struct inf_file;
+
+HRESULT inf_load(const char *path, struct inf_file **inf_file);
+void inf_free(struct inf_file *inf);
+
+BOOL inf_next_section(struct inf_file *inf, struct inf_section **sec);
+struct inf_section *inf_get_section(struct inf_file *inf, const char *name);
+char *inf_section_get_name(struct inf_section *section);
+BOOL inf_section_next_value(struct inf_section *sec, struct inf_value **value);
+
+struct inf_value *inf_get_value(struct inf_section *sec, const char *key);
+char *inf_value_get_key(struct inf_value *value);
+char *inf_value_get_value(struct inf_value *value);
+
+char *trim(char *str, char **last_chr, BOOL strip_quotes);
+
+void component_set_actual_download_size(ICifComponent *iface, DWORD size);
+void component_set_downloaded(ICifComponent *iface, BOOL value);
+void component_set_installed(ICifComponent *iface, BOOL value);
+char *component_get_id(ICifComponent *iface);
diff --git a/include/inseng.idl b/include/inseng.idl
index 8a3f4c4d270..82927418a99 100644
--- a/include/inseng.idl
+++ b/include/inseng.idl
@@ -1,5 +1,6 @@
 /*
  * Copyright 2015 Jacek Caban for CodeWeavers
+ * Copyright 2016 Michael Müller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -26,15 +27,231 @@ cpp_quote("#endif")
 
 interface IStream;
 
-/* FIXME: Add full declarations. */
-interface ICifComponent;
-interface IEnumCifComponents;
-interface ICifGroup;
-interface IEnumCifGroups;
-interface ICifMode;
-interface IEnumCifModes;
+cpp_quote("#define MAX_ID_LENGTH            48")
+cpp_quote("#define MAX_DISPLAYNAME_LENGTH   128")
 
-typedef struct {
+cpp_quote("#define URLF_DEFAULT                 0x0")
+cpp_quote("#define URLF_EXTRACT                 0x1")
+cpp_quote("#define URLF_RELATIVEURL             0x2")
+cpp_quote("#define URLF_DELETE_AFTER_EXTRACT    0x4")
+
+cpp_quote("#define ENGINESTATUS_NOTREADY    0x0")
+cpp_quote("#define ENGINESTATUS_LOADING     0x1")
+cpp_quote("#define ENGINESTATUS_INSTALLING  0x2")
+cpp_quote("#define ENGINESTATUS_READY       0x3")
+
+cpp_quote("#define SETACTION_NONE       0x0")
+cpp_quote("#define SETACTION_INSTALL    0x1")
+
+cpp_quote("#define INSTALLOPTIONS_NOCACHE               0x01")
+cpp_quote("#define INSTALLOPTIONS_DOWNLOAD              0x02")
+cpp_quote("#define INSTALLOPTIONS_INSTALL               0x04")
+cpp_quote("#define INSTALLOPTIONS_DONTALLOWXPLATFORM    0x08")
+cpp_quote("#define INSTALLOPTIONS_FORCEDEPENDENCIES     0x10")
+
+cpp_quote("#define EXECUTEJOB_SILENT                0x01")
+cpp_quote("#define EXECUTEJOB_DELETE_JOB            0x02")
+cpp_quote("#define EXECUTEJOB_VERIFYFILES           0x08")
+cpp_quote("#define EXECUTEJOB_IGNORETRUST           0x10")
+cpp_quote("#define EXECUTEJOB_IGNOREDOWNLOADERROR   0x20")
+cpp_quote("#define EXECUTEJOB_DONTALLOWCANCEL       0x40")
+
+cpp_quote("#define ENGINEPROBLEM_DOWNLOADFAIL   0x1")
+
+cpp_quote("#define PLATFORM_WIN95       0x01")
+cpp_quote("#define PLATFORM_WIN98       0x02")
+cpp_quote("#define PLATFORM_NT4         0x04")
+cpp_quote("#define PLATFORM_NT5         0x08")
+cpp_quote("#define PLATFORM_NT4ALPHA    0x10")
+cpp_quote("#define PLATFORM_NT5ALPHA    0x20")
+cpp_quote("#define PLATFORM_MILLEN      0x40")
+cpp_quote("#define PLATFORM_ALL         (PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN)")
+
+enum InstallStatus
+{
+    INSTALLSTATUS_INITIALIZING,
+    INSTALLSTATUS_DEPENDENCY,
+    INSTALLSTATUS_DOWNLOADING,
+    INSTALLSTATUS_COPYING,
+    INSTALLSTATUS_RETRYING,
+    INSTALLSTATUS_CHECKINGTRUST,
+    INSTALLSTATUS_EXTRACTING,
+    INSTALLSTATUS_RUNNING,
+    INSTALLSTATUS_FINISHED,
+    INSTALLSTATUS_DOWNLOADFINISHED,
+};
+
+enum ComponentAction
+{
+    ActionNone,
+    ActionInstall,
+    ActionUninstall,
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifComponent
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetGUID(char *guid, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    HRESULT GetDetails(char *details, DWORD size);
+    HRESULT GetUrl(UINT index, char *url, DWORD size, DWORD *flags);
+    HRESULT GetFileExtractList(UINT index, char *extract, DWORD size);
+    HRESULT GetUrlCheckRange(UINT index, DWORD *min, DWORD *max);
+    HRESULT GetCommand(UINT index, char *cmd, DWORD cmd_size, char *switches, DWORD switch_size, DWORD *type);
+    HRESULT GetVersion(DWORD *version, DWORD *build);
+    HRESULT GetLocale(char *pszLocale, DWORD size);
+    HRESULT GetUninstallKey(char *key, DWORD size);
+    HRESULT GetInstalledSize(DWORD *win, DWORD *app);
+    DWORD GetDownloadSize();
+    DWORD GetExtractSize();
+    HRESULT GetSuccessKey(char *key, DWORD size);
+    HRESULT GetProgressKeys(char *progress, DWORD progress_size, char *cancel, DWORD cancel_size);
+    HRESULT IsActiveSetupAware();
+    HRESULT IsRebootRequired();
+    HRESULT RequiresAdminRights();
+    DWORD GetPriority();
+    HRESULT GetDependency(UINT index, char *id, DWORD buf, char *type, DWORD *ver, DWORD *build);
+    DWORD GetPlatform();
+    HRESULT GetMode(UINT index, char *mode, DWORD size);
+    HRESULT GetGroup(char *id, DWORD size);
+    HRESULT IsUIVisible();
+    HRESULT GetPatchID(char *id, DWORD size);
+    HRESULT GetDetVersion(char *dll, DWORD dll_size, char *entry, DWORD entry_size);
+    HRESULT GetTreatAsOneComponents(UINT index, char *id, DWORD buf);
+    HRESULT GetCustomData(char *key, char *data, DWORD size);
+    DWORD IsComponentInstalled();
+    HRESULT IsComponentDownloaded();
+    DWORD IsThisVersionInstalled(DWORD version, DWORD build, DWORD *ret_version, DWORD *ret_build);
+    DWORD GetInstallQueueState();
+    HRESULT SetInstallQueueState(DWORD state);
+    DWORD GetActualDownloadSize();
+    DWORD GetCurrentPriority();
+    HRESULT SetCurrentPriority(DWORD priority);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWComponent : ICifComponent
+{
+    HRESULT SetGUID(const char *guid);
+    HRESULT SetDescription(const char *desc);
+    HRESULT SetUrl(UINT index, const char *url, DWORD url_flags);
+    HRESULT SetCommand(UINT index, const char *cmd, const char *switches, DWORD type);
+    HRESULT SetVersion(const char *version);
+    HRESULT SetUninstallKey(const char *key);
+    HRESULT SetInstalledSize(DWORD win, DWORD app);
+    HRESULT SetDownloadSize(DWORD size);
+    HRESULT SetExtractSize(DWORD size);
+    HRESULT DeleteDependency(const char *id, char type);
+    HRESULT AddDependency(const char *id, char type);
+    HRESULT SetUIVisible(BOOL visible);
+    HRESULT SetGroup(const char *id);
+    HRESULT SetPlatform(DWORD platform);
+    HRESULT SetPriority(DWORD priority);
+    HRESULT SetReboot(BOOL reboot);
+    HRESULT DeleteFromModes(const char *mode);
+    HRESULT AddToMode(const char *mode);
+    HRESULT SetModes(const char *mode);
+    HRESULT CopyComponent(const char *ciffile);
+    HRESULT AddToTreatAsOne(const char *compid);
+    HRESULT SetDetails(const char *desc);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifComponents : IUnknown
+{
+    HRESULT Next(ICifComponent **);
+    HRESULT Reset();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifGroup
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    DWORD GetPriority();
+
+    HRESULT EnumComponents(IEnumCifComponents **, DWORD filter, void *pv);
+    DWORD GetCurrentPriority();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWGroup : ICifGroup
+{
+   HRESULT SetDescription(const char *desc);
+   HRESULT SetPriority(DWORD priority);
+   HRESULT SetDetails(const char *details);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifGroups : IUnknown
+{
+    HRESULT Next(ICifGroup **);
+    HRESULT Reset();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifMode
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    HRESULT GetDetails(char *details, DWORD size);
+
+    HRESULT EnumComponents(IEnumCifComponents **, DWORD filter, void *pv);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWMode : ICifMode
+{
+    HRESULT SetDescription(const char *desc);
+    HRESULT SetDetails(const char *details);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifModes : IUnknown
+{
+    HRESULT Next(ICifMode **);
+    HRESULT Reset();
+};
+
+typedef struct
+{
     DWORD cbSize;
     DWORD dwInstallSize;
     DWORD dwWinDriveSize;
@@ -49,6 +266,15 @@ typedef struct {
     DWORD dwTotalDownloadSize;
 } COMPONENT_SIZES;
 
+typedef struct
+{
+    DWORD cbSize;
+    DWORD dwDownloadKBRemaining;
+    DWORD dwInstallKBRemaining;
+    DWORD dwDownloadSecsRemaining;
+    DWORD dwInstallSecsRemaining;
+} INSTALLPROGRESS;
+
 [
     uuid(6e449688-c509-11cf-aafa-00aa00b6015c),
     local
@@ -62,7 +288,24 @@ interface ICifFile : IUnknown
     HRESULT EnumModes(IEnumCifModes **cuf_modes, DWORD filter, void *pv);
     HRESULT FindMode(const char *id, ICifMode **p);
     HRESULT GetDescription(char *desc, DWORD size);
-    HRESULT GetDetDlls(char **dlls, DWORD size);
+    HRESULT GetDetDlls(char *dlls, DWORD size);
+}
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWFile : ICifFile
+{
+    HRESULT SetDescription(const char *desc);
+    HRESULT CreateComponent(const char *id, ICifRWComponent **p);
+    HRESULT CreateGroup(const char *id, ICifRWGroup **p);
+    HRESULT CreateMode(const char *id, ICifRWMode **p);
+    HRESULT DeleteComponent(const char *id);
+    HRESULT DeleteGroup(const char *id);
+    HRESULT DeleteMode(const char *id);
+    HRESULT Flush();
 }
 
 [
@@ -78,7 +321,7 @@ interface IInstallEngineCallback : IUnknown
            const char *msg_string, ULONG progress, ULONG max);
    HRESULT OnStopComponent(const char *id, HRESULT error, DWORD phrase, const char *string, DWORD status);
    HRESULT OnStopInstall(HRESULT error, const char *error_string, DWORD status);
-   HRESULT OnEngineProblem(DWORD problem, LPDWORD action);
+   HRESULT OnEngineProblem(DWORD problem, DWORD *action);
 }
 
 [
@@ -121,6 +364,16 @@ interface IInstallEngine2 : IInstallEngine
     HRESULT GetICifFile(ICifFile **cif_file);
 }
 
+[
+    uuid(6e449687-c509-11cf-aafa-00aa00b6015c),
+    local
+]
+interface IInstallEngineTiming : IUnknown
+{
+    HRESULT GetRates(DWORD *download, DWORD *install);
+    HRESULT GetInstallProgress(INSTALLPROGRESS *progress);
+}
+
 [
     helpstring("Microsoft Active Setup Engine"),
     threading(apartment),
@@ -134,3 +387,6 @@ coclass InstallEngine { }
     uuid(bfc880f1-7484-11d0-8309-00aa00b6015c)
 ]
 coclass DownloadSiteMgr { }
+
+cpp_quote("HRESULT WINAPI GetICifFileFromFile(ICifFile **, const char *);")
+cpp_quote("HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **, const char *);")

From 635315e0dc9bd670da79f9726d03bc79609f62aa Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Fri, 13 Jan 2017 01:59:13 +0100
Subject: [PATCH 059/244] kernel32: Always start debugger on WinSta0.

---
 dlls/kernelbase/debug.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
index 6d24abc80ad..14246976cc2 100644
--- a/dlls/kernelbase/debug.c
+++ b/dlls/kernelbase/debug.c
@@ -625,6 +625,7 @@ static BOOL start_debugger( EXCEPTION_POINTERS *epointers, HANDLE event )
     TRACE( "Starting debugger %s\n", debugstr_w(cmdline) );
     memset( &startup, 0, sizeof(startup) );
     startup.cb = sizeof(startup);
+    startup.lpDesktop = (WCHAR*)L"WinSta0";
     startup.dwFlags = STARTF_USESHOWWINDOW;
     startup.wShowWindow = SW_SHOWNORMAL;
     ret = CreateProcessW( NULL, cmdline, NULL, NULL, TRUE, CREATE_UNICODE_ENVIRONMENT | CREATE_NO_WINDOW, env, NULL, &startup, &info );

From 7cf3ff1891b5293d60f5b187a73907d623e63df9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 27 Feb 2016 00:04:10 +0100
Subject: [PATCH 060/244] krnl386.exe16: Emulate GDT and LDT access.

---
 dlls/krnl386.exe16/instr.c | 64 ++++++++++++++++++++++++++++++++------
 1 file changed, 55 insertions(+), 9 deletions(-)

diff --git a/dlls/krnl386.exe16/instr.c b/dlls/krnl386.exe16/instr.c
index b21a00d5ccf..0954fd86fb8 100644
--- a/dlls/krnl386.exe16/instr.c
+++ b/dlls/krnl386.exe16/instr.c
@@ -60,7 +60,7 @@ static inline void *get_stack( CONTEXT *context )
 }
 
 #include "pshpack1.h"
-struct idtr
+struct dtr
 {
     WORD  limit;
     BYTE *base;
@@ -68,19 +68,41 @@ struct idtr
 #include "poppack.h"
 
 static LDT_ENTRY idt[256];
+static LDT_ENTRY gdt[8192];
+static LDT_ENTRY ldt[8192];
 
-static inline struct idtr get_idtr(void)
+static BOOL emulate_idtr( BYTE *data, unsigned int data_size, unsigned int *offset )
 {
-    struct idtr ret;
 #if defined(__i386__) && defined(__GNUC__)
+    struct dtr ret;
     __asm__( "sidtl %0" : "=m" (ret) );
+    *offset = data - ret.base;
+    return (*offset <= ret.limit + 1 - data_size);
 #else
-    ret.base = (BYTE *)idt;
-    ret.limit = sizeof(idt) - 1;
+    return FALSE;
 #endif
-    return ret;
 }
 
+static BOOL emulate_gdtr( BYTE *data, unsigned int data_size, unsigned int *offset )
+{
+#if defined(__i386__) && defined(__GNUC__)
+    struct dtr ret;
+    __asm__( "sgdtl %0" : "=m" (ret) );
+    *offset = data - ret.base;
+    return (*offset <= ret.limit + 1 - data_size);
+#else
+    return FALSE;
+#endif
+}
+
+static inline WORD get_ldt(void)
+{
+    WORD seg = 1;
+#if defined(__i386__) && defined(__GNUC__)
+    __asm__( "sldt %0" : "=m" (seg) );
+#endif
+    return seg;
+}
 
 /***********************************************************************
  *           INSTR_ReplaceSelector
@@ -705,10 +727,9 @@ DWORD __wine_emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
                 BYTE *data = INSTR_GetOperandAddr(context, instr + 1, long_addr,
                                                   segprefix, &len);
                 unsigned int data_size = (*instr == 0x8b) ? (long_op ? 4 : 2) : 1;
-                struct idtr idtr = get_idtr();
-                unsigned int offset = data - idtr.base;
+                unsigned int offset;
 
-                if (offset <= idtr.limit + 1 - data_size)
+                if (emulate_idtr( data, data_size, &offset ))
                 {
                     idt[1].LimitLow = 0x100; /* FIXME */
                     idt[2].LimitLow = 0x11E; /* FIXME */
@@ -722,6 +743,31 @@ DWORD __wine_emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
                     context->Eip += prefixlen + len + 1;
                     return ExceptionContinueExecution;
                 }
+
+                if (emulate_gdtr( data, data_size, &offset ))
+                {
+                    static BOOL initialized;
+
+                    if (!initialized)
+                    {
+                        WORD index = get_ldt() >> 3;
+                        gdt[index].BaseLow                = ((DWORD_PTR)ldt & 0x0000FFFF);
+                        gdt[index].HighWord.Bytes.BaseMid = ((DWORD_PTR)ldt & 0x00FF0000) >> 16;
+                        gdt[index].HighWord.Bytes.BaseHi  = ((DWORD_PTR)ldt & 0xFF000000) >> 24;
+                        gdt[index].LimitLow               = 0xFFFF;
+                        gdt[index].HighWord.Bits.Pres     = 1;
+
+                        initialized = TRUE;
+                    }
+
+                    switch (*instr)
+                    {
+                    case 0x8a: store_reg_byte( context, instr[1], (BYTE *)gdt + offset ); break;
+                    case 0x8b: store_reg_word( context, instr[1], (BYTE *)gdt + offset, long_op ); break;
+                    }
+                    context->Eip += prefixlen + len + 1;
+                    return ExceptionContinueExecution;
+                }
             }
             break;  /* Unable to emulate it */
 

From 51ef83023d369d97f2751b1c8db9b49942aa9c1c Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 1 Jul 2019 09:58:55 +1000
Subject: [PATCH 061/244] loader: Add Keyboard Layouts registry enteries.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 loader/wine.inf.in | 209 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 209 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 30751cc1510..4f3a0fc74ac 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -63,6 +63,7 @@ AddReg=\
     Debugger,\
     DirectX,\
     Fonts,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     OLE,\
@@ -89,6 +90,7 @@ AddReg=\
     Debugger,\
     DirectX,\
     Fonts,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     OLE,\
@@ -120,6 +122,7 @@ AddReg=\
     Debugger,\
     DirectX,\
     Fonts,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     OLE,\
@@ -177,6 +180,7 @@ AddReg=\
     CurrentVersionWow64.ntx86,\
     Debugger,\
     DirectX,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     ProtonOverrides,\
@@ -750,6 +754,211 @@ HKCU,Software\Microsoft\Windows\Shell\Associations\UrlAssociations\ftp\UserChoic
 HKCU,Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice,"ProgId",,"http"
 HKCU,Software\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice,"ProgId",,"https"
 
+[KeyboardLayouts]
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000401,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000404,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000405,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000406,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000407,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000410,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000411,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000412,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000413,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000414,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000415,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000416,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000418,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000419,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000420,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000422,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000423,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000424,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000425,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000426,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000427,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000428,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000429,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000432,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000438,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000439,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000043a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000043b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000043f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000440,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000442,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000444,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000445,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000446,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000447,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000448,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000449,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000450,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000451,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000452,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000453,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000454,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000045a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000045b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000045c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000461,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000463,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000465,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000468,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000470,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000474,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000475,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000480,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000481,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000485,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000488,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000492,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000804,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000807,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000809,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000080a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000080c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000813,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000816,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000081a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000082c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000083b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000843,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000850,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000085d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000085f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000c04,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000c0c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000c1a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001004,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001009,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000100c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000105f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001404,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001809,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000201a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00004009,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010401,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010405,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010407,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001040a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001040e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010410,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010415,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010416,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010418,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010419,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001041b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001041f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010426,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010427,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010439,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001043a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001043b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010444,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010445,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010451,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010453,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010465,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010480,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001080c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001083b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010850,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00011009,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001105f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00011809,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020401,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020405,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002040d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020418,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020419,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020422,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020426,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020427,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002042e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020445,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002083b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0003041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0003042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00050408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00050409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00050429,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00060408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00070c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00080c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00090c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000a0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000b0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000c0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000d0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000e0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000f0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00100c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00110c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00120c00,,16
+
 [OLE]
 HKLM,"Software\Microsoft\OLE","EnableDCOM",,"Y"
 HKLM,"Software\Microsoft\OLE","EnableRemoteConnect",,"N"

From 6976c05ef1c0f55ec67b11ce96f6a117bcd62e18 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 9 Jul 2019 14:13:28 +1000
Subject: [PATCH 062/244] user32: Do not enumerate the registry in
 GetKeyboardLayoutList().

This function returns the current list of *installed* Keyboard layouts
not the complete list from the registry.
---
 dlls/user32/input.c       |  1 -
 dlls/user32/tests/input.c | 35 +++++++++++++++++++++++++++++++++++
 dlls/win32u/input.c       | 33 +--------------------------------
 3 files changed, 36 insertions(+), 33 deletions(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index db59f21f89b..f0aeedbc049 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -469,7 +469,6 @@ BOOL WINAPI UnloadKeyboardLayout( HKL layout )
     return FALSE;
 }
 
-
 static DWORD CALLBACK devnotify_window_callbackW(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
 {
     TRACE_(rawinput)("handle %p, flags %#lx, header %p\n", handle, flags, header);
diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index 4d4c3c81000..217f092c3fa 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -6100,6 +6100,40 @@ static void test_LoadKeyboardLayoutEx( HKL orig_hkl )
     ok_eq( old_hkl, GetKeyboardLayout( 0 ), HKL, "%p" );
 }
 
+static void test_GetKeyboardLayoutList(void)
+{
+    int cnt, cnt2;
+    HKL *layouts;
+    ULONG_PTR baselayout;
+    LANGID langid;
+
+    baselayout = GetUserDefaultLCID();
+    langid = PRIMARYLANGID(LANGIDFROMLCID(baselayout));
+    if (langid == LANG_CHINESE || langid == LANG_JAPANESE || langid == LANG_KOREAN)
+        baselayout = MAKELONG( baselayout, 0xe001 ); /* IME */
+    else
+        baselayout |= baselayout << 16;
+
+    cnt = GetKeyboardLayoutList(0, NULL);
+    /* Most users will not have more than a few keyboard layouts installed at a time. */
+    ok(cnt > 0 && cnt < 10, "Layout count %d\n", cnt);
+    if (cnt > 0)
+    {
+        layouts = HeapAlloc(GetProcessHeap(), 0, sizeof(*layouts) * cnt );
+
+        cnt2 = GetKeyboardLayoutList(cnt, layouts);
+        ok(cnt == cnt2, "wrong value %d!=%d\n", cnt, cnt2);
+        for(cnt = 0; cnt < cnt2; cnt++)
+        {
+            if(layouts[cnt] == (HKL)baselayout)
+                break;
+        }
+        ok(cnt < cnt2, "Didnt find current keyboard\n");
+
+        HeapFree(GetProcessHeap(), 0, layouts);
+    }
+}
+
 /* run the tests in a separate desktop to avoid interaction with other
  * tests, current desktop state, or user actions. */
 static void test_input_desktop( char **argv )
@@ -6351,6 +6385,7 @@ START_TEST(input)
     test_GetKeyState();
     test_OemKeyScan();
     test_rawinput(argv[0]);
+    test_GetKeyboardLayoutList();
     test_DefRawInputProc();
 
     if(pGetMouseMovePointsEx)
diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 97e651a7ce5..fe0674c9240 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -1393,11 +1393,7 @@ HKL WINAPI NtUserActivateKeyboardLayout( HKL layout, UINT flags )
  */
 UINT WINAPI NtUserGetKeyboardLayoutList( INT size, HKL *layouts )
 {
-    char buffer[4096];
-    KEY_NODE_INFORMATION *key_info = (KEY_NODE_INFORMATION *)buffer;
-    KEY_VALUE_PARTIAL_INFORMATION *value_info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
-    DWORD count, tmp, i = 0;
-    HKEY hkey, subkey;
+    DWORD count;
     HKL layout;
 
     TRACE_(keyboard)( "size %d, layouts %p.\n", size, layouts );
@@ -1411,33 +1407,6 @@ UINT WINAPI NtUserGetKeyboardLayoutList( INT size, HKL *layouts )
     if (size && layouts)
     {
         layouts[count - 1] = layout;
-        if (count == size) return count;
-    }
-
-    if ((hkey = reg_open_key( NULL, keyboard_layouts_keyW, sizeof(keyboard_layouts_keyW) )))
-    {
-        while (!NtEnumerateKey( hkey, i++, KeyNodeInformation, key_info,
-                                sizeof(buffer) - sizeof(WCHAR), &tmp ))
-        {
-            if (!(subkey = reg_open_key( hkey, key_info->Name, key_info->NameLength ))) continue;
-            key_info->Name[key_info->NameLength / sizeof(WCHAR)] = 0;
-            tmp = wcstoul( key_info->Name, NULL, 16 );
-            if (query_reg_ascii_value( subkey, "Layout Id", value_info, sizeof(buffer) ) &&
-                value_info->Type == REG_SZ)
-                tmp = 0xf000 | (wcstoul( (const WCHAR *)value_info->Data, NULL, 16 ) & 0xfff);
-            NtClose( subkey );
-
-            tmp = MAKELONG( LOWORD( layout ), LOWORD( tmp ) );
-            if (layout == UlongToHandle( tmp )) continue;
-
-            count++;
-            if (size && layouts)
-            {
-                layouts[count - 1] = UlongToHandle( tmp );
-                if (count == size) break;
-            }
-        }
-        NtClose( hkey );
     }
 
     return count;

From 11efecfa30988e7883bede4575bd3cea229c7197 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 26 Feb 2016 03:54:28 +0100
Subject: [PATCH 063/244] mmsystem.dll16: Refcount midihdr to work around buggy
 application which unprepares buffer during a callback.

---
 dlls/mmsystem.dll16/message16.c | 123 +++++++++++++++++++-------------
 1 file changed, 74 insertions(+), 49 deletions(-)

diff --git a/dlls/mmsystem.dll16/message16.c b/dlls/mmsystem.dll16/message16.c
index b12b9b94327..7f39be07991 100644
--- a/dlls/mmsystem.dll16/message16.c
+++ b/dlls/mmsystem.dll16/message16.c
@@ -33,6 +33,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(winmm);
 
+struct mihdrWrap
+{
+    int ref;
+    SEGPTR mh16;
+    MIDIHDR hdr;
+};
+
 /* =================================
  *       A U X    M A P P E R S
  * ================================= */
@@ -117,13 +124,13 @@ static  void            	MMSYSTDRV_MidiIn_MapCB(DWORD uMsg, DWORD_PTR* dwUser, D
     case MIM_LONGDATA:
     case MIM_LONGERROR:
         {
-	    LPMIDIHDR		mh32 = (LPMIDIHDR)(*dwParam1);
-	    SEGPTR		segmh16 = *(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR));
-	    LPMIDIHDR16		mh16 = MapSL(segmh16);
+	        struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*dwParam1, struct mihdrWrap, hdr);
+	        SEGPTR              segmh16 = mh32->mh16;
+	        LPMIDIHDR16         mh16 = MapSL(segmh16);
 
-	    *dwParam1 = (DWORD)segmh16;
-	    mh16->dwFlags = mh32->dwFlags;
-	    mh16->dwBytesRecorded = mh32->dwBytesRecorded;
+	        *dwParam1 = (DWORD)segmh16;
+	        mh16->dwFlags = mh32->hdr.dwFlags;
+	        mh16->dwBytesRecorded = mh32->hdr.dwBytesRecorded;
 	}
 	break;
     default:
@@ -175,42 +182,49 @@ static MMSYSTEM_MapType	MMSYSTDRV_MidiOut_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
 	break;
     case MODM_PREPARE:
 	{
-	    LPMIDIHDR		mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(LPMIDIHDR) + sizeof(MIDIHDR));
-	    LPMIDIHDR16		mh16 = MapSL(*lpParam1);
-
-	    if (mh32) {
-		*(LPMIDIHDR*)mh32 = (LPMIDIHDR)*lpParam1;
-		mh32 = (LPMIDIHDR)((LPSTR)mh32 + sizeof(LPMIDIHDR));
-		mh32->lpData = MapSL((SEGPTR)mh16->lpData);
-		mh32->dwBufferLength = mh16->dwBufferLength;
-		mh32->dwBytesRecorded = mh16->dwBytesRecorded;
-		mh32->dwUser = mh16->dwUser;
-		mh32->dwFlags = mh16->dwFlags;
-		mh16->lpNext = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
-		*lpParam1 = (DWORD)mh32;
-		*lpParam2 = offsetof(MIDIHDR,dwOffset); /* old size, without dwOffset */
+        struct mihdrWrap   *mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(struct mihdrWrap));
+        LPMIDIHDR16         mh16 = MapSL(*lpParam1);
 
-		ret = MMSYSTEM_MAP_OKMEM;
-	    } else {
-		ret = MMSYSTEM_MAP_NOMEM;
-	    }
+        if (mh32)
+        {
+            mh32->ref = 2;
+            mh32->mh16 = (SEGPTR)*lpParam1;
+            mh32->hdr.lpData = MapSL((SEGPTR)mh16->lpData);
+            mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+            mh32->hdr.dwBytesRecorded = mh16->dwBytesRecorded;
+            mh32->hdr.dwUser = mh16->dwUser;
+            mh32->hdr.dwFlags = mh16->dwFlags;
+            mh16->lpNext = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
+            *lpParam1 = (DWORD)&mh32->hdr;
+            *lpParam2 = offsetof(MIDIHDR,dwOffset); /* old size, without dwOffset */
+
+            ret = MMSYSTEM_MAP_OKMEM;
+        }
+        else
+            ret = MMSYSTEM_MAP_NOMEM;
 	}
 	break;
     case MODM_UNPREPARE:
     case MODM_LONGDATA:
 	{
-	    LPMIDIHDR16		mh16 = MapSL(*lpParam1);
-	    LPMIDIHDR		mh32 = (MIDIHDR*)mh16->lpNext;
+        LPMIDIHDR16         mh16 = MapSL(*lpParam1);
+        struct mihdrWrap   *mh32 = (struct mihdrWrap*)mh16->lpNext;
 
-	    *lpParam1 = (DWORD)mh32;
-	    *lpParam2 = offsetof(MIDIHDR,dwOffset);
-	    /* dwBufferLength can be reduced between prepare & write */
-	    if (wMsg == MODM_LONGDATA && mh32->dwBufferLength < mh16->dwBufferLength) {
-		ERR("Size of buffer has been increased from %ld to %ld, keeping initial value\n",
-		    mh32->dwBufferLength, mh16->dwBufferLength);
-	    } else
-                mh32->dwBufferLength = mh16->dwBufferLength;
-	    ret = MMSYSTEM_MAP_OKMEM;
+        mh32->ref++;
+
+        *lpParam1 = (DWORD)&mh32->hdr;
+        *lpParam2 = offsetof(MIDIHDR,dwOffset);
+
+        /* dwBufferLength can be reduced between prepare & write */
+        if (wMsg == MODM_LONGDATA && mh32->hdr.dwBufferLength < mh16->dwBufferLength)
+        {
+            ERR("Size of buffer has been increased from %d to %d, keeping initial value\n",
+                mh32->hdr.dwBufferLength, mh16->dwBufferLength);
+        }
+        else
+            mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+
+        ret = MMSYSTEM_MAP_OKMEM;
 	}
 	break;
 
@@ -267,17 +281,28 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiOut_UnMap16To32W(DWORD wMsg, DWORD_PTR* l
     case MODM_UNPREPARE:
     case MODM_LONGDATA:
 	{
-	    LPMIDIHDR		mh32 = (LPMIDIHDR)(*lpParam1);
-	    LPMIDIHDR16		mh16 = MapSL(*(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR)));
+        struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*lpParam1, struct mihdrWrap, hdr);
+        LPMIDIHDR16         mh16;
 
-	    assert((MIDIHDR*)mh16->lpNext == mh32);
-	    mh16->dwFlags = mh32->dwFlags;
+        /* Prosound unprepares the buffer during a callback */
+        if (mh32->mh16)
+        {
+            mh16 = MapSL(mh32->mh16);
+            assert((struct mihdrWrap *)mh16->lpNext == mh32);
+            mh16->dwFlags = mh32->hdr.dwFlags;
 
-	    if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR) {
-		HeapFree(GetProcessHeap(), 0, (LPSTR)mh32 - sizeof(LPMIDIHDR));
-		mh16->lpNext = 0;
-	    }
-	    ret = MMSYSTEM_MAP_OK;
+            if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR)
+            {
+                mh32->mh16 = 0;
+                mh32->ref--;
+                mh16->lpNext = 0;
+            }
+        }
+
+        if (!--mh32->ref)
+            HeapFree(GetProcessHeap(), 0, mh32);
+
+        ret = MMSYSTEM_MAP_OK;
 	}
 	break;
 
@@ -307,12 +332,12 @@ static  void MMSYSTDRV_MidiOut_MapCB(DWORD uMsg, DWORD_PTR* dwUser, DWORD_PTR* d
     case MOM_DONE:
         {
 	    /* initial map is: 16 => 32 */
-	    LPMIDIHDR		mh32 = (LPMIDIHDR)(*dwParam1);
-	    SEGPTR		segmh16 = *(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR));
-	    LPMIDIHDR16		mh16 = MapSL(segmh16);
+        struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*dwParam1, struct mihdrWrap, hdr);
+        SEGPTR              segmh16 = mh32->mh16;
+        LPMIDIHDR16         mh16 = MapSL(segmh16);
 
-	    *dwParam1 = (DWORD)segmh16;
-	    mh16->dwFlags = mh32->dwFlags;
+        *dwParam1 = (DWORD)segmh16;
+        mh16->dwFlags = mh32->hdr.dwFlags;
 	}
 	break;
     default:

From 2bbac7781cd48ca123934677078c576fbb19ca17 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 26 Feb 2016 04:04:12 +0100
Subject: [PATCH 064/244] mmsystem.dll16: Translate MidiIn messages.

---
 dlls/mmsystem.dll16/message16.c | 128 +++++++++++++++++++++++++++++++-
 1 file changed, 126 insertions(+), 2 deletions(-)

diff --git a/dlls/mmsystem.dll16/message16.c b/dlls/mmsystem.dll16/message16.c
index 7f39be07991..64382ae070b 100644
--- a/dlls/mmsystem.dll16/message16.c
+++ b/dlls/mmsystem.dll16/message16.c
@@ -95,7 +95,78 @@ static  void	                MMSYSTDRV_Mixer_MapCB(DWORD uMsg, DWORD_PTR* dwUser
  */
 static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lpParam1, DWORD_PTR* lpParam2)
 {
-    return MMSYSTEM_MAP_MSGERROR;
+    MMSYSTEM_MapType ret = MMSYSTEM_MAP_MSGERROR;
+
+    switch (wMsg)
+    {
+        case MIDM_GETNUMDEVS:
+        case MIDM_RESET:
+            ret = MMSYSTEM_MAP_OK;
+            break;
+
+        case MIDM_GETDEVCAPS:
+            {
+                LPMIDIINCAPSW  mic32 = HeapAlloc(GetProcessHeap(), 0, sizeof(LPMIDIINCAPS16) + sizeof(MIDIINCAPSW));
+                LPMIDIINCAPS16 mic16 = MapSL(*lpParam1);
+
+                if (mic32)
+                {
+                    *(LPMIDIINCAPS16 *)mic32 = mic16;
+                    mic32 = (LPMIDIINCAPSW)((LPSTR)mic32 + sizeof(LPMIDIINCAPS16));
+                    *lpParam1 = (DWORD)mic32;
+                    *lpParam2 = sizeof(LPMIDIINCAPSW);
+
+                    ret = MMSYSTEM_MAP_OKMEM;
+                }
+                else
+                    ret = MMSYSTEM_MAP_NOMEM;
+            }
+            break;
+
+        case MIDM_ADDBUFFER:
+        case MIDM_PREPARE:
+            {
+                struct mihdrWrap   *mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(struct mihdrWrap));
+                LPMIDIHDR16         mh16 = MapSL(*lpParam1);
+
+                if (mh32)
+                {
+                    mh32->ref = 2;
+                    mh32->mh16 = (SEGPTR)*lpParam1;
+                    mh32->hdr.lpData = MapSL((SEGPTR)mh16->lpData);
+                    mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+                    mh32->hdr.dwBytesRecorded = mh16->dwBytesRecorded;
+                    mh32->hdr.dwUser = mh16->dwUser;
+                    mh32->hdr.dwFlags = mh16->dwFlags;
+                    mh16->lpNext = (MIDIHDR16*)mh32;
+                    *lpParam1 = (DWORD)&mh32->hdr;
+                    *lpParam2 = offsetof(MIDIHDR,dwOffset);
+
+                    ret = MMSYSTEM_MAP_OKMEM;
+                }
+                else
+                    ret = MMSYSTEM_MAP_NOMEM;
+            }
+            break;
+
+        case MIDM_UNPREPARE:
+            {
+                LPMIDIHDR16         mh16 = MapSL(*lpParam1);
+                struct mihdrWrap   *mh32 = (struct mihdrWrap *)mh16->lpNext;
+
+                mh32->ref++;
+
+                *lpParam1 = (DWORD)&mh32->hdr;
+                *lpParam2 = offsetof(MIDIHDR,dwOffset);
+
+                mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+
+                ret = MMSYSTEM_MAP_OKMEM;
+            }
+            break;
+    }
+
+    return ret;
 }
 
 /**************************************************************************
@@ -103,7 +174,60 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
  */
 static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_UnMap16To32W(DWORD wMsg, DWORD_PTR* lpParam1, DWORD_PTR* lpParam2, MMRESULT fn_ret)
 {
-    return MMSYSTEM_MAP_MSGERROR;
+    MMSYSTEM_MapType    ret = MMSYSTEM_MAP_MSGERROR;
+
+    switch (wMsg)
+    {
+        case MIDM_GETNUMDEVS:
+        case MIDM_RESET:
+            ret = MMSYSTEM_MAP_OK;
+            break;
+
+        case MIDM_GETDEVCAPS:
+            {
+                LPMIDIINCAPSW   mic32 = (LPMIDIINCAPSW)(*lpParam1);
+                LPMIDIINCAPS16  mic16 = *(LPMIDIINCAPS16*)((LPSTR)mic32 - sizeof(LPMIDIINCAPS16));
+
+                mic16->wMid             = mic32->wMid;
+                mic16->wPid             = mic32->wPid;
+                mic16->vDriverVersion   = mic32->vDriverVersion;
+                WideCharToMultiByte( CP_ACP, 0, mic32->szPname, -1, mic16->szPname,
+                                     sizeof(mic16->szPname), NULL, NULL );
+                mic16->dwSupport        = mic32->dwSupport;
+                HeapFree(GetProcessHeap(), 0, (LPSTR)mic32 - sizeof(LPMIDIINCAPS16));
+                ret = MMSYSTEM_MAP_OK;
+            }
+            break;
+
+        case MIDM_PREPARE:
+        case MIDM_UNPREPARE:
+            {
+                struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*lpParam1, struct mihdrWrap, hdr);
+                LPMIDIHDR16         mh16;
+
+                if (mh32->mh16)
+                {
+                    mh16 = MapSL(mh32->mh16);
+                    assert((struct mihdrWrap *)mh16->lpNext == mh32);
+                    mh16->dwFlags = mh32->hdr.dwFlags;
+
+                    if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR)
+                    {
+                        mh32->mh16 = 0;
+                        mh32->ref--;
+                        mh16->lpNext = 0;
+                    }
+                }
+
+                if (!--mh32->ref)
+                    HeapFree(GetProcessHeap(), 0, mh32);
+
+                ret = MMSYSTEM_MAP_OK;
+            }
+            break;
+
+    }
+    return ret;
 }
 
 /**************************************************************************

From 6000f9adcd7d1d8e4311fa4c1a8a65b6e1a2d225 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Mon, 30 Mar 2015 04:01:51 +0200
Subject: [PATCH 065/244] mountmgr.sys: Write usable device paths into
 HKLM\SYSTEM\MountedDevices.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch by Bernhard Übelacker.
---
 dlls/mountmgr.sys/device.c   |  4 ++--
 dlls/mountmgr.sys/mountmgr.c | 11 +++++++++--
 dlls/mountmgr.sys/mountmgr.h |  2 +-
 3 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
index d0308a3c993..d0edb97a976 100644
--- a/dlls/mountmgr.sys/device.c
+++ b/dlls/mountmgr.sys/device.c
@@ -1023,8 +1023,8 @@ static NTSTATUS set_volume_info( struct volume *volume, struct dos_drive *drive,
         id = disk_device->unix_mount;
         id_len = strlen( disk_device->unix_mount ) + 1;
     }
-    if (volume->mount) set_mount_point_id( volume->mount, id, id_len );
-    if (drive && drive->mount) set_mount_point_id( drive->mount, id, id_len );
+    if (volume->mount) set_mount_point_id( volume->mount, id, id_len, -1 );
+    if (drive && drive->mount) set_mount_point_id( drive->mount, id, id_len, drive->drive );
 
     return STATUS_SUCCESS;
 }
diff --git a/dlls/mountmgr.sys/mountmgr.c b/dlls/mountmgr.sys/mountmgr.c
index 77c2b795ef5..8a441e03772 100644
--- a/dlls/mountmgr.sys/mountmgr.c
+++ b/dlls/mountmgr.sys/mountmgr.c
@@ -44,14 +44,21 @@ struct mount_point
 static struct list mount_points_list = LIST_INIT(mount_points_list);
 static HKEY mount_key;
 
-void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len )
+void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len, int drive )
 {
+    WCHAR logicalW[] = {'\\','\\','.','\\','a',':',0};
     free( mount->id );
     mount->id_len = max( MIN_ID_LEN, id_len );
     if ((mount->id = calloc( mount->id_len, 1 )))
     {
         memcpy( mount->id, id, id_len );
-        RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, mount->id, mount->id_len );
+        if (drive < 0)
+            RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, mount->id, mount->id_len );
+        else
+        {
+            logicalW[4] = 'a' + drive;
+            RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, (BYTE*)logicalW, sizeof(logicalW) );
+        }
     }
     else mount->id_len = 0;
 }
diff --git a/dlls/mountmgr.sys/mountmgr.h b/dlls/mountmgr.sys/mountmgr.h
index ae6927335b1..c6490e82021 100644
--- a/dlls/mountmgr.sys/mountmgr.h
+++ b/dlls/mountmgr.sys/mountmgr.h
@@ -108,6 +108,6 @@ extern struct mount_point *add_dosdev_mount_point( DEVICE_OBJECT *device, UNICOD
 extern struct mount_point *add_volume_mount_point( DEVICE_OBJECT *device, UNICODE_STRING *device_name,
                                                    const GUID *guid );
 extern void delete_mount_point( struct mount_point *mount );
-extern void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len );
+extern void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len, int drive );
 
 #endif /* __WINE_MOUNTMGR_H */

From 93c83efbd59a07d7c5cb44271f4878d305c7ab7e Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 11 Jun 2019 15:27:50 +1000
Subject: [PATCH 066/244] mshtml: Improve IOleInPlaceActiveObject
 TranslateAccelerator

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=37058
---
 dlls/mshtml/oleobj.c | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/dlls/mshtml/oleobj.c b/dlls/mshtml/oleobj.c
index 3b1c65c9a3b..b462892531e 100644
--- a/dlls/mshtml/oleobj.c
+++ b/dlls/mshtml/oleobj.c
@@ -1392,8 +1392,28 @@ static HRESULT WINAPI DocObjOleInPlaceActiveObject_ContextSensitiveHelp(IOleInPl
 static HRESULT WINAPI DocObjOleInPlaceActiveObject_TranslateAccelerator(IOleInPlaceActiveObject *iface, LPMSG lpmsg)
 {
     HTMLDocumentObj *This = HTMLDocumentObj_from_IOleInPlaceActiveObject(iface);
-    FIXME("(%p)->(%p)\n", This, lpmsg);
-    return E_NOTIMPL;
+    HRESULT hres = S_FALSE;
+
+    TRACE("(%p)->(%p)\n", This, lpmsg);
+
+    switch(lpmsg->message)
+    {
+        case WM_KEYDOWN:
+            break;
+        case WM_KEYUP:
+        {
+            TRACE("Processing key %Ix\n", lpmsg->wParam);
+            if (lpmsg->wParam == VK_F5)
+                hres = IOleCommandTarget_Exec(&This->IOleCommandTarget_iface, NULL, OLECMDID_REFRESH, 0, NULL, NULL);
+
+            break;
+        }
+        default:
+            FIXME("Unsupported message %04x\n", lpmsg->message);
+    }
+
+    TRACE("result 0x%08lx\n", hres);
+    return hres;
 }
 
 static HRESULT WINAPI DocObjOleInPlaceActiveObject_OnFrameWindowActivate(IOleInPlaceActiveObject *iface,

From c19e701a84aed68fcf0b6b1bf3f7aaef6cec8867 Mon Sep 17 00:00:00 2001
From: Czcibor Bohusz-Dobosz <czbd@o2.pl>
Date: Sun, 14 Jan 2024 17:50:49 +1100
Subject: [PATCH 067/244] msi: Only process cabinet files if it exists

---
 dlls/msi/files.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 35166788dae..cacf3ac0c36 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -819,7 +819,7 @@ UINT ACTION_PatchFiles( MSIPACKAGE *package )
             data.cb      = patchfiles_cb;
             data.user    = &cursor;
 
-            if (!msi_cabextract( package, mi, &data ))
+            if (mi->cabinet && !msi_cabextract( package, mi, &data ))
             {
                 ERR("Failed to extract cabinet: %s\n", debugstr_w(mi->cabinet));
                 rc = ERROR_INSTALL_FAILURE;

From 1a15ef1a9cb346d4c274e90585a1c53fbb200bac Mon Sep 17 00:00:00 2001
From: Jefferson Carpenter <jeffersoncarpenter2@gmail.com>
Date: Thu, 4 Nov 2021 22:30:05 +0000
Subject: [PATCH 068/244] msxml3: Write to DOMDocument mxwriter destination in
 endDocument.

---
 dlls/msxml3/mxwriter.c        | 41 +++++++++++++++++++++++++++++++++--
 dlls/msxml3/tests/saxreader.c |  1 +
 2 files changed, 40 insertions(+), 2 deletions(-)

diff --git a/dlls/msxml3/mxwriter.c b/dlls/msxml3/mxwriter.c
index d46a3bc41b1..6ef682ebc85 100644
--- a/dlls/msxml3/mxwriter.c
+++ b/dlls/msxml3/mxwriter.c
@@ -189,6 +189,7 @@ typedef struct
     BSTR element;
 
     IStream *dest;
+    IXMLDOMDocument *dest_doc;
 
     output_buffer buffer;
 } mxwriter;
@@ -850,6 +851,7 @@ static ULONG WINAPI mxwriter_Release(IMXWriter *iface)
         free_output_buffer(&This->buffer);
 
         if (This->dest) IStream_Release(This->dest);
+        if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
         SysFreeString(This->version);
         SysFreeString(This->encoding);
 
@@ -914,6 +916,8 @@ static HRESULT WINAPI mxwriter_put_output(IMXWriter *iface, VARIANT dest)
     {
         if (This->dest) IStream_Release(This->dest);
         This->dest = NULL;
+        if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
+        This->dest_doc = NULL;
         close_output_buffer(This);
         break;
     }
@@ -929,12 +933,33 @@ static HRESULT WINAPI mxwriter_put_output(IMXWriter *iface, VARIANT dest)
 
             if (This->dest) IStream_Release(This->dest);
             This->dest = stream;
+            if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
+            This->dest_doc = NULL;
             break;
         }
 
         FIXME("unhandled interface type for VT_UNKNOWN destination\n");
         return E_NOTIMPL;
     }
+    case VT_DISPATCH:
+    {
+        IXMLDOMDocument *doc;
+
+        hr = IDispatch_QueryInterface(V_DISPATCH(&dest), &IID_IXMLDOMDocument, (void**)&doc);
+        if (hr == S_OK)
+        {
+            close_output_buffer(This);
+
+            if (This->dest) IStream_Release(This->dest);
+            This->dest = NULL;
+            if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
+            This->dest_doc = doc;
+            break;
+        }
+
+        FIXME("unhandled interface type for VT_DISPATCH destination\n");
+        return E_NOTIMPL;
+    }
     default:
         FIXME("unhandled destination type %s\n", debugstr_variant(&dest));
         return E_NOTIMPL;
@@ -1201,7 +1226,7 @@ static HRESULT WINAPI SAXContentHandler_putDocumentLocator(
 {
     mxwriter *This = impl_from_ISAXContentHandler( iface );
     FIXME("(%p)->(%p)\n", This, locator);
-    return E_NOTIMPL;
+    return S_OK;
 }
 
 static HRESULT WINAPI SAXContentHandler_startDocument(ISAXContentHandler *iface)
@@ -1239,10 +1264,21 @@ static HRESULT WINAPI SAXContentHandler_startDocument(ISAXContentHandler *iface)
 
 static HRESULT WINAPI SAXContentHandler_endDocument(ISAXContentHandler *iface)
 {
+    HRESULT hr;
+    VARIANT dest;
+    VARIANT_BOOL success;
     mxwriter *This = impl_from_ISAXContentHandler( iface );
     TRACE("(%p)\n", This);
     This->prop_changed = FALSE;
-    return flush_output_buffer(This);
+
+    hr = flush_output_buffer(This);
+    if (FAILED(hr)) return hr;
+
+    if (This->dest_doc) {
+        mxwriter_get_output(&This->IMXWriter_iface, &dest);
+        return IXMLDOMDocument_loadXML(This->dest_doc, V_BSTR(&dest), &success);
+    }
+    return S_OK;
 }
 
 static HRESULT WINAPI SAXContentHandler_startPrefixMapping(
@@ -2630,6 +2666,7 @@ HRESULT MXWriter_create(MSXML_VERSION version, void **ppObj)
     This->newline = FALSE;
 
     This->dest = NULL;
+    This->dest_doc = NULL;
 
     hr = init_output_buffer(This->xml_enc, &This->buffer);
     if (hr != S_OK) {
diff --git a/dlls/msxml3/tests/saxreader.c b/dlls/msxml3/tests/saxreader.c
index 48cfa8f5593..b43c31d2e2f 100644
--- a/dlls/msxml3/tests/saxreader.c
+++ b/dlls/msxml3/tests/saxreader.c
@@ -4564,6 +4564,7 @@ static void test_mxwriter_domdoc(void)
     todo_wine
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
 
+    if (!node) return;
     hr = IXMLDOMNode_get_nodeName(node, &str);
 todo_wine {
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);

From efee035a1d652fe98e5083c1a57d6db67accdb7c Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Tue, 3 Mar 2015 03:39:12 +0100
Subject: [PATCH 069/244] ntdll: Reuse old async fileio structures if possible.

This should speed up apps which heavily rely on async io stuff. Some
tests (using the kernel and ntdll wine tests) show that it is very
often possible to reuse old fileio structures.
---
 dlls/ntdll/unix/file.c         | 23 +++++++++++++++++------
 dlls/ntdll/unix/unix_private.h |  1 +
 2 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index b3db4a975dd..89aedd2b05c 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5337,18 +5337,29 @@ void release_fileio( struct async_fileio *io )
 struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback, HANDLE handle )
 {
     /* first free remaining previous fileinfos */
-    struct async_fileio *io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
+    struct async_fileio *old_io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
+    struct async_fileio *io = NULL;
 
-    while (io)
+    while (old_io)
     {
-        struct async_fileio *next = io->next;
-        free( io );
-        io = next;
+        if (!io && old_io->size >= size && old_io->size <= max(4096, 4 * size))
+        {
+            io     = old_io;
+            size   = old_io->size;
+            old_io = old_io->next;
+        }
+        else
+        {
+            struct async_fileio *next = old_io->next;
+            free( old_io );
+            old_io = next;
+        }
     }
 
-    if ((io = malloc( size )))
+    if (io || (io = malloc( size )))
     {
         io->callback = callback;
+        io->size     = size;
         io->handle   = handle;
     }
     return io;
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index cd070e0b98f..afae39def06 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -130,6 +130,7 @@ struct async_fileio
 {
     async_callback_t    *callback;
     struct async_fileio *next;
+    DWORD                size;
     HANDLE               handle;
 };
 

From aeefac855b1fe5d029b8f55b0daec489139de654 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sun, 28 Sep 2014 23:39:51 +0200
Subject: [PATCH 070/244] ntdll: OutputDebugString should throw the exception a
 second time, if a debugger is attached.

---
 dlls/kernelbase/debug.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
index 14246976cc2..4293b58f35c 100644
--- a/dlls/kernelbase/debug.c
+++ b/dlls/kernelbase/debug.c
@@ -203,6 +203,23 @@ void WINAPI DECLSPEC_HOTPATCH OutputDebugStringA( LPCSTR str )
     __ENDTRY
     if (caught_by_dbg) return;
 
+    /* for some unknown reason Windows sends the exception a second time, if a
+     * debugger is attached, and the event wasn't handled in the first attempt */
+    if (NtCurrentTeb()->Peb->BeingDebugged)
+    {
+        __TRY
+        {
+            ULONG_PTR args[2];
+            args[0] = strlen(str) + 1;
+            args[1] = (ULONG_PTR)str;
+            RaiseException( DBG_PRINTEXCEPTION_C, 0, 2, args );
+        }
+        __EXCEPT(debug_exception_handler)
+        {
+        }
+        __ENDTRY
+    }
+
     /* send string to a system-wide monitor */
     if (!mutex_inited)
     {

From af806d53ae56f227aa725f7cfc87520977c3a041 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 30 May 2015 02:23:15 +0200
Subject: [PATCH 071/244] ntdll: Add support for hiding wine version
 information from applications.

---
 dlls/ntdll/loader.c     | 99 ++++++++++++++++++++++++++++++++++++++++-
 dlls/ntdll/ntdll_misc.h |  5 +++
 2 files changed, 103 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 07d3920c2a8..84df6640bb3 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -89,6 +89,9 @@ const WCHAR system_dir[] = L"C:\\windows\\system32\\";
 /* system search path */
 static const WCHAR system_path[] = L"C:\\windows\\system32;C:\\windows\\system;C:\\windows;C:\\Program Files (x86)\\Steam";
 
+#define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+
 static BOOL is_prefix_bootstrap;  /* are we bootstrapping the prefix? */
 static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed up, before attaching them */
 static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
@@ -108,6 +111,8 @@ struct dll_dir_entry
 
 static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from LdrAddDllDirectory */
 
+static BOOL hide_wine_exports = FALSE;  /* try to hide ntdll wine exports from applications */
+
 struct ldr_notification
 {
     struct list                    entry;
@@ -2094,6 +2099,96 @@ NTSTATUS WINAPI LdrUnlockLoaderLock( ULONG flags, ULONG_PTR magic )
 }
 
 
+/***********************************************************************
+ *           hidden_exports_init
+ *
+ * Initializes the hide_wine_exports options.
+ */
+static void hidden_exports_init( const WCHAR *appname )
+{
+    static const WCHAR configW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e',0};
+    static const WCHAR appdefaultsW[] = {'A','p','p','D','e','f','a','u','l','t','s','\\',0};
+    static const WCHAR hideWineExports[] = {'H','i','d','e','W','i','n','e','E','x','p','o','r','t','s',0};
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING nameW;
+    HANDLE root, config_key, hkey;
+    BOOL got_hide_wine_exports = FALSE;
+    char tmp[80];
+    DWORD dummy;
+
+    RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString( &nameW, configW );
+
+    /* @@ Wine registry key: HKCU\Software\Wine */
+    if (NtOpenKey( &config_key, KEY_QUERY_VALUE, &attr )) config_key = 0;
+    NtClose( root );
+    if (!config_key) return;
+
+    if (appname && *appname)
+    {
+        const WCHAR *p;
+        WCHAR appversion[MAX_PATH+20];
+
+        if ((p = wcsrchr( appname, '/' ))) appname = p + 1;
+        if ((p = wcsrchr( appname, '\\' ))) appname = p + 1;
+
+        wcscpy( appversion, appdefaultsW );
+        wcscat( appversion, appname );
+        RtlInitUnicodeString( &nameW, appversion );
+        attr.RootDirectory = config_key;
+
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe */
+        if (!NtOpenKey( &hkey, KEY_QUERY_VALUE, &attr ))
+        {
+            TRACE( "getting HideWineExports from %s\n", debugstr_w(appversion) );
+
+            RtlInitUnicodeString( &nameW, hideWineExports );
+            if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+            {
+                WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
+                hide_wine_exports = IS_OPTION_TRUE( str[0] );
+                got_hide_wine_exports = TRUE;
+            }
+
+            NtClose( hkey );
+        }
+    }
+
+    if (!got_hide_wine_exports)
+    {
+        TRACE( "getting default HideWineExports\n" );
+
+        RtlInitUnicodeString( &nameW, hideWineExports );
+        if (!NtQueryValueKey( config_key, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+        {
+            WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
+            hide_wine_exports = IS_OPTION_TRUE( str[0] );
+        }
+    }
+
+    NtClose( config_key );
+}
+
+
+/***********************************************************************
+ *           is_hidden_export
+ *
+ * Checks if a specific export should be hidden.
+ */
+static BOOL is_hidden_export( void *proc )
+{
+    return hide_wine_exports && (proc == &wine_get_version ||
+                                 proc == &wine_get_build_id ||
+                                 proc == &wine_get_host_version);
+}
+
+
 /******************************************************************
  *		LdrGetProcedureAddress  (NTDLL.@)
  */
@@ -2114,7 +2209,7 @@ NTSTATUS WINAPI LdrGetProcedureAddress(HMODULE module, const ANSI_STRING *name,
     {
         void *proc = name ? find_named_export( module, exports, exp_size, name->Buffer, -1, NULL )
                           : find_ordinal_export( module, exports, exp_size, ord - exports->Base, NULL );
-        if (proc)
+        if (proc && !is_hidden_export( proc ))
         {
             *address = proc;
             ret = STATUS_SUCCESS;
@@ -2443,6 +2538,8 @@ static void build_ntdll_module(void)
     wm->ldr.Flags &= ~LDR_DONT_RESOLVE_REFS;
     node_ntdll = wm->ldr.DdagNode;
     if (TRACE_ON(relay)) RELAY_SetupDLL( module );
+
+    hidden_exports_init( wm->ldr.FullDllName.Buffer );
 }
 
 
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 3dae3079c4e..8b89c92fe16 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -123,6 +123,11 @@ static inline void *get_rva( HMODULE module, DWORD va )
     return (void *)((char *)module + va);
 }
 
+/* version */
+extern const char * CDECL wine_get_version(void);
+extern const char * CDECL wine_get_build_id(void);
+extern void CDECL wine_get_host_version( const char **sysname, const char **release );
+
 /* convert from straight ASCII to Unicode without depending on the current codepage */
 static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
 {

From 057295a6fee83885816762de5e34b81a1aef0c10 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Thu, 28 Apr 2016 18:14:36 +0800
Subject: [PATCH 072/244] ntdll: Implement NtSetLdtEntries.

---
 dlls/kernel32/tests/thread.c  | 79 +++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/signal_i386.c |  2 +-
 2 files changed, 80 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index fa25fd4e4a7..e2db450faea 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -101,6 +101,7 @@ static HRESULT (WINAPI *pSetThreadDescription)(HANDLE,const WCHAR *);
 static HRESULT (WINAPI *pGetThreadDescription)(HANDLE,WCHAR **);
 static PVOID (WINAPI *pRtlAddVectoredExceptionHandler)(ULONG,PVECTORED_EXCEPTION_HANDLER);
 static ULONG (WINAPI *pRtlRemoveVectoredExceptionHandler)(PVOID);
+static NTSTATUS (WINAPI *pNtSetLdtEntries)(ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
 
 static HANDLE create_target_process(const char *arg)
 {
@@ -1298,6 +1299,82 @@ static void test_GetThreadSelectorEntry(void)
     ok(entry.HighWord.Bits.Granularity == 1,  "expected 1, got %u\n", entry.HighWord.Bits.Granularity);
 }
 
+static void test_NtSetLdtEntries(void)
+{
+    THREAD_DESCRIPTOR_INFORMATION tdi;
+    LDT_ENTRY ds_entry;
+    CONTEXT ctx;
+    DWORD ret;
+    union
+    {
+        LDT_ENTRY entry;
+        DWORD dw[2];
+    } sel;
+
+    if (!pNtSetLdtEntries)
+    {
+        win_skip("NtSetLdtEntries is not available on this platform\n");
+        return;
+    }
+
+    if (pNtSetLdtEntries(0, 0, 0, 0, 0, 0) == STATUS_NOT_IMPLEMENTED) /* WoW64 */
+    {
+        win_skip("NtSetLdtEntries is not implemented on this platform\n");
+        return;
+    }
+
+    ret = pNtSetLdtEntries(0, 0, 0, 0, 0, 0);
+    ok(!ret, "NtSetLdtEntries failed: %08x\n", ret);
+
+    ctx.ContextFlags = CONTEXT_SEGMENTS;
+    ret = GetThreadContext(GetCurrentThread(), &ctx);
+    ok(ret, "GetThreadContext failed\n");
+
+    tdi.Selector = ctx.SegDs;
+    ret = pNtQueryInformationThread(GetCurrentThread(), ThreadDescriptorTableEntry, &tdi, sizeof(tdi), &ret);
+    ok(!ret, "NtQueryInformationThread failed: %08x\n", ret);
+    ds_entry = tdi.Entry;
+
+    tdi.Selector = 0x000f;
+    ret = pNtQueryInformationThread(GetCurrentThread(), ThreadDescriptorTableEntry, &tdi, sizeof(tdi), &ret);
+    ok(ret == STATUS_ACCESS_VIOLATION, "got %08x\n", ret);
+
+    tdi.Selector = 0x001f;
+    ret = pNtQueryInformationThread(GetCurrentThread(), ThreadDescriptorTableEntry, &tdi, sizeof(tdi), &ret);
+    ok(ret == STATUS_ACCESS_VIOLATION, "NtQueryInformationThread returned %08x\n", ret);
+
+    ret = GetThreadSelectorEntry(GetCurrentThread(), 0x000f, &sel.entry);
+    ok(!ret, "GetThreadSelectorEntry should fail\n");
+
+    ret = GetThreadSelectorEntry(GetCurrentThread(), 0x001f, &sel.entry);
+    ok(!ret, "GetThreadSelectorEntry should fail\n");
+
+    memset(&sel.entry, 0x9a, sizeof(sel.entry));
+    ret = GetThreadSelectorEntry(GetCurrentThread(), ctx.SegDs, &sel.entry);
+    ok(ret, "GetThreadSelectorEntry failed\n");
+    ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
+
+    ret = pNtSetLdtEntries(0x000f, sel.dw[0], sel.dw[1], 0x001f, sel.dw[0], sel.dw[1]);
+    ok(!ret || broken(ret == STATUS_INVALID_LDT_DESCRIPTOR) /*XP*/, "NtSetLdtEntries failed: %08x\n", ret);
+
+    if (!ret)
+    {
+        memset(&sel.entry, 0x9a, sizeof(sel.entry));
+        ret = GetThreadSelectorEntry(GetCurrentThread(), 0x000f, &sel.entry);
+        todo_wine
+        ok(ret, "GetThreadSelectorEntry failed\n");
+        todo_wine
+        ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
+
+        memset(&sel.entry, 0x9a, sizeof(sel.entry));
+        ret = GetThreadSelectorEntry(GetCurrentThread(), 0x001f, &sel.entry);
+        todo_wine
+        ok(ret, "GetThreadSelectorEntry failed\n");
+        todo_wine
+        ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
+    }
+}
+
 #endif  /* __i386__ */
 
 static HANDLE finish_event;
@@ -2619,6 +2696,7 @@ static void init_funcs(void)
        X(NtSetInformationThread);
        X(RtlAddVectoredExceptionHandler);
        X(RtlRemoveVectoredExceptionHandler);
+       X(NtSetLdtEntries);
    }
 #undef X
 }
@@ -2675,6 +2753,7 @@ START_TEST(thread)
    test_SetThreadContext();
    test_GetThreadSelectorEntry();
    test_GetThreadContext();
+   test_NtSetLdtEntries();
 #endif
    test_QueueUserWorkItem();
    test_RegisterWaitForSingleObject();
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 33958f76ee9..666a4a47fcf 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2360,7 +2360,7 @@ NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_
                 if (reply->flags)
                     info->Entry = ldt_make_entry( (void *)reply->base, reply->limit, reply->flags );
                 else
-                    status = STATUS_UNSUCCESSFUL;
+                    status = STATUS_ACCESS_VIOLATION;
             }
         }
         SERVER_END_REQ;

From 9ec408e3d577ddaad14a888ade8ae672582874f2 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Thu, 28 Apr 2016 17:01:16 +0200
Subject: [PATCH 073/244] libs/wine: Allow to modify reserved LDT entries.

Some implementation notes:

1. Some copy protections call NtSetLdtEntries(0x000f) and then with 'retf'
instruction jump to that selector expecting that it works (the tests show that
NtSetLdtEntries(0x000f,0x001f) should succeed). In order to make this work a
limitation to set only selectors > LDT_FIRST_ENTRY (512) in wine_ldt_set_entry()
was removed.

2. wine_ldt_set_entry() was made to always mark modified selector entries as
WINE_LDT_FLAGS_ALLOCATED, otherwise get_selector_entry() server call returns
entries without that flag set and NtQueryInformationThread(ThreadDescriptorTableEntry)
fails.
---
 dlls/kernel32/tests/thread.c  | 4 ----
 dlls/ntdll/unix/signal_i386.c | 2 --
 2 files changed, 6 deletions(-)

diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index e2db450faea..8ddac77a291 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -1361,16 +1361,12 @@ static void test_NtSetLdtEntries(void)
     {
         memset(&sel.entry, 0x9a, sizeof(sel.entry));
         ret = GetThreadSelectorEntry(GetCurrentThread(), 0x000f, &sel.entry);
-        todo_wine
         ok(ret, "GetThreadSelectorEntry failed\n");
-        todo_wine
         ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
 
         memset(&sel.entry, 0x9a, sizeof(sel.entry));
         ret = GetThreadSelectorEntry(GetCurrentThread(), 0x001f, &sel.entry);
-        todo_wine
         ok(ret, "GetThreadSelectorEntry failed\n");
-        todo_wine
         ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
     }
 }
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 666a4a47fcf..7c522a32158 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2382,8 +2382,6 @@ NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_E
     sigset_t sigset;
 
     if (sel1 >> 16 || sel2 >> 16) return STATUS_INVALID_LDT_DESCRIPTOR;
-    if (sel1 && (sel1 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
-    if (sel2 && (sel2 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
 
     server_enter_uninterrupted_section( &ldt_mutex, &sigset );
     if (sel1) ldt_set_entry( sel1, entry1 );

From d872d220c0ad6d3b6bff212478841eeb071aa28b Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Tue, 29 Dec 2015 00:48:02 -0700
Subject: [PATCH 074/244] mountmgr.sys: Do a device check before returning a
 default serial port name.

Fixes https://bugs.winehq.org/show_bug.cgi?id=39793
---
 dlls/mountmgr.sys/device.c  |  2 +-
 dlls/mountmgr.sys/unixlib.c | 22 ++++++++++++++++++++++
 dlls/mountmgr.sys/unixlib.h |  1 +
 3 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
index d0edb97a976..d372f0ff9ac 100644
--- a/dlls/mountmgr.sys/device.c
+++ b/dlls/mountmgr.sys/device.c
@@ -1921,7 +1921,7 @@ static BOOL create_port_device( DRIVER_OBJECT *driver, int n, const char *unix_p
     UNICODE_STRING nt_name, symlink_name, default_name;
     DEVICE_OBJECT *dev_obj;
     NTSTATUS status;
-    struct set_dosdev_symlink_params params = { dosdevices_path, unix_path };
+    struct set_dosdev_symlink_params params = { dosdevices_path, unix_path, driver == serial_driver };
 
     /* create DOS device */
     if (MOUNTMGR_CALL( set_dosdev_symlink, &params )) return FALSE;
diff --git a/dlls/mountmgr.sys/unixlib.c b/dlls/mountmgr.sys/unixlib.c
index 36f9f82dad8..79ecb35dc2a 100644
--- a/dlls/mountmgr.sys/unixlib.c
+++ b/dlls/mountmgr.sys/unixlib.c
@@ -36,6 +36,7 @@
 #ifdef HAVE_SYS_STATVFS_H
 # include <sys/statvfs.h>
 #endif
+#include <termios.h>
 #include <unistd.h>
 
 #include "unixlib.h"
@@ -298,6 +299,27 @@ static NTSTATUS set_dosdev_symlink( void *args )
     char *path;
     NTSTATUS status = STATUS_SUCCESS;
 
+#ifdef linux
+    /* Serial port device files almost always exist on Linux even if the corresponding serial
+     * ports don't exist. Do a basic functionality check before advertising a serial port. */
+    if (params->serial)
+    {
+        struct termios tios;
+        int fd;
+
+        if ((fd = open( params->dest, O_RDONLY )) == -1)
+            return FALSE;
+
+        if (tcgetattr( fd, &tios ) == -1)
+        {
+            close( fd );
+            return FALSE;
+        }
+
+        close( fd );
+    }
+#endif
+
     if (!(path = get_dosdevices_path( params->dev ))) return STATUS_NO_MEMORY;
 
     if (params->dest && params->dest[0])
diff --git a/dlls/mountmgr.sys/unixlib.h b/dlls/mountmgr.sys/unixlib.h
index b40b323ac80..4158c27bfed 100644
--- a/dlls/mountmgr.sys/unixlib.h
+++ b/dlls/mountmgr.sys/unixlib.h
@@ -91,6 +91,7 @@ struct set_dosdev_symlink_params
 {
     const char *dev;
     const char *dest;
+    BOOL serial;
 };
 
 struct get_volume_dos_devices_params

From a9818183b1d432d28d946246fadd7b52f7845652 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Thu, 21 Dec 2023 20:09:23 +0100
Subject: [PATCH 075/244] kernelbase: Correct return value in VirtualProtect
 for PAGE_WRITECOPY

---
 dlls/kernelbase/memory.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/memory.c b/dlls/kernelbase/memory.c
index e102345119a..ef68737c4fa 100644
--- a/dlls/kernelbase/memory.c
+++ b/dlls/kernelbase/memory.c
@@ -575,7 +575,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH  VirtualLock( void *addr, SIZE_T size )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH VirtualProtect( void *addr, SIZE_T size, DWORD new_prot, DWORD *old_prot )
 {
-    return VirtualProtectEx( GetCurrentProcess(), addr, size, new_prot, old_prot );
+    BOOL ret = VirtualProtectEx( GetCurrentProcess(), addr, size, new_prot, old_prot );
+    if (*old_prot == PAGE_WRITECOPY) *old_prot = PAGE_READWRITE;
+    return ret;
 }
 
 

From 8bc534783206ef33ebd8ce6289aa022d373bf9bd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Aida=20Jonikien=C4=97?= <aidas957@gmail.com>
Date: Fri, 26 Jul 2024 20:33:57 +0300
Subject: [PATCH 076/244] kernelbase: Handle NULL old_prot parameter in
 VirtualProtect().

This fixes a segfault when launching any game with the EA Desktop application.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56694
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56711
---
 dlls/kernelbase/memory.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/kernelbase/memory.c b/dlls/kernelbase/memory.c
index ef68737c4fa..194b1049f3d 100644
--- a/dlls/kernelbase/memory.c
+++ b/dlls/kernelbase/memory.c
@@ -576,7 +576,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH  VirtualLock( void *addr, SIZE_T size )
 BOOL WINAPI DECLSPEC_HOTPATCH VirtualProtect( void *addr, SIZE_T size, DWORD new_prot, DWORD *old_prot )
 {
     BOOL ret = VirtualProtectEx( GetCurrentProcess(), addr, size, new_prot, old_prot );
-    if (*old_prot == PAGE_WRITECOPY) *old_prot = PAGE_READWRITE;
+    if (old_prot && *old_prot == PAGE_WRITECOPY) *old_prot = PAGE_READWRITE;
     return ret;
 }
 

From 381d504357c90453581672ef9eb5e4c8db04245d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 24 May 2019 15:09:35 +0300
Subject: [PATCH 077/244] ntdll/server: Mark drive_c as case-insensitive when
 created
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47099
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/ntdll/unix/server.c | 43 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 30fc6fc9214..c35cf741211 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -49,6 +49,10 @@
 #ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
+#include <sys/ioctl.h>
+#ifdef HAVE_LINUX_IOCTL_H
+#include <linux/ioctl.h>
+#endif
 #ifdef HAVE_SYS_PRCTL_H
 # include <sys/prctl.h>
 #endif
@@ -87,6 +91,22 @@ WINE_DEFAULT_DEBUG_CHANNEL(server);
 WINE_DECLARE_DEBUG_CHANNEL(client);
 WINE_DECLARE_DEBUG_CHANNEL(ftrace);
 
+/* just in case... */
+#undef EXT2_IOC_GETFLAGS
+#undef EXT2_IOC_SETFLAGS
+#undef EXT4_CASEFOLD_FL
+
+#ifdef __linux__
+
+/* Define the ext2 ioctls for handling extra attributes */
+#define EXT2_IOC_GETFLAGS _IOR('f', 1, long)
+#define EXT2_IOC_SETFLAGS _IOW('f', 2, long)
+
+/* Case-insensitivity attribute */
+#define EXT4_CASEFOLD_FL 0x40000000
+
+#endif
+
 #ifndef MSG_CMSG_CLOEXEC
 #define MSG_CMSG_CLOEXEC 0
 #endif
@@ -1272,6 +1292,28 @@ static const char *init_server_dir( dev_t dev, ino_t ino )
 }
 
 
+/***********************************************************************
+ *           set_case_insensitive
+ *
+ * Make the supplied directory case insensitive, if available.
+ */
+static void set_case_insensitive(const char *dir)
+{
+#if defined(EXT2_IOC_GETFLAGS) && defined(EXT2_IOC_SETFLAGS) && defined(EXT4_CASEFOLD_FL)
+    int flags, fd;
+
+    if ((fd = open(dir, O_RDONLY | O_NONBLOCK | O_LARGEFILE)) == -1)
+        return;
+    if (ioctl(fd, EXT2_IOC_GETFLAGS, &flags) != -1 && !(flags & EXT4_CASEFOLD_FL))
+    {
+        flags |= EXT4_CASEFOLD_FL;
+        ioctl(fd, EXT2_IOC_SETFLAGS, &flags);
+    }
+    close(fd);
+#endif
+}
+
+
 /***********************************************************************
  *           setup_config_dir
  *
@@ -1308,6 +1350,7 @@ static int setup_config_dir(void)
     if (!mkdir( "dosdevices", 0777 ))
     {
         mkdir( "drive_c", 0777 );
+        set_case_insensitive( "drive_c" );
         symlink( "../drive_c", "dosdevices/c:" );
         symlink( "/", "dosdevices/z:" );
     }

From f713043a791e25c98437d80d0f9edf549c1ae874 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 12 Jul 2024 14:44:43 +1000
Subject: [PATCH 078/244] odbc32: Load function pointer for SQLBindParam

---
 dlls/odbc32/proxyodbc.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 9dea285b6ee..9a0ae037e05 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -50,6 +50,7 @@ struct win32_funcs
     SQLRETURN (WINAPI *SQLAllocHandleStd)(SQLSMALLINT,SQLHANDLE,SQLHANDLE*);
     SQLRETURN (WINAPI *SQLAllocStmt)(SQLHDBC,SQLHSTMT*);
     SQLRETURN (WINAPI *SQLBindCol)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
+    SQLRETURN (WINAPI *SQLBindParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN*);
     SQLRETURN (WINAPI *SQLBindParameter)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,
                                          SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
     SQLRETURN (WINAPI *SQLBrowseConnect)(SQLHDBC,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
@@ -206,6 +207,7 @@ static BOOL load_function_table( HMODULE module, struct win32_driver *driver )
     LOAD_FUNCPTR( SQLAllocHandleStd )
     LOAD_FUNCPTR( SQLAllocStmt )
     LOAD_FUNCPTR( SQLBindCol )
+    LOAD_FUNCPTR( SQLBindParam )
     LOAD_FUNCPTR( SQLBindParameter )
     LOAD_FUNCPTR( SQLBrowseConnect )
     LOAD_FUNCPTR( SQLBrowseConnectW )

From 1af701233f012ec488e6a72b01ef82c4e3a3854d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 12 Jul 2024 14:40:32 +1000
Subject: [PATCH 079/244] odbc32: SQLBindParameter handle fallback function

---
 dlls/odbc32/proxyodbc.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 9a0ae037e05..14aec385652 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -5503,6 +5503,29 @@ static SQLRETURN bind_parameter_win32( struct statement *stmt, SQLUSMALLINT para
     if (stmt->hdr.win32_funcs->SQLBindParameter)
         return stmt->hdr.win32_funcs->SQLBindParameter( stmt->hdr.win32_handle, param, io_type, value_type,
                                                         param_type, size, digits, value, buflen, len );
+    else if(stmt->hdr.win32_funcs->SQLBindParam)
+    {
+        /* ODBC v2 */
+        /* TODO: Make function */
+        if (value_type == SQL_C_TYPE_TIME)
+            value_type = SQL_C_TIME;
+        else if (value_type == SQL_C_TYPE_DATE)
+            value_type = SQL_C_DATE;
+        else if (value_type == SQL_C_TYPE_TIMESTAMP)
+            value_type = SQL_C_TIMESTAMP;
+
+        /* TODO: Make function */
+        if (param_type == SQL_TIME)
+            param_type = SQL_TYPE_TIME;
+        else if (param_type == SQL_DATE)
+            param_type = SQL_TYPE_DATE;
+        else if (param_type == SQL_TIMESTAMP)
+            param_type = SQL_TYPE_TIMESTAMP;;;
+
+        return stmt->hdr.win32_funcs->SQLBindParam( stmt->hdr.win32_handle, param, value_type, param_type,
+                                                 size, digits, value, len);
+    }
+
     return SQL_ERROR;
 }
 

From fcf11957b9b745b5190d9df19934b3113a34ddb6 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 12 Jul 2024 14:55:47 +1000
Subject: [PATCH 080/244] odbc32: SQLSetConnectAttr/W handle fallback function

---
 dlls/odbc32/proxyodbc.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 14aec385652..892c38cf3e1 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -6684,6 +6684,11 @@ static SQLRETURN set_connect_attr_win32_w( struct connection *con, SQLINTEGER at
     if (con->hdr.win32_funcs->SQLSetConnectAttrW)
         return con->hdr.win32_funcs->SQLSetConnectAttrW( con->hdr.win32_handle, attr, value, len );
     if (con->hdr.win32_funcs->SQLSetConnectAttr) FIXME( "Unicode to ANSI conversion not handled\n" );
+    else if(con->hdr.win32_funcs->SQLSetConnectOptionW)
+    {
+        /* ODBC v2 */
+        return con->hdr.win32_funcs->SQLSetConnectOptionW( con->hdr.win32_handle, attr, (SQLULEN)value );
+    }
     return SQL_ERROR;
 }
 

From bcbbf2b62bae60f68ffa97d35be576ce6c0c8697 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 18 Jul 2024 07:13:48 +1000
Subject: [PATCH 081/244] odbc32: Record loaded driver SQL_ATTR_ODBC_VERSION

---
 dlls/odbc32/proxyodbc.c | 4 ++++
 dlls/odbc32/unixlib.h   | 1 +
 2 files changed, 5 insertions(+)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 892c38cf3e1..3eb5b1f170d 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -464,6 +464,7 @@ static struct environment *create_environment( void )
     if (!(ret = calloc( 1, sizeof(*ret) ))) return NULL;
     init_object( &ret->hdr, SQL_HANDLE_ENV, NULL );
     ret->attr_version = SQL_OV_ODBC2;
+    ret->driver_ver = SQL_OV_ODBC2;
     return ret;
 }
 
@@ -1257,6 +1258,9 @@ static SQLRETURN set_env_attr( struct environment *env, SQLINTEGER attr, SQLPOIN
     }
     else if (env->hdr.win32_handle)
     {
+        if (env->hdr.win32_funcs->SQLGetEnvAttr)
+           ret = env->hdr.win32_funcs->SQLGetEnvAttr( env->hdr.win32_handle, SQL_ATTR_ODBC_VERSION, &env->driver_ver, 0, NULL );
+
         if (env->hdr.win32_funcs->SQLSetEnvAttr)
             ret = env->hdr.win32_funcs->SQLSetEnvAttr( env->hdr.win32_handle, attr, value, len );
     }
diff --git a/dlls/odbc32/unixlib.h b/dlls/odbc32/unixlib.h
index c865a83711d..4ff13a68add 100644
--- a/dlls/odbc32/unixlib.h
+++ b/dlls/odbc32/unixlib.h
@@ -205,6 +205,7 @@ struct environment
     UINT32 sources_idx;
     void  *sources_key;
     BOOL   sources_system;
+    UINT32 driver_ver;
 };
 
 struct connection

From 819fe4672d4b782d121e944835772cfa89525938 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 17 Jul 2024 21:55:20 +1000
Subject: [PATCH 082/244] odbc32: SQLGetData support ODBC v2.0

---
 dlls/odbc32/proxyodbc.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 3eb5b1f170d..92d8ccbc790 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -2458,11 +2458,35 @@ static SQLRETURN get_data_unix( struct statement *stmt, SQLUSMALLINT column, SQL
     return ret;
 }
 
+static struct object *find_object_type(SQLSMALLINT type, struct object *object)
+{
+    while (object && object->type != type)
+    {
+        object = object->parent;
+    }
+
+    return object;
+}
+
 static SQLRETURN get_data_win32( struct statement *stmt, SQLUSMALLINT column, SQLSMALLINT type, SQLPOINTER value,
                                  SQLLEN buflen, SQLLEN *retlen )
 {
     if (stmt->hdr.win32_funcs->SQLGetData)
+    {
+        struct environment *env = (struct environment *)find_object_type(SQL_HANDLE_ENV, stmt->hdr.parent);
+        if (env && env->attr_version == SQL_OV_ODBC2)
+        {
+            if (type == SQL_C_TYPE_TIME)
+                type = SQL_C_TIME;
+            else if (type == SQL_C_TYPE_DATE)
+                type = SQL_C_DATE;
+            else if (type == SQL_C_TYPE_TIMESTAMP)
+                type = SQL_C_TIMESTAMP;
+        }
+
         return stmt->hdr.win32_funcs->SQLGetData( stmt->hdr.win32_handle, column, type, value, buflen, retlen );
+    }
+
     return SQL_ERROR;
 }
 

From 22ed161469db9ee8eb54c08530223a504cb60dde Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 17 Jul 2024 22:03:03 +1000
Subject: [PATCH 083/244] odbc32: SQLColAttributesW support ODBC v2.0

---
 dlls/odbc32/proxyodbc.c | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 92d8ccbc790..9718aa42f4b 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -6232,6 +6232,8 @@ static SQLRETURN col_attribute_win32_w( struct statement *stmt, SQLUSMALLINT col
                                         SQLPOINTER char_attr, SQLSMALLINT buflen, SQLSMALLINT *retlen,
                                         SQLLEN *num_attr )
 {
+    SQLRETURN ret = SQL_ERROR;
+
     if (stmt->hdr.win32_funcs->SQLColAttributeW)
         return stmt->hdr.win32_funcs->SQLColAttributeW( stmt->hdr.win32_handle, col, field_id, char_attr, buflen,
                                                        retlen, num_attr );
@@ -6291,11 +6293,23 @@ static SQLRETURN col_attribute_win32_w( struct statement *stmt, SQLUSMALLINT col
             return SQL_ERROR;
         }
 
-        return stmt->hdr.win32_funcs->SQLColAttributesW( stmt->hdr.win32_handle, col, field_id, char_attr, buflen,
+        ret = stmt->hdr.win32_funcs->SQLColAttributesW( stmt->hdr.win32_handle, col, field_id, char_attr, buflen,
                                                          retlen, num_attr );
+        /* Convert back for ODBC2 drivers */
+        if (SQL_SUCCEEDED(ret) && num_attr && field_id == SQL_COLUMN_TYPE &&
+                ((struct environment*)(stmt->hdr.parent))->attr_version == SQL_OV_ODBC2 &&
+                ((struct environment*)(stmt->hdr.parent))->driver_ver == SQL_OV_ODBC2)
+        {
+            if (*num_attr == SQL_TIME)
+                *num_attr = SQL_TYPE_TIME;
+            else if (*num_attr == SQL_DATETIME)
+                *num_attr = SQL_TYPE_DATE;
+            else if (*num_attr == SQL_TIMESTAMP)
+                *num_attr = SQL_TYPE_TIMESTAMP;
+        }
     }
 
-    return SQL_ERROR;
+    return ret;
 }
 
 /*************************************************************************

From d9dfb2707c458eea11d4d1f21a4a9ae57732cb93 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 17 Jul 2024 22:04:39 +1000
Subject: [PATCH 084/244] odbc32: SQLSetStmtAttrW support fallback for ODBC
 v2.0

---
 dlls/odbc32/proxyodbc.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 9718aa42f4b..d88771be50e 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -7918,6 +7918,11 @@ static SQLRETURN set_stmt_attr_win32_w( struct statement *stmt, SQLINTEGER attr,
     if (stmt->hdr.win32_funcs->SQLSetStmtAttrW)
         return stmt->hdr.win32_funcs->SQLSetStmtAttrW( stmt->hdr.win32_handle, attr, value, len );
     if (stmt->hdr.win32_funcs->SQLSetStmtAttr) FIXME( "Unicode to ANSI conversion not handled\n" );
+    else if (stmt->hdr.win32_funcs->SQLSetStmtOption)
+    {
+        /* ODBC v2.0 */
+        return stmt->hdr.win32_funcs->SQLSetStmtOption( stmt->hdr.win32_handle, attr, (SQLULEN)value );
+    }
     return SQL_ERROR;
 }
 

From 2a54160c65acb9b9282d156a551a27421390b212 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 28 Aug 2024 07:57:17 +1000
Subject: [PATCH 085/244] odbc32: SQLColAttributes/W fall throught for unknown
 field ids

---
 dlls/odbc32/proxyodbc.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index d88771be50e..bfc529e5602 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -1027,7 +1027,6 @@ static SQLRETURN col_attribute_win32_a( struct statement *stmt, SQLUSMALLINT col
 
         default:
             FIXME( "field id %u not handled\n", field_id );
-            return SQL_ERROR;
         }
 
         return stmt->hdr.win32_funcs->SQLColAttributes( stmt->hdr.win32_handle, col, field_id, char_attr, buflen,
@@ -6290,7 +6289,6 @@ static SQLRETURN col_attribute_win32_w( struct statement *stmt, SQLUSMALLINT col
 
         default:
             FIXME( "field id %u not handled\n", field_id );
-            return SQL_ERROR;
         }
 
         ret = stmt->hdr.win32_funcs->SQLColAttributesW( stmt->hdr.win32_handle, col, field_id, char_attr, buflen,

From 1c965dc5fbad8dfef096da71c584c28c3cbfd799 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 2 Sep 2015 13:09:34 +1000
Subject: [PATCH 086/244] oleaut32: Implement semi-stub for CreateTypeLib.

---
 dlls/oleaut32/typelib.c | 20 +++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/dlls/oleaut32/typelib.c b/dlls/oleaut32/typelib.c
index f421a76fe95..1e43c3a91a1 100644
--- a/dlls/oleaut32/typelib.c
+++ b/dlls/oleaut32/typelib.c
@@ -408,11 +408,21 @@ HRESULT WINAPI QueryPathOfRegTypeLib( REFGUID guid, WORD wMaj, WORD wMin, LCID l
  *    Success: S_OK
  *    Failure: Status
  */
-HRESULT WINAPI CreateTypeLib(
-	SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib** ppctlib
-) {
-    FIXME("(%d,%s,%p), stub!\n",syskind,debugstr_w(szFile),ppctlib);
-    return E_FAIL;
+HRESULT WINAPI CreateTypeLib(SYSKIND syskind, LPCOLESTR file, ICreateTypeLib **ctlib)
+{
+    ICreateTypeLib2 *typelib2;
+    HRESULT hres;
+
+    FIXME("(%d, %s, %p): forwarding to CreateTypeLib2\n", syskind, debugstr_w(file), ctlib);
+
+    hres = CreateTypeLib2(syskind, file, &typelib2);
+    if(SUCCEEDED(hres))
+    {
+        hres = ICreateTypeLib2_QueryInterface(typelib2, &IID_ICreateTypeLib, (void **)ctlib);
+        ICreateTypeLib2_Release(typelib2);
+    }
+
+    return hres;
 }
 
 /******************************************************************************

From ac6b747ddaa17d68cd99b48b8d7e0f19d704736d Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 26 Apr 2016 12:11:17 +0800
Subject: [PATCH 087/244] oleaut32/tests: Add some tests for loading and saving
 EMF using IPicture interface.

---
 dlls/oleaut32/tests/olepicture.c | 90 ++++++++++++++++++++++++++++++++
 1 file changed, 90 insertions(+)

diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index f0468a6f83c..f06befd2976 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -1613,6 +1613,95 @@ static void test_load_save_dib(void)
     }
 }
 
+static void test_load_save_emf(void)
+{
+    HDC hdc;
+    IPicture *pic;
+    PICTDESC desc;
+    short type;
+    OLE_HANDLE handle;
+    HGLOBAL hmem;
+    DWORD *mem;
+    ENHMETAHEADER *emh;
+    IPersistStream *src_stream;
+    IStream *dst_stream;
+    LARGE_INTEGER offset;
+    HRESULT hr;
+    LONG size;
+
+    hdc = CreateEnhMetaFileA(0, NULL, NULL, NULL);
+    ok(hdc != 0, "CreateEnhMetaFileA failed\n");
+
+    desc.cbSizeofstruct = sizeof(desc);
+    desc.picType = PICTYPE_ENHMETAFILE;
+    desc.emf.hemf = CloseEnhMetaFile(hdc);
+    ok(desc.emf.hemf != 0, "CloseEnhMetaFile failed\n");
+    hr = OleCreatePictureIndirect(&desc, &IID_IPicture, FALSE, (void**)&pic);
+    ok(hr == S_OK, "OleCreatePictureIndirect error %#x\n", hr);
+
+    type = -1;
+    hr = IPicture_get_Type(pic, &type);
+    ok(hr == S_OK,"get_Type error %#8x\n", hr);
+    ok(type == PICTYPE_ENHMETAFILE,"expected PICTYPE_ENHMETAFILE, got %d\n", type);
+
+    hr = IPicture_get_Handle(pic, &handle);
+    ok(hr == S_OK,"get_Handle error %#8x\n", hr);
+    ok(IntToPtr(handle) == desc.emf.hemf, "get_Handle returned wrong handle %#x\n", handle);
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, 0);
+    hr = CreateStreamOnHGlobal(hmem, FALSE, &dst_stream);
+    ok(hr == S_OK, "createstreamonhglobal error %#x\n", hr);
+
+    size = -1;
+    hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
+    ok(hr == S_OK, "IPicture_SaveasFile error %#x\n", hr);
+todo_wine
+    ok(size == 128, "expected 128, got %d\n", size);
+    emh = GlobalLock(hmem);
+if (size)
+{
+    ok(emh->iType == EMR_HEADER, "wrong iType %04x\n", emh->iType);
+    ok(emh->dSignature == ENHMETA_SIGNATURE, "wrong dSignature %08x\n", emh->dSignature);
+}
+    GlobalUnlock(hmem);
+
+    size = -1;
+    hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
+todo_wine
+    ok(hr == E_FAIL, "expected E_FAIL, got %#x\n", hr);
+todo_wine
+    ok(size == -1, "expected -1, got %d\n", size);
+
+    offset.QuadPart = 0;
+    hr = IStream_Seek(dst_stream, offset, SEEK_SET, NULL);
+    ok(hr == S_OK, "IStream_Seek %#x\n", hr);
+
+    hr = IPicture_QueryInterface(pic, &IID_IPersistStream, (void **)&src_stream);
+    ok(hr == S_OK, "QueryInterface error %#x\n", hr);
+
+    hr = IPersistStream_Save(src_stream, dst_stream, TRUE);
+todo_wine
+    ok(hr == S_OK, "Save error %#x\n", hr);
+
+    IPersistStream_Release(src_stream);
+    IStream_Release(dst_stream);
+
+    mem = GlobalLock(hmem);
+if (hr == S_OK)
+{
+    ok(!memcmp(mem, "lt\0\0", 4), "got wrong stream header %04x\n", mem[0]);
+    ok(mem[1] == 128, "expected 128, got %u\n", mem[1]);
+    emh = (ENHMETAHEADER *)(mem + 2);
+    ok(emh->iType == EMR_HEADER, "wrong iType %04x\n", emh->iType);
+    ok(emh->dSignature == ENHMETA_SIGNATURE, "wrong dSignature %08x\n", emh->dSignature);
+}
+    GlobalUnlock(hmem);
+    GlobalFree(hmem);
+
+    DeleteEnhMetaFile(desc.emf.hemf);
+    IPicture_Release(pic);
+}
+
 START_TEST(olepicture)
 {
     hOleaut32 = GetModuleHandleA("oleaut32.dll");
@@ -1653,6 +1742,7 @@ START_TEST(olepicture)
     test_load_save_dib();
     test_load_save_icon();
     test_load_save_empty_picture();
+    test_load_save_emf();
 }
 
 

From e4f09273efbcf4fdbc3c96531761b8988021c7f3 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 26 Apr 2016 13:15:41 +0800
Subject: [PATCH 088/244] oleaut32: Add support for loading and saving EMF to
 IPicture interface.

For bug #40523.
---
 dlls/oleaut32/olepicture.c       | 53 +++++++++++++++++++++++++++++---
 dlls/oleaut32/tests/olepicture.c |  5 +--
 2 files changed, 49 insertions(+), 9 deletions(-)

diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index a461d28f6eb..cb74ce88651 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -256,6 +256,18 @@ static void OLEPictureImpl_SetIcon(OLEPictureImpl * This)
     }
 }
 
+static void OLEPictureImpl_SetEMF(OLEPictureImpl *This)
+{
+    ENHMETAHEADER emh;
+
+    GetEnhMetaFileHeader(This->desc.emf.hemf, sizeof(emh), &emh);
+
+    This->origWidth = 0;
+    This->origHeight = 0;
+    This->himetricWidth = emh.rclFrame.right - emh.rclFrame.left;
+    This->himetricHeight = emh.rclFrame.bottom - emh.rclFrame.top;
+}
+
 /************************************************************************
  * OLEPictureImpl_Construct
  *
@@ -339,8 +351,7 @@ static HRESULT OLEPictureImpl_Construct(LPPICTDESC pictDesc, BOOL fOwn, OLEPictu
         break;
 
       case PICTYPE_ENHMETAFILE:
-        FIXME("EMF is not supported\n");
-        newObject->himetricWidth = newObject->himetricHeight = 0;
+        OLEPictureImpl_SetEMF(newObject);
         break;
 
       default:
@@ -1800,6 +1811,22 @@ static BOOL serializeIcon(HICON hIcon, void ** ppBuffer, unsigned int * pLength)
         return success;
 }
 
+static HRESULT serializeEMF(HENHMETAFILE hemf, void **buf, unsigned *size)
+{
+    if (!(*size = GetEnhMetaFileBits(hemf, 0, NULL)))
+        return E_FAIL;
+
+    if (!(*buf = HeapAlloc(GetProcessHeap(), 0, *size)))
+        return E_OUTOFMEMORY;
+
+    if (!GetEnhMetaFileBits(hemf, *size, *buf))
+    {
+        HeapFree(GetProcessHeap(), 0, *buf);
+        return E_FAIL;
+    }
+    return S_OK;
+}
+
 static HRESULT WINAPI OLEPictureImpl_Save(
   IPersistStream* iface,IStream*pStm,BOOL fClearDirty)
 {
@@ -1871,12 +1898,28 @@ static HRESULT WINAPI OLEPictureImpl_Save(
         IStream_Write(pStm, This->data, This->datalen, &dummy);
         hResult = S_OK;
         break;
+
+    case PICTYPE_ENHMETAFILE:
+        if (This->bIsDirty || !This->data)
+        {
+            hResult = serializeEMF(This->desc.emf.hemf, &pIconData, &iDataSize);
+            if (hResult != S_OK)
+                break;
+
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = pIconData;
+            This->datalen = iDataSize;
+        }
+        header[0] = 0x0000746c;
+        header[1] = This->datalen;
+        IStream_Write(pStm, header, 2 * sizeof(DWORD), &dummy);
+        IStream_Write(pStm, This->data, This->datalen, &dummy);
+        hResult = S_OK;
+        break;
+
     case PICTYPE_METAFILE:
         FIXME("(%p,%p,%d), PICTYPE_METAFILE not implemented!\n",This,pStm,fClearDirty);
         break;
-    case PICTYPE_ENHMETAFILE:
-        FIXME("(%p,%p,%d),PICTYPE_ENHMETAFILE not implemented!\n",This,pStm,fClearDirty);
-        break;
     default:
         FIXME("(%p,%p,%d), [unknown type] not implemented!\n",This,pStm,fClearDirty);
         break;
diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index f06befd2976..5393ed7142a 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -1680,21 +1680,18 @@ todo_wine
     ok(hr == S_OK, "QueryInterface error %#x\n", hr);
 
     hr = IPersistStream_Save(src_stream, dst_stream, TRUE);
-todo_wine
     ok(hr == S_OK, "Save error %#x\n", hr);
 
     IPersistStream_Release(src_stream);
     IStream_Release(dst_stream);
 
     mem = GlobalLock(hmem);
-if (hr == S_OK)
-{
     ok(!memcmp(mem, "lt\0\0", 4), "got wrong stream header %04x\n", mem[0]);
     ok(mem[1] == 128, "expected 128, got %u\n", mem[1]);
     emh = (ENHMETAHEADER *)(mem + 2);
     ok(emh->iType == EMR_HEADER, "wrong iType %04x\n", emh->iType);
     ok(emh->dSignature == ENHMETA_SIGNATURE, "wrong dSignature %08x\n", emh->dSignature);
-}
+
     GlobalUnlock(hmem);
     GlobalFree(hmem);
 

From 10f60c4a8a3e66fa065b06db28fc796ef58876b0 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 24 Nov 2015 17:22:02 +0800
Subject: [PATCH 089/244] oleaut32: Implement a better stub for
 IPicture::SaveAsFile.

Based on OLEPictureImpl_Save implementation.

For bug 8532.
---
 dlls/oleaut32/olepicture.c       | 92 +++++++++++++++++++++++++++-----
 dlls/oleaut32/tests/olepicture.c |  9 ----
 2 files changed, 79 insertions(+), 22 deletions(-)

diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index cb74ce88651..22836e77a92 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -830,19 +830,6 @@ static HRESULT WINAPI OLEPictureImpl_PictureChanged(IPicture *iface)
   return S_OK;
 }
 
-/************************************************************************
- * OLEPictureImpl_SaveAsFile
- */
-static HRESULT WINAPI OLEPictureImpl_SaveAsFile(IPicture *iface,
-						IStream *pstream,
-						BOOL SaveMemCopy,
-						LONG *pcbSize)
-{
-  OLEPictureImpl *This = impl_from_IPicture(iface);
-  FIXME("(%p)->(%p, %d, %p), hacked stub.\n", This, pstream, SaveMemCopy, pcbSize);
-  return IStream_Write(pstream,This->data,This->datalen,(ULONG*)pcbSize);
-}
-
 /************************************************************************
  * OLEPictureImpl_get_Attributes
  */
@@ -1984,6 +1971,85 @@ static HRESULT WINAPI OLEPictureImpl_GetSizeMax(IPersistStream *iface, ULARGE_IN
     return hr;
 }
 
+/************************************************************************
+ * OLEPictureImpl_SaveAsFile
+ */
+static HRESULT WINAPI OLEPictureImpl_SaveAsFile(IPicture *iface,
+    IStream *stream, BOOL mem_copy, LONG *size)
+{
+    OLEPictureImpl *This = impl_from_IPicture(iface);
+    void *data;
+    unsigned data_size;
+    ULONG written;
+    HRESULT hr;
+
+    FIXME("(%p)->(%p,%d,%p): semi-stub\n", This, stream, mem_copy, size);
+
+    switch (This->desc.picType)
+    {
+    case PICTYPE_NONE:
+        return S_OK;
+
+    case PICTYPE_ICON:
+        if (!mem_copy) return E_FAIL;
+
+        if (This->bIsDirty || !This->data)
+        {
+            if (!serializeIcon(This->desc.icon.hicon, &data, &data_size))
+                return E_FAIL;
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = data;
+            This->datalen = data_size;
+        }
+        hr = IStream_Write(stream, This->data, This->datalen, &written);
+        if (hr == S_OK && size) *size = written;
+        return hr;
+
+    case PICTYPE_BITMAP:
+        if (!mem_copy) return E_FAIL;
+
+        if (This->bIsDirty || !This->data)
+        {
+            switch (This->keepOrigFormat ? This->loadtime_format : BITMAP_FORMAT_BMP)
+            {
+            case BITMAP_FORMAT_BMP:
+                if (!serializeBMP(This->desc.bmp.hbitmap, &data, &data_size))
+                    return E_FAIL;
+                break;
+            case BITMAP_FORMAT_JPEG:
+                FIXME("BITMAP_FORMAT_JPEG is not implemented\n");
+                return E_NOTIMPL;
+            case BITMAP_FORMAT_GIF:
+                FIXME("BITMAP_FORMAT_GIF is not implemented\n");
+                return E_NOTIMPL;
+            case BITMAP_FORMAT_PNG:
+                FIXME("BITMAP_FORMAT_PNG is not implemented\n");
+                return E_NOTIMPL;
+            default:
+                FIXME("PICTYPE_BITMAP/%#x is not implemented\n", This->loadtime_format);
+                return E_NOTIMPL;
+            }
+
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = data;
+            This->datalen = data_size;
+        }
+        hr = IStream_Write(stream, This->data, This->datalen, &written);
+        if (hr == S_OK && size) *size = written;
+        return hr;
+
+    case PICTYPE_METAFILE:
+        FIXME("PICTYPE_METAFILE is not implemented\n");
+        return E_NOTIMPL;
+    case PICTYPE_ENHMETAFILE:
+        FIXME("ENHMETAFILE is not implemented\n");
+        return E_NOTIMPL;
+    default:
+        FIXME("%#x is not implemented\n", This->desc.picType);
+        break;
+    }
+    return E_NOTIMPL;
+}
 
 /************************************************************************
  *    IDispatch
diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index 5393ed7142a..19755e2721c 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -1231,18 +1231,14 @@ static void test_load_save_bmp(void)
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#lx\n", hr);
-    todo_wine
     ok(size == 66, "expected 66, got %ld\n", size);
     mem = GlobalLock(hmem);
-    todo_wine
     ok(!memcmp(&mem[0], "BM", 2), "got wrong bmp header %04lx\n", mem[0]);
     GlobalUnlock(hmem);
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
-    todo_wine
     ok(hr == E_FAIL, "expected E_FAIL, got %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     offset.QuadPart = 0;
@@ -1320,15 +1316,12 @@ static void test_load_save_icon(void)
     todo_wine
     ok(size == 766, "expected 766, got %ld\n", size);
     mem = GlobalLock(hmem);
-    todo_wine
     ok(mem[0] == 0x00010000, "got wrong icon header %04lx\n", mem[0]);
     GlobalUnlock(hmem);
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
-    todo_wine
     ok(hr == E_FAIL, "expected E_FAIL, got %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     offset.QuadPart = 0;
@@ -1409,13 +1402,11 @@ static void test_load_save_empty_picture(void)
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     hr = IPicture_QueryInterface(pic, &IID_IPersistStream, (void **)&src_stream);

From 8632aaddd13b382689ea0ec9084ab51442271f96 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sun, 15 May 2016 19:08:44 +0200
Subject: [PATCH 090/244] oleaut32: Implement SaveAsFile for
 PICTYPE_ENHMETAFILE.

---
 dlls/oleaut32/olepicture.c       | 17 +++++++++++++++--
 dlls/oleaut32/tests/olepicture.c |  3 ---
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index 22836e77a92..4d3e7ef2445 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -2041,9 +2041,22 @@ static HRESULT WINAPI OLEPictureImpl_SaveAsFile(IPicture *iface,
     case PICTYPE_METAFILE:
         FIXME("PICTYPE_METAFILE is not implemented\n");
         return E_NOTIMPL;
+
     case PICTYPE_ENHMETAFILE:
-        FIXME("ENHMETAFILE is not implemented\n");
-        return E_NOTIMPL;
+        if (!mem_copy) return E_FAIL;
+
+        if (This->bIsDirty || !This->data)
+        {
+            if (!serializeEMF(This->desc.emf.hemf, &data, &data_size))
+                return E_FAIL;
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = data;
+            This->datalen = data_size;
+        }
+        hr = IStream_Write(stream, This->data, This->datalen, &written);
+        if (hr == S_OK && size) *size = written;
+        return hr;
+
     default:
         FIXME("%#x is not implemented\n", This->desc.picType);
         break;
diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index 19755e2721c..59056abe83a 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -1646,7 +1646,6 @@ static void test_load_save_emf(void)
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#x\n", hr);
-todo_wine
     ok(size == 128, "expected 128, got %d\n", size);
     emh = GlobalLock(hmem);
 if (size)
@@ -1658,9 +1657,7 @@ if (size)
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
-todo_wine
     ok(hr == E_FAIL, "expected E_FAIL, got %#x\n", hr);
-todo_wine
     ok(size == -1, "expected -1, got %d\n", size);
 
     offset.QuadPart = 0;

From 383c127249b16276aa3b025787bb174b5f1ab6e9 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Thu, 21 Apr 2016 14:40:58 +0800
Subject: [PATCH 091/244] oleaut32: OleLoadPicture should create a DIB section
 for a being loaded bitmap. (v3)

Application in the bug 39474 depends on this (GetObject/bmBits should not be
NULL, otherwise it crashes).
---
 dlls/oleaut32/olepicture.c       | 65 +++++++++++++-------------------
 dlls/oleaut32/tests/olepicture.c |  2 +-
 2 files changed, 27 insertions(+), 40 deletions(-)

diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index 4d3e7ef2445..0c882c0508b 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -983,23 +983,16 @@ static HRESULT OLEPictureImpl_LoadDIB(OLEPictureImpl *This, BYTE *xbuf, ULONG xr
 {
     BITMAPFILEHEADER	*bfh = (BITMAPFILEHEADER*)xbuf;
     BITMAPINFO		*bi = (BITMAPINFO*)(bfh+1);
-    HDC			hdcref;
+    void *bits;
+    BITMAP bmp;
 
-    /* Does not matter whether this is a coreheader or not, we only use
-     * components which are in both
-     */
-    hdcref = GetDC(0);
-    This->desc.bmp.hbitmap = CreateDIBitmap(
-	hdcref,
-	&(bi->bmiHeader),
-	CBM_INIT,
-	xbuf+bfh->bfOffBits,
-	bi,
-       DIB_RGB_COLORS
-    );
-    ReleaseDC(0, hdcref);
+    This->desc.bmp.hbitmap = CreateDIBSection(0, bi, DIB_RGB_COLORS, &bits, NULL, 0);
     if (This->desc.bmp.hbitmap == 0)
         return E_FAIL;
+
+    GetObjectA(This->desc.u.bmp.hbitmap, sizeof(bmp), &bmp);
+    memcpy(bits, xbuf + bfh->bfOffBits, bmp.bmHeight * bmp.bmWidthBytes);
+
     This->desc.picType = PICTYPE_BITMAP;
     OLEPictureImpl_SetBitmap(This);
     return S_OK;
@@ -1009,10 +1002,9 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
 {
     HRESULT hr;
     BITMAPINFOHEADER bih;
-    HDC hdcref;
     UINT width, height;
     UINT stride, buffersize;
-    LPBYTE bits=NULL;
+    BYTE *bits, *mask = NULL;
     WICRect rc;
     IWICBitmapSource *real_source;
     UINT x, y;
@@ -1040,34 +1032,28 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
     stride = 4 * width;
     buffersize = stride * height;
 
-    bits = malloc(buffersize);
-    if (!bits)
+    mask = malloc(buffersize);
+    if (!mask)
     {
         hr = E_OUTOFMEMORY;
         goto end;
     }
 
+    This->desc.bmp.hbitmap = CreateDIBSection(0, (BITMAPINFO*)&bih, DIB_RGB_COLORS, (void **)&bits, NULL, 0);
+    if (This->desc.bmp.hbitmap == 0)
+    {
+        hr = E_FAIL;
+        goto end;
+    }
+
     rc.X = 0;
     rc.Y = 0;
     rc.Width = width;
     rc.Height = height;
     hr = IWICBitmapSource_CopyPixels(real_source, &rc, stride, buffersize, bits);
     if (FAILED(hr))
-        goto end;
-
-    hdcref = GetDC(0);
-    This->desc.bmp.hbitmap = CreateDIBitmap(
-        hdcref,
-        &bih,
-        CBM_INIT,
-        bits,
-        (BITMAPINFO*)&bih,
-        DIB_RGB_COLORS);
-
-    if (This->desc.bmp.hbitmap == 0)
     {
-        hr = E_FAIL;
-        ReleaseDC(0, hdcref);
+        DeleteObject(This->desc.bmp.hbitmap);
         goto end;
     }
 
@@ -1081,23 +1067,25 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
             if((*pixel & 0x80000000) == 0)
             {
                 has_alpha = TRUE;
-                *pixel = black;
+                *(DWORD *)(mask + stride * y + 4 * x) = black;
             }
             else
-                *pixel = white;
+                *(DWORD *)(mask + stride * y + 4 * x) = white;
         }
     }
 
     if (has_alpha)
     {
-        HDC hdcBmp, hdcXor, hdcMask;
+        HDC hdcref, hdcBmp, hdcXor, hdcMask;
         HBITMAP hbmoldBmp, hbmoldXor, hbmoldMask;
 
+        hdcref = GetDC(0);
+
         This->hbmXor = CreateDIBitmap(
             hdcref,
             &bih,
             CBM_INIT,
-            bits,
+            mask,
             (BITMAPINFO*)&bih,
             DIB_RGB_COLORS
         );
@@ -1122,12 +1110,11 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
         DeleteDC(hdcBmp);
         DeleteDC(hdcXor);
         DeleteDC(hdcMask);
+        ReleaseDC(0, hdcref);
     }
 
-    ReleaseDC(0, hdcref);
-
 end:
-    free(bits);
+    free(mask);
     IWICBitmapSource_Release(real_source);
     return hr;
 }
diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index 59056abe83a..99c8267d078 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -239,7 +239,7 @@ test_pic_with_stream(LPSTREAM stream, unsigned int imgsize)
         {
             BITMAP bmp;
             GetObjectA(UlongToHandle(handle), sizeof(BITMAP), &bmp);
-            todo_wine ok(bmp.bmBits != 0, "not a dib\n");
+            ok(bmp.bmBits != 0, "not a dib\n");
         }
 
 	width = 0;

From 058bb3b5dbbf0d415b889474158562c863ce1ca7 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 5 Apr 2017 12:03:19 +0800
Subject: [PATCH 092/244] oleaut32: Make OleLoadPicture load DIBs using WIC
 decoder.

CreateDIBSection doesn't support RLE compressed bitmaps.

This patch fixes a regression with displaying images in a Wix based
installer.
---
 dlls/oleaut32/olepicture.c       | 21 +--------------------
 dlls/oleaut32/tests/olepicture.c | 12 +++++++++++-
 2 files changed, 12 insertions(+), 21 deletions(-)

diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index 0c882c0508b..94ff4d1eae5 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -979,25 +979,6 @@ static HRESULT WINAPI OLEPictureImpl_IsDirty(
   return E_NOTIMPL;
 }
 
-static HRESULT OLEPictureImpl_LoadDIB(OLEPictureImpl *This, BYTE *xbuf, ULONG xread)
-{
-    BITMAPFILEHEADER	*bfh = (BITMAPFILEHEADER*)xbuf;
-    BITMAPINFO		*bi = (BITMAPINFO*)(bfh+1);
-    void *bits;
-    BITMAP bmp;
-
-    This->desc.bmp.hbitmap = CreateDIBSection(0, bi, DIB_RGB_COLORS, &bits, NULL, 0);
-    if (This->desc.bmp.hbitmap == 0)
-        return E_FAIL;
-
-    GetObjectA(This->desc.u.bmp.hbitmap, sizeof(bmp), &bmp);
-    memcpy(bits, xbuf + bfh->bfOffBits, bmp.bmHeight * bmp.bmWidthBytes);
-
-    This->desc.picType = PICTYPE_BITMAP;
-    OLEPictureImpl_SetBitmap(This);
-    return S_OK;
-}
-
 static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSource *src)
 {
     HRESULT hr;
@@ -1479,7 +1460,7 @@ static HRESULT WINAPI OLEPictureImpl_Load(IPersistStream* iface, IStream *pStm)
     hr = OLEPictureImpl_LoadWICDecoder(This, &CLSID_WICJpegDecoder, xbuf, xread);
     break;
   case BITMAP_FORMAT_BMP: /* Bitmap */
-    hr = OLEPictureImpl_LoadDIB(This, xbuf, xread);
+    hr = OLEPictureImpl_LoadWICDecoder(This, &CLSID_WICBmpDecoder, xbuf, xread);
     break;
   case BITMAP_FORMAT_PNG: /* PNG */
     hr = OLEPictureImpl_LoadWICDecoder(This, &CLSID_WICPngDecoder, xbuf, xread);
diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index 99c8267d078..b01bb6a557f 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -97,7 +97,7 @@ static const unsigned char pngimage[285] = {
 0xe7,0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82
 };
 
-/* 1x1 pixel bmp */
+/* 1bpp BI_RGB 1x1 pixel bmp */
 static const unsigned char bmpimage[66] = {
 0x42,0x4d,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x28,0x00,
 0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,
@@ -106,6 +106,15 @@ static const unsigned char bmpimage[66] = {
 0x00,0x00
 };
 
+/* 8bpp BI_RLE8 1x1 pixel bmp */
+static const unsigned char bmpimage_rle8[] = {
+0x42,0x4d,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x28,0x00,
+0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x08,0x00,0x01,0x00,
+0x00,0x00,0x04,0x00,0x00,0x00,0x12,0x0b,0x00,0x00,0x12,0x0b,0x00,0x00,0x02,0x00,
+0x00,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0x00,0x01,
+0x00,0x00
+};
+
 /* 2x2 pixel gif */
 static const unsigned char gif4pixel[42] = {
 0x47,0x49,0x46,0x38,0x37,0x61,0x02,0x00,0x02,0x00,0xa1,0x00,0x00,0x00,0x00,0x00,
@@ -1702,6 +1711,7 @@ START_TEST(olepicture)
     test_pic(gifimage, sizeof(gifimage));
     test_pic(jpgimage, sizeof(jpgimage));
     test_pic(bmpimage, sizeof(bmpimage));
+    test_pic(bmpimage_rle8, sizeof(bmpimage_rle8));
     test_pic(gif4pixel, sizeof(gif4pixel));
     /* FIXME: No PNG support in Windows... */
     if (0) test_pic(pngimage, sizeof(pngimage));

From 7814b6a644b59040b4836d38c3aa66e7ecb4b09f Mon Sep 17 00:00:00 2001
From: Damjan Jovanovic <damjan.jov@gmail.com>
Date: Sat, 29 Feb 2020 09:21:55 +0200
Subject: [PATCH 093/244] oleaut32: preferentially load icons having the
 desired size in OleLoadPictureEx

Currently OleLoadPictureEx() ignores the caller-desired icon size
and always loads the 32x32 icon, which sometimes has to be
scaled down to 16x16, resulting in quality loss. Change this
to load the icon having the desired size, falling back to 32x32
only when the desired size is unavailable.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=20732

Signed-off-by: Damjan Jovanovic <damjan.jov@gmail.com>

Updated to default 32 when x/y are LP_DEFAULT.
---
 dlls/oleaut32/olepicture.c | 23 +++++++++++++++++++----
 1 file changed, 19 insertions(+), 4 deletions(-)

diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index 94ff4d1eae5..e4885afef95 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -149,6 +149,8 @@ typedef struct OLEPictureImpl {
     BOOL bIsDirty;                  /* Set to TRUE if picture has changed */
     unsigned int loadtime_magic;    /* If a length header was found, saves value */
     unsigned int loadtime_format;   /* for PICTYPE_BITMAP only, keeps track of image format (GIF/BMP/JPEG) */
+    DWORD desiredWidth;
+    DWORD desiredHeight;
 } OLEPictureImpl;
 
 static inline OLEPictureImpl *impl_from_IPicture(IPicture *iface)
@@ -1188,14 +1190,20 @@ static HRESULT OLEPictureImpl_LoadIcon(OLEPictureImpl *This, BYTE *xbuf, ULONG x
         return E_FAIL;
     }
     i=0;
-    /* If we have more than one icon, try to find the best.
-     * this currently means '32 pixel wide'.
-     */
     if (cifd->idCount!=1) {
+	/* First try exact match on the desired dimensions */
 	for (i=0;i<cifd->idCount;i++) {
-	    if (cifd->idEntries[i].bWidth == 32)
+	    if (cifd->idEntries[i].bWidth == This->desiredWidth &&
+		cifd->idEntries[i].bHeight == This->desiredHeight)
 		break;
 	}
+	/* Otherwise, try to find the best. This currently means '32 pixel wide'. */
+	if (i==cifd->idCount) {
+	    for (i=0;i<cifd->idCount;i++) {
+		if (cifd->idEntries[i].bWidth == 32)
+		    break;
+	    }
+	}
 	if (i==cifd->idCount) i=0;
     }
     if (xread < cifd->idEntries[i].dwDIBOffset + cifd->idEntries[i].dwDIBSize)
@@ -2453,14 +2461,21 @@ HRESULT WINAPI OleLoadPictureEx( LPSTREAM lpstream, LONG lSize, BOOL fRunmode,
 {
   LPPERSISTSTREAM ps;
   IPicture	*newpic;
+  OLEPictureImpl *pictureImpl;
   HRESULT hr;
 
   FIXME("%p, %ld, %d, %s, %lu, %lu, %#lx, %p, partially implemented.\n",
 	lpstream, lSize, fRunmode, debugstr_guid(riid), xsiz, ysiz, flags, ppvObj);
+  /* hack to prevent this patch from applying in the wrong place */
 
   hr = OleCreatePictureIndirect(NULL,riid,!fRunmode,(LPVOID*)&newpic);
   if (hr != S_OK)
     return hr;
+  if (xsiz == LP_DEFAULT && ysiz == LP_DEFAULT)
+      xsiz = ysiz = 32;
+  pictureImpl = impl_from_IPicture(newpic);
+  pictureImpl->desiredWidth = xsiz;
+  pictureImpl->desiredHeight = ysiz;
   hr = IPicture_QueryInterface(newpic,&IID_IPersistStream, (LPVOID*)&ps);
   if (hr != S_OK) {
       ERR("Could not get IPersistStream iface from Ole Picture?\n");

From d6c86b2e6e8e4c0d26c7adc72dfd2684e1ffc9e5 Mon Sep 17 00:00:00 2001
From: Jactry Zeng <wine@jactry.com>
Date: Sun, 10 Aug 2014 22:17:57 +0800
Subject: [PATCH 094/244] riched20: Stub for ITextPara interface and implement
 ITextRange::GetPara.

---
 dlls/riched20/richole.c       | 202 +++++++++++++++++++++++++
 dlls/riched20/tests/richole.c | 275 ++++++++++++++++++++++++++++++++++
 2 files changed, 477 insertions(+)

diff --git a/dlls/riched20/richole.c b/dlls/riched20/richole.c
index 51ae41d2fe7..85e7cea88b9 100644
--- a/dlls/riched20/richole.c
+++ b/dlls/riched20/richole.c
@@ -3562,6 +3562,16 @@ static ULONG WINAPI TextPara_Release(ITextPara *iface)
     return ref;
 }
 
+static struct text_services *para_get_reole(ITextParaImpl *This)
+{
+    if (This->range)
+    {
+        ITextRangeImpl *rng = impl_from_ITextRange(This->range);
+        return rng->child.reole;
+    }
+    return NULL;
+}
+
 static HRESULT WINAPI TextPara_GetTypeInfoCount(ITextPara *iface, UINT *pctinfo)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
@@ -3629,6 +3639,10 @@ static HRESULT WINAPI TextPara_GetDuplicate(ITextPara *iface, ITextPara **ret)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, ret);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3636,6 +3650,10 @@ static HRESULT WINAPI TextPara_SetDuplicate(ITextPara *iface, ITextPara *para)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, para);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3643,6 +3661,10 @@ static HRESULT WINAPI TextPara_CanChange(ITextPara *iface, LONG *ret)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, ret);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3650,6 +3672,10 @@ static HRESULT WINAPI TextPara_IsEqual(ITextPara *iface, ITextPara *para, LONG *
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p %p)\n", This, para, ret);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3657,6 +3683,10 @@ static HRESULT WINAPI TextPara_Reset(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3664,6 +3694,10 @@ static HRESULT WINAPI TextPara_GetStyle(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3671,6 +3705,10 @@ static HRESULT WINAPI TextPara_SetStyle(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3678,6 +3716,10 @@ static HRESULT WINAPI TextPara_GetAlignment(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3685,6 +3727,10 @@ static HRESULT WINAPI TextPara_SetAlignment(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3692,6 +3738,10 @@ static HRESULT WINAPI TextPara_GetHyphenation(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3699,6 +3749,10 @@ static HRESULT WINAPI TextPara_SetHyphenation(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3706,6 +3760,10 @@ static HRESULT WINAPI TextPara_GetFirstLineIndent(ITextPara *iface, FLOAT *value
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3713,6 +3771,10 @@ static HRESULT WINAPI TextPara_GetKeepTogether(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3720,6 +3782,10 @@ static HRESULT WINAPI TextPara_SetKeepTogether(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3727,6 +3793,10 @@ static HRESULT WINAPI TextPara_GetKeepWithNext(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3734,6 +3804,10 @@ static HRESULT WINAPI TextPara_SetKeepWithNext(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3741,6 +3815,10 @@ static HRESULT WINAPI TextPara_GetLeftIndent(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3748,6 +3826,10 @@ static HRESULT WINAPI TextPara_GetLineSpacing(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3755,6 +3837,10 @@ static HRESULT WINAPI TextPara_GetLineSpacingRule(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3762,6 +3848,10 @@ static HRESULT WINAPI TextPara_GetListAlignment(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3769,6 +3859,10 @@ static HRESULT WINAPI TextPara_SetListAlignment(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3776,6 +3870,10 @@ static HRESULT WINAPI TextPara_GetListLevelIndex(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3783,6 +3881,10 @@ static HRESULT WINAPI TextPara_SetListLevelIndex(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3790,6 +3892,10 @@ static HRESULT WINAPI TextPara_GetListStart(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3797,6 +3903,10 @@ static HRESULT WINAPI TextPara_SetListStart(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3804,6 +3914,10 @@ static HRESULT WINAPI TextPara_GetListTab(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3811,6 +3925,10 @@ static HRESULT WINAPI TextPara_SetListTab(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3818,6 +3936,10 @@ static HRESULT WINAPI TextPara_GetListType(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3825,6 +3947,10 @@ static HRESULT WINAPI TextPara_SetListType(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3832,6 +3958,10 @@ static HRESULT WINAPI TextPara_GetNoLineNumber(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3839,6 +3969,10 @@ static HRESULT WINAPI TextPara_SetNoLineNumber(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3846,6 +3980,10 @@ static HRESULT WINAPI TextPara_GetPageBreakBefore(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3853,6 +3991,10 @@ static HRESULT WINAPI TextPara_SetPageBreakBefore(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3860,6 +4002,10 @@ static HRESULT WINAPI TextPara_GetRightIndent(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3867,6 +4013,10 @@ static HRESULT WINAPI TextPara_SetRightIndent(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3874,6 +4024,10 @@ static HRESULT WINAPI TextPara_SetIndents(ITextPara *iface, FLOAT StartIndent, F
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f %.2f %.2f)\n", This, StartIndent, LeftIndent, RightIndent);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3881,6 +4035,10 @@ static HRESULT WINAPI TextPara_SetLineSpacing(ITextPara *iface, LONG LineSpacing
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld %.2f)\n", This, LineSpacingRule, LineSpacing);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3888,6 +4046,10 @@ static HRESULT WINAPI TextPara_GetSpaceAfter(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3895,6 +4057,10 @@ static HRESULT WINAPI TextPara_SetSpaceAfter(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3902,6 +4068,10 @@ static HRESULT WINAPI TextPara_GetSpaceBefore(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3909,6 +4079,10 @@ static HRESULT WINAPI TextPara_SetSpaceBefore(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3916,6 +4090,10 @@ static HRESULT WINAPI TextPara_GetWidowControl(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3923,6 +4101,10 @@ static HRESULT WINAPI TextPara_SetWidowControl(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3930,6 +4112,10 @@ static HRESULT WINAPI TextPara_GetTabCount(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3937,6 +4123,10 @@ static HRESULT WINAPI TextPara_AddTab(ITextPara *iface, FLOAT tbPos, LONG tbAlig
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f %ld %ld)\n", This, tbPos, tbAlign, tbLeader);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3944,6 +4134,10 @@ static HRESULT WINAPI TextPara_ClearAllTabs(ITextPara *iface)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)\n", This);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3951,6 +4145,10 @@ static HRESULT WINAPI TextPara_DeleteTab(ITextPara *iface, FLOAT pos)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, pos);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3958,6 +4156,10 @@ static HRESULT WINAPI TextPara_GetTab(ITextPara *iface, LONG iTab, FLOAT *ptbPos
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld %p %p %p)\n", This, iTab, ptbPos, ptbAlign, ptbLeader);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
diff --git a/dlls/riched20/tests/richole.c b/dlls/riched20/tests/richole.c
index fb5177b83e9..cde2a9ab4c3 100644
--- a/dlls/riched20/tests/richole.c
+++ b/dlls/riched20/tests/richole.c
@@ -5565,6 +5565,274 @@ static void test_freeze(void)
   release_interfaces(&hwnd, &reole, &doc, &selection);
 }
 
+static void test_ITextRange_SetStart(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  hres = ITextRange_SetStart(txtRge, first);
+  ok(hres == S_FALSE, "ITextRange_SetStart\n");
+
+#define TEST_TXTRGE_SETSTART(cp, expected_start, expected_end)  \
+  hres = ITextRange_SetStart(txtRge, cp);                       \
+  ok(hres == S_OK, "ITextRange_SetStart\n");                    \
+  ITextRange_GetStart(txtRge, &start);                          \
+  ITextRange_GetEnd(txtRge, &end);                              \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTRGE_SETSTART(2, 2, 8)
+  TEST_TXTRGE_SETSTART(-1, 0, 8)
+  TEST_TXTRGE_SETSTART(13, 12, 12)
+
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextRange_SetEnd(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  hres = ITextRange_SetEnd(txtRge, lim);
+  ok(hres == S_FALSE, "ITextRange_SetEnd\n");
+
+#define TEST_TXTRGE_SETEND(cp, expected_start, expected_end)    \
+  hres = ITextRange_SetEnd(txtRge, cp);                         \
+  ok(hres == S_OK, "ITextRange_SetEnd\n");                      \
+  ITextRange_GetStart(txtRge, &start);                          \
+  ITextRange_GetEnd(txtRge, &end);                              \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTRGE_SETEND(6, 4, 6)
+  TEST_TXTRGE_SETEND(14, 4, 13)
+  TEST_TXTRGE_SETEND(-1, 0, 0)
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextSelection_SetStart(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  hres = ITextSelection_SetStart(txtSel, first);
+  ok(hres == S_FALSE, "ITextSelection_SetStart\n");
+
+#define TEST_TXTSEL_SETSTART(cp, expected_start, expected_end)        \
+  hres = ITextSelection_SetStart(txtSel, cp);                         \
+  ok(hres == S_OK, "ITextSelection_SetStart\n");                      \
+  SendMessageA(w, EM_GETSEL, (LPARAM)&start, (WPARAM)&end);           \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTSEL_SETSTART(2, 2, 8)
+  TEST_TXTSEL_SETSTART(-1, 0, 8)
+  TEST_TXTSEL_SETSTART(13, 12, 12)
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
+static void test_ITextSelection_SetEnd(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  hres = ITextSelection_SetEnd(txtSel, lim);
+  ok(hres == S_FALSE, "ITextSelection_SetEnd\n");
+
+#define TEST_TXTSEL_SETEND(cp, expected_start, expected_end)          \
+  hres = ITextSelection_SetEnd(txtSel, cp);                           \
+  ok(hres == S_OK, "ITextSelection_SetEnd\n");                        \
+  SendMessageA(w, EM_GETSEL, (LPARAM)&start, (WPARAM)&end);           \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTSEL_SETEND(6, 4, 6)
+  TEST_TXTSEL_SETEND(14, 4, 13)
+  TEST_TXTSEL_SETEND(-1, 0, 0)
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
+static void test_ITextRange_GetFont(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  ITextFont *txtFont = NULL, *txtFont1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetFont(txtRge, &txtFont);
+  ok(hres == S_OK, "ITextRange_GetFont\n");
+  refcount = get_refcount((IUnknown *)txtFont);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetFont(txtRge, &txtFont1);
+  ok(hres == S_OK, "ITextRange_GetFont\n");
+  ok(txtFont1 != txtFont, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtFont1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextFont_Release(txtFont1);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  hres = ITextFont_GetOutline(txtFont, &value);
+  ok(hres == CO_E_RELEASED, "ITextFont after ITextDocument destroyed\n");
+
+  ITextFont_Release(txtFont);
+}
+
+static void test_ITextSelection_GetFont(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  ITextFont *txtFont = NULL, *txtFont1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextSelection_GetFont(txtSel, &txtFont);
+  ok(hres == S_OK, "ITextSelection_GetFont\n");
+  refcount = get_refcount((IUnknown *)txtFont);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 3, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextSelection_GetFont(txtSel, &txtFont1);
+  ok(hres == S_OK, "ITextSelection_GetFont\n");
+  ok(txtFont1 != txtFont, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtFont1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextFont_Release(txtFont1);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 3, "got wrong ref count: %d\n", refcount);
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+
+  hres = ITextFont_GetOutline(txtFont, &value);
+  ok(hres == CO_E_RELEASED, "ITextFont after ITextDocument destroyed\n");
+
+  ITextFont_Release(txtFont);
+}
+
+static void test_ITextRange_GetPara(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  ITextPara *txtPara = NULL, *txtPara1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetPara(txtRge, &txtPara);
+  ok(hres == S_OK, "ITextRange_GetPara\n");
+  refcount = get_refcount((IUnknown *)txtPara);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetPara(txtRge, &txtPara1);
+  ok(hres == S_OK, "ITextRange_GetPara\n");
+  ok(txtPara1 != txtPara, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtPara1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextPara_Release(txtPara1);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  hres = ITextPara_GetStyle(txtPara, &value);
+  ok(hres == CO_E_RELEASED, "ITextPara after ITextDocument destroyed\n");
+
+  ITextPara_Release(txtPara);
+}
+
 START_TEST(richole)
 {
   /* Must explicitly LoadLibrary(). The test has no references to functions in
@@ -5585,6 +5853,13 @@ START_TEST(richole)
   test_ITextRange_SetRange();
   test_ITextRange_GetDuplicate();
   test_ITextRange_Collapse();
+  test_ITextRange_GetFont();
+  test_ITextRange_SetEnd();
+  test_ITextSelection_GetFont();
+  test_ITextRange_SetStart();
+  test_ITextSelection_SetStart();
+  test_ITextSelection_SetEnd();
+  test_ITextRange_GetPara();
   test_GetClientSite();
   test_IOleWindow_GetWindow();
   test_IOleInPlaceSite_GetWindow();

From d912b2bd22371c19f60fe68437ceddb844a97554 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 16 Sep 2021 15:27:51 +1000
Subject: [PATCH 095/244] sapi: ISpObjectToken CreateInstance support ISpAudio

---
 dlls/sapi/token.c | 276 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 276 insertions(+)

diff --git a/dlls/sapi/token.c b/dlls/sapi/token.c
index 65d35dc96ff..13dca34bf6d 100644
--- a/dlls/sapi/token.c
+++ b/dlls/sapi/token.c
@@ -1653,6 +1653,276 @@ static HRESULT WINAPI token_GetCategory( ISpObjectToken *iface,
     return E_NOTIMPL;
 }
 
+struct speech_audio
+{
+    ISpAudio ISpAudio_iface;
+    LONG ref;
+};
+
+static inline struct speech_audio *impl_from_ISpAudio(ISpAudio *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_audio, ISpAudio_iface);
+}
+
+static HRESULT WINAPI spaudio_QueryInterface(ISpAudio *iface, REFIID iid, void **obj)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+
+    TRACE("(%p, %s %p).\n", audio, debugstr_guid(iid), obj);
+
+    if (IsEqualIID(iid, &IID_IUnknown) ||
+        IsEqualIID(iid, &IID_ISequentialStream) ||
+        IsEqualIID(iid, &IID_IStream) ||
+        IsEqualIID(iid, &IID_ISpStreamFormat) ||
+        IsEqualIID(iid, &IID_ISpAudio))
+        *obj = &audio->ISpAudio_iface;
+    else
+    {
+        *obj = NULL;
+        FIXME("interface %s not implemented.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*obj);
+    return S_OK;
+}
+
+static ULONG WINAPI spaudio_AddRef(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    ULONG ref = InterlockedIncrement(&audio->ref);
+
+    TRACE("(%p): ref=%lu.\n", audio, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI spaudio_Release(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    ULONG ref = InterlockedDecrement(&audio->ref);
+
+    TRACE("(%p): ref=%lu.\n", audio, ref);
+
+    if (!ref)
+    {
+        free(audio);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI spaudio_Read(ISpAudio *iface,void *pv, ULONG cb, ULONG *pcbRead)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+
+    FIXME("%p, %p, %ld %p\n", audio, pv, cb, pcbRead);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Write(ISpAudio *iface, const void *pv, ULONG cb, ULONG *pcbWritten)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+
+    FIXME("%p, %p, %ld %p\n", audio, pv, cb, pcbWritten);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Seek(ISpAudio *iface, LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %s, %ld, %p\n", audio, wine_dbgstr_longlong(dlibMove.QuadPart), dwOrigin, plibNewPosition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetSize(ISpAudio *iface, ULARGE_INTEGER libNewSize)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %s)\n", audio, wine_dbgstr_longlong(libNewSize.QuadPart));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_CopyTo(ISpAudio *iface, IStream *pstm, ULARGE_INTEGER cb,
+        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %p, %s, %p, %p)\n", audio, pstm, wine_dbgstr_longlong(cb.QuadPart), pcbRead, pcbWritten);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Commit(ISpAudio *iface, DWORD grfCommitFlags)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %#lx)\n", audio, grfCommitFlags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Revert(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p)\n", audio);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_LockRegion(ISpAudio *iface, ULARGE_INTEGER offset, ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %s, %s, %ld)\n", audio, wine_dbgstr_longlong(offset.QuadPart),
+        wine_dbgstr_longlong(cb.QuadPart), dwLockType);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_UnlockRegion(ISpAudio *iface,ULARGE_INTEGER offset, ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %s, %s, %ld)\n", audio, wine_dbgstr_longlong(offset.QuadPart),
+        wine_dbgstr_longlong(cb.QuadPart), dwLockType);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Stat(ISpAudio *iface, STATSTG *stg, DWORD flag)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p, %lx\n", audio, stg, flag);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Clone(ISpAudio *iface, IStream **ppstm)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, ppstm);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetFormat(ISpAudio *iface, GUID *format, WAVEFORMATEX **wave)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p, %p\n", audio, format, wave);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetState(ISpAudio *iface, SPAUDIOSTATE state, ULONGLONG reserved)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %d, %s\n", audio, state, wine_dbgstr_longlong(reserved));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetFormat(ISpAudio *iface, REFGUID guid, const WAVEFORMATEX *wave)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %s, %p\n", audio, debugstr_guid(guid), wave);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetStatus(ISpAudio *iface, SPAUDIOSTATUS *status)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, status);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetBufferInfo(ISpAudio *iface,const SPAUDIOBUFFERINFO *buffer)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, buffer);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetBufferInfo(ISpAudio *iface, SPAUDIOBUFFERINFO *buffer)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, buffer);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetDefaultFormat(ISpAudio *iface, GUID *guid, WAVEFORMATEX **wave)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p, %p\n", audio, guid, wave);
+    return E_NOTIMPL;
+}
+
+static HANDLE WINAPI spaudio_EventHandle(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p\n", audio);
+    return NULL;
+}
+
+static HRESULT WINAPI spaudio_GetVolumeLevel(ISpAudio *iface, ULONG *level)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, level);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetVolumeLevel(ISpAudio *iface, ULONG level)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %lu\n", audio, level);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetBufferNotifySize(ISpAudio *iface, ULONG *size)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetBufferNotifySize(ISpAudio *iface, ULONG size)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %lu\n", audio, size);
+    return E_NOTIMPL;
+}
+
+const struct ISpAudioVtbl spaudio_vtbl =
+{
+    spaudio_QueryInterface,
+    spaudio_AddRef,
+    spaudio_Release,
+    spaudio_Read,
+    spaudio_Write,
+    spaudio_Seek,
+    spaudio_SetSize,
+    spaudio_CopyTo,
+    spaudio_Commit,
+    spaudio_Revert,
+    spaudio_LockRegion,
+    spaudio_UnlockRegion,
+    spaudio_Stat,
+    spaudio_Clone,
+    spaudio_GetFormat,
+    spaudio_SetState,
+    spaudio_SetFormat,
+    spaudio_GetStatus,
+    spaudio_SetBufferInfo,
+    spaudio_GetBufferInfo,
+    spaudio_GetDefaultFormat,
+    spaudio_EventHandle,
+    spaudio_GetVolumeLevel,
+    spaudio_SetVolumeLevel,
+    spaudio_GetBufferNotifySize,
+    spaudio_SetBufferNotifySize
+};
+
+static HRESULT speech_audio_create(void **obj)
+{
+    struct speech_audio *This = malloc(sizeof(*This));
+
+    if (!This)
+        return E_OUTOFMEMORY;
+    This->ISpAudio_iface.lpVtbl = &spaudio_vtbl;
+    This->ref = 1;
+
+    *obj = &This->ISpAudio_iface;
+    return S_OK;
+}
+
 static HRESULT WINAPI token_CreateInstance( ISpObjectToken *iface,
                                             IUnknown *outer,
                                             DWORD class_context,
@@ -1667,6 +1937,12 @@ static HRESULT WINAPI token_CreateInstance( ISpObjectToken *iface,
 
     TRACE( "%p, %p, %#lx, %s, %p\n", iface, outer, class_context, debugstr_guid( riid ), object );
 
+    /* Ubtil the Enum class is implemented correctly. */
+    if (IsEqualIID(riid, &IID_ISpAudio))
+    {
+        return speech_audio_create(object);
+    }
+
     if (FAILED(hr = ISpObjectToken_GetStringValue( iface, L"CLSID", &clsid_str )))
         return hr;
 

From ba53e4211ae5aced1e1812bc0ca969cad4cdfa68 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 16:05:48 +0200
Subject: [PATCH 096/244] scrrun: Implement MoveFolder().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52128

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       |  7 +++----
 dlls/scrrun/tests/filesystem.c | 20 ++++++++++++++++++++
 2 files changed, 23 insertions(+), 4 deletions(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index e53355267db..ab02d4680cd 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3803,12 +3803,11 @@ static HRESULT WINAPI filesys_MoveFile(IFileSystem3 *iface, BSTR source, BSTR de
     return MoveFileW(source, destination) ? S_OK : create_error(GetLastError());
 }
 
-static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface,BSTR Source,
-                                            BSTR Destination)
+static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR destination)
 {
-    FIXME("%p %s %s\n", iface, debugstr_w(Source), debugstr_w(Destination));
+    TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
 
-    return E_NOTIMPL;
+    return MoveFileW(source, destination) ? S_OK : create_error(GetLastError());
 }
 
 static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index e53bd092ce9..7a5de4407a8 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2639,6 +2639,25 @@ static void test_MoveFile(void)
     SysFreeString(str);
 }
 
+static void test_MoveFolder(void)
+{
+    BSTR src, dst;
+    WCHAR buffW1[MAX_PATH],buffW2[MAX_PATH];
+    HRESULT hr;
+
+    get_temp_path(L"foo", buffW1);
+    get_temp_path(L"bar", buffW2);
+
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+}
+
 static void test_DoOpenPipeStream(void)
 {
     static const char testdata[] = "test";
@@ -2772,6 +2791,7 @@ START_TEST(filesystem)
     test_GetExtensionName();
     test_GetSpecialFolder();
     test_MoveFile();
+    test_MoveFolder();
     test_DoOpenPipeStream();
 
     IFileSystem3_Release(fs3);

From d7817cf59b1577674c73415377118e31906b5019 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 16:11:56 +0200
Subject: [PATCH 097/244] scrrun: Check for null and empty arguments in
 MoveFolder.

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       |  3 +++
 dlls/scrrun/tests/filesystem.c | 15 ++++++++++++++-
 2 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index ab02d4680cd..a56af2f0461 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3807,6 +3807,9 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
 {
     TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
 
+    if(!source || !source[0] || !destination || !destination[0])
+        return E_INVALIDARG;
+
     return MoveFileW(source, destination) ? S_OK : create_error(GetLastError());
 }
 
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 7a5de4407a8..3ddd782a6fe 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2641,7 +2641,7 @@ static void test_MoveFile(void)
 
 static void test_MoveFolder(void)
 {
-    BSTR src, dst;
+    BSTR src, dst, str, empty;
     WCHAR buffW1[MAX_PATH],buffW2[MAX_PATH];
     HRESULT hr;
 
@@ -2656,6 +2656,19 @@ static void test_MoveFolder(void)
     SysFreeString(src);
     SysFreeString(dst);
     ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    str = SysAllocString(L"null.dir");
+    empty = SysAllocString(L"");
+    hr = IFileSystem3_MoveFolder(fs3, str, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    hr = IFileSystem3_MoveFolder(fs3, NULL, str);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    hr = IFileSystem3_MoveFolder(fs3, str, empty);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    hr = IFileSystem3_MoveFolder(fs3, empty, str);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(str);
+    SysFreeString(empty);
 }
 
 static void test_DoOpenPipeStream(void)

From f140fa4debd41904d66a4709a535ab04f170f47b Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 16:15:47 +0200
Subject: [PATCH 098/244] scrrun: Test MoveFolder with already existing
 destination.

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/tests/filesystem.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 3ddd782a6fe..4305ac394e6 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2669,6 +2669,17 @@ static void test_MoveFolder(void)
     ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
     SysFreeString(str);
     SysFreeString(empty);
+
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst); /* dst already exists */
+    ok(hr == CTL_E_FILEALREADYEXISTS, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
 }
 
 static void test_DoOpenPipeStream(void)

From 7f8db893692e3d68c714aa6e37e2efc7451f499e Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 16:24:40 +0200
Subject: [PATCH 099/244] scrrun: Check for non-existant source in
 MoveFolder().

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       | 16 +++++++++++++++-
 dlls/scrrun/tests/filesystem.c |  7 +++++++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index a56af2f0461..5c4b13d48b8 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3803,6 +3803,20 @@ static HRESULT WINAPI filesys_MoveFile(IFileSystem3 *iface, BSTR source, BSTR de
     return MoveFileW(source, destination) ? S_OK : create_error(GetLastError());
 }
 
+static inline HRESULT create_movefolder_error(DWORD err)
+{
+    switch(err) {
+    case ERROR_FILE_NOT_FOUND:
+    case ERROR_PATH_NOT_FOUND: return CTL_E_PATHNOTFOUND;
+    case ERROR_ACCESS_DENIED: return CTL_E_PERMISSIONDENIED;
+    case ERROR_FILE_EXISTS: return CTL_E_FILEALREADYEXISTS;
+    case ERROR_ALREADY_EXISTS: return CTL_E_FILEALREADYEXISTS;
+    default:
+        FIXME("Unsupported error code: %ld\n", err);
+        return E_FAIL;
+    }
+}
+
 static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR destination)
 {
     TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
@@ -3810,7 +3824,7 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
     if(!source || !source[0] || !destination || !destination[0])
         return E_INVALIDARG;
 
-    return MoveFileW(source, destination) ? S_OK : create_error(GetLastError());
+    return MoveFileW(source, destination) ? S_OK : create_movefolder_error(GetLastError());
 }
 
 static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 4305ac394e6..9b352797073 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2680,6 +2680,13 @@ static void test_MoveFolder(void)
     SysFreeString(dst);
     ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
     ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst); /* src nonexistant */
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
 }
 
 static void test_DoOpenPipeStream(void)

From 75578d103da5956cba298c621613155d2dfb9cd7 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 16:29:55 +0200
Subject: [PATCH 100/244] scrrun: Check that source is directory in
 MoveFolder().

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       | 10 +++++++++-
 dlls/scrrun/tests/filesystem.c | 14 ++++++++++++++
 2 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index 5c4b13d48b8..72a15aae545 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3806,6 +3806,7 @@ static HRESULT WINAPI filesys_MoveFile(IFileSystem3 *iface, BSTR source, BSTR de
 static inline HRESULT create_movefolder_error(DWORD err)
 {
     switch(err) {
+    case ERROR_INVALID_NAME:
     case ERROR_FILE_NOT_FOUND:
     case ERROR_PATH_NOT_FOUND: return CTL_E_PATHNOTFOUND;
     case ERROR_ACCESS_DENIED: return CTL_E_PERMISSIONDENIED;
@@ -3819,12 +3820,19 @@ static inline HRESULT create_movefolder_error(DWORD err)
 
 static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR destination)
 {
+    int len;
+    WCHAR src_path[MAX_PATH];
+
     TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
 
     if(!source || !source[0] || !destination || !destination[0])
         return E_INVALIDARG;
 
-    return MoveFileW(source, destination) ? S_OK : create_movefolder_error(GetLastError());
+    len = SysStringLen(source);
+    lstrcpyW(src_path, source);
+    if (source[len-1] != '\\' && source[len-1] != '/') wcscat(src_path, L"\\");
+
+    return MoveFileW(src_path, destination) ? S_OK : create_movefolder_error(GetLastError());
 }
 
 static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 9b352797073..0236a02aa74 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2644,6 +2644,7 @@ static void test_MoveFolder(void)
     BSTR src, dst, str, empty;
     WCHAR buffW1[MAX_PATH],buffW2[MAX_PATH];
     HRESULT hr;
+    HANDLE file;
 
     get_temp_path(L"foo", buffW1);
     get_temp_path(L"bar", buffW2);
@@ -2687,6 +2688,19 @@ static void test_MoveFolder(void)
     ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
     SysFreeString(src);
     SysFreeString(dst);
+
+    file = CreateFileW(buffW1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst); /* src is regular file */
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    DeleteFileW(buffW1);
 }
 
 static void test_DoOpenPipeStream(void)

From 83886ff8b9bd4cd55d85a531d69b4bbba7cc9a78 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 17:21:10 +0200
Subject: [PATCH 101/244] scrrun: Move source dir into destination dir if
 destination ends with separator in MoveFolder().

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       | 22 +++++++++++++++-----
 dlls/scrrun/tests/filesystem.c | 38 +++++++++++++++++++++++++++++++++-
 2 files changed, 54 insertions(+), 6 deletions(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index 72a15aae545..2c364ec6e08 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3820,18 +3820,30 @@ static inline HRESULT create_movefolder_error(DWORD err)
 
 static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR destination)
 {
-    int len;
-    WCHAR src_path[MAX_PATH];
+    int src_len, dst_len;
+    WCHAR src_path[MAX_PATH], dst_path[MAX_PATH];
+    WCHAR *filename;
 
     TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
 
     if(!source || !source[0] || !destination || !destination[0])
         return E_INVALIDARG;
 
-    len = SysStringLen(source);
-    lstrcpyW(src_path, source);
-    if (source[len-1] != '\\' && source[len-1] != '/') wcscat(src_path, L"\\");
+    if (!GetFullPathNameW(source, MAX_PATH, src_path, &filename))
+        return E_FAIL;
 
+    src_len = SysStringLen(src_path);
+    if (src_path[src_len-1] != '\\' && src_path[src_len-1] != '/')
+        wcscat(src_path, L"\\");
+
+    dst_len = lstrlenW(destination);
+    if (destination[dst_len-1] == '\\' || destination[dst_len-1] == '/') {
+        lstrcpyW(dst_path, destination);
+        lstrcatW(dst_path, filename);
+        TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(dst_path));
+        return MoveFileW(src_path, dst_path) ? S_OK : create_movefolder_error(GetLastError());
+    }
+    TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(destination));
     return MoveFileW(src_path, destination) ? S_OK : create_movefolder_error(GetLastError());
 }
 
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 0236a02aa74..d237e21e9a6 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2642,7 +2642,7 @@ static void test_MoveFile(void)
 static void test_MoveFolder(void)
 {
     BSTR src, dst, str, empty;
-    WCHAR buffW1[MAX_PATH],buffW2[MAX_PATH];
+    WCHAR buffW1[MAX_PATH],buffW2[MAX_PATH],pathW[MAX_PATH];
     HRESULT hr;
     HANDLE file;
 
@@ -2701,6 +2701,42 @@ static void test_MoveFolder(void)
     SysFreeString(src);
     SysFreeString(dst);
     DeleteFileW(buffW1);
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    lstrcpyW(pathW,buffW2);
+    lstrcatW(pathW,L"\\");
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    lstrcatW(pathW,L"foo");
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    lstrcpyW(pathW,buffW2);
+    lstrcatW(pathW,L"/");
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    lstrcatW(pathW,L"foo");
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
 }
 
 static void test_DoOpenPipeStream(void)

From 9451fd3bdf3bc071135fcedb4c2195b2af81094c Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Wed, 29 Jun 2022 17:40:58 +0200
Subject: [PATCH 102/244] scrrun: Support wildcards in MoveFolder().

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       | 49 ++++++++++++++++++++++++++--------
 dlls/scrrun/tests/filesystem.c | 27 ++++++++++++++++++-
 2 files changed, 64 insertions(+), 12 deletions(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index 2c364ec6e08..749a06739c7 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3820,9 +3820,12 @@ static inline HRESULT create_movefolder_error(DWORD err)
 
 static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR destination)
 {
-    int src_len, dst_len;
+    int src_len, dst_len, name_len;
     WCHAR src_path[MAX_PATH], dst_path[MAX_PATH];
     WCHAR *filename;
+    WIN32_FIND_DATAW ffd;
+    HANDLE f;
+    BOOL wildcard = FALSE, separator = FALSE;
 
     TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
 
@@ -3832,19 +3835,43 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
     if (!GetFullPathNameW(source, MAX_PATH, src_path, &filename))
         return E_FAIL;
 
-    src_len = SysStringLen(src_path);
-    if (src_path[src_len-1] != '\\' && src_path[src_len-1] != '/')
-        wcscat(src_path, L"\\");
+    if (wcspbrk(filename,L"*?"))
+        wildcard = TRUE;
 
     dst_len = lstrlenW(destination);
-    if (destination[dst_len-1] == '\\' || destination[dst_len-1] == '/') {
-        lstrcpyW(dst_path, destination);
-        lstrcatW(dst_path, filename);
-        TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(dst_path));
-        return MoveFileW(src_path, dst_path) ? S_OK : create_movefolder_error(GetLastError());
+    if (destination[dst_len-1] == '\\' || destination[dst_len-1] == '/')
+        separator = TRUE;
+
+    if (!wildcard && !separator) {
+        src_len = SysStringLen(src_path);
+        if (src_path[src_len-1] != '\\' && src_path[src_len-1] != '/')
+            wcscat(src_path, L"\\");
+        TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(destination));
+        return MoveFileW(src_path, destination) ? S_OK : create_movefolder_error(GetLastError());
     }
-    TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(destination));
-    return MoveFileW(src_path, destination) ? S_OK : create_movefolder_error(GetLastError());
+
+    memcpy(dst_path, destination, dst_len*sizeof(WCHAR));
+    if (!separator)
+        dst_path[dst_len++] = '\\';
+    src_len = filename - src_path;
+    f = FindFirstFileW(source, &ffd);
+    if(f == INVALID_HANDLE_VALUE)
+        return create_error(GetLastError());
+
+    do {
+        name_len = lstrlenW(ffd.cFileName);
+        if(src_len+name_len+1 >= MAX_PATH || dst_len+name_len+1 >= MAX_PATH) {
+            FindClose(f);
+            return E_FAIL;
+        }
+        memcpy(filename, ffd.cFileName, (name_len+1)*sizeof(WCHAR));
+        memcpy(dst_path + dst_len, ffd.cFileName, (name_len+1)*sizeof(WCHAR));
+        TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(dst_path));
+        if (!MoveFileW(src_path, dst_path)) return create_error(GetLastError());
+    } while(FindNextFileW(f, &ffd));
+    FindClose(f);
+
+    return S_OK;
 }
 
 static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index d237e21e9a6..4f5f1b0a7b8 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2642,7 +2642,7 @@ static void test_MoveFile(void)
 static void test_MoveFolder(void)
 {
     BSTR src, dst, str, empty;
-    WCHAR buffW1[MAX_PATH],buffW2[MAX_PATH],pathW[MAX_PATH];
+    WCHAR buffW1[MAX_PATH], buffW2[MAX_PATH], pathW[MAX_PATH], srcW[MAX_PATH];
     HRESULT hr;
     HANDLE file;
 
@@ -2737,6 +2737,31 @@ static void test_MoveFolder(void)
     lstrcatW(pathW,L"foo");
     ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
     ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo1");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"foo2");
+    GetTempPathW(MAX_PATH, srcW);
+    lstrcatW(srcW,L"foo?");
+    GetTempPathW(MAX_PATH, pathW);
+    lstrcatW(pathW,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    ok(CreateDirectoryW(pathW, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(pathW));
+    src = SysAllocString(srcW);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    lstrcpyW(buffW1,pathW);
+    lstrcatW(buffW1,L"\\foo1");
+    lstrcpyW(buffW2,pathW);
+    lstrcatW(buffW2,L"\\foo2");
+    ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
 }
 
 static void test_DoOpenPipeStream(void)

From 8e3ec4414401ffd6cead4f8c39ee380e0db93575 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Mon, 18 Jul 2022 11:53:08 +0200
Subject: [PATCH 103/244] scrrun: Move directories only in MoveFolder().

Signed-off-by: Robert Wilhelm <robert.wilhelm@gmx.net>
---
 dlls/scrrun/filesystem.c       |  8 ++++++--
 dlls/scrrun/tests/filesystem.c | 10 +++++++++-
 2 files changed, 15 insertions(+), 3 deletions(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index 749a06739c7..79cd3439ea2 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3860,14 +3860,18 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
 
     do {
         name_len = lstrlenW(ffd.cFileName);
-        if(src_len+name_len+1 >= MAX_PATH || dst_len+name_len+1 >= MAX_PATH) {
+        if(src_len+name_len+2 >= MAX_PATH || dst_len+name_len+1 >= MAX_PATH) {
             FindClose(f);
             return E_FAIL;
         }
         memcpy(filename, ffd.cFileName, (name_len+1)*sizeof(WCHAR));
+        wcscat(filename, L"\\");
         memcpy(dst_path + dst_len, ffd.cFileName, (name_len+1)*sizeof(WCHAR));
         TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(dst_path));
-        if (!MoveFileW(src_path, dst_path)) return create_error(GetLastError());
+        if (!MoveFileW(src_path, dst_path)) {
+            if (GetLastError() == ERROR_INVALID_NAME) continue;
+            return create_movefolder_error(GetLastError());
+        }
     } while(FindNextFileW(f, &ffd));
     FindClose(f);
 
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 4f5f1b0a7b8..1d6e7da921b 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2642,7 +2642,7 @@ static void test_MoveFile(void)
 static void test_MoveFolder(void)
 {
     BSTR src, dst, str, empty;
-    WCHAR buffW1[MAX_PATH], buffW2[MAX_PATH], pathW[MAX_PATH], srcW[MAX_PATH];
+    WCHAR buffW1[MAX_PATH], buffW2[MAX_PATH], buffW3[MAX_PATH], pathW[MAX_PATH], srcW[MAX_PATH];
     HRESULT hr;
     HANDLE file;
 
@@ -2742,6 +2742,8 @@ static void test_MoveFolder(void)
     lstrcatW(buffW1,L"foo1");
     GetTempPathW(MAX_PATH, buffW2);
     lstrcatW(buffW2,L"foo2");
+    GetTempPathW(MAX_PATH, buffW3);
+    lstrcatW(buffW3,L"foo3");
     GetTempPathW(MAX_PATH, srcW);
     lstrcatW(srcW,L"foo?");
     GetTempPathW(MAX_PATH, pathW);
@@ -2749,6 +2751,11 @@ static void test_MoveFolder(void)
     ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
     ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
     ok(CreateDirectoryW(pathW, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(pathW));
+    /* create a file, should not be moved by MoveFolder() */
+    file = CreateFileW(buffW3, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
     src = SysAllocString(srcW);
     dst = SysAllocString(pathW);
     hr = IFileSystem3_MoveFolder(fs3, src, dst);
@@ -2762,6 +2769,7 @@ static void test_MoveFolder(void)
     ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
     ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
     ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(DeleteFileW(buffW3), "can't remove %s\n", wine_dbgstr_w(buffW3));
 }
 
 static void test_DoOpenPipeStream(void)

From 08e79bdda0ef85ea6ff8fbb71ad920445156fc65 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Tue, 2 Aug 2022 22:19:10 +0200
Subject: [PATCH 104/244] scrrun: return path not found error if source ends
 with path separator in MoveFolder().

---
 dlls/scrrun/filesystem.c       |  4 ++++
 dlls/scrrun/tests/filesystem.c | 17 +++++++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index 79cd3439ea2..dd1c18ed406 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3832,6 +3832,10 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
     if(!source || !source[0] || !destination || !destination[0])
         return E_INVALIDARG;
 
+    src_len = SysStringLen(source);
+    if (source[src_len-1] == '\\' || source[src_len-1] == '/')
+        return CTL_E_PATHNOTFOUND;
+
     if (!GetFullPathNameW(source, MAX_PATH, src_path, &filename))
         return E_FAIL;
 
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index 1d6e7da921b..a5bc7964f2a 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2720,6 +2720,23 @@ static void test_MoveFolder(void)
     ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
     ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
 
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    lstrcpyW(pathW,buffW1);
+    lstrcatW(pathW,L"\\");
+    src = SysAllocString(pathW);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
     GetTempPathW(MAX_PATH, buffW1);
     lstrcatW(buffW1,L"foo");
     GetTempPathW(MAX_PATH, buffW2);

From f9b1da79fc81104ad8ddd6d31e4bbfc22220ffb2 Mon Sep 17 00:00:00 2001
From: Robert Wilhelm <robert.wilhelm@gmx.net>
Date: Tue, 2 Aug 2022 22:31:17 +0200
Subject: [PATCH 105/244] scrrun: Return path not found error if no folders
 were moved in MoveFolder().

---
 dlls/scrrun/filesystem.c       |  5 +++--
 dlls/scrrun/tests/filesystem.c | 28 ++++++++++++++++++++++++++++
 2 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index dd1c18ed406..af4521898a7 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3825,7 +3825,7 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
     WCHAR *filename;
     WIN32_FIND_DATAW ffd;
     HANDLE f;
-    BOOL wildcard = FALSE, separator = FALSE;
+    BOOL wildcard = FALSE, separator = FALSE, success = FALSE;
 
     TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
 
@@ -3876,10 +3876,11 @@ static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR
             if (GetLastError() == ERROR_INVALID_NAME) continue;
             return create_movefolder_error(GetLastError());
         }
+        success = TRUE;
     } while(FindNextFileW(f, &ffd));
     FindClose(f);
 
-    return S_OK;
+    return success ? S_OK : CTL_E_PATHNOTFOUND;
 }
 
 static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index a5bc7964f2a..8cd465f1454 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2787,6 +2787,34 @@ static void test_MoveFolder(void)
     ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
     ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
     ok(DeleteFileW(buffW3), "can't remove %s\n", wine_dbgstr_w(buffW3));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo1");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"foo2");
+    GetTempPathW(MAX_PATH, srcW);
+    lstrcatW(srcW,L"foo*");
+    GetTempPathW(MAX_PATH, pathW);
+    lstrcatW(pathW,L"bar");
+    ok(CreateDirectoryW(pathW, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(pathW));
+    /* create two files, should not be moved by MoveFolder() */
+    file = CreateFileW(buffW1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+    file = CreateFileW(buffW2, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+    src = SysAllocString(srcW);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(DeleteFileW(buffW1), "can't remove %s\n", wine_dbgstr_w(buffW1));
+    ok(DeleteFileW(buffW2), "can't remove %s\n", wine_dbgstr_w(buffW2));
 }
 
 static void test_DoOpenPipeStream(void)

From de9992ebec10242e7d21e01c00928e0f91cd6ff5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 3 Mar 2016 04:52:35 +0100
Subject: [PATCH 106/244] setupapi: Rewrite DiskSpaceList logic using lists.

---
 dlls/setupapi/diskspace.c | 181 +++++++++++++++++++++-----------------
 1 file changed, 100 insertions(+), 81 deletions(-)

diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index 5b89fd5ca99..04bc2696236 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -1,6 +1,7 @@
 /*
  * SetupAPI DiskSpace functions
  *
+ * Copyright 2016 Michael Müller
  * Copyright 2004 CodeWeavers (Aric Stewart)
  *
  * This library is free software; you can redistribute it and/or
@@ -27,69 +28,50 @@
 #include "winnls.h"
 #include "winreg.h"
 #include "setupapi.h"
+#include "wine/list.h"
 #include "wine/debug.h"
+#include "setupapi_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(setupapi);
 
-typedef struct {
-    WCHAR   lpzName[20];
-    LONGLONG dwFreeSpace;
-    LONGLONG dwWantedSpace;
-} DRIVE_ENTRY, *LPDRIVE_ENTRY;
+struct file_entry
+{
+    struct list entry;
+    WCHAR *path;
+    UINT operation;
+    LONGLONG size;
+};
+
+struct space_list
+{
+    struct list files;
+    UINT flags;
+};
 
-typedef struct {
-    DWORD   dwDriveCount;
-    DRIVE_ENTRY Drives[26];
-} DISKSPACELIST, *LPDISKSPACELIST;
 
 
 /***********************************************************************
  *		SetupCreateDiskSpaceListW  (SETUPAPI.@)
  */
-HDSKSPC WINAPI SetupCreateDiskSpaceListW(PVOID Reserved1, DWORD Reserved2, UINT Flags)
+HDSKSPC WINAPI SetupCreateDiskSpaceListW(PVOID reserved1, DWORD reserved2, UINT flags)
 {
-    WCHAR drives[255];
-    DWORD rc;
-    WCHAR *ptr;
-    LPDISKSPACELIST list=NULL;
+    struct space_list *list;
 
-    TRACE("(%p, %lu, 0x%08x)\n", Reserved1, Reserved2, Flags);
+    TRACE("(%p, %lu, 0x%08x)\n", reserved1, reserved2, flags);
 
-    if (Reserved1 || Reserved2 || Flags & ~SPDSL_IGNORE_DISK)
+    if (reserved1 || reserved2 || flags & ~SPDSL_IGNORE_DISK)
     {
         SetLastError(ERROR_INVALID_PARAMETER);
         return NULL;
     }
 
-    rc = GetLogicalDriveStringsW(255,drives);
-
-    if (rc == 0)
-        return NULL;
-
-    list = malloc(sizeof(DISKSPACELIST));
-
-    list->dwDriveCount = 0;
-    
-    ptr = drives;
-    
-    while (*ptr)
+    list = malloc(sizeof(*list));
+    if (list)
     {
-        DWORD type = GetDriveTypeW(ptr);
-        if (type == DRIVE_FIXED)
-        {
-            DWORD clusters;
-            DWORD sectors;
-            DWORD bytes;
-            DWORD total;
-            lstrcpyW(list->Drives[list->dwDriveCount].lpzName,ptr);
-            GetDiskFreeSpaceW(ptr,&sectors,&bytes,&clusters,&total);
-            list->Drives[list->dwDriveCount].dwFreeSpace = clusters * sectors *
-                                                           bytes;
-            list->Drives[list->dwDriveCount].dwWantedSpace = 0;
-            list->dwDriveCount++;
-        }
-       ptr += lstrlenW(ptr) + 1;
+        list->flags = flags;
+        list_init(&list->files);
     }
+
     return list;
 }
 
@@ -105,32 +87,58 @@ HDSKSPC WINAPI SetupCreateDiskSpaceListA(PVOID Reserved1, DWORD Reserved2, UINT
 /***********************************************************************
  *		SetupDuplicateDiskSpaceListW  (SETUPAPI.@)
  */
-HDSKSPC WINAPI SetupDuplicateDiskSpaceListW(HDSKSPC DiskSpace, PVOID Reserved1, DWORD Reserved2, UINT Flags)
+HDSKSPC WINAPI SetupDuplicateDiskSpaceListW(HDSKSPC diskspace, PVOID reserved1, DWORD reserved2, UINT flags)
 {
-    DISKSPACELIST *list_copy, *list_original = DiskSpace;
+    struct space_list *list_copy, *list = diskspace;
+    struct file_entry *file, *file_copy;
+
+    TRACE("(%p, %p, %lu, %u)\n", diskspace, reserved1, reserved2, flags);
 
-    if (Reserved1 || Reserved2 || Flags)
+    if (reserved1 || reserved2 || flags)
     {
         SetLastError(ERROR_INVALID_PARAMETER);
         return NULL;
     }
 
-    if (!DiskSpace)
+    if (!diskspace)
     {
         SetLastError(ERROR_INVALID_HANDLE);
         return NULL;
     }
 
-    list_copy = malloc(sizeof(DISKSPACELIST));
+    list_copy = malloc(sizeof(*list_copy));
     if (!list_copy)
     {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         return NULL;
     }
 
-    *list_copy = *list_original;
+    list_copy->flags = list->flags;
+    list_init(&list_copy->files);
+
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        file_copy = malloc(sizeof(*file_copy));
+        if (!file_copy) goto error;
+
+        file_copy->path = wcsdup(file->path);
+        if (!file_copy->path)
+        {
+            free(file_copy);
+            goto error;
+        }
+
+        file_copy->operation = file->operation;
+        file_copy->size = file->size;
+        list_add_head(&list_copy->files, &file->entry);
+    }
 
     return list_copy;
+
+error:
+    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+    SetupDestroyDiskSpaceList(list_copy);
+    return NULL;
 }
 
 /***********************************************************************
@@ -155,55 +163,51 @@ BOOL WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC DiskSpace,
 /***********************************************************************
 *		SetupQuerySpaceRequiredOnDriveW  (SETUPAPI.@)
 */
-BOOL WINAPI SetupQuerySpaceRequiredOnDriveW(HDSKSPC DiskSpace,
-                        LPCWSTR DriveSpec, LONGLONG *SpaceRequired,
-                        PVOID Reserved1, UINT Reserved2)
+BOOL WINAPI SetupQuerySpaceRequiredOnDriveW(HDSKSPC diskspace,
+                        LPCWSTR drivespec, LONGLONG *required,
+                        PVOID reserved1, UINT reserved2)
 {
-    WCHAR *driveW;
-    unsigned int i;
-    LPDISKSPACELIST list = DiskSpace;
-    BOOL rc = FALSE;
-    static const WCHAR bkslsh[]= {'\\',0};
+    struct space_list *list = diskspace;
+    struct file_entry *file;
+    LONGLONG sum = 0;
 
-    if (!DiskSpace)
+    TRACE("(%p, %s, %p, %p, %u)\n", diskspace, debugstr_w(drivespec), required, reserved1, reserved2);
+
+    if (!diskspace)
     {
         SetLastError(ERROR_INVALID_HANDLE);
         return FALSE;
     }
 
-    if (!DriveSpec)
+    if (!drivespec || !drivespec[0])
     {
-        SetLastError(ERROR_INVALID_PARAMETER);
+        SetLastError(drivespec ? ERROR_INVALID_DRIVE : ERROR_INVALID_DRIVE);
         return FALSE;
     }
 
-    driveW = malloc((wcslen(DriveSpec) + 2) * sizeof(WCHAR));
-    if (!driveW)
+    if (!required)
     {
-        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }
 
-    lstrcpyW(driveW,DriveSpec);
-    lstrcatW(driveW,bkslsh);
-
-    TRACE("Looking for drive %s\n",debugstr_w(driveW));
- 
-    for (i = 0; i < list->dwDriveCount; i++)
+    if (towlower(drivespec[0]) < 'a' || towlower(drivespec[0]) > 'z' ||
+        drivespec[1] != ':' || drivespec[2] != 0)
     {
-        TRACE("checking drive %s\n",debugstr_w(list->Drives[i].lpzName));
-        if (wcscmp(driveW,list->Drives[i].lpzName)==0)
-        {
-            rc = TRUE;
-            *SpaceRequired = list->Drives[i].dwWantedSpace;
-            break;
-        }
+        FIXME("UNC paths not yet supported (%s)\n", debugstr_w(drivespec));
+        SetLastError((GetVersion() & 0x80000000) ? ERROR_INVALID_DRIVE : ERROR_INVALID_PARAMETER);
+        return FALSE;
     }
 
-    free(driveW);
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        if (towlower(file->path[0]) == towlower(drivespec[0]) &&
+            file->path[1] == ':' && file->path[2] == '\\')
+            sum += file->size;
+    }
 
-    if (!rc) SetLastError(ERROR_INVALID_DRIVE);
-    return rc;
+    *required = sum;
+    return TRUE;
 }
 
 /***********************************************************************
@@ -253,9 +257,24 @@ BOOL WINAPI SetupQuerySpaceRequiredOnDriveA(HDSKSPC DiskSpace,
 /***********************************************************************
 *		SetupDestroyDiskSpaceList  (SETUPAPI.@)
 */
-BOOL WINAPI SetupDestroyDiskSpaceList(HDSKSPC DiskSpace)
+BOOL WINAPI SetupDestroyDiskSpaceList(HDSKSPC diskspace)
 {
-    LPDISKSPACELIST list = DiskSpace;
+    struct space_list *list = diskspace;
+    struct file_entry *file, *file2;
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    LIST_FOR_EACH_ENTRY_SAFE(file, file2, &list->files, struct file_entry, entry)
+    {
+        free(file->path);
+        list_remove(&file->entry);
+        free(file);
+    }
+
     free(list);
     return TRUE;
 }

From 6888d34d18fbf1179c2a6921b62e72c30ec766c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 3 Mar 2016 05:02:21 +0100
Subject: [PATCH 107/244] setupapi: Implement SetupAddToDiskSpaceList.

---
 dlls/setupapi/diskspace.c       | 137 +++++++++++++++++++++++++--
 dlls/setupapi/tests/diskspace.c | 159 +++++++++++++++++++++++++++++++-
 2 files changed, 285 insertions(+), 11 deletions(-)

diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index 04bc2696236..e261f6ea4b7 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -48,7 +48,21 @@ struct space_list
     UINT flags;
 };
 
+static LONGLONG get_file_size(WCHAR *path)
+{
+    HANDLE file;
+    LARGE_INTEGER size;
+
+    file = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE) return 0;
 
+    if (!GetFileSizeEx(file, &size))
+        size.QuadPart = 0;
+
+    CloseHandle(file);
+    return size.QuadPart;
+}
 
 /***********************************************************************
  *		SetupCreateDiskSpaceListW  (SETUPAPI.@)
@@ -280,25 +294,128 @@ BOOL WINAPI SetupDestroyDiskSpaceList(HDSKSPC diskspace)
 }
 
 /***********************************************************************
-*		SetupAddToDiskSpaceListA  (SETUPAPI.@)
+*		SetupAddToDiskSpaceListW  (SETUPAPI.@)
 */
-BOOL WINAPI SetupAddToDiskSpaceListA(HDSKSPC diskspace, PCSTR targetfile,
+BOOL WINAPI SetupAddToDiskSpaceListW(HDSKSPC diskspace, PCWSTR targetfile,
                                     LONGLONG filesize, UINT operation,
                                     PVOID reserved1, UINT reserved2)
 {
-    FIXME(": stub\n");
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    struct space_list *list = diskspace;
+    struct file_entry *file;
+    WCHAR *fullpathW;
+    BOOL ret = FALSE;
+    DWORD size;
+
+    TRACE("(%p, %s, %s, %u, %p, %u)\n", diskspace, debugstr_w(targetfile),
+          wine_dbgstr_longlong(filesize), operation, reserved1, reserved2);
+
+    if (!targetfile)
+        return TRUE;
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    if (operation != FILEOP_COPY && operation != FILEOP_DELETE)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    size = GetFullPathNameW(targetfile, 0, NULL, NULL);
+    if (!size)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    size = (size+1) * sizeof(WCHAR);
+    fullpathW = HeapAlloc(GetProcessHeap(), 0, size);
+
+    if (!GetFullPathNameW(targetfile, size, fullpathW, NULL))
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        goto done;
+    }
+
+    if (fullpathW[1] != ':' && fullpathW[2] != '\\')
+    {
+        FIXME("UNC paths not yet supported\n");
+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+        goto done;
+    }
+
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        if (!lstrcmpiW(file->path, fullpathW))
+            break;
+    }
+
+    if (&file->entry == &list->files)
+    {
+        file = HeapAlloc(GetProcessHeap(), 0, sizeof(*file));
+        if (!file)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            goto done;
+        }
+
+        file->path = wcsdup(fullpathW);
+        if (!file->path)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            HeapFree(GetProcessHeap(), 0, file);
+            goto done;
+        }
+
+        list_add_tail(&list->files, &file->entry);
+    }
+
+    file->operation = operation;
+    if (operation == FILEOP_COPY)
+        file->size = filesize;
+    else
+        file->size = 0;
+
+    if (!(list->flags & SPDSL_IGNORE_DISK))
+        file->size -= get_file_size(fullpathW);
+
+    ret = TRUE;
+
+done:
+    HeapFree(GetProcessHeap(), 0, fullpathW);
+    return ret;
 }
 
 /***********************************************************************
-*		SetupAddToDiskSpaceListW  (SETUPAPI.@)
+*       SetupAddToDiskSpaceListA  (SETUPAPI.@)
 */
-BOOL WINAPI SetupAddToDiskSpaceListW(HDSKSPC diskspace, PCWSTR targetfile,
+BOOL WINAPI SetupAddToDiskSpaceListA(HDSKSPC diskspace, PCSTR targetfile,
                                     LONGLONG filesize, UINT operation,
                                     PVOID reserved1, UINT reserved2)
 {
-    FIXME(": stub\n");
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    LPWSTR targetfileW = NULL;
+    DWORD len;
+    BOOL ret;
+
+    if (targetfile)
+    {
+        len = MultiByteToWideChar(CP_ACP, 0, targetfile, -1, NULL, 0);
+
+        targetfileW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+        if (!targetfileW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, targetfile, -1, targetfileW, len);
+    }
+
+    ret = SetupAddToDiskSpaceListW(diskspace, targetfileW, filesize,
+                                   operation, reserved1, reserved2);
+    if (targetfileW) HeapFree(GetProcessHeap(), 0, targetfileW);
+    return ret;
 }
diff --git a/dlls/setupapi/tests/diskspace.c b/dlls/setupapi/tests/diskspace.c
index 577b1f84a2a..3cd83c8471f 100644
--- a/dlls/setupapi/tests/diskspace.c
+++ b/dlls/setupapi/tests/diskspace.c
@@ -19,6 +19,7 @@
  */
 
 #include <stdarg.h>
+#include <stdio.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -29,6 +30,16 @@
 
 #include "wine/test.h"
 
+static inline const char* debugstr_longlong(ULONGLONG ll)
+{
+    static char string[17];
+    if (sizeof(ll) > sizeof(unsigned long) && ll >> 32)
+        sprintf(string, "%lx%08lx", (unsigned long)(ll >> 32), (unsigned long)ll);
+    else
+        sprintf(string, "%lx", (unsigned long)ll);
+    return string;
+}
+
 static void test_SetupCreateDiskSpaceListA(void)
 {
     HDSKSPC ret;
@@ -293,11 +304,31 @@ static void test_SetupDuplicateDiskSpaceListW(void)
     ok(SetupDestroyDiskSpaceList(handle), "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
 
+static LONGLONG get_file_size(char *path)
+{
+    HANDLE file;
+    LARGE_INTEGER size;
+
+    file = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE) return 0;
+
+    if (!GetFileSizeEx(file, &size))
+        size.QuadPart = 0;
+
+    CloseHandle(file);
+    return size.QuadPart;
+}
+
 static void test_SetupQuerySpaceRequiredOnDriveA(void)
 {
     BOOL ret;
     HDSKSPC handle;
     LONGLONG space;
+    char windir[MAX_PATH];
+    char drive[3];
+    char tmp[MAX_PATH];
+    LONGLONG size;
 
     SetLastError(0xdeadbeef);
     ret = SetupQuerySpaceRequiredOnDriveA(NULL, NULL, NULL, NULL, 0);
@@ -357,7 +388,7 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
     ret = SetupQuerySpaceRequiredOnDriveA(handle, "", NULL, NULL, 0);
     ok(!ret, "Expected SetupQuerySpaceRequiredOnDriveA to return FALSE, got %d\n", ret);
     ok(GetLastError() == ERROR_INVALID_DRIVE,
-       "Expected GetLastError() to return ERROR_INVALID_PARAMETER, got %lu\n",
+       "Expected GetLastError() to return ERROR_INVALID_DRIVE, got %lu\n",
        GetLastError());
 
     SetLastError(0xdeadbeef);
@@ -369,6 +400,97 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
        "Expected GetLastError() to return ERROR_INVALID_PARAMETER, got %lu\n",
        GetLastError());
 
+    GetWindowsDirectoryA(windir, MAX_PATH);
+    drive[0] = windir[0]; drive[1] = windir[1]; drive[2] = 0;
+
+    snprintf(tmp, MAX_PATH, "%c:\\wine-test-should-not-exist.txt", drive[0]);
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x100000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x100000, "Expected 0x100000 as required space, got %s\n", debugstr_longlong(space));
+
+    /* adding the same file again doesn't sum up the size */
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x200000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x200000, "Expected 0x200000 as required space, got %s\n", debugstr_longlong(space));
+
+    /* the device doesn't need to exist */
+    snprintf(tmp, MAX_PATH, "F:\\wine-test-should-not-exist.txt");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x200000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, "F:", &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x200000, "Expected 0x100000 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    /* the real size is subtracted unless SPDSL_IGNORE_DISK is specified */
+    snprintf(tmp, MAX_PATH, "%s\\regedit.exe", windir);
+
+    size = get_file_size(tmp);
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0 || broken(space == -0x5000) || broken(space == -0x7000),
+       "Expected 0x0 as required space, got %s\n", debugstr_longlong(space));
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size + 0x100000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x100000 || broken(space == 0xf9000) || broken(space == 0xfb000),
+       "Expected 0x100000 as required space, got %s\n", debugstr_longlong(space));
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size - 0x1000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == -0x1000 || broken(space == -0x6000) || broken(space == -0x8000),
+       "Expected -0x1000 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space <= -size, "Expected space <= -size, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0, "Expected size = 0, got %s\n", debugstr_longlong(space));
+
     ok(SetupDestroyDiskSpaceList(handle),
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
@@ -460,6 +582,40 @@ static void test_SetupQuerySpaceRequiredOnDriveW(void)
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
 
+static void test_SetupAddToDiskSpaceListA(void)
+{
+    HDSKSPC handle;
+    BOOL ret;
+
+    ret = SetupAddToDiskSpaceListA(NULL, "C:\\some-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddToDiskSpaceListA to return FALSE, got %d\n", ret);
+    ok(GetLastError() == ERROR_INVALID_HANDLE,
+       "Expected GetLastError() to return ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, NULL, 0, FILEOP_COPY, 0, 0);
+    ok(ret || broken(!ret) /* >= Vista */, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "C:\\some-file.dat", -20, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "C:\\some-file.dat", 0, FILEOP_RENAME, 0, 0);
+    ok(!ret, "Expected SetupAddToDiskSpaceListA to return FALSE\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER,
+       "Expected GetLastError() to return ERROR_INVALID_PARAMETER, got %lu\n", GetLastError());
+
+    ret = SetupAddToDiskSpaceListA(handle, NULL, 0, FILEOP_RENAME, 0, 0);
+    ok(ret || broken(!ret) /* >= Vista */, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(NULL, NULL, 0, FILEOP_RENAME, 0, 0);
+    ok(ret || broken(!ret) /* >= Vista */, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+}
+
 START_TEST(diskspace)
 {
     test_SetupCreateDiskSpaceListA();
@@ -468,4 +624,5 @@ START_TEST(diskspace)
     test_SetupDuplicateDiskSpaceListW();
     test_SetupQuerySpaceRequiredOnDriveA();
     test_SetupQuerySpaceRequiredOnDriveW();
+    test_SetupAddToDiskSpaceListA();
 }

From c644249d59f0c3860b6dca748bcbced9f1293377 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 3 Mar 2016 05:03:11 +0100
Subject: [PATCH 108/244] setupapi: Implement SetupQueryDrivesInDiskSpaceList.

---
 dlls/setupapi/diskspace.c       | 85 +++++++++++++++++++++++++++++++++
 dlls/setupapi/stubs.c           | 18 -------
 dlls/setupapi/tests/diskspace.c | 70 +++++++++++++++++++++++++++
 3 files changed, 155 insertions(+), 18 deletions(-)

diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index e261f6ea4b7..1b49b9600c8 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -419,3 +419,88 @@ BOOL WINAPI SetupAddToDiskSpaceListA(HDSKSPC diskspace, PCSTR targetfile,
     if (targetfileW) HeapFree(GetProcessHeap(), 0, targetfileW);
     return ret;
 }
+
+/***********************************************************************
+ *      SetupQueryDrivesInDiskSpaceListW (SETUPAPI.@)
+ */
+BOOL WINAPI SetupQueryDrivesInDiskSpaceListW(HDSKSPC diskspace, PWSTR buffer, DWORD size, PDWORD required_size)
+{
+    struct space_list *list = diskspace;
+    struct file_entry *file;
+    DWORD cur_size = 1;
+    BOOL used[26];
+
+    TRACE("(%p, %p, %ld, %p)\n", diskspace, buffer, size, required_size);
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    memset(&used, 0, sizeof(used));
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        int device;
+
+        /* UNC paths are not yet supported by this function */
+        if (towlower(file->path[0]) < 'a' || towlower(file->path[0]) > 'z' || file->path[1] != ':')
+            continue;
+
+        device = towlower(file->path[0]) - 'a';
+        if (used[device]) continue;
+
+        cur_size += 3;
+
+        if (buffer)
+        {
+            if (cur_size > size)
+            {
+                if (required_size) *required_size = cur_size;
+                SetLastError(ERROR_INSUFFICIENT_BUFFER);
+                return FALSE;
+            }
+            *buffer++ = towlower(file->path[0]);
+            *buffer++ = ':';
+            *buffer++ = 0;
+        }
+
+        used[device] = TRUE;
+    }
+
+    if (buffer && size) *buffer = 0;
+    if (required_size)  *required_size = cur_size;
+    return TRUE;
+}
+
+/***********************************************************************
+ *      SetupQueryDrivesInDiskSpaceListA (SETUPAPI.@)
+ */
+BOOL WINAPI SetupQueryDrivesInDiskSpaceListA(HDSKSPC diskspace, PSTR buffer, DWORD size, PDWORD required_size)
+{
+    WCHAR *bufferW = NULL;
+    BOOL ret;
+    int i;
+
+    if (buffer && size)
+    {
+        bufferW = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+        if (!bufferW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+    }
+
+    ret = SetupQueryDrivesInDiskSpaceListW(diskspace, bufferW ? bufferW : (WCHAR *)buffer,
+                                           size, required_size);
+
+    if (bufferW)
+    {
+        for (i = 0; i < size; i++)
+            buffer[i] = bufferW[i];
+        HeapFree(GetProcessHeap(), 0, bufferW);
+    }
+
+    return ret;
+}
diff --git a/dlls/setupapi/stubs.c b/dlls/setupapi/stubs.c
index 44c81a1fd97..8aa8a754b4a 100644
--- a/dlls/setupapi/stubs.c
+++ b/dlls/setupapi/stubs.c
@@ -186,24 +186,6 @@ INT WINAPI SetupPromptReboot( HSPFILEQ file_queue, HWND owner, BOOL scan_only )
     return 0;
 }
 
-/***********************************************************************
- *      SetupQueryDrivesInDiskSpaceListA (SETUPAPI.@)
- */
-BOOL WINAPI SetupQueryDrivesInDiskSpaceListA(HDSKSPC disk_space, PSTR return_buffer, DWORD return_buffer_size, PDWORD required_size)
-{
-    FIXME("%p, %p, %ld, %p: stub\n", disk_space, return_buffer, return_buffer_size, required_size);
-    return FALSE;
-}
-
-/***********************************************************************
- *      SetupQueryDrivesInDiskSpaceListW (SETUPAPI.@)
- */
-BOOL WINAPI SetupQueryDrivesInDiskSpaceListW(HDSKSPC disk_space, PWSTR return_buffer, DWORD return_buffer_size, PDWORD required_size)
-{
-    FIXME("%p, %p, %ld, %p: stub\n", disk_space, return_buffer, return_buffer_size, required_size);
-    return FALSE;
-}
-
 /***********************************************************************
  *      SetupAddToSourceListA (SETUPAPI.@)
  */
diff --git a/dlls/setupapi/tests/diskspace.c b/dlls/setupapi/tests/diskspace.c
index 3cd83c8471f..930b957e913 100644
--- a/dlls/setupapi/tests/diskspace.c
+++ b/dlls/setupapi/tests/diskspace.c
@@ -616,6 +616,75 @@ static void test_SetupAddToDiskSpaceListA(void)
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
 
+static void test_SetupQueryDrivesInDiskSpaceListA(void)
+{
+    char buffer[MAX_PATH];
+    HDSKSPC handle;
+    DWORD size;
+    BOOL ret;
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(handle != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, NULL, 0, NULL);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, NULL, 0, &size);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(size == 1, "Expected size 1, got %lu\n", size);
+
+    ret = SetupAddToDiskSpaceListA(handle, "F:\\random-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "G:\\random-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "G:\\random-file2.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "X:\\random-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, NULL, 0, &size);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(size == 10, "Expected size 10, got %lu\n", size);
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, 0, &size);
+    ok(!ret, "Expected SetupQueryDrivesInDiskSpaceListA to fail\n");
+    ok(size == 4, "Expected size 4, got %lu\n", size);
+    ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER,
+       "Expected GetLastError() to return ERROR_INSUFFICIENT_BUFFER, got %lu\n", GetLastError());
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, 4, &size);
+    ok(!ret, "Expected SetupQueryDrivesInDiskSpaceListA to fail\n");
+    ok(size == 7, "Expected size 7, got %lu\n", size);
+    ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER,
+       "Expected GetLastError() to return ERROR_INSUFFICIENT_BUFFER, got %lu\n", GetLastError());
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, 7, &size);
+    ok(!ret, "Expected SetupQueryDrivesInDiskSpaceListA to fail\n");
+    ok(size == 10, "Expected size 10, got %lu\n", size);
+    ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER,
+       "Expected GetLastError() to return ERROR_INSUFFICIENT_BUFFER, got %lu\n", GetLastError());
+
+    size = 0;
+    memset(buffer, 0xff, sizeof(buffer));
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, sizeof(buffer), &size);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(size == 10, "Expected size 10, got %lu\n", size);
+    ok(!memcmp("f:\0g:\0x:\0\0", buffer, 10), "Device list does not match\n");
+
+    memset(buffer, 0xff, sizeof(buffer));
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, sizeof(buffer), NULL);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(!memcmp("f:\0g:\0x:\0\0", buffer, 10), "Device list does not match\n");
+}
+
 START_TEST(diskspace)
 {
     test_SetupCreateDiskSpaceListA();
@@ -625,4 +694,5 @@ START_TEST(diskspace)
     test_SetupQuerySpaceRequiredOnDriveA();
     test_SetupQuerySpaceRequiredOnDriveW();
     test_SetupAddToDiskSpaceListA();
+    test_SetupQueryDrivesInDiskSpaceListA();
 }

From b56f17a4c67bab0f2f0be934df4b0513e29e090b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 4 Mar 2016 04:21:18 +0100
Subject: [PATCH 109/244] setupapi: Ignore deletion of added files in
 SetupAddToDiskSpaceList.

---
 dlls/setupapi/diskspace.c       |  6 ++++
 dlls/setupapi/tests/diskspace.c | 60 ++++++++++++++++++++++++++++++++-
 2 files changed, 65 insertions(+), 1 deletion(-)

diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index 1b49b9600c8..ee9fdb801bb 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -372,6 +372,12 @@ BOOL WINAPI SetupAddToDiskSpaceListW(HDSKSPC diskspace, PCWSTR targetfile,
 
         list_add_tail(&list->files, &file->entry);
     }
+    else if (operation == FILEOP_DELETE)
+    {
+        /* delete operations for added files are ignored */
+        ret = TRUE;
+        goto done;
+    }
 
     file->operation = operation;
     if (operation == FILEOP_COPY)
diff --git a/dlls/setupapi/tests/diskspace.c b/dlls/setupapi/tests/diskspace.c
index 930b957e913..0cacf9a75aa 100644
--- a/dlls/setupapi/tests/diskspace.c
+++ b/dlls/setupapi/tests/diskspace.c
@@ -428,7 +428,15 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
 
     ret = SetupQuerySpaceRequiredOnDriveA(handle, "F:", &space, NULL, 0);
     ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
-    ok(space == 0x200000, "Expected 0x100000 as required space, got %s\n", debugstr_longlong(space));
+    ok(space == 0x200000, "Expected 0x200000 as required space, got %s\n", debugstr_longlong(space));
+
+    snprintf(tmp, MAX_PATH, "F:\\wine-test-should-not-exist.txt");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x200000, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, "F:", &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x200000, "Expected 0x200000 as required space, got %s\n", debugstr_longlong(space));
 
     ok(SetupDestroyDiskSpaceList(handle),
        "Expected SetupDestroyDiskSpaceList to succeed\n");
@@ -466,6 +474,45 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
     ok(SetupDestroyDiskSpaceList(handle),
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 
+    /* test FILEOP_DELETE, then FILEOP_COPY */
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0 || broken(space == -0x5000) || broken(space == -0x7000),
+       "Expected 0x0 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    /* test FILEOP_COPY, then FILEOP_DELETE */
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0 || broken(space == -0x5000) || broken(space == -0x7000),
+       "Expected 0x0 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    /* test FILEOP_DELETE without SPDSL_IGNORE_DISK */
     handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
     ok(handle != NULL,
        "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
@@ -480,6 +527,7 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
     ok(SetupDestroyDiskSpaceList(handle),
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 
+    /* test FILEOP_COPY and FILEOP_DELETE with SPDSL_IGNORE_DISK */
     handle = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
     ok(handle != NULL,
        "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
@@ -491,6 +539,16 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
     ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
     ok(space == 0, "Expected size = 0, got %s\n", debugstr_longlong(space));
 
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space >= size, "Expected size >= %s\n", debugstr_longlong(space));
+
     ok(SetupDestroyDiskSpaceList(handle),
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 }

From 38159dae542e648893ea4b53a190e1ee30786ddf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 4 Mar 2016 04:53:00 +0100
Subject: [PATCH 110/244] setupapi: ImplementSetupAddSectionToDiskSpaceList.

---
 dlls/setupapi/diskspace.c        | 131 ++++++++++++++++++++-
 dlls/setupapi/queue.c            |   2 +-
 dlls/setupapi/setupapi.spec      |   4 +-
 dlls/setupapi/setupapi_private.h |   2 +
 dlls/setupapi/tests/diskspace.c  | 193 +++++++++++++++++++++++++++++++
 5 files changed, 328 insertions(+), 4 deletions(-)

diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index ee9fdb801bb..3d1e96f43c3 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -20,6 +20,7 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -64,6 +65,23 @@ static LONGLONG get_file_size(WCHAR *path)
     return size.QuadPart;
 }
 
+static BOOL get_size_from_inf(HINF layoutinf, WCHAR *filename, LONGLONG *size)
+{
+    static const WCHAR SourceDisksFiles[]  = {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s',0};
+    INFCONTEXT context;
+    WCHAR buffer[20];
+
+    if (!SetupFindFirstLineW(layoutinf, SourceDisksFiles, filename, &context))
+        return FALSE;
+
+    if (!SetupGetStringFieldW(&context, 3, buffer, sizeof(buffer), NULL))
+        return FALSE;
+
+    /* FIXME: is there a atollW ? */
+    *size = wcstol(buffer, NULL, 10);
+    return TRUE;
+}
+
 /***********************************************************************
  *		SetupCreateDiskSpaceListW  (SETUPAPI.@)
  */
@@ -164,7 +182,118 @@ HDSKSPC WINAPI SetupDuplicateDiskSpaceListA(HDSKSPC DiskSpace, PVOID Reserved1,
 }
 
 /***********************************************************************
- *		SetupAddInstallSectionToDiskSpaceListA  (SETUPAPI.@)
+ *      SetupAddSectionToDiskSpaceListW  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupAddSectionToDiskSpaceListW(HDSKSPC diskspace, HINF hinf, HINF hlist,
+                                            PCWSTR section, UINT operation, PVOID reserved1,
+                                            UINT reserved2)
+{
+    static const WCHAR sepW[] = {'\\',0};
+    WCHAR dest[MAX_PATH], src[MAX_PATH], *dest_dir, *full_path;
+    INFCONTEXT context;
+    BOOL ret = FALSE;
+
+    TRACE("(%p, %p, %p, %s, %u, %p, %u)\n", diskspace, hinf, hlist, debugstr_w(section),
+                                            operation, reserved1, reserved2);
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    if (!section)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    if (!hlist) hlist = hinf;
+
+    if (!SetupFindFirstLineW(hlist, section, NULL, &context))
+    {
+        SetLastError(ERROR_SECTION_NOT_FOUND);
+        return FALSE;
+    }
+
+    dest_dir = get_destination_dir(hinf, section);
+    if (!dest_dir)
+    {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return FALSE;
+    }
+
+    do
+    {
+        LONGLONG filesize;
+        int path_size;
+        BOOL tmp_ret;
+
+        if (!SetupGetStringFieldW(&context, 1, dest, sizeof(dest) / sizeof(WCHAR), NULL))
+            goto end;
+        if (!SetupGetStringFieldW(&context, 2, src, sizeof(src) / sizeof(WCHAR), NULL))
+            *src = 0;
+        if (!get_size_from_inf(hinf, src[0] ? src : dest, &filesize))
+            goto end;
+
+        path_size = lstrlenW(dest_dir) + lstrlenW(dest) + 2;
+        full_path = HeapAlloc(GetProcessHeap(), 0, path_size * sizeof(WCHAR));
+        if (!full_path)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            goto end;
+        }
+
+        lstrcpyW(full_path, dest_dir);
+        lstrcatW(full_path, sepW);
+        lstrcatW(full_path, dest);
+
+        tmp_ret = SetupAddToDiskSpaceListW(diskspace, full_path, filesize, operation, 0, 0);
+        HeapFree(GetProcessHeap(), 0, full_path);
+        if (!tmp_ret) goto end;
+    }
+    while (SetupFindNextLine(&context, &context));
+
+    ret = TRUE;
+
+end:
+    HeapFree(GetProcessHeap(), 0, dest_dir);
+    return ret;
+}
+
+/***********************************************************************
+ *      SetupAddInstallSectionToDiskSpaceListA  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupAddSectionToDiskSpaceListA(HDSKSPC diskspace, HINF hinf, HINF hlist,
+                                            PCSTR section, UINT operation, PVOID reserved1,
+                                            UINT reserved2)
+{
+    LPWSTR sectionW = NULL;
+    DWORD len;
+    BOOL ret;
+
+    if (section)
+    {
+        len = MultiByteToWideChar(CP_ACP, 0, section, -1, NULL, 0);
+
+        sectionW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+        if (!sectionW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, section, -1, sectionW, len);
+    }
+
+    ret = SetupAddSectionToDiskSpaceListW(diskspace, hinf, hlist, sectionW, operation,
+                                          reserved1, reserved2);
+    if (sectionW) HeapFree(GetProcessHeap(), 0, sectionW);
+    return ret;
+}
+
+/***********************************************************************
+ *      SetupAddInstallSectionToDiskSpaceListW  (SETUPAPI.@)
  */
 BOOL WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC DiskSpace, 
                         HINF InfHandle, HINF LayoutInfHandle, 
diff --git a/dlls/setupapi/queue.c b/dlls/setupapi/queue.c
index 1c43808bc5f..ad556ff119a 100644
--- a/dlls/setupapi/queue.c
+++ b/dlls/setupapi/queue.c
@@ -324,7 +324,7 @@ static void get_source_info( HINF hinf, const WCHAR *src_file, SP_FILE_COPY_PARA
  *
  * Retrieve the destination dir for a given section.
  */
-static WCHAR *get_destination_dir( HINF hinf, const WCHAR *section )
+WCHAR *get_destination_dir( HINF hinf, const WCHAR *section )
 {
     INFCONTEXT context;
     WCHAR systemdir[MAX_PATH], *dir;
diff --git a/dlls/setupapi/setupapi.spec b/dlls/setupapi/setupapi.spec
index 1c93a1f3b9b..8335e705534 100644
--- a/dlls/setupapi/setupapi.spec
+++ b/dlls/setupapi/setupapi.spec
@@ -254,8 +254,8 @@
 @ stub SetArrayToMultiSzValue
 @ stdcall SetupAddInstallSectionToDiskSpaceListA(long long long str ptr long)
 @ stub SetupAddInstallSectionToDiskSpaceListW
-@ stub SetupAddSectionToDiskSpaceListA
-@ stub SetupAddSectionToDiskSpaceListW
+@ stdcall SetupAddSectionToDiskSpaceListA(long long long str long ptr long)
+@ stdcall SetupAddSectionToDiskSpaceListW(long long long wstr long ptr long)
 @ stdcall SetupAddToDiskSpaceListA(long str int64 long ptr long)
 @ stdcall SetupAddToDiskSpaceListW(long wstr int64 long ptr long)
 @ stdcall SetupAddToSourceListA(long str)
diff --git a/dlls/setupapi/setupapi_private.h b/dlls/setupapi/setupapi_private.h
index 9d3d19c84c0..c93cfd6af49 100644
--- a/dlls/setupapi/setupapi_private.h
+++ b/dlls/setupapi/setupapi_private.h
@@ -86,6 +86,8 @@ extern const WCHAR *DIRID_get_string( int dirid );
 extern const WCHAR *PARSER_get_inf_filename( HINF hinf );
 extern WCHAR *PARSER_get_dest_dir( INFCONTEXT *context );
 
+extern WCHAR *get_destination_dir( HINF hinf, const WCHAR *section );
+
 /* support for ANSI queue callback functions */
 
 struct callback_WtoA_context
diff --git a/dlls/setupapi/tests/diskspace.c b/dlls/setupapi/tests/diskspace.c
index 0cacf9a75aa..8e2eb88bf93 100644
--- a/dlls/setupapi/tests/diskspace.c
+++ b/dlls/setupapi/tests/diskspace.c
@@ -30,6 +30,8 @@
 
 #include "wine/test.h"
 
+#define STD_HEADER "[Version]\r\nSignature=\"$CHICAGO$\"\r\n"
+
 static inline const char* debugstr_longlong(ULONGLONG ll)
 {
     static char string[17];
@@ -40,6 +42,18 @@ static inline const char* debugstr_longlong(ULONGLONG ll)
     return string;
 }
 
+/* create a new file with specified contents and open it */
+static HINF inf_open_file_content(const char * tmpfilename, const char *data, UINT *err_line)
+{
+    DWORD res;
+    HANDLE handle = CreateFileA(tmpfilename, GENERIC_READ|GENERIC_WRITE,
+                                FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, 0);
+    if (handle == INVALID_HANDLE_VALUE) return 0;
+    if (!WriteFile( handle, data, strlen(data), &res, NULL )) trace( "write error\n" );
+    CloseHandle( handle );
+    return SetupOpenInfFileA( tmpfilename, 0, INF_STYLE_WIN4, err_line );
+}
+
 static void test_SetupCreateDiskSpaceListA(void)
 {
     HDSKSPC ret;
@@ -741,6 +755,184 @@ static void test_SetupQueryDrivesInDiskSpaceListA(void)
     ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, sizeof(buffer), NULL);
     ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
     ok(!memcmp("f:\0g:\0x:\0\0", buffer, 10), "Device list does not match\n");
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+}
+
+struct device_usage
+{
+    const char *dev;
+    LONGLONG usage;
+};
+
+struct section
+{
+    const char *name;
+    UINT fileop;
+    BOOL result;
+    DWORD error_code;
+};
+
+static const struct
+{
+    const char *data;
+    struct section sections[2];
+    const char *devices;
+    int device_length;
+    struct device_usage usage[2];
+}
+section_test[] =
+{
+    /* 0 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 1 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_DELETE, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 0}, {NULL, 0}}},
+    /* 2 */
+    {STD_HEADER "[a]\ntest,,,\n\r\n",
+     {{"a", FILEOP_COPY, FALSE, ERROR_LINE_NOT_FOUND}, {NULL, 0, TRUE, 0}},
+     "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 3 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\n[DestinationDirs]\nDefaultDestDir=-1,F:\\test\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "f:\00", sizeof("f:\00"), {{"f:", 4096}, {NULL, 0}}},
+    /* 4 */
+    {STD_HEADER "[a]\ntest,test2,,\n[SourceDisksFiles]\ntest2=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 5 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"b", FILEOP_COPY, FALSE, ERROR_SECTION_NOT_FOUND}, {NULL, 0, TRUE, 0}},
+     "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 6 */
+    {STD_HEADER "[a]\ntest,,,\n[b]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 7 */
+    {STD_HEADER "[a]\ntest,,,\n[b]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\n[DestinationDirs]\nb=-1,F:\\test\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00f:\00", sizeof("c:\00f:\00"), {{"c:", 4096}, {"f:", 4096}}},
+    /* 8 */
+    {STD_HEADER "[a]\ntest,test1,,\n[b]\ntest,test2,,\n[SourceDisksFiles]\ntest1=1,,4096\ntest2=1,,8192\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+    /* 9 */
+    {STD_HEADER "[a]\ntest1,test,,\n[b]\ntest2,test,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+};
+
+static void test_SetupAddSectionToDiskSpaceListA(void)
+{
+    char tmp[MAX_PATH];
+    char tmpfilename[MAX_PATH];
+    char buffer[MAX_PATH];
+    HDSKSPC diskspace;
+    UINT err_line;
+    LONGLONG space;
+    BOOL ret;
+    int i, j;
+    HINF inf;
+
+    if (!GetTempPathA(MAX_PATH, tmp))
+    {
+        win_skip("GetTempPath failed with error %lu\n", GetLastError());
+        return;
+    }
+
+    if (!GetTempFileNameA(tmp, "inftest", 0, tmpfilename))
+    {
+        win_skip("GetTempFileNameA failed with error %lu\n", GetLastError());
+        return;
+    }
+
+    inf = inf_open_file_content(tmpfilename, STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n", &err_line);
+    ok(!!inf, "Failed to open inf file (%lu, line %d)\n", GetLastError(), err_line);
+
+    diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(diskspace != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupAddSectionToDiskSpaceListA(diskspace, NULL, NULL, "a", FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_SECTION_NOT_FOUND, "Expected ERROR_SECTION_NOT_FOUND as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddSectionToDiskSpaceListA(NULL, inf, NULL, "a", FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "Expected ERROR_INVALID_HANDLE as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddSectionToDiskSpaceListA(NULL, inf, NULL, "b", FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "Expected ERROR_INVALID_HANDLE as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddSectionToDiskSpaceListA(diskspace, inf, NULL, "a", 0, 0, 0);
+    ok(ret, "Expected SetupAddSectionToDiskSpaceListA to succeed (%lu)\n", GetLastError());
+
+    ok(SetupDestroyDiskSpaceList(diskspace),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    for (i = 0; i < sizeof(section_test) / sizeof(section_test[0]); i++)
+    {
+        err_line = 0;
+
+        inf = inf_open_file_content(tmpfilename, section_test[i].data, &err_line);
+        ok(!!inf, "test %d: Failed to open inf file (%lu, line %d)\n", i, GetLastError(), err_line);
+        if (!inf) continue;
+
+        diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+        ok(diskspace != NULL, "Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct section *section = &section_test[i].sections[j];
+            if (!section->name)
+                continue;
+
+            SetLastError(0xdeadbeef);
+            ret = SetupAddSectionToDiskSpaceListA(diskspace, inf, NULL, section->name, section->fileop, 0, 0);
+            if (section->result)
+                ok(ret, "test %d: Expected adding section %d to succeed (%lu)\n", i, j, GetLastError());
+            else
+            {
+                ok(!ret, "test %d: Expected adding section %d to fail\n", i, j);
+                ok(GetLastError() == section->error_code, "test %d: Expected %lu as error, got %lu\n",
+                   i, section->error_code, GetLastError());
+            }
+        }
+
+        memset(buffer, 0x0, sizeof(buffer));
+        ret = SetupQueryDrivesInDiskSpaceListA(diskspace, buffer, sizeof(buffer), NULL);
+        ok(ret, "test %d: Expected SetupQueryDrivesInDiskSpaceListA to succeed (%lu)\n", i, GetLastError());
+        ok(!memcmp(section_test[i].devices, buffer, section_test[i].device_length),
+           "test %d: Device list (%s) does not match\n", i, buffer);
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct device_usage *usage = &section_test[i].usage[j];
+            if (!usage->dev)
+                continue;
+
+            space = 0;
+            ret = SetupQuerySpaceRequiredOnDriveA(diskspace, usage->dev, &space, NULL, 0);
+            ok(ret, "test %d: Expected SetupQuerySpaceRequiredOnDriveA to succeed for device %s (%lu)\n",
+               i, usage->dev, GetLastError());
+            ok(space == usage->usage, "test %d: Expected size %lu for device %s, got %lu\n",
+               i, (DWORD)usage->usage, usage->dev, (DWORD)space);
+        }
+
+        ok(SetupDestroyDiskSpaceList(diskspace),
+           "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+        SetupCloseInfFile(inf);
+    }
+
+    DeleteFileA(tmpfilename);
 }
 
 START_TEST(diskspace)
@@ -753,4 +945,5 @@ START_TEST(diskspace)
     test_SetupQuerySpaceRequiredOnDriveW();
     test_SetupAddToDiskSpaceListA();
     test_SetupQueryDrivesInDiskSpaceListA();
+    test_SetupAddSectionToDiskSpaceListA();
 }

From 0b505a4858952f959860785b2a2e928accac2359 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 4 Mar 2016 04:54:37 +0100
Subject: [PATCH 111/244] setupapi: Implement
 SetupAddInstallSectionToDiskSpaceList.

---
 dlls/setupapi/diskspace.c       |  87 +++++++++++++++-
 dlls/setupapi/setupapi.spec     |   2 +-
 dlls/setupapi/tests/diskspace.c | 170 ++++++++++++++++++++++++++++++++
 include/setupapi.h              |  12 +++
 4 files changed, 266 insertions(+), 5 deletions(-)

diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index 3d1e96f43c3..39663aac07a 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -295,14 +295,93 @@ BOOL WINAPI SetupAddSectionToDiskSpaceListA(HDSKSPC diskspace, HINF hinf, HINF h
 /***********************************************************************
  *      SetupAddInstallSectionToDiskSpaceListW  (SETUPAPI.@)
  */
-BOOL WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC DiskSpace, 
-                        HINF InfHandle, HINF LayoutInfHandle, 
-                        LPCSTR SectionName, PVOID Reserved1, UINT Reserved2)
+BOOL WINAPI SetupAddInstallSectionToDiskSpaceListW(HDSKSPC diskspace,
+                        HINF inf, HINF layoutinf, LPCWSTR section,
+                        PVOID reserved1, UINT reserved2)
 {
-    FIXME ("Stub\n");
+    static const WCHAR CopyFiles[]  = {'C','o','p','y','F','i','l','e','s',0};
+    static const WCHAR DelFiles[]   = {'D','e','l','F','i','l','e','s',0};
+    WCHAR section_name[MAX_PATH];
+    INFCONTEXT context;
+    BOOL ret;
+    int i;
+
+    TRACE("(%p, %p, %p, %s, %p, %u)\n", diskspace, inf, layoutinf, debugstr_w(section),
+                                        reserved1, reserved2);
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    if (!section)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    if (!inf) return TRUE;
+    if (!layoutinf) layoutinf = inf;
+
+    ret = SetupFindFirstLineW(inf, section, CopyFiles, &context);
+    while (ret)
+    {
+        for (i = 1;; i++)
+        {
+            if (!SetupGetStringFieldW(&context, i, section_name, sizeof(section_name) / sizeof(WCHAR), NULL))
+                break;
+            SetupAddSectionToDiskSpaceListW(diskspace, layoutinf, inf, section_name, FILEOP_COPY, 0, 0);
+        }
+        ret = SetupFindNextLine(&context, &context);
+    }
+
+    ret = SetupFindFirstLineW(inf, section, DelFiles, &context);
+    while (ret)
+    {
+        for (i = 1;; i++)
+        {
+            if (!SetupGetStringFieldW(&context, i, section_name, sizeof(section_name) / sizeof(WCHAR), NULL))
+                break;
+            SetupAddSectionToDiskSpaceListW(diskspace, layoutinf, inf, section_name, FILEOP_DELETE, 0, 0);
+        }
+        ret = SetupFindNextLine(&context, &context);
+    }
+
     return TRUE;
 }
 
+/***********************************************************************
+ *		SetupAddInstallSectionToDiskSpaceListA  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC diskspace,
+                        HINF inf, HINF layoutinf, LPCSTR section,
+                        PVOID reserved1, UINT reserved2)
+{
+    LPWSTR sectionW = NULL;
+    DWORD len;
+    BOOL ret;
+
+    if (section)
+    {
+        len = MultiByteToWideChar(CP_ACP, 0, section, -1, NULL, 0);
+
+        sectionW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+        if (!sectionW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, section, -1, sectionW, len);
+    }
+
+    ret = SetupAddInstallSectionToDiskSpaceListW(diskspace, inf, layoutinf,
+                                                 sectionW, reserved1, reserved2);
+    if (sectionW) HeapFree(GetProcessHeap(), 0, sectionW);
+    return ret;
+}
+
 /***********************************************************************
 *		SetupQuerySpaceRequiredOnDriveW  (SETUPAPI.@)
 */
diff --git a/dlls/setupapi/setupapi.spec b/dlls/setupapi/setupapi.spec
index 8335e705534..3a4abbefb4c 100644
--- a/dlls/setupapi/setupapi.spec
+++ b/dlls/setupapi/setupapi.spec
@@ -253,7 +253,7 @@
 @ stub SearchForInfFile
 @ stub SetArrayToMultiSzValue
 @ stdcall SetupAddInstallSectionToDiskSpaceListA(long long long str ptr long)
-@ stub SetupAddInstallSectionToDiskSpaceListW
+@ stdcall SetupAddInstallSectionToDiskSpaceListW(long long long wstr ptr long)
 @ stdcall SetupAddSectionToDiskSpaceListA(long long long str long ptr long)
 @ stdcall SetupAddSectionToDiskSpaceListW(long long long wstr long ptr long)
 @ stdcall SetupAddToDiskSpaceListA(long str int64 long ptr long)
diff --git a/dlls/setupapi/tests/diskspace.c b/dlls/setupapi/tests/diskspace.c
index 8e2eb88bf93..5643f930d9d 100644
--- a/dlls/setupapi/tests/diskspace.c
+++ b/dlls/setupapi/tests/diskspace.c
@@ -935,6 +935,175 @@ static void test_SetupAddSectionToDiskSpaceListA(void)
     DeleteFileA(tmpfilename);
 }
 
+struct section_i
+{
+    const char *name;
+    BOOL result;
+    DWORD error_code;
+};
+
+static const struct
+{
+    const char *data;
+    struct section_i sections[2];
+    const char *devices;
+    int device_length;
+    struct device_usage usage[2];
+}
+section_test_i[] =
+{
+    /* 0 */
+    {STD_HEADER "[a.Install]\nCopyFiles=a.CopyFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a.Install", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 1 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 2 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\nCopyFiles=a.CopyFiles2\n"
+                "[a.CopyFiles]\ntest,,,\n[a.CopyFiles2]\ntest2,,,\n"
+                "[SourceDisksFiles]\ntest=1,,4096\ntest2=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+    /* 3 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles,a.CopyFiles2\n"
+                "[a.CopyFiles]\ntest,,,\n[a.CopyFiles2]\ntest2,,,\n"
+                "[SourceDisksFiles]\ntest=1,,4096\ntest2=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+    /* 4 */
+    {STD_HEADER "[a]\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 5 */
+    {STD_HEADER "[a]\nDelFiles=a.DelFiles\n"
+                "[a.nDelFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 6 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\nDelFiles=a.DelFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[a.DelFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 7 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\n[b]\nDelFiles=b.DelFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[b.DelFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {"b", TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 7 */
+    {STD_HEADER "[a]\nCopyFiles=\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 8 */
+    {STD_HEADER "[a]\nCopyFiles=something\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 9 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles,b.CopyFiles\n[a.CopyFiles]\ntest,,,\n[b.CopyFiles]\ntest,,,\n"
+                "[SourceDisksFiles]\ntest=1,,4096\n[DestinationDirs]\nb.CopyFiles=-1,F:\\test\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00f:\00", sizeof("c:\00f:\00"), {{"c:", 4096}, {"f:", 4096}}},
+};
+
+static void test_SetupAddInstallSectionToDiskSpaceListA(void)
+{
+    char tmp[MAX_PATH];
+    char tmpfilename[MAX_PATH];
+    char buffer[MAX_PATH];
+    HDSKSPC diskspace;
+    LONGLONG space;
+    UINT err_line;
+    BOOL ret;
+    int i, j;
+    HINF inf;
+
+    if (!GetTempPathA(MAX_PATH, tmp))
+    {
+        win_skip("GetTempPath failed with error %ld\n", GetLastError());
+        return;
+    }
+
+    if (!GetTempFileNameA(tmp, "inftest", 0, tmpfilename))
+    {
+        win_skip("GetTempFileNameA failed with error %ld\n", GetLastError());
+        return;
+    }
+
+    inf = inf_open_file_content(tmpfilename, STD_HEADER "[a]\nCopyFiles=b\n[b]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n", &err_line);
+    ok(!!inf, "Failed to open inf file (%ld, line %u)\n", GetLastError(), err_line);
+
+    diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(diskspace != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, NULL, NULL, "a", 0, 0);
+    ok(ret, "Expected SetupAddInstallSectionToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(NULL, inf, NULL, "a", 0, 0);
+    ok(!ret, "Expected SetupAddInstallSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "Expected ERROR_INVALID_HANDLE as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, inf, NULL, NULL, 0, 0);
+    ok(!ret || broken(ret), "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER || broken(ret),
+       "Expected ERROR_INVALID_PARAMETER as error, got %lu\n", GetLastError());
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, inf, NULL, "", 0, 0);
+    ok(ret, "Expected SetupAddInstallSectionToDiskSpaceListA to succeed (%lu)\n", GetLastError());
+
+    ok(SetupDestroyDiskSpaceList(diskspace),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    for (i = 0; i < sizeof(section_test_i) / sizeof(section_test_i[0]); i++)
+    {
+        err_line = 0;
+
+        inf = inf_open_file_content(tmpfilename, section_test_i[i].data, &err_line);
+        ok(!!inf, "test %u: Failed to open inf file (%lu, line %u)\n", i, GetLastError(), err_line);
+        if (!inf) continue;
+
+        diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+        ok(diskspace != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct section_i *section = &section_test_i[i].sections[j];
+            if (!section->name)
+                continue;
+
+            SetLastError(0xdeadbeef);
+            ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, inf, NULL, section->name, 0, 0);
+            if (section->result)
+                ok(ret, "test %d: Expected adding section %d to succeed (%lu)\n", i, j, GetLastError());
+            else
+            {
+                ok(!ret, "test %d: Expected adding section %d to fail\n", i, j);
+                ok(GetLastError() == section->error_code, "test %d: Expected %lu as error, got %lu\n",
+                   i, section->error_code, GetLastError());
+            }
+        }
+
+        memset(buffer, 0x0, sizeof(buffer));
+        ret = SetupQueryDrivesInDiskSpaceListA(diskspace, buffer, sizeof(buffer), NULL);
+        ok(ret, "test %d: Expected SetupQueryDrivesInDiskSpaceListA to succeed (%lu)\n", i, GetLastError());
+        ok(!memcmp(section_test_i[i].devices, buffer, section_test_i[i].device_length),
+           "test %d: Device list (%s) does not match\n", i, buffer);
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct device_usage *usage = &section_test_i[i].usage[j];
+            if (!usage->dev)
+                continue;
+
+            space = 0;
+            ret = SetupQuerySpaceRequiredOnDriveA(diskspace, usage->dev, &space, NULL, 0);
+            ok(ret, "test %d: Expected SetupQuerySpaceRequiredOnDriveA to succeed for device %s (%lu)\n",
+               i, usage->dev, GetLastError());
+            ok(space == usage->usage, "test %d: Expected size %lu for device %s, got %lu\n",
+               i, (DWORD)usage->usage, usage->dev, (DWORD)space);
+        }
+
+        ok(SetupDestroyDiskSpaceList(diskspace),
+           "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+        SetupCloseInfFile(inf);
+    }
+
+    DeleteFileA(tmpfilename);
+}
+
 START_TEST(diskspace)
 {
     test_SetupCreateDiskSpaceListA();
@@ -946,4 +1115,5 @@ START_TEST(diskspace)
     test_SetupAddToDiskSpaceListA();
     test_SetupQueryDrivesInDiskSpaceListA();
     test_SetupAddSectionToDiskSpaceListA();
+    test_SetupAddInstallSectionToDiskSpaceListA();
 }
diff --git a/include/setupapi.h b/include/setupapi.h
index 74b5d003453..f152fe99a4b 100644
--- a/include/setupapi.h
+++ b/include/setupapi.h
@@ -1426,6 +1426,18 @@ typedef enum {
 WINSETUPAPI void     WINAPI InstallHinfSectionA( HWND hwnd, HINSTANCE handle, PCSTR cmdline, INT show );
 WINSETUPAPI void     WINAPI InstallHinfSectionW( HWND hwnd, HINSTANCE handle, PCWSTR cmdline, INT show );
 #define                     InstallHinfSection WINELIB_NAME_AW(InstallHinfSection)
+WINSETUPAPI BOOL     WINAPI IsUserAdmin(VOID);
+WINSETUPAPI PWSTR    WINAPI MultiByteToUnicode(PCSTR lpMultiByteStr, UINT uCodePage);
+WINSETUPAPI VOID     WINAPI MyFree(PVOID lpMem);
+WINSETUPAPI PVOID    WINAPI MyMalloc(DWORD dwSize);
+WINSETUPAPI PVOID    WINAPI MyRealloc(PVOID lpSrc, DWORD dwSize);
+WINSETUPAPI DWORD    WINAPI OpenAndMapForRead(PCWSTR, PDWORD, PHANDLE, PHANDLE, PVOID *);
+WINSETUPAPI LONG     WINAPI QueryRegistryValue(HKEY, PCWSTR, PBYTE *, PDWORD, PDWORD);
+/* RetreiveFileSecurity is not a typo, as per Microsoft's dlls */
+WINSETUPAPI DWORD    WINAPI RetreiveFileSecurity(PCWSTR, PSECURITY_DESCRIPTOR *);
+WINSETUPAPI BOOL     WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC, HINF, HINF, PCSTR, PVOID, UINT);
+WINSETUPAPI BOOL     WINAPI SetupAddInstallSectionToDiskSpaceListW(HDSKSPC, HINF, HINF, PCWSTR, PVOID, UINT);
+#define         SetupAddInstallSectionToDiskSpaceList WINELIB_NAME_AW(SetupAddInstallSectionToDiskSpaceList)
 WINSETUPAPI BOOL     WINAPI SetupAddSectionToDiskSpaceListA(HDSKSPC, HINF, HINF, PCSTR, UINT, PVOID, UINT);
 WINSETUPAPI BOOL     WINAPI SetupAddSectionToDiskSpaceListW(HDSKSPC, HINF, HINF, PCWSTR, UINT, PVOID, UINT);
 #define                     SetupAddSectionToDiskSpaceList WINELIB_NAME_AW(SetupAddSectionToDiskSpaceList)

From 56db6f8bdb2f89bf6811bc4cefb9fc6ec4904e40 Mon Sep 17 00:00:00 2001
From: Christian Costa <titan.costa@gmail.com>
Date: Tue, 3 Sep 2013 23:28:14 +0200
Subject: [PATCH 112/244] shdocvw: Check precisely ParseURLFromOutsideSourceX
 returned values in tests and make code clearer about that. (try 3)

Try 3:
  - fix test check for ansi version
  - fix error message for both versions
Try 2:
  - improve comments
---
 dlls/shdocvw/shdocvw_main.c  |  8 +++++---
 dlls/shdocvw/tests/shdocvw.c | 13 +++++++------
 2 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/dlls/shdocvw/shdocvw_main.c b/dlls/shdocvw/shdocvw_main.c
index 6556223e1d7..194f0cdab71 100644
--- a/dlls/shdocvw/shdocvw_main.c
+++ b/dlls/shdocvw/shdocvw_main.c
@@ -344,8 +344,7 @@ DWORD WINAPI ParseURLFromOutsideSourceW(LPCWSTR url, LPWSTR out, LPDWORD plen, L
     HRESULT hr;
     DWORD needed;
     DWORD len;
-    DWORD res = 0;
-
+    DWORD res;
 
     TRACE("(%s, %p, %p, %p) len: %ld, unknown: 0x%lx\n", debugstr_w(url), out, plen, unknown,
             plen ? *plen : 0, unknown ? *unknown : 0);
@@ -371,10 +370,12 @@ DWORD WINAPI ParseURLFromOutsideSourceW(LPCWSTR url, LPWSTR out, LPDWORD plen, L
     needed = lstrlenW(buffer_out)+1;
     TRACE("got 0x%lx with %s (need %ld)\n", hr, debugstr_w(buffer_out), needed);
 
+    res = 0;
     if (*plen >= needed) {
         if (out != NULL) {
             lstrcpyW(out, buffer_out);
-            res++;
+            /* On success, 1 is returned for unicode version */
+            res = 1;
         }
         needed--;
     }
@@ -417,6 +418,7 @@ DWORD WINAPI ParseURLFromOutsideSourceA(LPCSTR url, LPSTR out, LPDWORD plen, LPD
     if (*plen >= needed) {
         if (out != NULL) {
             WideCharToMultiByte(CP_ACP, 0, buffer, -1, out, *plen, NULL, NULL);
+            /* On success, string size including terminating 0 is returned for ansi version */
             res = needed;
         }
         needed--;
diff --git a/dlls/shdocvw/tests/shdocvw.c b/dlls/shdocvw/tests/shdocvw.c
index fcfd4a644db..24991ea0f22 100644
--- a/dlls/shdocvw/tests/shdocvw.c
+++ b/dlls/shdocvw/tests/shdocvw.c
@@ -212,13 +212,13 @@ static void test_ParseURLFromOutsideSourceA(void)
         buffer[sizeof(buffer)-1] = '\0';
         len = sizeof(buffer);
         dummy = 0;
-        /* on success, len+1 is returned. No idea, if someone depend on this */
+        /* on success, string size including terminating 0 is returned for ansi version */
         res = pParseURLFromOutsideSourceA(ParseURL_table[i].url, buffer, &len, &dummy);
         /* len does not include the terminating 0, when buffer is large enough */
-        ok( res != 0 && len == ParseURL_table[i].len &&
+        ok( res == (ParseURL_table[i].len+1) && len == ParseURL_table[i].len &&
             !lstrcmpA(buffer, ParseURL_table[i].newurl),
-            "#%d: got %ld and %ld with '%s' (expected '!=0' and %ld with '%s')\n",
-            i, res, len, buffer, ParseURL_table[i].len, ParseURL_table[i].newurl);
+            "#%d: got %ld and %ld with '%s' (expected %ld and %ld with '%s')\n",
+            i, res, len, buffer, ParseURL_table[i].len+1, ParseURL_table[i].len, ParseURL_table[i].newurl);
 
 
         /* use the size test only for the first examples */
@@ -308,11 +308,12 @@ static void test_ParseURLFromOutsideSourceW(void)
     /* len is in characters */
     len = ARRAY_SIZE(bufferW);
     dummy = 0;
+    /* on success, 1 is returned for unicode version */
     res = pParseURLFromOutsideSourceW(urlW, bufferW, &len, &dummy);
     WideCharToMultiByte(CP_ACP, 0, bufferW, -1, bufferA, sizeof(bufferA), NULL, NULL);
-    ok( res != 0 && len == ParseURL_table[0].len &&
+    ok( res == 1 && len == ParseURL_table[0].len &&
         !lstrcmpA(bufferA, ParseURL_table[0].newurl),
-        "got %ld and %ld with '%s' (expected '!=0' and %ld with '%s')\n",
+        "got %ld and %ld with '%s' (expected 1 and %ld with '%s')\n",
         res, len, bufferA, ParseURL_table[0].len, ParseURL_table[0].newurl);
 
 

From 59d8954ceb4699f3ab5371d5afaa82ea801c6da7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 30 Nov 2018 12:20:40 +0200
Subject: [PATCH 113/244] shell32/iconcache: Generate icons from available
 icons if some icon sizes failed to load
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

For icon sizes that fail to load, create them from another icon that
succeeded by resizing it, favoring icons that are the closest and larger
(to reduce pixelation artefacts) and with the closest aspect ratio as the
source of this operation (to be as generic as possible). For example, if
the icon that needs to be created must be 16x16, an 18x18 icon would get
picked over either a 32x32 (it's further from 16x16) or a 15x15 (icons
larger than 16x16 are favored since they're larger than the result, so
smaller icons are only picked if no other available icon is larger).

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45696
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/shell32/iconcache.c | 75 ++++++++++++++++++++++++++++++++--------
 1 file changed, 60 insertions(+), 15 deletions(-)

diff --git a/dlls/shell32/iconcache.c b/dlls/shell32/iconcache.c
index 8f9519d2ca8..03eea049d0c 100644
--- a/dlls/shell32/iconcache.c
+++ b/dlls/shell32/iconcache.c
@@ -21,6 +21,7 @@
 #include <stdarg.h>
 #include <string.h>
 #include <sys/types.h>
+#include <math.h>
 
 #define COBJMACROS
 
@@ -333,17 +334,6 @@ static INT SIC_IconAppend (const WCHAR *sourcefile, INT src_index, HICON *hicons
     return ret;
 }
 
-static BOOL get_imagelist_icon_size(int list, SIZE *size)
-{
-    int cx, cy;
-    if (list < 0 || list >= ARRAY_SIZE(shell_imagelists)) return FALSE;
-
-    if (!ImageList_GetIconSize( shell_imagelists[list], &cx, &cy )) return FALSE;
-    size->cx = cx;
-    size->cy = cy;
-    return TRUE;
-}
-
 /****************************************************************************
  * SIC_LoadIcon				[internal]
  *
@@ -354,15 +344,70 @@ static INT SIC_LoadIcon (const WCHAR *sourcefile, INT index, DWORD flags)
 {
     HICON hicons[ARRAY_SIZE(shell_imagelists)] = { 0 };
     HICON hshortcuts[ARRAY_SIZE(hicons)] = { 0 };
+    SIZE size[ARRAY_SIZE(shell_imagelists)];
     unsigned int i;
-    SIZE size;
     INT ret = -1;
+    INT x, y;
 
+    /* Keep track of the sizes in case any icon fails to get extracted */
     for (i = 0; i < ARRAY_SIZE(hicons); i++)
     {
-        if (!get_imagelist_icon_size( i, &size ) ||
-            !PrivateExtractIconsW( sourcefile, index, size.cx, size.cy, &hicons[i], 0, 1, 0 ))
-            WARN("Failed to load icon %d from %s.\n", index, debugstr_w(sourcefile));
+        ImageList_GetIconSize(shell_imagelists[i], &x, &y);
+        size[i].cx = x;
+        size[i].cy = y;
+        PrivateExtractIconsW(sourcefile, index, size[i].cx, size[i].cy, &hicons[i], 0, 1, 0);
+    }
+
+    /* Fill any icon handles that failed to get extracted, by resizing
+       another icon handle that succeeded and creating the icon from it.
+       Use a dumb O(n^2) algorithm since ARRAY_SIZE(hicons) is small */
+    for (i = 0; i < ARRAY_SIZE(hicons); i++)
+    {
+        unsigned int k, ix, iy;
+        BOOL failed = TRUE;
+        if (hicons[i]) continue;
+
+        for (k = 0; k < ARRAY_SIZE(hicons); k++)
+        {
+            if (hicons[k])
+            {
+                ix = iy = k;
+                failed = FALSE;
+                break;
+            }
+        }
+        if (failed) goto fail;
+
+        for (k++; k < ARRAY_SIZE(hicons); k++)
+        {
+            if (!hicons[k]) continue;
+
+            /* Find closest-sized icon, but favor larger icons to resize from */
+            if (size[k].cx >= size[i].cx)
+                ix = (size[ix].cx < size[i].cx || size[ix].cx > size[k].cx) ? k : ix;
+            else
+                ix = (size[ix].cx < size[i].cx && size[ix].cx < size[k].cx) ? k : ix;
+
+            if (size[k].cy >= size[i].cy)
+                iy = (size[iy].cy < size[i].cy || size[iy].cy > size[k].cy) ? k : iy;
+            else
+                iy = (size[iy].cy < size[i].cy && size[iy].cy < size[k].cy) ? k : iy;
+        }
+
+        /* Use the closest icon in aspect ratio if ix and iy differ */
+        if (ix != iy)
+        {
+            float i_ratio, ix_ratio, iy_ratio;
+            i_ratio  = (float)size[i].cx  / (float)size[i].cy;
+            ix_ratio = (float)size[ix].cx / (float)size[ix].cy;
+            iy_ratio = (float)size[iy].cx / (float)size[iy].cy;
+            if (fabsf(ix_ratio - i_ratio) > fabsf(iy_ratio - i_ratio))
+                ix = iy;
+        }
+
+        /* If this fails, we have to abort to prevent the image lists from
+           becoming out of sync and completely screwing the icons up */
+        hicons[i] = CopyImage(hicons[ix], IMAGE_ICON, size[i].cx, size[i].cy, 0);
         if (!hicons[i]) goto fail;
     }
 

From d21335b75c597ce8e0a4bcf1f18827aa5a238a2c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 15 Aug 2015 21:12:00 +0200
Subject: [PATCH 114/244] shell32: Set SFGAO_HASSUBFOLDER correctly for normal
 shellfolders.

---
 dlls/shell32/shlfolder.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/dlls/shell32/shlfolder.c b/dlls/shell32/shlfolder.c
index 1ff45e7139c..eddaa2c6b9e 100644
--- a/dlls/shell32/shlfolder.c
+++ b/dlls/shell32/shlfolder.c
@@ -439,7 +439,23 @@ HRESULT SHELL32_GetItemAttributes (IShellFolder2 *psf, LPCITEMIDLIST pidl, LPDWO
                           SFGAO_CANRENAME | SFGAO_CANLINK | SFGAO_CANMOVE | SFGAO_CANCOPY;
 
 	if (file_attr & FILE_ATTRIBUTE_DIRECTORY)
-	    *pdwAttributes |=  (SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE);
+        {
+            IEnumIDList *enum_list;
+            IShellFolder *child;
+
+            *pdwAttributes |= (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE);
+
+            if (SUCCEEDED(IShellFolder2_BindToObject(psf, pidl, NULL, &IID_IShellFolder, (void **)&child)))
+            {
+                if (IShellFolder_EnumObjects(child, NULL, SHCONTF_FOLDERS|SHCONTF_INCLUDEHIDDEN, &enum_list) == S_OK)
+                {
+                    if (IEnumIDList_Skip(enum_list, 1) != S_OK)
+                        *pdwAttributes &= ~SFGAO_HASSUBFOLDER;
+                    IEnumIDList_Release(enum_list);
+                }
+                IShellFolder_Release(child);
+            }
+        }
 	else
         {
 	    *pdwAttributes &= ~(SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE);

From 11b2fd197d33ccf3b7e3ecc5b347732a05638ba7 Mon Sep 17 00:00:00 2001
From: Louis Lenders <xerox.xerox2000x@gmail.com>
Date: Fri, 12 Oct 2018 11:57:18 +0200
Subject: [PATCH 115/244] shell32: Improve semi-stub SHGetStockIconInfo, try
 find existing iconhandle

v3: try find handle to existing icon

this is the best I can come up with for now, on windows afaict all these icons mostly come from imegares.dll
so the attached patch is not really how windows does it

Fix for bug https://bugs.winehq.org/show_bug.cgi?id=45868

Signed-off-by: Louis Lenders <xerox.xerox2000x@gmail.com>
---
 dlls/shell32/iconcache.c       | 156 +++++++++++++++++++++++++++++++--
 dlls/shell32/tests/shelllink.c |  15 ++++
 2 files changed, 164 insertions(+), 7 deletions(-)

diff --git a/dlls/shell32/iconcache.c b/dlls/shell32/iconcache.c
index 03eea049d0c..4a84b2055fe 100644
--- a/dlls/shell32/iconcache.c
+++ b/dlls/shell32/iconcache.c
@@ -1021,6 +1021,119 @@ INT WINAPI SHGetIconOverlayIndexW(LPCWSTR pszIconPath, INT iIconIndex)
   return -1;
 }
 
+/****************************************************************************
+ * For SHGetStockIconInfo
+ */
+typedef struct {
+    SHSTOCKICONID id;
+    DWORD iconid;
+} SI_ENTRY;
+
+static const SI_ENTRY si_table[] =
+{
+    [0]   = { SIID_DOCNOASSOC, IDI_SHELL_FILE},
+    [1]   = { SIID_DOCASSOC, IDI_SHELL_DOCUMENT},
+    [2]   = { SIID_APPLICATION, IDI_SHELL_WINDOW},
+    [3]   = { SIID_FOLDER, IDI_SHELL_FOLDER},
+    [4]   = { SIID_FOLDEROPEN, IDI_SHELL_FOLDER_OPEN},
+    [5]   = { SIID_DRIVE525, 0},
+    [6]   = { SIID_DRIVE35, 0},
+    [7]   = { SIID_DRIVERREMOVE, 0},
+    [8]   = { SIID_DRIVERFIXED, IDI_SHELL_DRIVE},
+    [9]   = { SIID_DRIVERNET, IDI_SHELL_NETDRIVE},
+    [10]  = { SIID_DRIVERNETDISABLE, IDI_SHELL_NETDRIVE2},
+    [11]  = { SIID_DRIVERCD, IDI_SHELL_OPTICAL_DRIVE},
+    [12]  = { SIID_DRIVERRAM, IDI_SHELL_RAMDISK},
+    [13]  = { SIID_WORLD, 0},
+    /* Missing: 14 */
+    [15]  = { SIID_SERVER, 0},
+    [16]  = { SIID_PRINTER, IDI_SHELL_PRINT},
+    [17]  = { SIID_MYNETWORK, 0},
+    /* Missing: 18 - 21 */
+    [22]  = { SIID_FIND, 0},
+    [23]  = { SIID_HELP, IDI_SHELL_HELP},
+    /* Missing: 24 - 27 */
+    [28]  = {SIID_SHARE, 0},
+    [29]  = {SIID_LINK, 0},
+    [30]  = {SIID_SLOWFILE, 0},
+    [31]  = {SIID_RECYCLER, IDI_SHELL_TRASH_FOLDER},
+    [32]  = {SIID_RECYCLERFULL, IDI_SHELL_FULL_RECYCLE_BIN},
+    /* Missing: 33 - 39 */
+    [40]  = {SIID_MEDIACDAUDIO, 0},
+    /* Missing: 41 - 46 */
+    [47]  = {SIID_LOCK, IDI_SHELL_PASSWORDS},
+    /* Missing: 48 */
+    [49]  = {SIID_AUTOLIST, 0},
+    [50]  = {SIID_PRINTERNET, 0},
+    [51]  = {SIID_SERVERSHARE, 0},
+    [52]  = {SIID_PRINTERFAX, 0},
+    [53]  = {SIID_PRINTERFAXNET, 0},
+    [54]  = {SIID_PRINTERFILE, 0},
+    [55]  = {SIID_STACK, 0},
+    [56]  = {SIID_MEDIASVCD, 0},
+    [57]  = {SIID_STUFFEDFOLDER, 0},
+    [58]  = {SIID_DRIVEUNKNOWN, 0},
+    [59]  = {SIID_DRIVEDVD, 0},
+    [60]  = {SIID_MEDIADVD, 0},
+    [61]  = {SIID_MEDIADVDRAM, 0},
+    [62]  = {SIID_MEDIADVDRW, 0},
+    [63]  = {SIID_MEDIADVDR, 0},
+    [64]  = {SIID_MEDIADVDROM, 0},
+    [65]  = {SIID_MEDIACDAUDIOPLUS, 0},
+    [66]  = {SIID_MEDIACDRW, 0},
+    [67]  = {SIID_MEDIACDR, 0},
+    [68]  = {SIID_MEDIACDBURN, 0},
+    [69]  = {SIID_MEDIABLANKCD, 0},
+    [70]  = {SIID_MEDIACDROM, 0},
+    [71]  = {SIID_AUDIOFILES, IDI_SHELL_AUDIO_FILE},
+    [72]  = {SIID_IMAGEFILES, IDI_SHELL_IMAGE_FILE},
+    [73]  = {SIID_VIDEOFILES, IDI_SHELL_VIDEO_FILE},
+    [74]  = {SIID_MIXEDFILES, 0},
+    [75]  = {SIID_FOLDERBACK, 0},
+    [76]  = {SIID_FOLDERFRONT, 0},
+    [77]  = {SIID_SHIELD, 0},
+    [78]  = {SIID_WARNING, 0},
+    [79]  = {SIID_INFO, 0},
+    [80]  = {SIID_ERROR, 0},
+    [81]  = {SIID_KEY, 0},
+    [82]  = {SIID_SOFTWARE, 0},
+    [83]  = {SIID_RENAME, IDI_SHELL_RENAME},
+    [84]  = {SIID_DELETE, IDI_SHELL_CONFIRM_DELETE},
+    [85]  = {SIID_MEDIAAUDIODVD, 0},
+    [86]  = {SIID_MEDIAMOVIEDVD, 0},
+    [87]  = {SIID_MEDIAENHANCEDCD, 0},
+    [88]  = {SIID_MEDIAENHANCEDDVD, 0},
+    [89]  = {SIID_MEDIAHDDVD, 0},
+    [90]  = {SIID_MEDIABLUERAY, 0},
+    [91]  = {SIID_MEDIAVCD, 0},
+    [92]  = {SIID_MEDIADVDPLUSR, 0},
+    [93]  = {SIID_MEDIADVDPLUSRW, 0},
+    [94]  = {SIID_DESKTOPPC, IDI_SHELL_MY_COMPUTER},
+    [95]  = {SIID_MOBILEPC, 0},
+    [96]  = {SIID_USERS, IDI_SHELL_USERS},
+    [97]  = {SIID_MEDIASMARTMEDIA, 0},
+    [98]  = {SIID_MEDIACOMPACTFLASH, 0},
+    [99]  = {SIID_DEVICECELLPHONE, 0},
+    [100] = {SIID_DEVICECAMERA, 0},
+    [101] = {SIID_DEVICEVIDEOCAMERA, 0},
+    [102] = {SIID_DEVICEAUDIOPLAYER, 0},
+    [103] = {SIID_NETWORKCONNECT, 0},
+    [104] = {SIID_INTERNET, IDI_SHELL_WEB_BROWSER},
+    [105] = {SIID_ZIPFILE, 0},
+    [106] = {SIID_SETTINGS, IDI_SHELL_SETTINGS},
+    /* Missing: 107 - 131 */
+    [132] = {SIID_DRIVEHDDVD, 0},
+    [133] = {SIID_DRIVEBD, 0},
+    [134] = {SIID_MEDIAHDDVDROM, 0},
+    [135] = {SIID_MEDIAHDDVDR, 0},
+    [136] = {SIID_MEDIAHDDVDRAM, 0},
+    [137] = {SIID_MEDIABDROM, 0},
+    [138] = {SIID_MEDIABDR, 0},
+    [139] = {SIID_MEDIABDRE, 0},
+    [140] = {SIID_CLUSTEREDDRIVE, 0}
+    /* Missing: 141 - 180  and  SIID_MAX_ICONS = 181*/
+ };
+
 /****************************************************************************
  * SHGetStockIconInfo [SHELL32.@]
  *
@@ -1038,25 +1151,54 @@ INT WINAPI SHGetIconOverlayIndexW(LPCWSTR pszIconPath, INT iIconIndex)
  */
 HRESULT WINAPI SHGetStockIconInfo(SHSTOCKICONID id, UINT flags, SHSTOCKICONINFO *sii)
 {
-    FIXME("(%d, 0x%x, %p) semi-stub\n", id, flags, sii);
+    HMODULE hmod;
+
+    TRACE("(%d, 0x%x, %p)\n", id, flags, sii);
+
     if ((id < 0) || (id >= SIID_MAX_ICONS) || !sii || (sii->cbSize != sizeof(SHSTOCKICONINFO))) {
         return E_INVALIDARG;
     }
 
     GetSystemDirectoryW(sii->szPath, MAX_PATH);
-
-    /* no icons defined: use default */
-    sii->iIcon = -IDI_SHELL_FILE;
     lstrcatW(sii->szPath, L"\\shell32.dll");
 
-    if (flags)
-        FIXME("flags 0x%x not implemented\n", flags);
-
     sii->hIcon = NULL;
     if (flags & SHGSI_ICON)
         sii->hIcon = LoadIconW(GetModuleHandleW(sii->szPath), MAKEINTRESOURCEW(sii->iIcon));
     sii->iSysImageIndex = -1;
 
+    /* this is not how windows does it, on windows picked mostly from imageres.dll !*/
+    if (si_table[id].iconid)
+        sii->iIcon = sii->iSysImageIndex - si_table[id].id;
+    else
+    {
+        FIXME("Couldn`t find SIID %d, returning default values (IDI_SHELL_FILE)\n", id);
+        sii->iIcon = sii->iSysImageIndex - IDI_SHELL_FILE;
+    }
+
+    if (flags & SHGSI_ICON)
+    {
+        flags &= ~SHGSI_ICON;
+
+        hmod = GetModuleHandleW(L"shell32.dll");
+        if (hmod)
+        {
+            if (si_table[id].iconid)
+                sii->hIcon = LoadIconW(hmod, MAKEINTRESOURCEW(si_table[id].iconid));
+            else
+                sii->hIcon = LoadIconW(hmod, MAKEINTRESOURCEW(IDI_SHELL_FILE));
+        }
+
+        if (!sii->hIcon)
+        {
+            ERR("failed to get an icon handle\n");
+            return E_INVALIDARG;
+        }
+    }
+
+    if (flags)
+        FIXME("flags 0x%x not implemented\n", flags);
+
     TRACE("%3d: returning %s (%d)\n", id, debugstr_w(sii->szPath), sii->iIcon);
 
     return S_OK;
diff --git a/dlls/shell32/tests/shelllink.c b/dlls/shell32/tests/shelllink.c
index f13155ade2f..c70bc9d5946 100644
--- a/dlls/shell32/tests/shelllink.c
+++ b/dlls/shell32/tests/shelllink.c
@@ -1119,6 +1119,21 @@ static void test_SHGetStockIconInfo(void)
     /* there is a NULL check for the struct  */
     hr = pSHGetStockIconInfo(SIID_FOLDER, SHGSI_ICONLOCATION, NULL);
     ok(hr == E_INVALIDARG, "NULL: got 0x%lx\n", hr);
+
+    for(i = 0; i < 140; i++)  /* highest on wvista, i > 140 gives E_INVALIDARG, win7 can go higher */
+    {
+        memset(buffer, 0, sizeof(buffer));
+        sii->cbSize = sizeof(SHSTOCKICONINFO);
+        hr = pSHGetStockIconInfo(i, SHGSI_ICON | SHGSI_SMALLICON, sii);
+        ok(hr == S_OK, "got 0x%lx (expected S_OK)\n", hr);
+        ok(sii->hIcon != NULL, "got NULL, expected an icon handle\n");
+        ok(sii->iIcon != 0, "got unexpected 0 for SIID %d\n", i); /* howto find out exact sii->iIcon value??? */
+        ok(sii->iSysImageIndex == -1, "got %d (expected -1)\n", sii->iSysImageIndex);
+        ok(DestroyIcon(sii->hIcon), "DestroyIcon failed\n");
+        if (winetest_debug > 1)
+            trace("%3d: got iSysImageIndex %3d, iIcon %3d and %s\n", i, sii->iSysImageIndex,
+            sii->iIcon, wine_dbgstr_w(sii->szPath));
+    }
 }
 
 static void test_SHExtractIcons(void)

From e5f872f713eb143328da6eb66006ebf534abede0 Mon Sep 17 00:00:00 2001
From: Mark Jansen <learn0more@gmail.com>
Date: Sat, 2 May 2015 13:47:30 +0200
Subject: [PATCH 118/244] shlwapi/tests: Add tests for AssocGetPerceivedType.

---
 dlls/shlwapi/assoc.c       |   7 +-
 dlls/shlwapi/tests/assoc.c | 283 ++++++++++++++++++++++++++++++++++++-
 2 files changed, 284 insertions(+), 6 deletions(-)

diff --git a/dlls/shlwapi/assoc.c b/dlls/shlwapi/assoc.c
index b2afe52ec0e..c3c5a321f3b 100644
--- a/dlls/shlwapi/assoc.c
+++ b/dlls/shlwapi/assoc.c
@@ -130,10 +130,9 @@ HRESULT WINAPI AssocGetPerceivedType(LPCWSTR lpszExt, PERCEIVED *lpType,
 {
   FIXME("(%s, %p, %p, %p) not supported\n", debugstr_w(lpszExt), lpType, lpFlag, lppszType);
 
-  if (lpszExt == NULL)
-    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
-
-  return E_NOTIMPL;
+  if (lpType) *lpType = PERCEIVED_TYPE_UNSPECIFIED;
+  if (lpFlag) *lpFlag = PERCEIVEDFLAG_UNDEFINED;
+  return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
 }
 
 /*************************************************************************
diff --git a/dlls/shlwapi/tests/assoc.c b/dlls/shlwapi/tests/assoc.c
index 93e0d140518..a39cf49ea87 100644
--- a/dlls/shlwapi/tests/assoc.c
+++ b/dlls/shlwapi/tests/assoc.c
@@ -23,12 +23,13 @@
 #include "shlwapi.h"
 #include "shlguid.h"
 
-#define expect(expected, got) ok ( expected == got, "Expected %ld, got %ld\n", expected, got)
-#define expect_hr(expected, got) ok ( expected == got, "Expected %08lx, got %08lx\n", expected, got)
+#define expect(expected, got) ok( (expected) == (got), "Expected %ld, got %ld\n", (expected), (got))
+#define expect_hr(expected, got) ok( (expected) == (got), "Expected %08lx, got %08lx\n", (expected), (got))
 
 static HRESULT (WINAPI *pAssocQueryStringA)(ASSOCF,ASSOCSTR,LPCSTR,LPCSTR,LPSTR,LPDWORD) = NULL;
 static HRESULT (WINAPI *pAssocQueryStringW)(ASSOCF,ASSOCSTR,LPCWSTR,LPCWSTR,LPWSTR,LPDWORD) = NULL;
 static HRESULT (WINAPI *pAssocCreate)(CLSID, REFIID, void **) = NULL;
+static HRESULT (WINAPI *pAssocGetPerceivedType)(LPCWSTR, PERCEIVED *, INT *, LPWSTR *) = NULL;
 
 /* Should every version of Windows with IE have .html association? */
 
@@ -301,6 +302,282 @@ static void test_assoc_create(void)
     }
 }
 
+/* Based on http://www.geoffchappell.com/studies/windows/shell/shlwapi/api/assocapi/getperceivedtype.htm */
+struct assoc_test_struct
+{
+    PCSTR     extension;
+    PERCEIVED perceived;
+    INT       flags;
+    PCSTR     type;
+    DWORD     minversion;
+    HRESULT   hr;
+};
+
+#define HARDCODED_NATIVE_WMSDK      (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_WMSDK)
+#define HARDCODED_NATIVE_GDIPLUS    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_GDIPLUS)
+#define HARDCODED_NATIVE_ZIPFLDR    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_ZIPFOLDER)
+#define SOFTCODED_NATIVESUPPORT     (PERCEIVEDFLAG_SOFTCODED | PERCEIVEDFLAG_NATIVESUPPORT)
+
+static const struct assoc_test_struct assoc_perceived_types[] =
+{
+    /* builtins */
+    { ".aif",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".aifc",          PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".aiff",          PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".asf",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".asx",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".au",            PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".avi",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".bas",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".bat",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".bmp",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".cmd",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".com",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".cpl",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_HARDCODED,    "system",       0x600 },
+    { ".dib",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".dvr-ms",        PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".emf",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".exe",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".gif",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".hta",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    /* htm & html are PERCEIVED_TYPE_TEXT, PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_SOFTCODED in w2k3 */
+    { ".htm",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,    "document",     0x600 },
+    { ".html",          PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,    "document",     0x600 },
+    { ".ico",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".IVF",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".jfif",          PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".jpe",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".jpeg",          PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".jpg",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".lnk",           PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_HARDCODED,    NULL,           0x600, E_FAIL },
+    { ".m1v",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".m3u",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".mht",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,    "document",     0x600 },
+    { ".mid",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".midi",          PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".msi",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    /* below win8 this is defined to be video */
+    { ".mp2",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio",        0x602 },
+    { ".mp2v",          PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mp3",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".mpa",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpe",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpeg",          PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpg",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpv2",          PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".pif",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".png",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".reg",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".rle",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".rmi",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".scr",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".search-ms",     PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_HARDCODED,    NULL,           0x600, E_FAIL },
+    { ".snd",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".tif",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".tiff",          PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".vb",            PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".wav",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".wax",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".wm",            PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".wma",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".wmf",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".wmv",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".wmx",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".wvx",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".zip",           PERCEIVED_TYPE_COMPRESSED,  HARDCODED_NATIVE_ZIPFLDR,   "compressed" },
+    /* found in the registry under HKEY_CLASSES_ROOT on a new Win7 VM */
+    { ".386",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".3g2",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".3gp",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".3gp2",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".3gpp",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".AAC",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".ADT",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".ADTS",          PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".asm",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".asmx",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".aspx",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".c",             PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".cab",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed",   0x600 },
+    { ".chk",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".cpp",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".css",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".cxx",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".def",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".diz",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".docx",          PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x601 },
+    { ".drv",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system",       0x600 },
+    { ".gz",            PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".h",             PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".hpp",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".hxx",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".inc",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".ini",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text",         0x600 },
+    { ".java",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".local",         PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".M2T",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".M2TS",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".M2V",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".m4a",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".m4b",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".m4p",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".m4v",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".manifest",      PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".MOD",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".mov",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".mp4",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".mp4v",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".MTS",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".nvr",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".ocx",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".odt",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x601 },
+    { ".php3",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".pl",            PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".plg",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".ps1xml",        PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "Text" },
+    { ".rtf",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".sed",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".shtml",         PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".sql",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".sys",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system",       0x600 },
+    { ".tar",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".text",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".tgz",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".TS",            PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".tsv",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".TTS",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".txt",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".vob",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".vxd",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".wdp",           PERCEIVED_TYPE_IMAGE,       PERCEIVEDFLAG_SOFTCODED,    "image" },
+    { ".wmz",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".wpl",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".wsz",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".x",             PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".xml",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text",         0x601 },
+    { ".xsl",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text",         0x601 },
+    { ".z",             PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    /* found in the registry under HKEY_CLASSES_ROOT\PerceivedType */
+    { ".doc",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".dot",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".mhtml",         PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".pot",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".ppt",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".rtf",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".wri",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".xls",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".xlt",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+
+};
+
+static void test_assoc_one(const struct assoc_test_struct* test)
+{
+    LPWSTR extension, type_expected, type_returned;
+    PERCEIVED perceived;
+    HRESULT hr;
+    INT flags;
+
+    /* if SHStrDupA receives a nullptr as input, it will null the output */
+    SHStrDupA(test->extension, &extension);
+    SHStrDupA(test->type, &type_expected);
+
+    perceived = 0xdeadbeef;
+    flags = 0xdeadbeef;
+
+    hr = pAssocGetPerceivedType(extension, &perceived, &flags, NULL);
+    expect_hr(type_expected ? S_OK : test->hr, hr);
+    ok(perceived == test->perceived, "%s: got perceived 0x%x, expected 0x%x\n",
+       test->extension, perceived, test->perceived);
+    ok(flags == test->flags, "%s: got flags 0x%x, expected 0x%x\n",
+       test->extension, flags, test->flags);
+
+    type_returned = (void *)0xdeadbeef;
+    perceived = 0xdeadbeef;
+    flags = 0xdeadbeef;
+
+    hr = pAssocGetPerceivedType(extension, &perceived, &flags, &type_returned);
+    expect_hr(type_expected ? S_OK : test->hr, hr);
+    ok(perceived == test->perceived, "%s: got perceived 0x%x, expected 0x%x\n",
+       test->extension, perceived, test->perceived);
+    ok(flags == test->flags, "%s: got flags 0x%x, expected 0x%x\n",
+       test->extension, flags, test->flags);
+
+    if (!type_expected)
+    {
+        ok(type_returned == (void *)0xdeadbeef || broken(type_returned == NULL) /* Win 8 */,
+           "%s: got type %p, expected 0xdeadbeef\n", test->extension, type_returned);
+    }
+    else if (type_returned == (void *)0xdeadbeef)
+    {
+        ok(type_returned != (void *)0xdeadbeef, "%s: got type %p, expected '%s'\n",
+           test->extension, type_returned, test->type);
+    }
+    else
+    {
+        ok(StrCmpIW(type_expected, type_returned) == 0, "%s: got type %s, expected '%s'\n",
+           test->extension, wine_dbgstr_w(type_returned), test->type);
+    }
+
+    CoTaskMemFree(type_returned);
+    CoTaskMemFree(extension);
+    CoTaskMemFree(type_expected);
+}
+
+static void test_assoc_perceived(void)
+{
+    static const struct assoc_test_struct should_not_exist =
+        { ".should_not_exist", PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_UNDEFINED, NULL, 0, 0x80070002 };
+    static const struct assoc_test_struct htm[] =
+    {
+        { ".htm",  PERCEIVED_TYPE_TEXT, SOFTCODED_NATIVESUPPORT, "text", 0x600 },
+        { ".html", PERCEIVED_TYPE_TEXT, SOFTCODED_NATIVESUPPORT, "text", 0x600 },
+    };
+    static const struct assoc_test_struct mp2 =
+        { ".mp2", PERCEIVED_TYPE_VIDEO, HARDCODED_NATIVE_WMSDK, "video" };
+
+    OSVERSIONINFOEXW osvi;
+    DWORD version;
+    size_t i;
+
+    if (!pAssocGetPerceivedType)
+    {
+        win_skip("AssocGetPerceivedType() is missing\n");
+        return;
+    }
+
+    memset(&osvi, 0, sizeof(osvi));
+    osvi.dwOSVersionInfoSize = sizeof(osvi);
+    GetVersionExW((LPOSVERSIONINFOW)&osvi);
+    version = (osvi.dwMajorVersion << 8) | osvi.dwMinorVersion;
+
+    /* invalid entry results in HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) */
+    test_assoc_one(&should_not_exist);
+
+    for (i = 0; i < sizeof(assoc_perceived_types) / sizeof(assoc_perceived_types[0]); ++i)
+    {
+        if (assoc_perceived_types[i].minversion && assoc_perceived_types[i].minversion > version)
+            continue;
+        todo_wine
+        test_assoc_one(&assoc_perceived_types[i]);
+    }
+
+    /* below Vista */
+    if (version < 0x600)
+    {
+        todo_wine
+        test_assoc_one(&htm[0]);
+        todo_wine
+        test_assoc_one(&htm[1]);
+    }
+
+    /* below Win8 */
+    if (version < 0x602)
+    {
+        todo_wine
+        test_assoc_one(&mp2);
+    }
+}
+
 START_TEST(assoc)
 {
     HMODULE hshlwapi;
@@ -308,9 +585,11 @@ START_TEST(assoc)
     pAssocQueryStringA = (void*)GetProcAddress(hshlwapi, "AssocQueryStringA");
     pAssocQueryStringW = (void*)GetProcAddress(hshlwapi, "AssocQueryStringW");
     pAssocCreate       = (void*)GetProcAddress(hshlwapi, "AssocCreate");
+    pAssocGetPerceivedType = (void*)GetProcAddress(hshlwapi, "AssocGetPerceivedType");
 
     test_getstring_bad();
     test_getstring_basic();
     test_getstring_no_extra();
     test_assoc_create();
+    test_assoc_perceived();
 }

From 3913444f7b7b290123f3cfc1124153894b617e73 Mon Sep 17 00:00:00 2001
From: Mark Jansen <learn0more@gmail.com>
Date: Sun, 10 May 2015 03:38:01 +0200
Subject: [PATCH 119/244] shlwapi: Implement AssocGetPerceivedType. (v2)

Changes in v2:
  * Fixed error checking for RegGetValueW based on feedback from Thomas Faber.
---
 dlls/shlwapi/assoc.c       | 228 +++++++++++++++++++++++++++++++++++--
 dlls/shlwapi/tests/assoc.c |   7 +-
 2 files changed, 225 insertions(+), 10 deletions(-)

diff --git a/dlls/shlwapi/assoc.c b/dlls/shlwapi/assoc.c
index c3c5a321f3b..06221b6a8da 100644
--- a/dlls/shlwapi/assoc.c
+++ b/dlls/shlwapi/assoc.c
@@ -100,6 +100,174 @@ HRESULT WINAPI AssocCreate(CLSID clsid, REFIID refiid, void **lpInterface)
   return SHCoCreateInstance( NULL, &clsid, NULL, refiid, lpInterface );
 }
 
+
+struct AssocPerceivedInfo
+{
+    PCWSTR Type;
+    PERCEIVED Perceived;
+    INT FlagHardcoded;
+    INT FlagSoftcoded;
+    PCWSTR Extensions;
+};
+
+static const WCHAR unspecified_exts[] = {
+    '.','l','n','k',0,
+    '.','s','e','a','r','c','h','-','m','s',0,
+    0
+};
+
+static const WCHAR image_exts[] = {
+    '.','b','m','p',0,
+    '.','d','i','b',0,
+    '.','e','m','f',0,
+    '.','g','i','f',0,
+    '.','i','c','o',0,
+    '.','j','f','i','f',0,
+    '.','j','p','e',0,
+    '.','j','p','e','g',0,
+    '.','j','p','g',0,
+    '.','p','n','g',0,
+    '.','r','l','e',0,
+    '.','t','i','f',0,
+    '.','t','i','f','f',0,
+    '.','w','m','f',0,
+    0
+};
+
+static const WCHAR audio_exts[] = {
+    '.','a','i','f',0,
+    '.','a','i','f','c',0,
+    '.','a','i','f','f',0,
+    '.','a','u',0,
+    '.','m','3','u',0,
+    '.','m','i','d',0,
+    '.','m','i','d','i',0,
+#if _WIN32_WINNT > 0x602
+    '.','m','p','2',0,
+#endif
+    '.','m','p','3',0,
+    '.','r','m','i',0,
+    '.','s','n','d',0,
+    '.','w','a','v',0,
+    '.','w','a','x',0,
+    '.','w','m','a',0,
+    0
+};
+
+static const WCHAR video_exts[] = {
+    '.','a','s','f',0,
+    '.','a','s','x',0,
+    '.','a','v','i',0,
+    '.','d','v','r','-','m','s',0,
+    '.','I','V','F',0,
+    '.','m','1','v',0,
+#if _WIN32_WINNT <= 0x602
+    '.','m','p','2',0,
+#endif
+    '.','m','p','2','v',0,
+    '.','m','p','a',0,
+    '.','m','p','e',0,
+    '.','m','p','e','g',0,
+    '.','m','p','g',0,
+    '.','m','p','v','2',0,
+    '.','w','m',0,
+    '.','w','m','v',0,
+    '.','w','m','x',0,
+    '.','w','v','x',0,
+    0
+};
+
+static const WCHAR compressed_exts[] = {
+    '.','z','i','p',0,
+    0
+};
+
+static const WCHAR document_exts[] = {
+#if _WIN32_WINNT >= 0x600
+    '.','h','t','m',0,
+    '.','h','t','m','l',0,
+#endif
+    '.','m','h','t',0,
+    0
+};
+
+static const WCHAR system_exts[] = {
+    '.','c','p','l',0,
+    0
+};
+
+static const WCHAR application_exts[] = {
+    '.','b','a','s',0,
+    '.','b','a','t',0,
+    '.','c','m','d',0,
+    '.','c','o','m',0,
+    '.','e','x','e',0,
+    '.','h','t','a',0,
+    '.','m','s','i',0,
+    '.','p','i','f',0,
+    '.','r','e','g',0,
+    '.','s','c','r',0,
+    '.','v','b',0,
+    0
+};
+
+const WCHAR type_text[] = {'t','e','x','t',0};
+const WCHAR type_image[] = {'i','m','a','g','e',0};
+const WCHAR type_audio[] = {'a','u','d','i','o',0};
+const WCHAR type_video[] = {'v','i','d','e','o',0};
+const WCHAR type_compressed[] = {'c','o','m','p','r','e','s','s','e','d',0};
+const WCHAR type_document[] = {'d','o','c','u','m','e','n','t',0};
+const WCHAR type_system[] = {'s','y','s','t','e','m',0};
+const WCHAR type_application[] = {'a','p','p','l','i','c','a','t','i','o','n',0};
+
+#define HARDCODED_NATIVE_WMSDK      (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_WMSDK)
+#define HARDCODED_NATIVE_GDIPLUS    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_GDIPLUS)
+#define HARDCODED_NATIVE_ZIPFLDR    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_ZIPFOLDER)
+#define SOFTCODED_NATIVESUPPORT     (PERCEIVEDFLAG_SOFTCODED | PERCEIVEDFLAG_NATIVESUPPORT)
+
+static const struct AssocPerceivedInfo known_types[] = {
+    { NULL,             PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, unspecified_exts },
+    { type_text,        PERCEIVED_TYPE_TEXT,        PERCEIVEDFLAG_HARDCODED,  SOFTCODED_NATIVESUPPORT, NULL },
+    { type_image,       PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS, PERCEIVEDFLAG_SOFTCODED, image_exts },
+    { type_audio,       PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,   PERCEIVEDFLAG_SOFTCODED, audio_exts },
+    { type_video,       PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,   PERCEIVEDFLAG_SOFTCODED, video_exts },
+    { type_compressed,  PERCEIVED_TYPE_COMPRESSED,  HARDCODED_NATIVE_ZIPFLDR, PERCEIVEDFLAG_SOFTCODED, compressed_exts },
+    { type_document,    PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, document_exts },
+    { type_system,      PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, system_exts },
+    { type_application, PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, application_exts },
+};
+
+static const struct AssocPerceivedInfo* AssocFindByBuiltinExtension(LPCWSTR pszExt)
+{
+    UINT n;
+    for (n = 0; n < sizeof(known_types) / sizeof(known_types[0]); ++n)
+    {
+        PCWSTR Ext = known_types[n].Extensions;
+        while (Ext && *Ext)
+        {
+            if (!StrCmpIW(Ext, pszExt))
+                return &known_types[n];
+            Ext += (lstrlenW(Ext) + 1);
+        }
+    }
+    return NULL;
+}
+
+static const struct AssocPerceivedInfo* AssocFindByType(LPCWSTR pszType)
+{
+    UINT n;
+    for (n = 0; n < sizeof(known_types) / sizeof(known_types[0]); ++n)
+    {
+        if (known_types[n].Type)
+        {
+            if (!StrCmpIW(known_types[n].Type, pszType))
+                return &known_types[n];
+        }
+    }
+    return NULL;
+}
+
+
 /*************************************************************************
  * AssocGetPerceivedType  [SHLWAPI.@]
  *
@@ -121,18 +289,64 @@ HRESULT WINAPI AssocCreate(CLSID clsid, REFIID refiid, void **lpInterface)
  *  lppszType is optional and it can be NULL.
  *  if lpType or lpFlag are NULL, the function will crash.
  *  if lpszExt is NULL, an error is returned.
- *
- * BUGS
- *   Unimplemented.
  */
 HRESULT WINAPI AssocGetPerceivedType(LPCWSTR lpszExt, PERCEIVED *lpType,
                                      INT *lpFlag, LPWSTR *lppszType)
 {
-  FIXME("(%s, %p, %p, %p) not supported\n", debugstr_w(lpszExt), lpType, lpFlag, lppszType);
+    static const WCHAR PerceivedTypeKey[] = {'P','e','r','c','e','i','v','e','d','T','y','p','e',0};
+    static const WCHAR SystemFileAssociationsKey[] = {'S','y','s','t','e','m','F','i','l','e',
+        'A','s','s','o','c','i','a','t','i','o','n','s','\\','%','s',0};
+    const struct AssocPerceivedInfo *Info;
+
+    TRACE("(%s,%p,%p,%p)\n", debugstr_w(lpszExt), lpType, lpFlag, lppszType);
 
-  if (lpType) *lpType = PERCEIVED_TYPE_UNSPECIFIED;
-  if (lpFlag) *lpFlag = PERCEIVEDFLAG_UNDEFINED;
-  return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
+    Info = AssocFindByBuiltinExtension(lpszExt);
+    if (Info)
+    {
+        *lpType = Info->Perceived;
+        *lpFlag = Info->FlagHardcoded;
+    }
+    else
+    {
+        WCHAR Buffer[100] = { 0 };
+        DWORD Size = sizeof(Buffer);
+        if (RegGetValueW(HKEY_CLASSES_ROOT, lpszExt, PerceivedTypeKey,
+                         RRF_RT_REG_SZ, NULL, Buffer, &Size) == ERROR_SUCCESS)
+        {
+            Info = AssocFindByType(Buffer);
+        }
+        if (!Info)
+        {
+            WCHAR KeyName[MAX_PATH] = { 0 };
+            swprintf(KeyName, MAX_PATH, SystemFileAssociationsKey, lpszExt);
+            Size = sizeof(Buffer);
+            if (RegGetValueW(HKEY_CLASSES_ROOT, KeyName, PerceivedTypeKey,
+                             RRF_RT_REG_SZ, NULL, Buffer, &Size) == ERROR_SUCCESS)
+            {
+                Info = AssocFindByType(Buffer);
+            }
+        }
+        if (Info)
+        {
+            *lpType = Info->Perceived;
+            *lpFlag = Info->FlagSoftcoded;
+        }
+    }
+
+    if (Info)
+    {
+        if (lppszType && Info->Type)
+        {
+            return SHStrDupW(Info->Type, lppszType);
+        }
+        return Info->Type ? S_OK : E_FAIL;
+    }
+    else
+    {
+        *lpType = PERCEIVED_TYPE_UNSPECIFIED;
+        *lpFlag = 0;
+    }
+    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
 }
 
 /*************************************************************************
diff --git a/dlls/shlwapi/tests/assoc.c b/dlls/shlwapi/tests/assoc.c
index a39cf49ea87..6c92e0725c5 100644
--- a/dlls/shlwapi/tests/assoc.c
+++ b/dlls/shlwapi/tests/assoc.c
@@ -557,8 +557,10 @@ static void test_assoc_perceived(void)
     {
         if (assoc_perceived_types[i].minversion && assoc_perceived_types[i].minversion > version)
             continue;
-        todo_wine
-        test_assoc_one(&assoc_perceived_types[i]);
+        if (!(assoc_perceived_types[i].flags & PERCEIVEDFLAG_HARDCODED))
+            todo_wine test_assoc_one(&assoc_perceived_types[i]);
+        else
+            test_assoc_one(&assoc_perceived_types[i]);
     }
 
     /* below Vista */
@@ -573,7 +575,6 @@ static void test_assoc_perceived(void)
     /* below Win8 */
     if (version < 0x602)
     {
-        todo_wine
         test_assoc_one(&mp2);
     }
 }

From 5249b5727a8d8a529ec5e3a04a71ab3044ad06e6 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Fri, 22 Jan 2016 17:40:43 +0800
Subject: [PATCH 120/244] include: Make stdole32.idl a public component.

This makes it possible to import stdole32.tlb from other .idl files.
---
 dlls/stdole32.tlb/std_ole_v1.idl | 119 +------------------------
 include/Makefile.in              |   1 +
 include/stdole32.idl             | 143 +++++++++++++++++++++++++++++++
 3 files changed, 145 insertions(+), 118 deletions(-)
 create mode 100644 include/stdole32.idl

diff --git a/dlls/stdole32.tlb/std_ole_v1.idl b/dlls/stdole32.tlb/std_ole_v1.idl
index 359a81062ae..de053e98227 100644
--- a/dlls/stdole32.tlb/std_ole_v1.idl
+++ b/dlls/stdole32.tlb/std_ole_v1.idl
@@ -20,121 +20,4 @@
 
 #pragma makedep regtypelib
 
-[
-  uuid(00020430-0000-0000-C000-000000000046),
-  restricted,
-  version(1.0),
-  helpstring("OLE Automation")
-]
-library stdole
-{
-	/* typedefs aren't stored in the type library.
-           These type names are known by the type compiler so it
-           doesn't really matter what we define them as. */
-
-    typedef void *VARIANT;
-    typedef wchar_t *BSTR;
-    typedef unsigned long SCODE;
-    typedef unsigned long HRESULT;
-    
-    typedef struct GUID {
-        unsigned long  Data1;
-        unsigned short Data2;
-        unsigned short Data3;
-        unsigned char  Data4[ 8 ];
-    } GUID;
-
-    typedef struct DISPPARAMS {
-        VARIANT *rgvarg;
-        long *rgdispidNamedArgs;
-        unsigned int cArgs;
-        unsigned int cNamedArgs;
-    } DISPPARAMS;
-
-    typedef struct EXCEPINFO {
-        unsigned short wCode;
-        unsigned short wReserved;
-        BSTR  bstrSource;
-        BSTR  bstrDescription;
-        BSTR  bstrHelpFile;
-        unsigned long dwHelpContext;
-        void *pvReserved;
-        void *pfnDeferredFillIn;
-        SCODE scode;
-    } EXCEPINFO;
-
-    [
-        odl,
-        uuid(00000000-0000-0000-C000-000000000046)
-    ]
-    interface IUnknown
-    {
-        [restricted]
-        HRESULT QueryInterface(
-                               [in] GUID *riid,
-                               [out] void **ppvObj);
-
-        [restricted]
-        unsigned long AddRef();
-
-        [restricted]
-        unsigned long Release();
-    }
-
-    [
-        odl,
-        uuid(00020400-0000-0000-C000-000000000046)
-    ]
-    interface IDispatch : IUnknown
-    {
-        [restricted]
-        HRESULT GetTypeInfoCount(
-                                 [out] unsigned int *pctinfo);
-
-        [restricted]
-        HRESULT GetTypeInfo(
-                            [in] unsigned int itinfo,
-                            [in] unsigned long lcid,
-                            [out] void **pptinfo);
-
-        [restricted]
-        HRESULT GetIDsOfNames(
-                              [in] GUID *riid,
-                              [in] char **rgszNames,
-                              [in] unsigned int cNames,
-                              [in] unsigned long lcid,
-                              [out] long *rgdispid);
-
-        [restricted]
-        HRESULT Invoke(
-                       [in] long dispidMember,
-                       [in] GUID *riid,
-                       [in] unsigned long lcid,
-                       [in] unsigned short wFlags,
-                       [in] DISPPARAMS *pdispparams,
-                       [out] VARIANT *pvarResult,
-                       [out] EXCEPINFO *pexcepinfo,
-                       [out] unsigned int *puArgErr);
-
-    }
-
-    [
-        odl,
-        uuid(00020404-0000-0000-C000-000000000046)
-    ]
-    interface IEnumVARIANT : IUnknown
-    {
-        HRESULT Next(
-                     [in] unsigned long celt,
-                     [in] VARIANT *rgvar,
-                     [out] unsigned long *pceltFetched);
-
-        HRESULT Skip(
-                     [in] unsigned long celt);
-
-        HRESULT Reset();
-
-        HRESULT Clone(
-                      [out] IEnumVARIANT **ppenum);
-    }
-};
+#include "stdole32.idl"
diff --git a/include/Makefile.in b/include/Makefile.in
index d56bc5182d8..37d4af0f82f 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -744,6 +744,7 @@ SOURCES = \
 	srrestoreptapi.h \
 	sspi.h \
 	stamp-h.in \
+	stdole32.idl \
 	stgprop.h \
 	sti.h \
 	storage.h \
diff --git a/include/stdole32.idl b/include/stdole32.idl
new file mode 100644
index 00000000000..107cee84591
--- /dev/null
+++ b/include/stdole32.idl
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2003 Robert Shearman
+ *               2005 Huw Davies
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#if 0
+#pragma makedep install
+#pragma makedep typelib
+#endif
+
+[
+  uuid(00020430-0000-0000-C000-000000000046),
+  restricted,
+  version(1.0),
+  helpstring("OLE Automation")
+]
+library stdole
+{
+	/* typedefs aren't stored in the type library.
+           These type names are known by the type compiler so it
+           doesn't really matter what we define them as. */
+
+    typedef void *VARIANT;
+    typedef wchar_t *BSTR;
+    typedef unsigned long SCODE;
+    typedef unsigned long HRESULT;
+
+    typedef struct GUID {
+        unsigned long  Data1;
+        unsigned short Data2;
+        unsigned short Data3;
+        unsigned char  Data4[ 8 ];
+    } GUID;
+
+    typedef struct DISPPARAMS {
+        VARIANT *rgvarg;
+        long *rgdispidNamedArgs;
+        unsigned int cArgs;
+        unsigned int cNamedArgs;
+    } DISPPARAMS;
+
+    typedef struct EXCEPINFO {
+        unsigned short wCode;
+        unsigned short wReserved;
+        BSTR  bstrSource;
+        BSTR  bstrDescription;
+        BSTR  bstrHelpFile;
+        unsigned long dwHelpContext;
+        void *pvReserved;
+        void *pfnDeferredFillIn;
+        SCODE scode;
+    } EXCEPINFO;
+
+    [
+        odl,
+        uuid(00000000-0000-0000-C000-000000000046)
+    ]
+    interface IUnknown
+    {
+        [restricted]
+        HRESULT QueryInterface(
+                               [in] GUID *riid,
+                               [out] void **ppvObj);
+
+        [restricted]
+        unsigned long AddRef();
+
+        [restricted]
+        unsigned long Release();
+    }
+
+    [
+        odl,
+        uuid(00020400-0000-0000-C000-000000000046)
+    ]
+    interface IDispatch : IUnknown
+    {
+        [restricted]
+        HRESULT GetTypeInfoCount(
+                                 [out] unsigned int *pctinfo);
+
+        [restricted]
+        HRESULT GetTypeInfo(
+                            [in] unsigned int itinfo,
+                            [in] unsigned long lcid,
+                            [out] void **pptinfo);
+
+        [restricted]
+        HRESULT GetIDsOfNames(
+                              [in] GUID *riid,
+                              [in] char **rgszNames,
+                              [in] unsigned int cNames,
+                              [in] unsigned long lcid,
+                              [out] long *rgdispid);
+
+        [restricted]
+        HRESULT Invoke(
+                       [in] long dispidMember,
+                       [in] GUID *riid,
+                       [in] unsigned long lcid,
+                       [in] unsigned short wFlags,
+                       [in] DISPPARAMS *pdispparams,
+                       [out] VARIANT *pvarResult,
+                       [out] EXCEPINFO *pexcepinfo,
+                       [out] unsigned int *puArgErr);
+
+    }
+
+    [
+        odl,
+        uuid(00020404-0000-0000-C000-000000000046)
+    ]
+    interface IEnumVARIANT : IUnknown
+    {
+        HRESULT Next(
+                     [in] unsigned long celt,
+                     [in] VARIANT *rgvar,
+                     [out] unsigned long *pceltFetched);
+
+        HRESULT Skip(
+                     [in] unsigned long celt);
+
+        HRESULT Reset();
+
+        HRESULT Clone(
+                      [out] IEnumVARIANT **ppenum);
+    }
+};

From 9cde2230a404a05ae9bf3c107fac045dbca0e2fa Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 15 Jun 2016 14:57:10 +0800
Subject: [PATCH 121/244] user32: Do not initialize dialog info for every
 window passed to DefDlgProc.

The tests in the last patch in the series use
DefDlgProcA(parent, DM_GETDEFID, 0, 0);
as a simple dialog detector, and that call leads to dialog info being
created for a not dialog window, which later makes this window being
treated as a dialog.

DIALOG_CreateControls32() gets called after the dialog info creation
has been forced, so passing TRUE to DIALOG_get_info() is redundant there.
---
 dlls/user32/defdlg.c | 4 ++--
 dlls/user32/dialog.c | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/user32/defdlg.c b/dlls/user32/defdlg.c
index 1b50893c041..3c35d10bddc 100644
--- a/dlls/user32/defdlg.c
+++ b/dlls/user32/defdlg.c
@@ -317,7 +317,7 @@ static LRESULT USER_DefDlgProcA( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPar
     LRESULT result;
 
     /* Perform DIALOGINFO initialization if not done */
-    if(!(dlgInfo = DIALOG_get_info( hwnd, TRUE ))) return 0;
+    if (!(dlgInfo = DIALOG_get_info( hwnd, msg == WM_NCCREATE ))) return 0;
 
     SetWindowLongPtrW( hwnd, DWLP_MSGRESULT, 0 );
 
@@ -369,7 +369,7 @@ static LRESULT USER_DefDlgProcW( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPar
     LRESULT result;
 
     /* Perform DIALOGINFO initialization if not done */
-    if(!(dlgInfo = DIALOG_get_info( hwnd, TRUE ))) return 0;
+    if (!(dlgInfo = DIALOG_get_info( hwnd, msg == WM_NCCREATE ))) return 0;
 
     SetWindowLongPtrW( hwnd, DWLP_MSGRESULT, 0 );
     result = WINPROC_CallDlgProcW( hwnd, msg, wParam, lParam );
diff --git a/dlls/user32/dialog.c b/dlls/user32/dialog.c
index 219a4326441..125e1d5fb75 100644
--- a/dlls/user32/dialog.c
+++ b/dlls/user32/dialog.c
@@ -192,7 +192,7 @@ static const WORD *DIALOG_GetControl32( const WORD *p, DLG_CONTROL_INFO *info,
 static BOOL DIALOG_CreateControls32( HWND hwnd, LPCSTR template, const DLG_TEMPLATE *dlgTemplate,
                                      HINSTANCE hInst, BOOL unicode )
 {
-    DIALOGINFO *dlgInfo = DIALOG_get_info( hwnd, TRUE );
+    DIALOGINFO *dlgInfo = DIALOG_get_info( hwnd, FALSE );
     DLG_CONTROL_INFO info;
     HWND hwndCtrl, hwndDefButton = 0;
     INT items = dlgTemplate->nbItems;

From dd66303b8a93e07ef638b526c600f96a09d3abb5 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 15 Jun 2016 15:07:39 +0800
Subject: [PATCH 122/244] user32: Use root dialog for DM_SETDEFID/DM_GETDEFID
 in DefDlgProc.

This patch fixes DM_SETDEFID/DM_GETDEFID handling in complex dialog
structures such as a property sheet.
---
 dlls/user32/defdlg.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/dlls/user32/defdlg.c b/dlls/user32/defdlg.c
index 3c35d10bddc..07113d8754d 100644
--- a/dlls/user32/defdlg.c
+++ b/dlls/user32/defdlg.c
@@ -180,6 +180,25 @@ static BOOL DEFDLG_SetDefButton( HWND hwndDlg, DIALOGINFO *dlgInfo, HWND hwndNew
 }
 
 
+static HWND root_dialog(HWND hwnd)
+{
+    while ((GetWindowLongA(hwnd, GWL_EXSTYLE) & WS_EX_CONTROLPARENT) &&
+           (GetWindowLongA(hwnd, GWL_STYLE) & (WS_CHILD|WS_POPUP)) == WS_CHILD)
+    {
+        HWND parent = GetParent(hwnd);
+
+        if (!DIALOG_get_info(parent, FALSE))
+            break;
+
+        hwnd = parent;
+
+        if (!(GetWindowLongA(hwnd, GWL_STYLE) & DS_CONTROL))
+            break;
+    }
+
+    return hwnd;
+}
+
 /***********************************************************************
  *           DEFDLG_Proc
  *
@@ -231,11 +250,17 @@ static LRESULT DEFDLG_Proc( HWND hwnd, UINT msg, WPARAM wParam,
             return 0;
 
         case DM_SETDEFID:
+            hwnd = root_dialog( hwnd );
+            dlgInfo = DIALOG_get_info( hwnd, FALSE );
+
             if (dlgInfo && !(dlgInfo->flags & DF_END))
                 DEFDLG_SetDefId( hwnd, dlgInfo, wParam );
             return 1;
 
         case DM_GETDEFID:
+            hwnd = root_dialog( hwnd );
+            dlgInfo = DIALOG_get_info( hwnd, FALSE );
+
             if (dlgInfo && !(dlgInfo->flags & DF_END))
             {
                 HWND hwndDefId;

From 16d20cec0a92555eca85272505e48743e5c2d41d Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 15 Jun 2016 15:09:46 +0800
Subject: [PATCH 123/244] user32/tests: Add a bunch of tests for
 DM_SETDEFID/DM_GETDEFID handling by a DefDlgProc.

---
 dlls/user32/tests/win.c | 87 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 87 insertions(+)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index caaf01f6089..49385f49240 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -5228,15 +5228,65 @@ static void test_window_styles(void)
     }
 }
 
+static HWND root_dialog(HWND hwnd)
+{
+    while ((GetWindowLongA(hwnd, GWL_EXSTYLE) & WS_EX_CONTROLPARENT) &&
+           (GetWindowLongA(hwnd, GWL_STYLE) & (WS_CHILD|WS_POPUP)) == WS_CHILD)
+    {
+        HWND parent = GetParent(hwnd);
+
+        /* simple detector for a window being a dialog */
+        if (!DefDlgProcA(parent, DM_GETDEFID, 0, 0))
+            break;
+
+        hwnd = parent;
+
+        if (!(GetWindowLongA(hwnd, GWL_STYLE) & DS_CONTROL))
+            break;
+    }
+
+    return hwnd;
+}
+
 static INT_PTR WINAPI empty_dlg_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     return 0;
 }
 
+static LRESULT expected_id;
+
 static INT_PTR WINAPI empty_dlg_proc3(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     if (msg == WM_INITDIALOG)
+    {
+        HWND parent = GetParent(hwnd);
+        LRESULT id, ret;
+
+        id = DefDlgProcA(parent, DM_GETDEFID, 0, 0);
+        if (!id || root_dialog(hwnd) == hwnd)
+            parent = 0;
+
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        if (!parent)
+            ok(id == MAKELONG(IDOK,DC_HASDEFID), "expected (IDOK,DC_HASDEFID), got %08lx\n", id);
+        else
+            ok(id == expected_id, "expected %08lx, got %08lx\n", expected_id, id);
+
+        ret = DefDlgProcA(hwnd, DM_SETDEFID, 0x3333, 0);
+        ok(ret, "DefDlgProc(DM_SETDEFID) failed\n");
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        ok(id == MAKELONG(0x3333,DC_HASDEFID), "expected (0x3333,DC_HASDEFID), got %08lx\n", id);
+
+        if (parent)
+        {
+            id = DefDlgProcA(parent, DM_GETDEFID, 0, 0);
+            ok(id == MAKELONG(0x3333,DC_HASDEFID), "expected (0x3333,DC_HASDEFID), got %08lx\n", id);
+
+            expected_id = MAKELONG(0x3333,DC_HASDEFID);
+        }
+
         EndDialog(hwnd, 0);
+    }
 
     return 0;
 }
@@ -5255,6 +5305,16 @@ static INT_PTR WINAPI empty_dlg_proc2(HWND hwnd, UINT msg, WPARAM wparam, LPARAM
         struct dialog_param *param = (struct dialog_param *)lparam;
         BOOL parent_is_child;
         HWND disabled_hwnd;
+        LRESULT id, ret;
+
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        ok(id == MAKELONG(IDOK,DC_HASDEFID), "expected (IDOK,DC_HASDEFID), got %08lx\n", id);
+        ret = DefDlgProcA(hwnd, DM_SETDEFID, 0x2222, 0);
+        ok(ret, "DefDlgProc(DM_SETDEFID) failed\n");
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        ok(id == MAKELONG(0x2222,DC_HASDEFID), "expected (0x2222,DC_HASDEFID), got %08lx\n", id);
+
+        expected_id = MAKELONG(0x2222,DC_HASDEFID);
 
         parent_is_child = (GetWindowLongA(param->parent, GWL_STYLE) & (WS_POPUP | WS_CHILD)) == WS_CHILD;
 
@@ -5296,6 +5356,25 @@ static INT_PTR WINAPI empty_dlg_proc2(HWND hwnd, UINT msg, WPARAM wparam, LPARAM
         DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
         ok(IsWindowEnabled(hwnd), "wrong state for %p (%08lx)\n", hwnd, style);
 
+        param->dlg_data->style |= DS_CONTROL;
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
+        param->dlg_data->dwExtendedStyle |= WS_EX_CONTROLPARENT;
+        SetWindowLongA(hwnd, GWL_EXSTYLE, GetWindowLongA(hwnd, GWL_EXSTYLE) | WS_EX_CONTROLPARENT);
+        SetWindowLongA(hwnd, GWL_STYLE, style & ~DS_CONTROL);
+        param->dlg_data->style &= ~DS_CONTROL;
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
+        SetWindowLongA(hwnd, GWL_STYLE, style | DS_CONTROL);
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
+        param->dlg_data->style |= DS_CONTROL;
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
         EndDialog(hwnd, 0);
     }
     return 0;
@@ -5314,6 +5393,7 @@ static void check_dialog_style(DWORD style_in, DWORD ex_style_in, DWORD style_ou
     DWORD style, ex_style;
     HWND hwnd, grand_parent = 0, parent = 0;
     struct dialog_param param;
+    LRESULT id, ret;
 
     if (style_in & WS_CHILD)
     {
@@ -5341,6 +5421,13 @@ static void check_dialog_style(DWORD style_in, DWORD ex_style_in, DWORD style_ou
     hwnd = CreateDialogIndirectParamA(GetModuleHandleA(NULL), &dlg_data.dt, parent, empty_dlg_proc, 0);
     ok(hwnd != 0, "dialog creation failed, style %#lx, exstyle %#lx\n", style_in, ex_style_in);
 
+    id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+    ok(id == MAKELONG(IDOK,DC_HASDEFID), "expected (IDOK,DC_HASDEFID), got %08lx\n", id);
+    ret = DefDlgProcA(hwnd, DM_SETDEFID, 0x1111, 0);
+    ok(ret, "DefDlgProc(DM_SETDEFID) failed\n");
+    id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+    ok(id == MAKELONG(0x1111,DC_HASDEFID), "expected (0x1111,DC_HASDEFID), got %08lx\n", id);
+
     flush_events( TRUE );
 
     style = GetWindowLongA(hwnd, GWL_STYLE);

From 14143066049ea04dfe9bb0a7788e88489945c08b Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Fri, 26 Sep 2014 20:24:50 +0200
Subject: [PATCH 124/244] user32: Call UpdateWindow() during
 DIALOG_CreateIndirect.

---
 dlls/user32/dialog.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/user32/dialog.c b/dlls/user32/dialog.c
index 125e1d5fb75..577e01e1b06 100644
--- a/dlls/user32/dialog.c
+++ b/dlls/user32/dialog.c
@@ -704,6 +704,7 @@ static HWND DIALOG_CreateIndirect( HINSTANCE hInst, LPCVOID dlgTemplate,
         if (template.style & WS_VISIBLE && !(GetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE))
         {
            NtUserShowWindow( hwnd, SW_SHOWNORMAL );   /* SW_SHOW doesn't always work */
+            UpdateWindow( hwnd );
         }
         return hwnd;
     }

From b6af0fcbbded9e487b870036913952c379b6422e Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Thu, 13 Nov 2014 06:43:43 +0100
Subject: [PATCH 125/244] user32: Fix handling of invert_y in DrawTextExW.

---
 dlls/user32/text.c | 32 +++++++++++++++-----------------
 1 file changed, 15 insertions(+), 17 deletions(-)

diff --git a/dlls/user32/text.c b/dlls/user32/text.c
index 1896627c893..1c95e8b4ad4 100644
--- a/dlls/user32/text.c
+++ b/dlls/user32/text.c
@@ -914,6 +914,15 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
     if (dtp && dtp->cbSize != sizeof(DRAWTEXTPARAMS))
         return 0;
 
+    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
+    {
+        SIZE window_ext, viewport_ext;
+        GetWindowExtEx(hdc, &window_ext);
+        GetViewportExtEx(hdc, &viewport_ext);
+        if ((window_ext.cy > 0) != (viewport_ext.cy > 0))
+            invert_y = TRUE;
+    }
+
     if (count == -1)
     {
         count = lstrlenW(str);
@@ -923,7 +932,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
             {
                 rect->right = rect->left;
                 if( flags & DT_SINGLELINE)
-                    rect->bottom = rect->top + lh;
+                    rect->bottom = rect->top + (invert_y ? -lh : lh);
                 else
                     rect->bottom = rect->top;
             }
@@ -931,15 +940,6 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
         }
     }
 
-    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
-    {
-        SIZE window_ext, viewport_ext;
-        GetWindowExtEx(hdc, &window_ext);
-        GetViewportExtEx(hdc, &viewport_ext);
-        if ((window_ext.cy > 0) != (viewport_ext.cy > 0))
-            invert_y = TRUE;
-    }
-
     if (dtp)
     {
         lmargin = dtp->iLeftMargin;
@@ -987,9 +987,10 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
 
 	if (flags & DT_SINGLELINE)
 	{
-	    if (flags & DT_VCENTER) y = rect->top +
-	    	(rect->bottom - rect->top) / 2 - size.cy / 2;
-	    else if (flags & DT_BOTTOM) y = rect->bottom - size.cy;
+            if (flags & DT_VCENTER)
+                y = rect->top + (rect->bottom - rect->top) / 2 + (invert_y ? (size.cy / 2) : (-size.cy / 2));
+            else if (flags & DT_BOTTOM)
+                y = rect->bottom + (invert_y ? 0 : -size.cy);
         }
 
 	if (!(flags & DT_CALCRECT))
@@ -1047,10 +1048,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
 	else if (size.cx > max_width)
 	    max_width = size.cx;
 
-        if (invert_y)
-	    y -= lh;
-        else
-	    y += lh;
+        y += invert_y ? -lh : lh;
         if (dtp)
             dtp->uiLengthDrawn += len;
     }

From e18c0a814debf353799833c0ed674b804264ed63 Mon Sep 17 00:00:00 2001
From: James Coonradt <gamax92@aol.com>
Date: Tue, 19 Sep 2017 12:28:50 -0600
Subject: [PATCH 126/244] user32: Improve FlashWindowEx message and return
 value.

---
 dlls/user32/tests/win.c | 4 ++--
 dlls/win32u/window.c    | 5 ++---
 2 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 49385f49240..8182e4021f2 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -10207,7 +10207,7 @@ static void test_FlashWindowEx(void)
 
     SetLastError(0xdeadbeef);
     ret = pFlashWindowEx(&finfo);
-    todo_wine ok(!ret, "previous window state should not be active\n");
+    ok(!ret, "previous window state should not be active\n");
 
     finfo.cbSize = sizeof(FLASHWINFO) - 1;
     SetLastError(0xdeadbeef);
@@ -10258,7 +10258,7 @@ static void test_FlashWindowEx(void)
     finfo.dwFlags = FLASHW_STOP;
     SetLastError(0xdeadbeef);
     ret = pFlashWindowEx(&finfo);
-    ok(prev != ret, "previous window state should be different\n");
+    todo_wine ok(prev != ret, "previous window state should be different\n");
 
     DestroyWindow( hwnd );
 }
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 82761d31753..f94e46bdc43 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -5002,8 +5002,7 @@ BOOL WINAPI NtUserFlashWindowEx( FLASHWINFO *info )
         if (!win || win == WND_OTHER_PROCESS || win == WND_DESKTOP) return FALSE;
         hwnd = win->obj.handle;  /* make it a full handle */
 
-        if (info->dwFlags) wparam = !(win->flags & WIN_NCACTIVATED);
-        else wparam = (hwnd == NtUserGetForegroundWindow());
+        wparam = (win->flags & WIN_NCACTIVATED) != 0;
 
         release_win_ptr( win );
 
@@ -5011,7 +5010,7 @@ BOOL WINAPI NtUserFlashWindowEx( FLASHWINFO *info )
             send_notify_message( hwnd, WM_NCACTIVATE, wparam, 0, 0 );
 
         user_driver->pFlashWindowEx( info );
-        return wparam;
+        return (info->dwFlags & FLASHW_CAPTION) ? TRUE : wparam;
     }
 }
 

From f4376ce6509e6d5fabb1bcf93335b18a6a112fdc Mon Sep 17 00:00:00 2001
From: katahiromz <katayama.hirofumi.mz@gmail.com>
Date: Thu, 11 Oct 2018 13:47:02 +0900
Subject: [PATCH 127/244] user32: Implement CascadeWindows.

Changes
Minor formatting
Added WCHAR for FindWindowW parameters
Use stanard heap_ functions.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45968
Signed-off-by: Hirofumi Katayama <katayama.hirofumi.mz@gmail.com>
---
 dlls/user32/mdi.c | 216 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 214 insertions(+), 2 deletions(-)

diff --git a/dlls/user32/mdi.c b/dlls/user32/mdi.c
index f579298544a..f6b0aaa59bf 100644
--- a/dlls/user32/mdi.c
+++ b/dlls/user32/mdi.c
@@ -2,6 +2,7 @@
  *
  * Copyright 1994, Bob Amstadt
  *           1995,1996 Alex Korobka
+ * Copyright 2018 Katayama Hirofumi MZ
  *
  * This file contains routines to support MDI (Multiple Document
  * Interface) features .
@@ -1795,12 +1796,223 @@ void WINAPI ScrollChildren(HWND hWnd, UINT uMsg, WPARAM wParam,
  *    Success: Number of cascaded windows.
  *    Failure: 0
  */
+
+typedef struct CASCADE_INFO
+{
+    HWND top;
+    UINT flags;
+    HWND parent;
+    HWND desktop;
+    HWND tray_wnd;
+    HWND progman;
+    HWND *wnd_array;
+    DWORD wnd_count;
+} CASCADE_INFO;
+
+static BOOL CALLBACK GetCascadeChildProc(HWND hwnd, LPARAM lParam)
+{
+    DWORD count, size;
+    HWND *wnd_array;
+    CASCADE_INFO *info = (CASCADE_INFO *)lParam;
+
+    if (hwnd == info->desktop || hwnd == info->tray_wnd ||
+        hwnd == info->progman || hwnd == info->top)
+    {
+        return TRUE;
+    }
+
+    if (info->parent && GetParent(hwnd) != info->parent)
+        return TRUE;
+
+    if ((info->flags & MDITILE_SKIPDISABLED) && !IsWindowEnabled(hwnd))
+        return TRUE;
+
+    if (!IsWindowVisible(hwnd) || IsIconic(hwnd))
+        return TRUE;
+
+    count = info->wnd_count;
+    size = (count + 1) * sizeof(HWND);
+
+    if (count == 0 || !info->wnd_array)
+    {
+        count = 0;
+        info->wnd_array = (HWND *)heap_alloc(size);
+    }
+    else
+    {
+        wnd_array = (HWND *)heap_realloc(info->wnd_array, size);
+        if (!wnd_array)
+        {
+            heap_free(info->wnd_array);
+        }
+        info->wnd_array = wnd_array;
+    }
+
+    if (!info->wnd_array)
+    {
+        info->wnd_count = 0;
+        return FALSE;
+    }
+
+    info->wnd_array[count] = hwnd;
+    info->wnd_count = count + 1;
+    return TRUE;
+}
+
+static BOOL
+QuerySizeFix(HWND hwnd, INT *pcx, INT *pcy)
+{
+    MINMAXINFO mmi;
+    DWORD_PTR result;
+
+    mmi.ptMinTrackSize.x = mmi.ptMinTrackSize.y = 0;
+    mmi.ptMaxTrackSize.x = mmi.ptMaxTrackSize.y = MAXLONG;
+    if (SendMessageTimeoutW(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&mmi,
+                            SMTO_ABORTIFHUNG | SMTO_NORMAL, 120, &result))
+    {
+        *pcx = min(max(*pcx, mmi.ptMinTrackSize.x), mmi.ptMaxTrackSize.x);
+        *pcy = min(max(*pcy, mmi.ptMinTrackSize.y), mmi.ptMaxTrackSize.y);
+        return TRUE;
+    }
+    return FALSE;
+}
+
 WORD WINAPI
 CascadeWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 		UINT cKids, const HWND *lpKids)
 {
-    FIXME("(%p,0x%08x,...,%u,...): stub\n", hwndParent, wFlags, cKids);
-    return 0;
+    static WCHAR shelltray[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
+    static WCHAR progman[] = {'P','r','o','g','m','a','n',0};
+    CASCADE_INFO info;
+    HWND hwnd, top, prev;
+    HMONITOR monitor;
+    MONITORINFO mi;
+    RECT work_rect, wnd_rect;
+    DWORD i, ret = 0;
+    INT x, y, width, height, new_width, new_height, work_width, work_height, dx, dy;
+    HDWP hDWP;
+    POINT pt;
+
+    TRACE("(%p,0x%08x,%p,%u,%p)\n", hwndParent, wFlags, lpRect, cKids, lpKids);
+
+    top = GetTopWindow(hwndParent);
+
+    ZeroMemory(&info, sizeof(info));
+    info.desktop = GetDesktopWindow();
+    info.tray_wnd = FindWindowW(shelltray, NULL);
+    info.progman = FindWindowW(progman, NULL);
+    info.parent = hwndParent;
+    info.flags = wFlags;
+
+    if (cKids == 0 || lpKids == NULL)
+    {
+        info.top = top;
+        EnumChildWindows(hwndParent, GetCascadeChildProc, (LPARAM)&info);
+
+        info.top = NULL;
+        GetCascadeChildProc(top, (LPARAM)&info);
+    }
+    else
+    {
+        info.wnd_count = cKids;
+        info.wnd_array = (HWND *)lpKids;
+    }
+
+    if (info.wnd_count == 0 || info.wnd_array == NULL)
+        return ret;
+
+    if (lpRect)
+    {
+        work_rect = *lpRect;
+    }
+    else if (hwndParent)
+    {
+        GetClientRect(hwndParent, &work_rect);
+    }
+    else
+    {
+        pt.x = pt.y = 0;
+        monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
+        mi.cbSize = sizeof(mi);
+        GetMonitorInfoW(monitor, &mi);
+        work_rect = mi.rcWork;
+    }
+
+    hDWP = BeginDeferWindowPos(info.wnd_count);
+    if (hDWP == NULL)
+        goto cleanup;
+
+    x = work_rect.left;
+    y = work_rect.top;
+    dx = GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXSIZE);
+    dy = GetSystemMetrics(SM_CYSIZEFRAME) + GetSystemMetrics(SM_CYSIZE);
+    work_width = work_rect.right - work_rect.left;
+    work_height = work_rect.bottom - work_rect.top;
+    prev = NULL;
+    for (i = info.wnd_count; i > 0;)    /* in reverse order */
+    {
+        --i;
+        hwnd = info.wnd_array[i];
+
+        if (!IsWindowVisible(hwnd) || IsIconic(hwnd))
+            continue;
+
+        if ((info.flags & MDITILE_SKIPDISABLED) && !IsWindowEnabled(hwnd))
+            continue;
+
+        if (IsZoomed(hwnd))
+            NtUserShowWindow(hwnd, SW_RESTORE | SW_SHOWNA);
+
+        GetWindowRect(hwnd, &wnd_rect);
+        new_width = width = wnd_rect.right - wnd_rect.left;
+        new_height = height = wnd_rect.bottom - wnd_rect.top;
+
+        /* if we can change the window size and it is not only one */
+        if (info.wnd_count != 1 && (GetWindowLongPtrW(hwnd, GWL_STYLE) & WS_THICKFRAME))
+        {
+            /* check the size */
+#define THRESHOLD(xy) (((xy) * 5) / 7)      /* in the rate 5/7 */
+            new_width = min(new_width, THRESHOLD(work_width));
+            new_height = min(new_height, THRESHOLD(work_height));
+#undef THRESHOLD
+            if (width != new_width || height != new_height)
+            {
+                /* too large. shrink if we can */
+                if (QuerySizeFix(hwnd, &new_width, &new_height))
+                {
+                    width = new_width;
+                    height = new_height;
+                }
+            }
+        }
+
+        if (x + width > work_rect.right)
+            x = work_rect.left;
+        if (y + height > work_rect.bottom)
+            y = work_rect.top;
+
+        hDWP = DeferWindowPos(hDWP, hwnd, HWND_TOP, x, y, width, height, SWP_NOACTIVATE);
+        if (hDWP == NULL)
+        {
+            ret = 0;
+            goto cleanup;
+        }
+
+        x += dx;
+        y += dy;
+        prev = hwnd;
+        ++ret;
+    }
+
+    EndDeferWindowPos(hDWP);
+
+    if (prev)
+        SetForegroundWindow(prev);
+
+cleanup:
+    heap_free(info.wnd_array);
+
+    return (WORD)ret;
 }
 
 

From 1245fdb96c9290412444b7fca49c20b142ff18cc Mon Sep 17 00:00:00 2001
From: Hirofumi Katayama <katayama.hirofumi.mz@gmail.com>
Date: Mon, 26 Nov 2018 09:09:52 +0900
Subject: [PATCH 128/244] user32: Implement TileWindows

Wine lacks the implementations of TileWindows
function of window arrangement.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46197
Signed-off-by: Hirofumi Katayama <katayama.hirofumi.mz@gmail.com>
---
 dlls/user32/mdi.c | 179 ++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 175 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/mdi.c b/dlls/user32/mdi.c
index f6b0aaa59bf..318e64d72e1 100644
--- a/dlls/user32/mdi.c
+++ b/dlls/user32/mdi.c
@@ -132,6 +132,10 @@ typedef struct
 
 static HBITMAP hBmpClose   = 0;
 
+static WCHAR shelltray[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
+static WCHAR progman[] = {'P','r','o','g','m','a','n',0};
+
+
 /* ----------------- declarations ----------------- */
 static void MDI_UpdateFrameText( HWND, HWND, BOOL, LPCWSTR);
 static BOOL MDI_AugmentFrameMenu( HWND, HWND );
@@ -1881,8 +1885,6 @@ WORD WINAPI
 CascadeWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 		UINT cKids, const HWND *lpKids)
 {
-    static WCHAR shelltray[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
-    static WCHAR progman[] = {'P','r','o','g','m','a','n',0};
     CASCADE_INFO info;
     HWND hwnd, top, prev;
     HMONITOR monitor;
@@ -2036,8 +2038,177 @@ WORD WINAPI
 TileWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 	     UINT cKids, const HWND *lpKids)
 {
-    FIXME("(%p,0x%08x,...,%u,...): stub\n", hwndParent, wFlags, cKids);
-    return 0;
+    HWND hwnd, hwndTop, hwndPrev;
+    CASCADE_INFO info;
+    RECT rcWork, rcWnd;
+    DWORD i, iRow, iColumn, cRows, cColumns, ret = 0;
+    INT x, y, cx, cy, cxNew, cyNew, cxWork, cyWork, cxCell, cyCell, cxMin2, cyMin3;
+    HDWP hDWP;
+    MONITORINFO mi;
+    HMONITOR hMon;
+    POINT pt;
+
+    TRACE("(%p,0x%08x,...,%u,...)\n", hwndParent, wFlags, cKids);
+
+    hwndTop = GetTopWindow(hwndParent);
+
+    ZeroMemory(&info, sizeof(info));
+    info.desktop = GetDesktopWindow();
+    info.tray_wnd = FindWindowW(shelltray, NULL);
+    info.progman = FindWindowW(progman, NULL);
+    info.parent = hwndParent;
+    info.flags = wFlags;
+
+    if (cKids == 0 || lpKids == NULL)
+    {
+        info.top = hwndTop;
+        EnumChildWindows(hwndParent, GetCascadeChildProc, (LPARAM)&info);
+
+        info.top = NULL;
+        GetCascadeChildProc(hwndTop, (LPARAM)&info);
+    }
+    else
+    {
+        info.wnd_count = cKids;
+        info.wnd_array = (HWND *)lpKids;
+    }
+
+    if (info.wnd_count == 0 || info.wnd_array == NULL)
+        return ret;
+
+    if (lpRect)
+    {
+        rcWork = *lpRect;
+    }
+    else if (hwndParent)
+    {
+        GetClientRect(hwndParent, &rcWork);
+    }
+    else
+    {
+        pt.x = pt.y = 0;
+        hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
+        mi.cbSize = sizeof(mi);
+        GetMonitorInfoW(hMon, &mi);
+        rcWork = mi.rcWork;
+    }
+
+    cxWork = rcWork.right - rcWork.left;
+    cyWork = rcWork.bottom - rcWork.top;
+
+    cxMin2 = GetSystemMetrics(SM_CXMIN) * 2;
+    cyMin3 = GetSystemMetrics(SM_CYMIN) * 3;
+
+    /* calculate the numbers and widths of columns and rows */
+    if (info.flags & MDITILE_HORIZONTAL)
+    {
+        cColumns = info.wnd_count;
+        cRows = 1;
+        for (;;)
+        {
+            cxCell = cxWork / cColumns;
+            cyCell = cyWork / cRows;
+            if (cyCell <= cyMin3 || cxCell >= cxMin2)
+                break;
+
+            ++cRows;
+            cColumns = (info.wnd_count + cRows - 1) / cRows;
+        }
+    }
+    else
+    {
+        cRows = info.wnd_count;
+        cColumns = 1;
+        for (;;)
+        {
+            cxCell = cxWork / cColumns;
+            cyCell = cyWork / cRows;
+            if (cxCell <= cxMin2 || cyCell >= cyMin3)
+                break;
+
+            ++cColumns;
+            cRows = (info.wnd_count + cColumns - 1) / cColumns;
+        }
+    }
+
+    hDWP = BeginDeferWindowPos(info.wnd_count);
+    if (hDWP == NULL)
+        goto cleanup;
+
+    x = rcWork.left;
+    y = rcWork.top;
+    hwndPrev = NULL;
+    iRow = iColumn = 0;
+    for (i = info.wnd_count; i > 0;)    /* in reverse order */
+    {
+        --i;
+        hwnd = info.wnd_array[i];
+
+        if (IsZoomed(hwnd))
+            NtUserShowWindow(hwnd, SW_RESTORE | SW_SHOWNA);
+
+        GetWindowRect(hwnd, &rcWnd);
+        cx = rcWnd.right - rcWnd.left;
+        cy = rcWnd.bottom - rcWnd.top;
+
+        /* if we can change the window size */
+        if (GetWindowLongPtrW(hwnd, GWL_STYLE) & WS_THICKFRAME)
+        {
+            cxNew = cxCell;
+            cyNew = cyCell;
+            /* shrink if we can */
+            if (QuerySizeFix(hwnd, &cxNew, &cyNew))
+            {
+                cx = cxNew;
+                cy = cyNew;
+            }
+        }
+
+        hDWP = DeferWindowPos(hDWP, hwnd, HWND_TOP, x, y, cx, cy, SWP_NOACTIVATE);
+        if (hDWP == NULL)
+        {
+            ret = 0;
+            goto cleanup;
+        }
+
+        if (info.flags & MDITILE_HORIZONTAL)
+        {
+            x += cxCell;
+            ++iColumn;
+            if (iColumn >= cColumns)
+            {
+                iColumn = 0;
+                ++iRow;
+                x = rcWork.left;
+                y += cyCell;
+            }
+        }
+        else
+        {
+            y += cyCell;
+            ++iRow;
+            if (iRow >= cRows)
+            {
+                iRow = 0;
+                ++iColumn;
+                x += cxCell;
+                y = rcWork.top;
+            }
+        }
+        hwndPrev = hwnd;
+        ++ret;
+    }
+
+    EndDeferWindowPos(hDWP);
+
+    if (hwndPrev)
+        SetForegroundWindow(hwndPrev);
+
+cleanup:
+    if (cKids == 0 || lpKids == NULL)
+        HeapFree(GetProcessHeap(), 0, info.wnd_array);
+
+    return (WORD)ret;
 }
 
 

From ba768e971a9e0773532414b389040da4f23ccbb2 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 18 May 2016 18:08:24 +0800
Subject: [PATCH 129/244] user32: Add a workaround for Windows 3.1 apps which
 call LoadImage(LR_LOADFROMFILE) with a resource id. (v2)

Fixes #24963.
---
 dlls/user32/cursoricon.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/cursoricon.c b/dlls/user32/cursoricon.c
index 0bfaca130d7..59642fafe96 100644
--- a/dlls/user32/cursoricon.c
+++ b/dlls/user32/cursoricon.c
@@ -1376,7 +1376,12 @@ static HICON CURSORICON_Load(HINSTANCE hInstance, LPCWSTR name,
           hInstance, debugstr_w(name), width, height, depth, fCursor, loadflags);
 
     if ( loadflags & LR_LOADFROMFILE )    /* Load from file */
-        return CURSORICON_LoadFromFile( name, width, height, depth, fCursor, loadflags );
+    {
+        if (IS_INTRESOURCE(name) && GetProcessVersion(0) < 0x40000)
+            WARN("Windows 3.1 app set LR_LOADFROMFILE without a name, fallback to loading from resource\n");
+        else
+            return CURSORICON_LoadFromFile( name, width, height, depth, fCursor, loadflags );
+    }
 
     if (!hInstance) hInstance = user32_module;  /* Load OEM cursor/icon */
 

From c66ad1c09866d54ab2626951c2b4d6bdc16c17d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 27 Sep 2015 03:30:43 +0200
Subject: [PATCH 130/244] user32: Fix calculation of listbox size when
 horizontal scrollbar is present.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Michael Müller <michael@fds-team.de>
---
 dlls/user32/listbox.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/user32/listbox.c b/dlls/user32/listbox.c
index 9d6ad8a3c75..af9fbf4e49f 100644
--- a/dlls/user32/listbox.c
+++ b/dlls/user32/listbox.c
@@ -452,8 +452,11 @@ static void LISTBOX_UpdatePage( LB_DESCR *descr )
 static void LISTBOX_UpdateSize( LB_DESCR *descr )
 {
     RECT rect;
+    LONG style = GetWindowLongW( descr->self, GWL_STYLE );
 
     GetClientRect( descr->self, &rect );
+    if (style & WS_HSCROLL)
+        rect.bottom += GetSystemMetrics(SM_CYHSCROLL);
     descr->width  = rect.right - rect.left;
     descr->height = rect.bottom - rect.top;
     if (!(descr->style & LBS_NOINTEGRALHEIGHT) && !(descr->style & LBS_OWNERDRAWVARIABLE))

From 441e601f2feb8dfbdb02d0661b66f6bb95eca3ed Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sun, 27 Sep 2015 19:35:05 +0200
Subject: [PATCH 131/244] user32: Refresh MDI menus when
 DefMDIChildProc(WM_SETTEXT) is called.

---
 dlls/user32/mdi.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/user32/mdi.c b/dlls/user32/mdi.c
index 318e64d72e1..01cb09f15a6 100644
--- a/dlls/user32/mdi.c
+++ b/dlls/user32/mdi.c
@@ -1362,6 +1362,7 @@ LRESULT WINAPI DefMDIChildProcA( HWND hwnd, UINT message,
 	DefWindowProcA(hwnd, message, wParam, lParam);
 	if( ci->hwndChildMaximized == hwnd )
 	    MDI_UpdateFrameText( GetParent(client), client, TRUE, NULL );
+        MDI_RefreshMenu( ci );
         return 1; /* success. FIXME: check text length */
 
     case WM_GETMINMAXINFO:
@@ -1402,6 +1403,7 @@ LRESULT WINAPI DefMDIChildProcW( HWND hwnd, UINT message,
         DefWindowProcW(hwnd, message, wParam, lParam);
         if( ci->hwndChildMaximized == hwnd )
             MDI_UpdateFrameText( GetParent(client), client, TRUE, NULL );
+        MDI_RefreshMenu( ci );
         return 1; /* success. FIXME: check text length */
 
     case WM_GETMINMAXINFO:

From 50d5a984d56910a41cbe0f7dd54b40a2d6fa1894 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Fri, 12 Dec 2014 05:06:31 +0100
Subject: [PATCH 132/244] win32u: Fix return value of ScrollWindowEx for
 invisible windows.

---
 dlls/win32u/dce.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/win32u/dce.c b/dlls/win32u/dce.c
index 506f531a40a..6c8980c2ff2 100644
--- a/dlls/win32u/dce.c
+++ b/dlls/win32u/dce.c
@@ -2107,10 +2107,13 @@ INT WINAPI NtUserScrollWindowEx( HWND hwnd, INT dx, INT dy, const RECT *rect,
     rdw_flags = (flags & SW_ERASE) && (flags & SW_INVALIDATE) ?
         RDW_INVALIDATE | RDW_ERASE  : RDW_INVALIDATE;
 
-    if (!is_window_drawable( hwnd, TRUE )) return ERROR;
     hwnd = get_full_window_handle( hwnd );
 
-    get_client_rect( hwnd, &rc, get_thread_dpi() );
+    if (!is_window_drawable( hwnd, TRUE ))
+        SetRectEmpty( &rc );
+    else
+        get_client_rect( hwnd, &rc, get_thread_dpi() );
+    
     if (clip_rect) intersect_rect( &cliprc, &rc, clip_rect );
     else cliprc = rc;
 

From c2622966aa3f8aafbf216d7c806937aa89548fe0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Wed, 16 Sep 2020 17:35:09 +0300
Subject: [PATCH 133/244] user32: Fix messages sent on a window without
 WS_CHILD, but with an invisible parent, when it is shown.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Some applications depend on the fact that WM_WINDOWPOSCHANGING is sent
after WM_SHOWWINDOW when SetParent is called, even if the window ends up
not visible because its parent is not visible, and occurs when the window
itself does not have the WS_CHILD style set.

This also fixes a TODO message sequence, so that Wine matches Windows.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=40262
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/user32/tests/msg.c |  3 ++-
 dlls/win32u/window.c    | 11 +++++++----
 2 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 15f2dd9b58b..d1ec1b70491 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -18811,6 +18811,7 @@ static const struct message WmSetParentSeq_2[] = {
     { HCBT_ACTIVATE, hook|optional },
     { EVENT_SYSTEM_FOREGROUND, winevent_hook|wparam|lparam|optional, 0, 0 },
     { WM_WINDOWPOSCHANGING, sent|wparam|optional, SWP_NOSIZE|SWP_NOMOVE },
+    { WM_QUERYNEWPALETTE, sent|optional },
     { WM_NCACTIVATE, sent|wparam|optional, 1 },
     { WM_ACTIVATE, sent|wparam|optional, 1 },
     { HCBT_SETFOCUS, hook|optional },
@@ -18881,7 +18882,7 @@ static void test_SetParent(void)
 
     SetParent(popup, child);
     flush_events();
-    ok_sequence(WmSetParentSeq_2, "SetParent() visible WS_POPUP", TRUE);
+    ok_sequence(WmSetParentSeq_2, "SetParent() visible WS_POPUP", FALSE);
 
     ok(GetWindowLongA(popup, GWL_STYLE) & WS_VISIBLE, "WS_VISIBLE should be set\n");
     ok(!IsWindowVisible(popup), "IsWindowVisible() should return FALSE\n");
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index f94e46bdc43..27796d888c3 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -3673,8 +3673,11 @@ static BOOL fixup_swp_flags( WINDOWPOS *winpos, const RECT *old_window_rect, int
     if (winpos->cy < 0) winpos->cy = 0;
     else if (winpos->cy > 32767) winpos->cy = 32767;
 
-    parent = NtUserGetAncestor( winpos->hwnd, GA_PARENT );
-    if (!is_window_visible( parent )) winpos->flags |= SWP_NOREDRAW;
+    if (win->dwStyle & WS_CHILD)
+    {
+        parent = NtUserGetAncestor( winpos->hwnd, GA_PARENT );
+        if (!is_window_visible( parent )) winpos->flags |= SWP_NOREDRAW;
+    }
 
     if (win->dwStyle & WS_VISIBLE) winpos->flags &= ~SWP_SHOWWINDOW;
     else
@@ -4789,8 +4792,8 @@ static BOOL show_window( HWND hwnd, INT cmd )
     }
     swp = new_swp;
 
-    parent = NtUserGetAncestor( hwnd, GA_PARENT );
-    if (parent && !is_window_visible( parent ) && !(swp & SWP_STATECHANGED))
+        if ((style & WS_CHILD) && (parent = NtUserGetAncestor( hwnd, GA_PARENT )) &&
+        !is_window_visible( parent ) && !(swp & SWP_STATECHANGED))
     {
         /* if parent is not visible simply toggle WS_VISIBLE and return */
         if (show_flag) set_window_style( hwnd, WS_VISIBLE, 0 );

From 6b8cda6edfc9c2e0c5ce4ab20f1b1b03e709ad0c Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 6 Mar 2024 20:21:36 +1100
Subject: [PATCH 134/244] user32/msgbox: Support WM_COPY Message

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=17205

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/user32/msgbox.c          |  85 ++++++++++++++++-
 dlls/user32/tests/dialog.c    | 166 ++++++++++++++++++++++++++++++++++
 dlls/user32/tests/resource.rc |  11 +++
 3 files changed, 257 insertions(+), 5 deletions(-)

diff --git a/dlls/user32/msgbox.c b/dlls/user32/msgbox.c
index 4d345777a10..6b5d867eb1f 100644
--- a/dlls/user32/msgbox.c
+++ b/dlls/user32/msgbox.c
@@ -41,6 +41,11 @@ struct ThreadWindows
     HWND *handles;
 };
 
+/* Index the order the buttons need to appear to an ID* constant */
+static const int buttonOrder[10] = { IDYES, IDNO, IDOK, IDABORT, IDRETRY,
+                                 IDCANCEL, IDIGNORE, IDTRYAGAIN,
+                                 IDCONTINUE, IDHELP };
+
 static BOOL CALLBACK MSGBOX_EnumProc(HWND hwnd, LPARAM lParam)
 {
     struct ThreadWindows *threadWindows = (struct ThreadWindows *)lParam;
@@ -74,11 +79,6 @@ static void MSGBOX_OnInit(HWND hwnd, LPMSGBOXPARAMSW lpmb)
     WCHAR *buffer = NULL;
     const WCHAR *ptr;
 
-    /* Index the order the buttons need to appear to an ID* constant */
-    static const int buttonOrder[10] = { IDYES, IDNO, IDOK, IDABORT, IDRETRY,
-                                         IDCANCEL, IDIGNORE, IDTRYAGAIN,
-                                         IDCONTINUE, IDHELP };
-
     nclm.cbSize = sizeof(nclm);
     SystemParametersInfoW (SPI_GETNONCLIENTMETRICS, 0, &nclm, 0);
 
@@ -320,6 +320,76 @@ static void MSGBOX_OnInit(HWND hwnd, LPMSGBOXPARAMSW lpmb)
     HeapFree( GetProcessHeap(), 0, buffer );
 }
 
+static void MSGBOX_CopyToClipbaord( HWND hwnd )
+{
+    int i;
+    static const WCHAR line[] = L"---------------------------\r\n";
+    static const WCHAR carriage[] = L"\r\n";
+    static const WCHAR spaces[] = L"   ";
+    int lenTitle = GetWindowTextLengthW(hwnd) + 1;
+    int lenMsg = GetWindowTextLengthW(GetDlgItem(hwnd, MSGBOX_IDTEXT)) + 1;
+
+    /*
+    ---------------------------
+    Dialog Title
+    ---------------------------
+    Dialog Message
+    ---------------------------
+    Button(s) Text. OK
+    ---------------------------
+    */
+    int len = ((wcslen(carriage) * 3) + (wcslen(line) * 4) + lenTitle + lenMsg) * sizeof(WCHAR);
+    WCHAR *text = heap_alloc(len);
+    if(text)
+    {
+        lstrcpyW(text, line);
+        if (GetWindowTextW(hwnd, text + lstrlenW(text), lenTitle))
+        {
+            HGLOBAL hMem;
+            WCHAR *data;
+
+            lstrcatW(text, carriage);
+            lstrcatW(text, line);
+            GetWindowTextW(GetDlgItem(hwnd, MSGBOX_IDTEXT), text + lstrlenW(text), lenMsg);
+            lstrcatW(text, carriage);
+            lstrcatW(text, line);
+
+            for (i = 0; i < ARRAY_SIZE(buttonOrder); i++)
+            {
+                HWND hItem = GetDlgItem(hwnd, buttonOrder[i]);
+                if (GetWindowLongW(hItem, GWL_STYLE) & WS_VISIBLE)
+                {
+                    WCHAR buffer[1024] = {0};
+                    int j = 0, k = lstrlenW(text);
+                    GetWindowTextW(hItem, buffer, 1024);
+                    while(buffer[j] != 0)
+                    {
+                        if(buffer[j] != '&')
+                            text[k++] = buffer[j];
+                        j++;
+                    }
+                    text[k] = 0;
+                    lstrcatW(text, spaces);
+                }
+            }
+
+            lstrcatW(text, carriage);
+            lstrcatW(text, line);
+
+            hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE|GMEM_ZEROINIT, (len + 1) * sizeof(WCHAR));
+            data = GlobalLock(hMem);
+            lstrcpyW(data, text);
+            GlobalUnlock(hMem);
+
+            OpenClipboard(hwnd);
+            NtUserEmptyClipboard();
+            SetClipboardData(CF_UNICODETEXT, hMem);
+            NtUserCloseClipboard();
+        }
+
+        heap_free(text);
+    }
+}
 
 /**************************************************************************
  *           MSGBOX_DlgProc
@@ -338,6 +408,11 @@ static INT_PTR CALLBACK MSGBOX_DlgProc( HWND hwnd, UINT message,
        SetPropA(hwnd, "WINE_MSGBOX_HELPCALLBACK", mbp->lpfnMsgBoxCallback);
        break;
    }
+   case WM_COPY:
+   {
+        MSGBOX_CopyToClipbaord(hwnd);
+        break;
+   }
 
    case WM_COMMAND:
     switch (LOWORD(wParam))
diff --git a/dlls/user32/tests/dialog.c b/dlls/user32/tests/dialog.c
index 7ea0d13c0f3..41572b29ecc 100644
--- a/dlls/user32/tests/dialog.c
+++ b/dlls/user32/tests/dialog.c
@@ -2068,6 +2068,171 @@ static void test_MessageBoxFontTest(void)
     DestroyWindow(hDlg);
 }
 
+static const char msgbox_title[] = "%5!z9ZXw*ia;57n/FGl.bCH,Su\"mfKN;foCqAU\'j6AmoJgAc_D:Z0A\'E6PF_O/w";
+
+DWORD WINAPI WorkerThread(void *param)
+{
+    WCHAR *expected = param;
+    char windowTitle[sizeof(msgbox_title)];
+    HWND hwndMbox;
+    BOOL succeeded = FALSE;
+
+    Sleep(200);
+
+    hwndMbox = GetForegroundWindow();
+
+    /* Find the Window, if it doesn't have focus */
+    if (!(IsWindow(hwndMbox) &&
+        GetWindowTextA(hwndMbox, windowTitle, sizeof(msgbox_title)) &&
+        lstrcmpA(msgbox_title, windowTitle) == 0))
+    {
+        hwndMbox = FindWindowA(NULL, msgbox_title);
+        if (!IsWindow(hwndMbox))
+            goto cleanup;
+    }
+
+    SendMessageA(hwndMbox, WM_COPY, 0, 0);
+
+    if (IsClipboardFormatAvailable(CF_UNICODETEXT) && OpenClipboard(NULL))
+    {
+        HANDLE textHandle = GetClipboardData(CF_UNICODETEXT);
+        WCHAR *text = GlobalLock(textHandle);
+
+        if (text != NULL)
+        {
+            succeeded = lstrcmpW(expected, text) == 0;
+            if(!succeeded)
+            {
+                ok(0, "%s\n", wine_dbgstr_w(text));
+                ok(0, "%s\n", wine_dbgstr_w(expected));
+            }
+
+            GlobalUnlock(textHandle);
+        }
+        else
+            ok(0, "No text on clipboard.\n");
+
+        CloseClipboard();
+
+    }
+    else
+        trace("Clipboard error\n");
+
+    PostMessageA(hwndMbox, WM_COMMAND, IDIGNORE, 0); /* For MB_ABORTRETRYIGNORE dialog. */
+    PostMessageA(hwndMbox, WM_CLOSE, 0, 0);
+
+cleanup:
+    ok(succeeded, "Failed to get string.\n");
+
+    return 0;
+}
+
+static WCHAR *shell_get_resource_string(UINT id)
+{
+    const WCHAR *resource;
+    unsigned int size;
+    WCHAR *ret;
+
+    size = LoadStringW(NULL, id, (WCHAR *)&resource, 0);
+    ret = malloc((size + 1) * sizeof(WCHAR));
+    memcpy(ret, resource, size * sizeof(WCHAR));
+    ret[size] = 0;
+    return ret;
+}
+
+static WCHAR *create_msgbox_message(UINT res1, UINT res2, UINT res3)
+{
+    /*
+    ---------------------------
+    Dialog Title
+    ---------------------------
+    Dialog Message
+    ---------------------------
+    Button(s) Text. OK<+3 spaces>
+    ---------------------------
+    */
+    static WCHAR text[512];
+    WCHAR *btn1text = shell_get_resource_string(res1);
+
+    lstrcpyW(text, L"---------------------------\r\n");
+    lstrcatW(text, L"%5!z9ZXw*ia;57n/FGl.bCH,Su\"mfKN;foCqAU\'j6AmoJgAc_D:Z0A\'E6PF_O/w");
+    lstrcatW(text, L"\r\n");
+    lstrcatW(text, L"---------------------------\r\n");
+    lstrcatW(text, L"Message\r\n");
+    lstrcatW(text, L"---------------------------\r\n");
+
+    lstrcatW(text, btn1text);
+    lstrcatW(text, L"   ");
+    free(btn1text);
+
+    if (res2 != 0)
+    {
+        WCHAR *btn2text = shell_get_resource_string(res2);
+        lstrcatW(text, btn2text);
+        lstrcatW(text, L"   ");
+        free(btn2text);
+    }
+    if (res3 != 0)
+    {
+        WCHAR *btn3text = shell_get_resource_string(res3);
+        lstrcatW(text, btn3text);
+        lstrcatW(text, L"   ");
+        free(btn3text);
+    }
+    lstrcatW(text, L"\r\n---------------------------\r\n");
+
+    return text;
+}
+
+static void test_MessageBox_WM_COPY_Test(void)
+{
+    DWORD tid = 0;
+    WCHAR *expected;
+    HANDLE hthread;
+
+    expected = create_msgbox_message(102 /* OK */, 0, 0);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_OK);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+
+    expected = create_msgbox_message(102 /* OK */, 105 /* Cancel */, 0);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_OKCANCEL);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+
+    expected = create_msgbox_message(103 /* Abort */, 104 /* Retry */, 106 /* Ignore */);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_ABORTRETRYIGNORE);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+
+    expected = create_msgbox_message(100 /* Yes */, 101 /* No */, 0);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_YESNO);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+
+    expected = create_msgbox_message(100 /* Yes */, 101 /* No */, 105 /* Cancel */);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_YESNOCANCEL);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+
+    expected = create_msgbox_message(104 /* Retry */, 105 /* Cancel */, 0);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_RETRYCANCEL);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+
+    expected = create_msgbox_message(105 /* Cancel */, 107 /* Try again */, 108 /* Continue */);
+    hthread = CreateThread(NULL, 0, WorkerThread, expected, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_CANCELTRYCONTINUE);
+    ok(WaitForSingleObject(hthread, 2000) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+}
+
 static void test_SaveRestoreFocus(void)
 {
     HWND hDlg;
@@ -2440,6 +2605,7 @@ START_TEST(dialog)
 
     if (!RegisterWindowClasses()) assert(0);
 
+    test_MessageBox_WM_COPY_Test();
     test_dialog_custom_data();
     test_GetNextDlgItem();
     test_IsDialogMessage();
diff --git a/dlls/user32/tests/resource.rc b/dlls/user32/tests/resource.rc
index a957e50689d..5056386ff0e 100644
--- a/dlls/user32/tests/resource.rc
+++ b/dlls/user32/tests/resource.rc
@@ -42,6 +42,17 @@ STRINGTABLE
   0 "String resource"
   1 "Another string resource"
   2 L"This is a wide string resource"
+
+  100 "Yes"
+  101 "No"
+  102 "OK"
+  103 "Abort"
+  104 "Retry"
+  105 "Cancel"
+  106 "Ignore"
+  107 "Try Again"
+  108 "Continue"
+
   65534 "Test high id"
 }
 

From 96a7d5a569f8922a2655a651fda996c03a33ded0 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 6 Mar 2024 20:21:36 +1100
Subject: [PATCH 135/244] user32/msgbox: Use a windows hook to trap Ctrl+C

---
 dlls/user32/msgbox.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/dlls/user32/msgbox.c b/dlls/user32/msgbox.c
index 6b5d867eb1f..bf28413f39d 100644
--- a/dlls/user32/msgbox.c
+++ b/dlls/user32/msgbox.c
@@ -391,6 +391,22 @@ static void MSGBOX_CopyToClipbaord( HWND hwnd )
     }
 }
 
+HHOOK msghook_handle;
+
+LRESULT CALLBACK msg_hook_proc(int nCode, WPARAM wParam, LPARAM lParam)
+{
+    MSG *msg = (MSG *)lParam;
+    if (nCode == MSGF_DIALOGBOX && msg->message == WM_KEYUP)
+    {
+        if ( (msg->wParam == 'C' || msg->wParam == 'c') && (NtUserGetKeyState(VK_CONTROL) & 0x8000))
+        {
+            MSGBOX_CopyToClipbaord(GetParent(msg->hwnd));
+        }
+    }
+
+    return NtUserCallNextHookEx(msghook_handle, nCode, wParam, lParam);
+}
+
 /**************************************************************************
  *           MSGBOX_DlgProc
  *
@@ -406,6 +422,7 @@ static INT_PTR CALLBACK MSGBOX_DlgProc( HWND hwnd, UINT message,
        SetWindowContextHelpId(hwnd, mbp->dwContextHelpId);
        MSGBOX_OnInit(hwnd, mbp);
        SetPropA(hwnd, "WINE_MSGBOX_HELPCALLBACK", mbp->lpfnMsgBoxCallback);
+       msghook_handle = SetWindowsHookExA(WH_MSGFILTER, msg_hook_proc, NULL, GetCurrentThreadId());
        break;
    }
    case WM_COPY:
@@ -413,6 +430,9 @@ static INT_PTR CALLBACK MSGBOX_DlgProc( HWND hwnd, UINT message,
         MSGBOX_CopyToClipbaord(hwnd);
         break;
    }
+   case WM_DESTROY:
+       NtUserUnhookWindowsHookEx(msghook_handle);
+       break;
 
    case WM_COMMAND:
     switch (LOWORD(wParam))

From be64e016886b27e3e97d11db65ebdb6d75ab9066 Mon Sep 17 00:00:00 2001
From: Ben Shefte <shefben@gmail.com>
Date: Wed, 1 Mar 2023 07:37:52 +1100
Subject: [PATCH 136/244] vcomp: Implement _vcomp_for_dynamic_init_i8

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52012
---
 dlls/vcomp/main.c           | 135 ++++++++++++++++++++++++++++++++++++
 dlls/vcomp/vcomp.spec       |   6 +-
 dlls/vcomp100/vcomp100.spec |   6 +-
 dlls/vcomp110/vcomp110.spec |   6 +-
 dlls/vcomp120/vcomp120.spec |   6 +-
 dlls/vcomp140/vcomp140.spec |   6 +-
 dlls/vcomp90/vcomp90.spec   |   6 +-
 7 files changed, 153 insertions(+), 18 deletions(-)

diff --git a/dlls/vcomp/main.c b/dlls/vcomp/main.c
index 451e47e9f9e..e3be001d302 100644
--- a/dlls/vcomp/main.c
+++ b/dlls/vcomp/main.c
@@ -880,6 +880,26 @@ double CDECL omp_get_wtime(void)
     return GetTickCount() / 1000.0;
 }
 
+/*****************************************************
+*      omp_get_wtick - Taken from:
+*      https://gist.github.com/Randl/45bcca59720f661fa033a67d5f44bff0
+*/
+double CDECL omp_get_wtick (void)
+{
+     /*return GetTickCount();*/
+    FILETIME createTime;
+    FILETIME exitTime;
+    FILETIME kernelTime;
+    FILETIME userTime;
+    ULARGE_INTEGER li;
+
+    GetProcessTimes(GetCurrentProcess(), &createTime, &exitTime, &kernelTime, &userTime);
+    li.LowPart = userTime.dwLowDateTime;
+    li.HighPart = userTime.dwHighDateTime;
+
+    return (double)li.QuadPart / 10000000.0;
+}
+
 void CDECL omp_set_dynamic(int val)
 {
     TRACE("(%d): stub\n", val);
@@ -1332,6 +1352,77 @@ void CDECL _vcomp_for_dynamic_init(unsigned int flags, unsigned int first, unsig
     }
 }
 
+void CDECL _vcomp_for_dynamic_init_i8(ULONG64 flags, ULONG64 first, ULONG64 last,
+                                   ULONG64 step, ULONG64 chunksize)
+{
+    ULONG64 iterations, per_thread, remaining;
+    struct vcomp_thread_data *thread_data = vcomp_init_thread_data();
+    struct vcomp_team_data *team_data = thread_data->team;
+    struct vcomp_task_data *task_data = thread_data->task;
+    LONG64 num_threads = team_data ? team_data->num_threads : 1;
+    LONG64 thread_num = thread_data->thread_num;
+    unsigned int type = flags & ~VCOMP_DYNAMIC_FLAGS_INCREMENT;
+
+    TRACE("(%llu, %llu, %llu, %lld, %llu)\n", flags, first, last, step, chunksize);
+
+    if (step <= 0)
+    {
+        thread_data->dynamic_type = 0;
+        return;
+    }
+
+    if (flags & VCOMP_DYNAMIC_FLAGS_INCREMENT)
+        iterations = 1 + (last - first) / step;
+    else
+    {
+        iterations = 1 + (first - last) / step;
+        step *= -1;
+    }
+
+    if (type == VCOMP_DYNAMIC_FLAGS_STATIC)
+    {
+        per_thread = iterations / num_threads;
+        remaining  = iterations - per_thread * num_threads;
+
+        if (thread_num < remaining)
+            per_thread++;
+        else if (per_thread)
+            first += remaining * step;
+        else
+        {
+            thread_data->dynamic_type = 0;
+            return;
+        }
+
+        thread_data->dynamic_type   = VCOMP_DYNAMIC_FLAGS_STATIC;
+        thread_data->dynamic_begin  = first + per_thread * thread_num * step;
+        thread_data->dynamic_end    = thread_data->dynamic_begin + (per_thread - 1) * step;
+    }
+    else
+    {
+        if (type != VCOMP_DYNAMIC_FLAGS_CHUNKED &&
+            type != VCOMP_DYNAMIC_FLAGS_GUIDED)
+        {
+            FIXME("unsupported flags %llu\n", flags);
+            type = VCOMP_DYNAMIC_FLAGS_GUIDED;
+        }
+
+        EnterCriticalSection(&vcomp_section);
+        thread_data->dynamic++;
+        thread_data->dynamic_type = type;
+        if ((LONG64)(thread_data->dynamic - task_data->dynamic) > 0)
+        {
+            task_data->dynamic              = thread_data->dynamic;
+            task_data->dynamic_first        = first;
+            task_data->dynamic_last         = last;
+            task_data->dynamic_iterations   = iterations;
+            task_data->dynamic_step         = step;
+            task_data->dynamic_chunksize    = chunksize;
+        }
+        LeaveCriticalSection(&vcomp_section);
+    }
+}
+
 int CDECL _vcomp_for_dynamic_next(unsigned int *begin, unsigned int *end)
 {
     struct vcomp_thread_data *thread_data = vcomp_init_thread_data();
@@ -1376,6 +1467,50 @@ int CDECL _vcomp_for_dynamic_next(unsigned int *begin, unsigned int *end)
     return 0;
 }
 
+LONG64 CDECL _vcomp_for_dynamic_next_i8(LONG64 *begin, LONG64 *end)
+{
+    struct vcomp_thread_data *thread_data = vcomp_init_thread_data();
+    struct vcomp_task_data *task_data = thread_data->task;
+    struct vcomp_team_data *team_data = thread_data->team;
+    LONG64 num_threads = team_data ? team_data->num_threads : 1;
+
+    TRACE("(%p, %p)\n", begin, end);
+
+    if (thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_STATIC)
+    {
+        *begin = thread_data->dynamic_begin;
+        *end   = thread_data->dynamic_end;
+        thread_data->dynamic_type = 0;
+        return 1;
+    }
+    else if (thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_CHUNKED ||
+             thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_GUIDED)
+    {
+        unsigned int iterations = 0;
+        EnterCriticalSection(&vcomp_section);
+        if (thread_data->dynamic == task_data->dynamic &&
+            task_data->dynamic_iterations != 0)
+        {
+            iterations = min(task_data->dynamic_iterations, task_data->dynamic_chunksize);
+            if (thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_GUIDED &&
+                task_data->dynamic_iterations > num_threads * task_data->dynamic_chunksize)
+            {
+                iterations = (task_data->dynamic_iterations + num_threads - 1) / num_threads;
+            }
+            *begin = task_data->dynamic_first;
+            *end   = task_data->dynamic_first + (iterations - 1) * task_data->dynamic_step;
+            task_data->dynamic_iterations -= iterations;
+            task_data->dynamic_first      += iterations * task_data->dynamic_step;
+            if (!task_data->dynamic_iterations)
+                *end = task_data->dynamic_last;
+        }
+        LeaveCriticalSection(&vcomp_section);
+        return iterations != 0;
+    }
+
+    return 0;
+}
+
 int CDECL omp_in_parallel(void)
 {
     TRACE("()\n");
diff --git a/dlls/vcomp/vcomp.spec b/dlls/vcomp/vcomp.spec
index fb67146e058..09bf45550d5 100644
--- a/dlls/vcomp/vcomp.spec
+++ b/dlls/vcomp/vcomp.spec
@@ -56,9 +56,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64)
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr)
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -96,7 +96,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick()
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp100/vcomp100.spec b/dlls/vcomp100/vcomp100.spec
index fb67146e058..9aa43e3ba4b 100644
--- a/dlls/vcomp100/vcomp100.spec
+++ b/dlls/vcomp100/vcomp100.spec
@@ -56,9 +56,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -96,7 +96,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp110/vcomp110.spec b/dlls/vcomp110/vcomp110.spec
index e1cb8ab9931..d8b4d3e3f16 100644
--- a/dlls/vcomp110/vcomp110.spec
+++ b/dlls/vcomp110/vcomp110.spec
@@ -57,9 +57,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -97,7 +97,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp120/vcomp120.spec b/dlls/vcomp120/vcomp120.spec
index e1cb8ab9931..d8b4d3e3f16 100644
--- a/dlls/vcomp120/vcomp120.spec
+++ b/dlls/vcomp120/vcomp120.spec
@@ -57,9 +57,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -97,7 +97,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp140/vcomp140.spec b/dlls/vcomp140/vcomp140.spec
index e1cb8ab9931..d8b4d3e3f16 100644
--- a/dlls/vcomp140/vcomp140.spec
+++ b/dlls/vcomp140/vcomp140.spec
@@ -57,9 +57,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -97,7 +97,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp90/vcomp90.spec b/dlls/vcomp90/vcomp90.spec
index 9fac400ea0e..563f5391ed9 100644
--- a/dlls/vcomp90/vcomp90.spec
+++ b/dlls/vcomp90/vcomp90.spec
@@ -56,9 +56,9 @@
 @ cdecl _vcomp_enter_critsect(ptr) vcomp._vcomp_enter_critsect
 @ cdecl _vcomp_flush() vcomp._vcomp_flush
 @ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr) vcomp._vcomp_for_dynamic_next
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init_i8
@@ -96,7 +96,7 @@
 @ cdecl omp_get_num_procs() vcomp.omp_get_num_procs
 @ cdecl omp_get_num_threads() vcomp.omp_get_num_threads
 @ cdecl omp_get_thread_num() vcomp.omp_get_thread_num
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime() vcomp.omp_get_wtime
 @ cdecl omp_in_parallel() vcomp.omp_in_parallel
 @ cdecl omp_init_lock(ptr) vcomp.omp_init_lock

From 43f1e8e3392bc6936d0f4ffb9cd12099af4641d2 Mon Sep 17 00:00:00 2001
From: Mark Jansen <learn0more+wine@gmail.com>
Date: Fri, 27 Feb 2015 21:24:58 +0100
Subject: [PATCH 137/244] version: Test for VerQueryValueA (try 2)

This patch supersedes both '[2/2] version: Test for VerQueryValueA'
and '[1/2] version: Fix wrong length reported when selecting a block.
(resend 2)', as it is a better tests, and proves the fix to not work
fully.

The patch shows a difference in handling between wine's VerQueryValue,
and windows' VerQueryValue when selecting a 'BLOCK' object.

Implemented pointer checking and commented the binary structure as
suggested by nsivov from #winehackers.
---
 dlls/version/tests/info.c | 124 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 124 insertions(+)

diff --git a/dlls/version/tests/info.c b/dlls/version/tests/info.c
index 61ff05b2559..30bf08880c7 100644
--- a/dlls/version/tests/info.c
+++ b/dlls/version/tests/info.c
@@ -572,6 +572,129 @@ static void test_VerQueryValueA(void)
     HeapFree(GetProcessHeap(), 0, ver);
 }
 
+static void test_VerQueryValue_InvalidLength(void)
+{
+    /* this buffer is created with the reactos resource compiler from this resource:
+#include "winver.h"
+
+VS_VERSION_INFO VERSIONINFO
+FILEVERSION    1,0,0,0
+PRODUCTVERSION 1,0,0,0
+FILEFLAGSMASK  63
+FILEFLAGS      0
+FILEOS         VOS_UNKNOWN
+FILETYPE       VFT_APP
+FILESUBTYPE    VFT2_UNKNOWN
+{
+    BLOCK "StringFileInfo"
+    {
+    }
+}
+*/
+    char preparedbuffer[] = {
+        /* VS_VERSION_INFO_STRUCT32 */
+        0x80, 0x00,     /* wLength */
+        0x34, 0x00,     /* wValueLength */
+        0x00, 0x00,     /* wType */
+        /* L"VS_VERSION_INFO" + DWORD alignment */
+        0x56, 0x00, 0x53, 0x00, 0x5f, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4f,
+        0x00, 0x4e, 0x00, 0x5f, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x46, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+        /* VS_FIXEDFILEINFO */
+        0xbd, 0x04, 0xef, 0xfe,     /* dwSignature */
+        0x00, 0x00, 0x01, 0x00,     /* dwStrucVersion */
+        0x00, 0x00, 0x01, 0x00,     /* dwFileVersionMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileVersionLS */
+        0x00, 0x00, 0x01, 0x00,     /* dwProductVersionMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwProductVersionLS */
+        0x3f, 0x00, 0x00, 0x00,     /* dwFileFlagsMask */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileFlags */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileOS */
+        0x01, 0x00, 0x00, 0x00,     /* dwFileType */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileSubtype */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileDateMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileDateLS */
+
+        /* first child: */
+            0x24, 0x00,     /* wLength */
+            0x00, 0x00,     /* wValueLength */
+            0x01, 0x00,     /* wType */
+            /* L"StringFileInfo" + DWORD alignment */
+            0x53, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x46, 0x00, 0x69, 0x00,
+            0x6c, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x00, 0x00,
+            /* "FE2X" */
+            0x46, 0x45, 0x32, 0x58,
+
+            /* Extra bytes allocated for W->A conversions. */
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+    };
+    char *p;
+    UINT len, ret;
+    WCHAR FileDescriptionW[] = { '\\', '\\', 'S', 't', 'r', 'i', 'n', 'g', 'F', 'i', 'l', 'e', 'I', 'n', 'f', 'o', 0 };
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "\\StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "\\\\StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    /* also test the W versions. */
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW + 2, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW + 1, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+}
+
 static void test_extra_block(void)
 {
     WORD extra_block[] = {
@@ -731,6 +854,7 @@ START_TEST(info)
     test_info();
     test_32bit_win();
     test_VerQueryValueA();
+    test_VerQueryValue_InvalidLength();
     test_extra_block();
     test_GetFileVersionInfoEx();
 }

From 94b4009cc28c9ffe19462487df2f313941d0e41b Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 29 Nov 2024 07:14:57 +1100
Subject: [PATCH 138/244] Updated vkd3d to
 c7e173a1ffa1ba6916dd549bf9f32225440d1ec6.

---
 libs/vkd3d/include/private/vkd3d_common.h     |    2 +-
 libs/vkd3d/include/vkd3d_shader.h             |  219 +
 libs/vkd3d/libs/vkd3d-common/blob.c           |    1 +
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c        |  335 +-
 libs/vkd3d/libs/vkd3d-shader/d3dbc.c          | 1118 ++---
 libs/vkd3d/libs/vkd3d-shader/dxbc.c           |   35 +
 libs/vkd3d/libs/vkd3d-shader/dxil.c           |   87 +-
 libs/vkd3d/libs/vkd3d-shader/fx.c             |  175 +-
 libs/vkd3d/libs/vkd3d-shader/glsl.c           |    9 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.c           |  387 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.h           |  158 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.l           |    3 +
 libs/vkd3d/libs/vkd3d-shader/hlsl.y           |  671 ++-
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c   | 3839 ++++++++++++++---
 .../libs/vkd3d-shader/hlsl_constant_ops.c     |  363 +-
 libs/vkd3d/libs/vkd3d-shader/ir.c             | 2094 +++++++--
 libs/vkd3d/libs/vkd3d-shader/msl.c            |  465 +-
 libs/vkd3d/libs/vkd3d-shader/preproc.l        |    1 +
 libs/vkd3d/libs/vkd3d-shader/spirv.c          |  760 ++--
 libs/vkd3d/libs/vkd3d-shader/tpf.c            | 2232 +---------
 .../libs/vkd3d-shader/vkd3d_shader_main.c     |   34 +-
 .../libs/vkd3d-shader/vkd3d_shader_private.h  |   86 +-
 libs/vkd3d/libs/vkd3d/command.c               |  273 +-
 libs/vkd3d/libs/vkd3d/device.c                |   59 +-
 libs/vkd3d/libs/vkd3d/state.c                 |  242 +-
 libs/vkd3d/libs/vkd3d/vkd3d_private.h         |   63 +-
 26 files changed, 8687 insertions(+), 5024 deletions(-)

diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index ec1dd70c9b2..fd62730f948 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -275,7 +275,7 @@ static inline unsigned int vkd3d_popcount(unsigned int v)
 {
 #ifdef _MSC_VER
     return __popcnt(v);
-#elif defined(__MINGW32__)
+#elif defined(HAVE_BUILTIN_POPCOUNT)
     return __builtin_popcount(v);
 #else
     v -= (v >> 1) & 0x55555555;
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index f95caa2f825..af55d63a5c8 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -112,6 +112,11 @@ enum vkd3d_shader_structure_type
      * \since 1.13
      */
     VKD3D_SHADER_STRUCTURE_TYPE_PARAMETER_INFO,
+    /**
+     * The structure is a vkd3d_shader_scan_hull_shader_tessellation_info structure.
+     * \since 1.15
+     */
+    VKD3D_SHADER_STRUCTURE_TYPE_SCAN_HULL_SHADER_TESSELLATION_INFO,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_STRUCTURE_TYPE),
 };
@@ -471,6 +476,109 @@ enum vkd3d_shader_binding_flag
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_BINDING_FLAG),
 };
 
+/**
+ * The factor used to interpolate the fragment output colour with fog.
+ *
+ * See VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE for specification of the
+ * interpolation factor as defined here.
+ *
+ * The following variables may be used to determine the interpolation factor:
+ *
+ * c = The fog coordinate value output from the vertex shader. This is an
+ *     inter-stage varying with the semantic name "FOG" and semantic index 0.
+ *     It may be modified by VKD3D_SHADER_PARAMETER_NAME_FOG_SOURCE.
+ * E = The value of VKD3D_SHADER_PARAMETER_NAME_FOG_END.
+ * k = The value of VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE.
+ *
+ * \since 1.15
+ */
+enum vkd3d_shader_fog_fragment_mode
+{
+    /**
+     * No fog interpolation is applied;
+     * the output colour is passed through unmodified.
+     * Equivalently, the fog interpolation factor is 1.
+     */
+    VKD3D_SHADER_FOG_FRAGMENT_NONE = 0x0,
+    /**
+     * The fog interpolation factor is 2^-(k * c).
+     *
+     * In order to implement traditional exponential fog, as present in
+     * Direct3D and OpenGL, i.e.
+     *
+     *     e^-(density * c)
+     *
+     * set
+     *
+     *     k = density * log₂(e)
+     */
+    VKD3D_SHADER_FOG_FRAGMENT_EXP = 0x1,
+    /**
+     * The fog interpolation factor is 2^-((k * c)²).
+     *
+     * In order to implement traditional square-exponential fog, as present in
+     * Direct3D and OpenGL, i.e.
+     *
+     *     e^-((density * c)²)
+     *
+     * set
+     *
+     *     k = density * √log₂(e)
+     */
+    VKD3D_SHADER_FOG_FRAGMENT_EXP2 = 0x2,
+    /**
+     * The fog interpolation factor is (E - c) * k.
+     *
+     * In order to implement traditional linear fog, as present in Direct3D and
+     * OpenGL, i.e.
+     *
+     *     (end - c) / (end - start)
+     *
+     * set
+     *
+     *     E = end
+     *     k = 1 / (end - start)
+     */
+    VKD3D_SHADER_FOG_FRAGMENT_LINEAR = 0x3,
+};
+
+/**
+ * The source of the fog varying output by a pre-rasterization shader.
+ * The fog varying is defined as the output varying with the semantic name "FOG"
+ * and semantic index 0.
+ *
+ * See VKD3D_SHADER_PARAMETER_NAME_FOG_SOURCE for further documentation of this
+ * parameter.
+ *
+ * \since 1.15
+ */
+enum vkd3d_shader_fog_source
+{
+    /**
+     * The source shader is not modified. That is, the fog varying in the target
+     * shader is the original fog varying if and only if present.
+     */
+    VKD3D_SHADER_FOG_SOURCE_FOG = 0x0,
+    /**
+     * If the source shader has a fog varying, it is not modified.
+     * Otherwise, if the source shader outputs a varying with semantic name
+     * "COLOR" and semantic index 1 whose index includes a W component,
+     * said W component is output as fog varying.
+     * Otherwise, no fog varying is output.
+     */
+    VKD3D_SHADER_FOG_SOURCE_FOG_OR_SPECULAR_W = 0x1,
+    /**
+     * The fog source is the Z component of the position output by the vertex
+     * shader.
+     */
+    VKD3D_SHADER_FOG_SOURCE_Z = 0x2,
+    /**
+     * The fog source is the W component of the position output by the vertex
+     * shader.
+     */
+    VKD3D_SHADER_FOG_SOURCE_W = 0x3,
+};
+
 /**
  * The manner in which a parameter value is provided to the shader, used in
  * struct vkd3d_shader_parameter and struct vkd3d_shader_parameter1.
@@ -734,6 +842,97 @@ enum vkd3d_shader_parameter_name
      * \since 1.14
      */
     VKD3D_SHADER_PARAMETER_NAME_POINT_SPRITE,
+    /**
+     * Fog mode used in fragment shaders.
+     *
+     * The value specified by this parameter must be a member of
+     * enum vkd3d_shader_fog_fragment_mode.
+     *
+     * If not VKD3D_SHADER_FOG_FRAGMENT_NONE, the pixel shader colour output at
+     * location 0 is linearly interpolated with the fog colour defined by
+     * VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR. The interpolation factor is
+     * defined according to the enumerant selected by this parameter.
+     * The interpolated value is then outputted instead of the original value at
+     * location 0.
+     *
+     * An interpolation factor of 0 specifies to use the fog colour; a factor of
+     * 1 specifies to use the original colour output. The interpolation factor
+     * is clamped to the [0, 1] range before interpolating.
+     *
+     * The default value is VKD3D_SHADER_FOG_FRAGMENT_NONE.
+     *
+     * The data type for this parameter must be
+     * VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32.
+     *
+     * Only VKD3D_SHADER_PARAMETER_TYPE_IMMEDIATE_CONSTANT is supported in this
+     * version of vkd3d-shader.
+     *
+     * \since 1.15
+     */
+    VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE,
+    /**
+     * Fog colour.
+     * See VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE for documentation of
+     * fog.
+     *
+     * The data type for this parameter must be
+     * VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32_VEC4.
+     *
+     * The default value is transparent black, i.e. the vector {0, 0, 0, 0}.
+     *
+     * \since 1.15
+     */
+    VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR,
+    /**
+     * End coordinate for linear fog.
+     * See VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE for documentation of
+     * fog.
+     *
+     * The data type for this parameter must be
+     * VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32.
+     *
+     * The default value is 1.0.
+     *
+     * \since 1.15
+     */
+    VKD3D_SHADER_PARAMETER_NAME_FOG_END,
+    /**
+     * Scale value for fog.
+     * See VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE for documentation of
+     * fog.
+     *
+     * The data type for this parameter must be
+     * VKD3D_SHADER_PARAMETER_DATA_TYPE_FLOAT32.
+     *
+     * The default value is 1.0.
+     *
+     * \since 1.15
+     */
+    VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE,
+    /**
+     * Fog source. The value specified by this parameter must be a member of
+     * enum vkd3d_shader_fog_source.
+     *
+     * This parameter replaces or suppletes the fog varying output by a
+     * pre-rasterization shader. The fog varying is defined as the output
+     * varying with the semantic name "FOG" and semantic index 0.
+     *
+     * Together with other fog parameters, this parameter can be used to
+     * implement fixed function fog, as present in Direct3D versions up to 9,
+     * if the target environment does not support fog as part of its own
+     * fixed-function API (as Vulkan and core OpenGL).
+     *
+     * The default value is VKD3D_SHADER_FOG_SOURCE_FOG.
+     *
+     * The data type for this parameter must be
+     * VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32.
+     *
+     * Only VKD3D_SHADER_PARAMETER_TYPE_IMMEDIATE_CONSTANT is supported in this
+     * version of vkd3d-shader.
+     *
+     * \since 1.15
+     */
+    VKD3D_SHADER_PARAMETER_NAME_FOG_SOURCE,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_PARAMETER_NAME),
 };
@@ -2040,6 +2239,26 @@ struct vkd3d_shader_scan_combined_resource_sampler_info
     unsigned int combined_sampler_count;
 };
 
+/**
+ * A chained structure describing the tessellation information in a hull shader.
+ *
+ * This structure extends vkd3d_shader_compile_info.
+ *
+ * \since 1.15
+ */
+struct vkd3d_shader_scan_hull_shader_tessellation_info
+{
+    /** Must be set to VKD3D_SHADER_STRUCTURE_TYPE_SCAN_HULL_SHADER_TESSELLATION_INFO. */
+    enum vkd3d_shader_structure_type type;
+    /** Optional pointer to a structure containing further parameters. */
+    const void *next;
+
+    /** The tessellation output primitive. */
+    enum vkd3d_shader_tessellator_output_primitive output_primitive;
+    /** The tessellation partitioning mode. */
+    enum vkd3d_shader_tessellator_partitioning partitioning;
+};
+
 /**
  * Data type of a shader varying, returned as part of struct
  * vkd3d_shader_signature_element.
diff --git a/libs/vkd3d/libs/vkd3d-common/blob.c b/libs/vkd3d/libs/vkd3d-common/blob.c
index f60ef7db769..c2c6ad67804 100644
--- a/libs/vkd3d/libs/vkd3d-common/blob.c
+++ b/libs/vkd3d/libs/vkd3d-common/blob.c
@@ -20,6 +20,7 @@
 #define WIDL_C_INLINE_WRAPPERS
 #endif
 #define COBJMACROS
+
 #define CONST_VTABLE
 #include "vkd3d.h"
 #include "vkd3d_blob.h"
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 7c5444f63a3..69e14e0c7bf 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -49,7 +49,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_BFREV                           ] = "bfrev",
     [VKD3DSIH_BRANCH                          ] = "branch",
     [VKD3DSIH_BREAK                           ] = "break",
-    [VKD3DSIH_BREAKC                          ] = "breakc",
+    [VKD3DSIH_BREAKC                          ] = "break",
     [VKD3DSIH_BREAKP                          ] = "breakp",
     [VKD3DSIH_BUFINFO                         ] = "bufinfo",
     [VKD3DSIH_CALL                            ] = "call",
@@ -183,7 +183,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_IDIV                            ] = "idiv",
     [VKD3DSIH_IEQ                             ] = "ieq",
     [VKD3DSIH_IF                              ] = "if",
-    [VKD3DSIH_IFC                             ] = "ifc",
+    [VKD3DSIH_IFC                             ] = "if",
     [VKD3DSIH_IGE                             ] = "ige",
     [VKD3DSIH_ILT                             ] = "ilt",
     [VKD3DSIH_IMAD                            ] = "imad",
@@ -354,6 +354,64 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_XOR                             ] = "xor",
 };
 
+static const char * const shader_register_names[] =
+{
+    [VKD3DSPR_ADDR              ] = "a",
+    [VKD3DSPR_ATTROUT           ] = "oD",
+    [VKD3DSPR_COLOROUT          ] = "oC",
+    [VKD3DSPR_COMBINED_SAMPLER  ] = "s",
+    [VKD3DSPR_CONST             ] = "c",
+    [VKD3DSPR_CONSTBOOL         ] = "b",
+    [VKD3DSPR_CONSTBUFFER       ] = "cb",
+    [VKD3DSPR_CONSTINT          ] = "i",
+    [VKD3DSPR_COVERAGE          ] = "vCoverage",
+    [VKD3DSPR_DEPTHOUT          ] = "oDepth",
+    [VKD3DSPR_DEPTHOUTGE        ] = "oDepthGE",
+    [VKD3DSPR_DEPTHOUTLE        ] = "oDepthLE",
+    [VKD3DSPR_FORKINSTID        ] = "vForkInstanceId",
+    [VKD3DSPR_FUNCTIONBODY      ] = "fb",
+    [VKD3DSPR_FUNCTIONPOINTER   ] = "fp",
+    [VKD3DSPR_GROUPSHAREDMEM    ] = "g",
+    [VKD3DSPR_GSINSTID          ] = "vGSInstanceID",
+    [VKD3DSPR_IDXTEMP           ] = "x",
+    [VKD3DSPR_IMMCONST          ] = "l",
+    [VKD3DSPR_IMMCONST64        ] = "d",
+    [VKD3DSPR_IMMCONSTBUFFER    ] = "icb",
+    [VKD3DSPR_INCONTROLPOINT    ] = "vicp",
+    [VKD3DSPR_INPUT             ] = "v",
+    [VKD3DSPR_JOININSTID        ] = "vJoinInstanceId",
+    [VKD3DSPR_LABEL             ] = "l",
+    [VKD3DSPR_LOCALTHREADID     ] = "vThreadIDInGroup",
+    [VKD3DSPR_LOCALTHREADINDEX  ] = "vThreadIDInGroupFlattened",
+    [VKD3DSPR_LOOP              ] = "aL",
+    [VKD3DSPR_NULL              ] = "null",
+    [VKD3DSPR_OUTCONTROLPOINT   ] = "vocp",
+    [VKD3DSPR_OUTPOINTID        ] = "vOutputControlPointID",
+    [VKD3DSPR_OUTPUT            ] = "o",
+    [VKD3DSPR_OUTSTENCILREF     ] = "oStencilRef",
+    [VKD3DSPR_PARAMETER         ] = "parameter",
+    [VKD3DSPR_PATCHCONST        ] = "vpc",
+    [VKD3DSPR_POINT_COORD       ] = "vPointCoord",
+    [VKD3DSPR_PREDICATE         ] = "p",
+    [VKD3DSPR_PRIMID            ] = "primID",
+    [VKD3DSPR_RASTERIZER        ] = "rasterizer",
+    [VKD3DSPR_RESOURCE          ] = "t",
+    [VKD3DSPR_SAMPLEMASK        ] = "oMask",
+    [VKD3DSPR_SAMPLER           ] = "s",
+    [VKD3DSPR_SSA               ] = "sr",
+    [VKD3DSPR_STREAM            ] = "m",
+    [VKD3DSPR_TEMP              ] = "r",
+    [VKD3DSPR_TESSCOORD         ] = "vDomainLocation",
+    [VKD3DSPR_TEXCRDOUT         ] = "oT",
+    [VKD3DSPR_TEXTURE           ] = "t",
+    [VKD3DSPR_THREADGROUPID     ] = "vThreadGroupID",
+    [VKD3DSPR_THREADID          ] = "vThreadID",
+    [VKD3DSPR_UAV               ] = "u",
+    [VKD3DSPR_UNDEF             ] = "undef",
+    [VKD3DSPR_WAVELANECOUNT     ] = "vWaveLaneCount",
+    [VKD3DSPR_WAVELANEINDEX     ] = "vWaveLaneIndex",
+};
+
 struct vkd3d_d3d_asm_colours
 {
     const char *reset;
@@ -377,22 +435,6 @@ struct vkd3d_d3d_asm_compiler
     const struct vkd3d_shader_instruction *current;
 };
 
-/* Convert floating point offset relative to a register file to an absolute
- * offset for float constants. */
-static unsigned int shader_get_float_offset(enum vkd3d_shader_register_type register_type, UINT register_idx)
-{
-    switch (register_type)
-    {
-        case VKD3DSPR_CONST: return register_idx;
-        case VKD3DSPR_CONST2: return 2048 + register_idx;
-        case VKD3DSPR_CONST3: return 4096 + register_idx;
-        case VKD3DSPR_CONST4: return 6144 + register_idx;
-        default:
-            FIXME("Unsupported register type: %u.\n", register_type);
-            return register_idx;
-    }
-}
-
 static void shader_dump_global_flags(struct vkd3d_d3d_asm_compiler *compiler, enum vsir_global_flags global_flags)
 {
     unsigned int i;
@@ -815,7 +857,7 @@ static void shader_print_dcl_usage(struct vkd3d_d3d_asm_compiler *compiler,
             usage = "tessfactor";
             break;
         case VKD3D_DECL_USAGE_POSITIONT:
-            usage = "positionT";
+            usage = "positiont";
             indexed = true;
             break;
         case VKD3D_DECL_USAGE_FOG:
@@ -966,82 +1008,10 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
             reg->type == VKD3DSPR_LABEL ? compiler->colours.label : compiler->colours.reg);
     switch (reg->type)
     {
-        case VKD3DSPR_TEMP:
-            vkd3d_string_buffer_printf(buffer, "r");
-            break;
-
-        case VKD3DSPR_INPUT:
-            vkd3d_string_buffer_printf(buffer, "v");
-            break;
-
-        case VKD3DSPR_CONST:
-        case VKD3DSPR_CONST2:
-        case VKD3DSPR_CONST3:
-        case VKD3DSPR_CONST4:
-            vkd3d_string_buffer_printf(buffer, "c");
-            offset = shader_get_float_offset(reg->type, offset);
-            break;
-
-        case VKD3DSPR_TEXTURE: /* vs: case VKD3DSPR_ADDR */
-            vkd3d_string_buffer_printf(buffer, "%c",
-                    compiler->shader_version.type == VKD3D_SHADER_TYPE_PIXEL ? 't' : 'a');
-            break;
-
         case VKD3DSPR_RASTOUT:
             vkd3d_string_buffer_printf(buffer, "%s", rastout_reg_names[offset]);
             break;
 
-        case VKD3DSPR_COLOROUT:
-            vkd3d_string_buffer_printf(buffer, "oC");
-            break;
-
-        case VKD3DSPR_DEPTHOUT:
-            vkd3d_string_buffer_printf(buffer, "oDepth");
-            break;
-
-        case VKD3DSPR_DEPTHOUTGE:
-            vkd3d_string_buffer_printf(buffer, "oDepthGE");
-            break;
-
-        case VKD3DSPR_DEPTHOUTLE:
-            vkd3d_string_buffer_printf(buffer, "oDepthLE");
-            break;
-
-        case VKD3DSPR_ATTROUT:
-            vkd3d_string_buffer_printf(buffer, "oD");
-            break;
-
-        case VKD3DSPR_TEXCRDOUT:
-            /* Vertex shaders >= 3.0 use general purpose output registers
-             * (VKD3DSPR_OUTPUT), which can include an address token. */
-            if (vkd3d_shader_ver_ge(&compiler->shader_version, 3, 0))
-                vkd3d_string_buffer_printf(buffer, "o");
-            else
-                vkd3d_string_buffer_printf(buffer, "oT");
-            break;
-
-        case VKD3DSPR_CONSTINT:
-            vkd3d_string_buffer_printf(buffer, "i");
-            break;
-
-        case VKD3DSPR_CONSTBOOL:
-            vkd3d_string_buffer_printf(buffer, "b");
-            break;
-
-        case VKD3DSPR_LABEL:
-            vkd3d_string_buffer_printf(buffer, "l");
-            break;
-
-        case VKD3DSPR_LOOP:
-            vkd3d_string_buffer_printf(buffer, "aL");
-            break;
-
-        case VKD3DSPR_COMBINED_SAMPLER:
-        case VKD3DSPR_SAMPLER:
-            vkd3d_string_buffer_printf(buffer, "s");
-            is_descriptor = true;
-            break;
-
         case VKD3DSPR_MISCTYPE:
             if (offset > 1)
                 vkd3d_string_buffer_printf(buffer, "%s<unhandled misctype %#x>%s",
@@ -1050,156 +1020,20 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
                 vkd3d_string_buffer_printf(buffer, "%s", misctype_reg_names[offset]);
             break;
 
-        case VKD3DSPR_PREDICATE:
-            vkd3d_string_buffer_printf(buffer, "p");
-            break;
-
-        case VKD3DSPR_IMMCONST:
-            vkd3d_string_buffer_printf(buffer, "l");
-            break;
-
-        case VKD3DSPR_IMMCONST64:
-            vkd3d_string_buffer_printf(buffer, "d");
-            break;
-
+        case VKD3DSPR_COMBINED_SAMPLER:
+        case VKD3DSPR_SAMPLER:
         case VKD3DSPR_CONSTBUFFER:
-            vkd3d_string_buffer_printf(buffer, "cb");
-            is_descriptor = true;
-            break;
-
-        case VKD3DSPR_IMMCONSTBUFFER:
-            vkd3d_string_buffer_printf(buffer, "icb");
-            break;
-
-        case VKD3DSPR_PRIMID:
-            vkd3d_string_buffer_printf(buffer, "primID");
-            break;
-
-        case VKD3DSPR_NULL:
-            vkd3d_string_buffer_printf(buffer, "null");
-            break;
-
-        case VKD3DSPR_RASTERIZER:
-            vkd3d_string_buffer_printf(buffer, "rasterizer");
-            break;
-
         case VKD3DSPR_RESOURCE:
-            vkd3d_string_buffer_printf(buffer, "t");
-            is_descriptor = true;
-            break;
-
         case VKD3DSPR_UAV:
-            vkd3d_string_buffer_printf(buffer, "u");
             is_descriptor = true;
-            break;
-
-        case VKD3DSPR_OUTPOINTID:
-            vkd3d_string_buffer_printf(buffer, "vOutputControlPointID");
-            break;
-
-        case VKD3DSPR_FORKINSTID:
-            vkd3d_string_buffer_printf(buffer, "vForkInstanceId");
-            break;
-
-        case VKD3DSPR_JOININSTID:
-            vkd3d_string_buffer_printf(buffer, "vJoinInstanceId");
-            break;
-
-        case VKD3DSPR_INCONTROLPOINT:
-            vkd3d_string_buffer_printf(buffer, "vicp");
-            break;
-
-        case VKD3DSPR_OUTCONTROLPOINT:
-            vkd3d_string_buffer_printf(buffer, "vocp");
-            break;
-
-        case VKD3DSPR_PATCHCONST:
-            vkd3d_string_buffer_printf(buffer, "vpc");
-            break;
-
-        case VKD3DSPR_TESSCOORD:
-            vkd3d_string_buffer_printf(buffer, "vDomainLocation");
-            break;
-
-        case VKD3DSPR_GROUPSHAREDMEM:
-            vkd3d_string_buffer_printf(buffer, "g");
-            break;
-
-        case VKD3DSPR_THREADID:
-            vkd3d_string_buffer_printf(buffer, "vThreadID");
-            break;
-
-        case VKD3DSPR_THREADGROUPID:
-            vkd3d_string_buffer_printf(buffer, "vThreadGroupID");
-            break;
-
-        case VKD3DSPR_LOCALTHREADID:
-            vkd3d_string_buffer_printf(buffer, "vThreadIDInGroup");
-            break;
-
-        case VKD3DSPR_LOCALTHREADINDEX:
-            vkd3d_string_buffer_printf(buffer, "vThreadIDInGroupFlattened");
-            break;
-
-        case VKD3DSPR_IDXTEMP:
-            vkd3d_string_buffer_printf(buffer, "x");
-            break;
-
-        case VKD3DSPR_STREAM:
-            vkd3d_string_buffer_printf(buffer, "m");
-            break;
-
-        case VKD3DSPR_FUNCTIONBODY:
-            vkd3d_string_buffer_printf(buffer, "fb");
-            break;
-
-        case VKD3DSPR_FUNCTIONPOINTER:
-            vkd3d_string_buffer_printf(buffer, "fp");
-            break;
-
-        case VKD3DSPR_COVERAGE:
-            vkd3d_string_buffer_printf(buffer, "vCoverage");
-            break;
-
-        case VKD3DSPR_SAMPLEMASK:
-            vkd3d_string_buffer_printf(buffer, "oMask");
-            break;
-
-        case VKD3DSPR_GSINSTID:
-            vkd3d_string_buffer_printf(buffer, "vGSInstanceID");
-            break;
-
-        case VKD3DSPR_OUTSTENCILREF:
-            vkd3d_string_buffer_printf(buffer, "oStencilRef");
-            break;
-
-        case VKD3DSPR_UNDEF:
-            vkd3d_string_buffer_printf(buffer, "undef");
-            break;
-
-        case VKD3DSPR_SSA:
-            vkd3d_string_buffer_printf(buffer, "sr");
-            break;
-
-        case VKD3DSPR_WAVELANECOUNT:
-            vkd3d_string_buffer_printf(buffer, "vWaveLaneCount");
-            break;
-
-        case VKD3DSPR_WAVELANEINDEX:
-            vkd3d_string_buffer_printf(buffer, "vWaveLaneIndex");
-            break;
-
-        case VKD3DSPR_PARAMETER:
-            vkd3d_string_buffer_printf(buffer, "parameter");
-            break;
-
-        case VKD3DSPR_POINT_COORD:
-            vkd3d_string_buffer_printf(buffer, "vPointCoord");
-            break;
+            /* fall through */
 
         default:
-            vkd3d_string_buffer_printf(buffer, "%s<unhandled register type %#x>%s",
-                    compiler->colours.error, reg->type, compiler->colours.reset);
+            if (reg->type < ARRAY_SIZE(shader_register_names) && shader_register_names[reg->type])
+                vkd3d_string_buffer_printf(buffer, "%s", shader_register_names[reg->type]);
+            else
+                vkd3d_string_buffer_printf(buffer, "%s<unhandled register type %#x>%s",
+                        compiler->colours.error, reg->type, compiler->colours.reset);
             break;
     }
 
@@ -2132,8 +1966,7 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
 
         case VKD3DSIH_DEF:
             vkd3d_string_buffer_printf(buffer, " %sc%u%s", compiler->colours.reg,
-                    shader_get_float_offset(ins->dst[0].reg.type, ins->dst[0].reg.idx[0].offset),
-                    compiler->colours.reset);
+                    ins->dst[0].reg.idx[0].offset, compiler->colours.reset);
             shader_print_float_literal(compiler, " = ", ins->src[0].reg.u.immconst_f32[0], "");
             shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_f32[1], "");
             shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_f32[2], "");
@@ -2547,6 +2380,33 @@ static void trace_signature(const struct shader_signature *signature, const char
     vkd3d_string_buffer_cleanup(&buffer);
 }
 
+static void trace_io_declarations(const struct vsir_program *program)
+{
+    struct vkd3d_string_buffer buffer;
+    bool empty = true;
+    unsigned int i;
+
+    vkd3d_string_buffer_init(&buffer);
+
+    vkd3d_string_buffer_printf(&buffer, "Input/output declarations:");
+
+    for (i = 0; i < sizeof(program->io_dcls) * CHAR_BIT; ++i)
+    {
+        if (bitmap_is_set(program->io_dcls, i))
+        {
+            empty = false;
+            vkd3d_string_buffer_printf(&buffer, " %u", i);
+        }
+    }
+
+    if (empty)
+        vkd3d_string_buffer_printf(&buffer, " empty");
+
+    TRACE("%s\n", buffer.buffer);
+
+    vkd3d_string_buffer_cleanup(&buffer);
+}
+
 void vsir_program_trace(const struct vsir_program *program)
 {
     const unsigned int flags = VSIR_ASM_FLAG_DUMP_TYPES | VSIR_ASM_FLAG_DUMP_ALL_INDICES;
@@ -2556,6 +2416,7 @@ void vsir_program_trace(const struct vsir_program *program)
     trace_signature(&program->input_signature, "Input");
     trace_signature(&program->output_signature, "Output");
     trace_signature(&program->patch_constant_signature, "Patch-constant");
+    trace_io_declarations(program);
 
     if (d3d_asm_compile(program, NULL, &code, flags) != VKD3D_OK)
         return;
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 9e2eacbcfa6..58e35cf22e8 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -8,7 +8,7 @@
  * Copyright 2006 Ivan Gyurdiev
  * Copyright 2007-2008 Stefan Dösinger for CodeWeavers
  * Copyright 2009, 2021 Henri Verbeet for CodeWeavers
- * Copyright 2019-2020 Zebediah Figura for CodeWeavers
+ * Copyright 2019-2020, 2023-2024 Elizabeth Figura for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -25,7 +25,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "hlsl.h"
+#include "vkd3d_shader_private.h"
 
 #define VKD3D_SM1_VS  0xfffeu
 #define VKD3D_SM1_PS  0xffffu
@@ -89,6 +89,32 @@
 #define VKD3D_SM1_VERSION_MAJOR(version)       (((version) >> 8u) & 0xffu)
 #define VKD3D_SM1_VERSION_MINOR(version)       (((version) >> 0u) & 0xffu)
 
+enum vkd3d_sm1_register_type
+{
+    VKD3D_SM1_REG_TEMP              = 0x00,
+    VKD3D_SM1_REG_INPUT             = 0x01,
+    VKD3D_SM1_REG_CONST             = 0x02,
+    VKD3D_SM1_REG_ADDR              = 0x03,
+    VKD3D_SM1_REG_TEXTURE           = 0x03,
+    VKD3D_SM1_REG_RASTOUT           = 0x04,
+    VKD3D_SM1_REG_ATTROUT           = 0x05,
+    VKD3D_SM1_REG_TEXCRDOUT         = 0x06,
+    VKD3D_SM1_REG_OUTPUT            = 0x06,
+    VKD3D_SM1_REG_CONSTINT          = 0x07,
+    VKD3D_SM1_REG_COLOROUT          = 0x08,
+    VKD3D_SM1_REG_DEPTHOUT          = 0x09,
+    VKD3D_SM1_REG_SAMPLER           = 0x0a,
+    VKD3D_SM1_REG_CONST2            = 0x0b,
+    VKD3D_SM1_REG_CONST3            = 0x0c,
+    VKD3D_SM1_REG_CONST4            = 0x0d,
+    VKD3D_SM1_REG_CONSTBOOL         = 0x0e,
+    VKD3D_SM1_REG_LOOP              = 0x0f,
+    VKD3D_SM1_REG_TEMPFLOAT16       = 0x10,
+    VKD3D_SM1_REG_MISCTYPE          = 0x11,
+    VKD3D_SM1_REG_LABEL             = 0x12,
+    VKD3D_SM1_REG_PREDICATE         = 0x13,
+};
+
 enum vkd3d_sm1_address_mode_type
 {
     VKD3D_SM1_ADDRESS_MODE_ABSOLUTE = 0x0,
@@ -235,7 +261,7 @@ static const struct vkd3d_sm1_opcode_info vs_opcode_table[] =
     /* Arithmetic */
     {VKD3D_SM1_OP_NOP,          0, 0, VKD3DSIH_NOP},
     {VKD3D_SM1_OP_MOV,          1, 1, VKD3DSIH_MOV},
-    {VKD3D_SM1_OP_MOVA,         1, 1, VKD3DSIH_MOVA,         {2, 0}, {~0u, ~0u}},
+    {VKD3D_SM1_OP_MOVA,         1, 1, VKD3DSIH_MOVA,         {2, 0}},
     {VKD3D_SM1_OP_ADD,          1, 2, VKD3DSIH_ADD},
     {VKD3D_SM1_OP_SUB,          1, 2, VKD3DSIH_SUB},
     {VKD3D_SM1_OP_MAD,          1, 3, VKD3DSIH_MAD},
@@ -248,22 +274,22 @@ static const struct vkd3d_sm1_opcode_info vs_opcode_table[] =
     {VKD3D_SM1_OP_MAX,          1, 2, VKD3DSIH_MAX},
     {VKD3D_SM1_OP_SLT,          1, 2, VKD3DSIH_SLT},
     {VKD3D_SM1_OP_SGE,          1, 2, VKD3DSIH_SGE},
-    {VKD3D_SM1_OP_ABS,          1, 1, VKD3DSIH_ABS},
+    {VKD3D_SM1_OP_ABS,          1, 1, VKD3DSIH_ABS,          {2, 0}},
     {VKD3D_SM1_OP_EXP,          1, 1, VKD3DSIH_EXP},
     {VKD3D_SM1_OP_LOG,          1, 1, VKD3DSIH_LOG},
     {VKD3D_SM1_OP_EXPP,         1, 1, VKD3DSIH_EXPP},
     {VKD3D_SM1_OP_LOGP,         1, 1, VKD3DSIH_LOGP},
     {VKD3D_SM1_OP_LIT,          1, 1, VKD3DSIH_LIT},
     {VKD3D_SM1_OP_DST,          1, 2, VKD3DSIH_DST},
-    {VKD3D_SM1_OP_LRP,          1, 3, VKD3DSIH_LRP},
+    {VKD3D_SM1_OP_LRP,          1, 3, VKD3DSIH_LRP,          {2, 0}},
     {VKD3D_SM1_OP_FRC,          1, 1, VKD3DSIH_FRC},
-    {VKD3D_SM1_OP_POW,          1, 2, VKD3DSIH_POW},
-    {VKD3D_SM1_OP_CRS,          1, 2, VKD3DSIH_CRS},
-    {VKD3D_SM1_OP_SGN,          1, 3, VKD3DSIH_SGN,          {2, 0}, {  2,   1}},
-    {VKD3D_SM1_OP_SGN,          1, 1, VKD3DSIH_SGN,          {3, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_NRM,          1, 1, VKD3DSIH_NRM,},
-    {VKD3D_SM1_OP_SINCOS,       1, 3, VKD3DSIH_SINCOS,       {2, 0}, {  2,   1}},
-    {VKD3D_SM1_OP_SINCOS,       1, 1, VKD3DSIH_SINCOS,       {3, 0}, {~0u, ~0u}},
+    {VKD3D_SM1_OP_POW,          1, 2, VKD3DSIH_POW,          {2, 0}},
+    {VKD3D_SM1_OP_CRS,          1, 2, VKD3DSIH_CRS,          {2, 0}},
+    {VKD3D_SM1_OP_SGN,          1, 3, VKD3DSIH_SGN,          {2, 0}, {2, 1}},
+    {VKD3D_SM1_OP_SGN,          1, 1, VKD3DSIH_SGN,          {3, 0}},
+    {VKD3D_SM1_OP_NRM,          1, 1, VKD3DSIH_NRM,          {2, 0}},
+    {VKD3D_SM1_OP_SINCOS,       1, 3, VKD3DSIH_SINCOS,       {2, 0}, {2, 1}},
+    {VKD3D_SM1_OP_SINCOS,       1, 1, VKD3DSIH_SINCOS,       {3, 0}},
     /* Matrix */
     {VKD3D_SM1_OP_M4x4,         1, 2, VKD3DSIH_M4x4},
     {VKD3D_SM1_OP_M4x3,         1, 2, VKD3DSIH_M4x3},
@@ -274,27 +300,27 @@ static const struct vkd3d_sm1_opcode_info vs_opcode_table[] =
     {VKD3D_SM1_OP_DCL,          0, 0, VKD3DSIH_DCL},
     /* Constant definitions */
     {VKD3D_SM1_OP_DEF,          1, 1, VKD3DSIH_DEF},
-    {VKD3D_SM1_OP_DEFB,         1, 1, VKD3DSIH_DEFB},
-    {VKD3D_SM1_OP_DEFI,         1, 1, VKD3DSIH_DEFI},
+    {VKD3D_SM1_OP_DEFB,         1, 1, VKD3DSIH_DEFB,         {2, 0}},
+    {VKD3D_SM1_OP_DEFI,         1, 1, VKD3DSIH_DEFI,         {2, 0}},
     /* Control flow */
-    {VKD3D_SM1_OP_REP,          0, 1, VKD3DSIH_REP,          {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ENDREP,       0, 0, VKD3DSIH_ENDREP,       {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_IF,           0, 1, VKD3DSIH_IF,           {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_IFC,          0, 2, VKD3DSIH_IFC,          {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ELSE,         0, 0, VKD3DSIH_ELSE,         {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ENDIF,        0, 0, VKD3DSIH_ENDIF,        {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_BREAK,        0, 0, VKD3DSIH_BREAK,        {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_BREAKC,       0, 2, VKD3DSIH_BREAKC,       {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_BREAKP,       0, 1, VKD3DSIH_BREAKP},
-    {VKD3D_SM1_OP_CALL,         0, 1, VKD3DSIH_CALL,         {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_CALLNZ,       0, 2, VKD3DSIH_CALLNZ,       {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_LOOP,         0, 2, VKD3DSIH_LOOP,         {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_RET,          0, 0, VKD3DSIH_RET,          {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ENDLOOP,      0, 0, VKD3DSIH_ENDLOOP,      {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_LABEL,        0, 1, VKD3DSIH_LABEL,        {2, 0}, {~0u, ~0u}},
-
-    {VKD3D_SM1_OP_SETP,         1, 2, VKD3DSIH_SETP},
-    {VKD3D_SM1_OP_TEXLDL,       1, 2, VKD3DSIH_TEXLDL,       {3, 0}, {~0u, ~0u}},
+    {VKD3D_SM1_OP_REP,          0, 1, VKD3DSIH_REP,          {2, 0}},
+    {VKD3D_SM1_OP_ENDREP,       0, 0, VKD3DSIH_ENDREP,       {2, 0}},
+    {VKD3D_SM1_OP_IF,           0, 1, VKD3DSIH_IF,           {2, 0}},
+    {VKD3D_SM1_OP_IFC,          0, 2, VKD3DSIH_IFC,          {2, 1}},
+    {VKD3D_SM1_OP_ELSE,         0, 0, VKD3DSIH_ELSE,         {2, 0}},
+    {VKD3D_SM1_OP_ENDIF,        0, 0, VKD3DSIH_ENDIF,        {2, 0}},
+    {VKD3D_SM1_OP_BREAK,        0, 0, VKD3DSIH_BREAK,        {2, 1}},
+    {VKD3D_SM1_OP_BREAKC,       0, 2, VKD3DSIH_BREAKC,       {2, 1}},
+    {VKD3D_SM1_OP_BREAKP,       0, 1, VKD3DSIH_BREAKP,       {2, 1}},
+    {VKD3D_SM1_OP_CALL,         0, 1, VKD3DSIH_CALL,         {2, 0}},
+    {VKD3D_SM1_OP_CALLNZ,       0, 2, VKD3DSIH_CALLNZ,       {2, 0}},
+    {VKD3D_SM1_OP_LOOP,         0, 2, VKD3DSIH_LOOP,         {2, 0}},
+    {VKD3D_SM1_OP_RET,          0, 0, VKD3DSIH_RET,          {2, 0}},
+    {VKD3D_SM1_OP_ENDLOOP,      0, 0, VKD3DSIH_ENDLOOP,      {2, 0}},
+    {VKD3D_SM1_OP_LABEL,        0, 1, VKD3DSIH_LABEL,        {2, 0}},
+
+    {VKD3D_SM1_OP_SETP,         1, 2, VKD3DSIH_SETP,         {2, 1}},
+    {VKD3D_SM1_OP_TEXLDL,       1, 2, VKD3DSIH_TEXLDL,       {3, 0}},
     {0,                         0, 0, VKD3DSIH_INVALID},
 };
 
@@ -307,92 +333,115 @@ static const struct vkd3d_sm1_opcode_info ps_opcode_table[] =
     {VKD3D_SM1_OP_SUB,          1, 2, VKD3DSIH_SUB},
     {VKD3D_SM1_OP_MAD,          1, 3, VKD3DSIH_MAD},
     {VKD3D_SM1_OP_MUL,          1, 2, VKD3DSIH_MUL},
-    {VKD3D_SM1_OP_RCP,          1, 1, VKD3DSIH_RCP},
-    {VKD3D_SM1_OP_RSQ,          1, 1, VKD3DSIH_RSQ},
+    {VKD3D_SM1_OP_RCP,          1, 1, VKD3DSIH_RCP,          {2, 0}},
+    {VKD3D_SM1_OP_RSQ,          1, 1, VKD3DSIH_RSQ,          {2, 0}},
     {VKD3D_SM1_OP_DP3,          1, 2, VKD3DSIH_DP3},
-    {VKD3D_SM1_OP_DP4,          1, 2, VKD3DSIH_DP4},
-    {VKD3D_SM1_OP_MIN,          1, 2, VKD3DSIH_MIN},
-    {VKD3D_SM1_OP_MAX,          1, 2, VKD3DSIH_MAX},
-    {VKD3D_SM1_OP_SLT,          1, 2, VKD3DSIH_SLT},
-    {VKD3D_SM1_OP_SGE,          1, 2, VKD3DSIH_SGE},
-    {VKD3D_SM1_OP_ABS,          1, 1, VKD3DSIH_ABS},
-    {VKD3D_SM1_OP_EXP,          1, 1, VKD3DSIH_EXP},
-    {VKD3D_SM1_OP_LOG,          1, 1, VKD3DSIH_LOG},
-    {VKD3D_SM1_OP_EXPP,         1, 1, VKD3DSIH_EXPP},
-    {VKD3D_SM1_OP_LOGP,         1, 1, VKD3DSIH_LOGP},
-    {VKD3D_SM1_OP_DST,          1, 2, VKD3DSIH_DST},
+    {VKD3D_SM1_OP_DP4,          1, 2, VKD3DSIH_DP4,          {1, 2}},
+    {VKD3D_SM1_OP_MIN,          1, 2, VKD3DSIH_MIN,          {2, 0}},
+    {VKD3D_SM1_OP_MAX,          1, 2, VKD3DSIH_MAX,          {2, 0}},
+    {VKD3D_SM1_OP_ABS,          1, 1, VKD3DSIH_ABS,          {2, 0}},
+    {VKD3D_SM1_OP_EXP,          1, 1, VKD3DSIH_EXP,          {2, 0}},
+    {VKD3D_SM1_OP_LOG,          1, 1, VKD3DSIH_LOG,          {2, 0}},
     {VKD3D_SM1_OP_LRP,          1, 3, VKD3DSIH_LRP},
-    {VKD3D_SM1_OP_FRC,          1, 1, VKD3DSIH_FRC},
-    {VKD3D_SM1_OP_CND,          1, 3, VKD3DSIH_CND,          {1, 0}, {  1,   4}},
-    {VKD3D_SM1_OP_CMP,          1, 3, VKD3DSIH_CMP,          {1, 2}, {  3,   0}},
-    {VKD3D_SM1_OP_POW,          1, 2, VKD3DSIH_POW},
-    {VKD3D_SM1_OP_CRS,          1, 2, VKD3DSIH_CRS},
-    {VKD3D_SM1_OP_NRM,          1, 1, VKD3DSIH_NRM},
-    {VKD3D_SM1_OP_SINCOS,       1, 3, VKD3DSIH_SINCOS,       {2, 0}, {  2,   1}},
-    {VKD3D_SM1_OP_SINCOS,       1, 1, VKD3DSIH_SINCOS,       {3, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_DP2ADD,       1, 3, VKD3DSIH_DP2ADD,       {2, 0}, {~0u, ~0u}},
+    {VKD3D_SM1_OP_FRC,          1, 1, VKD3DSIH_FRC,          {2, 0}},
+    {VKD3D_SM1_OP_CND,          1, 3, VKD3DSIH_CND,          {1, 0}, {1, 4}},
+    {VKD3D_SM1_OP_CMP,          1, 3, VKD3DSIH_CMP,          {1, 2}},
+    {VKD3D_SM1_OP_POW,          1, 2, VKD3DSIH_POW,          {2, 0}},
+    {VKD3D_SM1_OP_CRS,          1, 2, VKD3DSIH_CRS,          {2, 0}},
+    {VKD3D_SM1_OP_NRM,          1, 1, VKD3DSIH_NRM,          {2, 0}},
+    {VKD3D_SM1_OP_SINCOS,       1, 3, VKD3DSIH_SINCOS,       {2, 0}, {2, 1}},
+    {VKD3D_SM1_OP_SINCOS,       1, 1, VKD3DSIH_SINCOS,       {3, 0}},
+    {VKD3D_SM1_OP_DP2ADD,       1, 3, VKD3DSIH_DP2ADD,       {2, 0}},
     /* Matrix */
-    {VKD3D_SM1_OP_M4x4,         1, 2, VKD3DSIH_M4x4},
-    {VKD3D_SM1_OP_M4x3,         1, 2, VKD3DSIH_M4x3},
-    {VKD3D_SM1_OP_M3x4,         1, 2, VKD3DSIH_M3x4},
-    {VKD3D_SM1_OP_M3x3,         1, 2, VKD3DSIH_M3x3},
-    {VKD3D_SM1_OP_M3x2,         1, 2, VKD3DSIH_M3x2},
+    {VKD3D_SM1_OP_M4x4,         1, 2, VKD3DSIH_M4x4,         {2, 0}},
+    {VKD3D_SM1_OP_M4x3,         1, 2, VKD3DSIH_M4x3,         {2, 0}},
+    {VKD3D_SM1_OP_M3x4,         1, 2, VKD3DSIH_M3x4,         {2, 0}},
+    {VKD3D_SM1_OP_M3x3,         1, 2, VKD3DSIH_M3x3,         {2, 0}},
+    {VKD3D_SM1_OP_M3x2,         1, 2, VKD3DSIH_M3x2,         {2, 0}},
     /* Declarations */
-    {VKD3D_SM1_OP_DCL,          0, 0, VKD3DSIH_DCL},
+    {VKD3D_SM1_OP_DCL,          0, 0, VKD3DSIH_DCL,          {2, 0}},
     /* Constant definitions */
     {VKD3D_SM1_OP_DEF,          1, 1, VKD3DSIH_DEF},
-    {VKD3D_SM1_OP_DEFB,         1, 1, VKD3DSIH_DEFB},
-    {VKD3D_SM1_OP_DEFI,         1, 1, VKD3DSIH_DEFI},
+    {VKD3D_SM1_OP_DEFB,         1, 1, VKD3DSIH_DEFB,         {2, 0}},
+    {VKD3D_SM1_OP_DEFI,         1, 1, VKD3DSIH_DEFI,         {2, 1}},
     /* Control flow */
-    {VKD3D_SM1_OP_REP,          0, 1, VKD3DSIH_REP,          {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ENDREP,       0, 0, VKD3DSIH_ENDREP,       {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_IF,           0, 1, VKD3DSIH_IF,           {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_IFC,          0, 2, VKD3DSIH_IFC,          {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ELSE,         0, 0, VKD3DSIH_ELSE,         {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ENDIF,        0, 0, VKD3DSIH_ENDIF,        {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_BREAK,        0, 0, VKD3DSIH_BREAK,        {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_BREAKC,       0, 2, VKD3DSIH_BREAKC,       {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_BREAKP,       0, 1, VKD3DSIH_BREAKP},
-    {VKD3D_SM1_OP_CALL,         0, 1, VKD3DSIH_CALL,         {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_CALLNZ,       0, 2, VKD3DSIH_CALLNZ,       {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_LOOP,         0, 2, VKD3DSIH_LOOP,         {3, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_RET,          0, 0, VKD3DSIH_RET,          {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_ENDLOOP,      0, 0, VKD3DSIH_ENDLOOP,      {3, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_LABEL,        0, 1, VKD3DSIH_LABEL,        {2, 1}, {~0u, ~0u}},
+    {VKD3D_SM1_OP_REP,          0, 1, VKD3DSIH_REP,          {2, 1}},
+    {VKD3D_SM1_OP_ENDREP,       0, 0, VKD3DSIH_ENDREP,       {2, 1}},
+    {VKD3D_SM1_OP_IF,           0, 1, VKD3DSIH_IF,           {2, 1}},
+    {VKD3D_SM1_OP_IFC,          0, 2, VKD3DSIH_IFC,          {2, 1}},
+    {VKD3D_SM1_OP_ELSE,         0, 0, VKD3DSIH_ELSE,         {2, 1}},
+    {VKD3D_SM1_OP_ENDIF,        0, 0, VKD3DSIH_ENDIF,        {2, 1}},
+    {VKD3D_SM1_OP_BREAK,        0, 0, VKD3DSIH_BREAK,        {2, 1}},
+    {VKD3D_SM1_OP_BREAKC,       0, 2, VKD3DSIH_BREAKC,       {2, 1}},
+    {VKD3D_SM1_OP_BREAKP,       0, 1, VKD3DSIH_BREAKP,       {2, 1}},
+    {VKD3D_SM1_OP_CALL,         0, 1, VKD3DSIH_CALL,         {2, 1}},
+    {VKD3D_SM1_OP_CALLNZ,       0, 2, VKD3DSIH_CALLNZ,       {2, 1}},
+    {VKD3D_SM1_OP_LOOP,         0, 2, VKD3DSIH_LOOP,         {3, 0}},
+    {VKD3D_SM1_OP_RET,          0, 0, VKD3DSIH_RET,          {2, 1}},
+    {VKD3D_SM1_OP_ENDLOOP,      0, 0, VKD3DSIH_ENDLOOP,      {3, 0}},
+    {VKD3D_SM1_OP_LABEL,        0, 1, VKD3DSIH_LABEL,        {2, 1}},
     /* Texture */
-    {VKD3D_SM1_OP_TEXCOORD,     1, 0, VKD3DSIH_TEXCOORD,     {0, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXCOORD,     1, 1, VKD3DSIH_TEXCOORD,     {1 ,4}, {  1,   4}},
-    {VKD3D_SM1_OP_TEXKILL,      1, 0, VKD3DSIH_TEXKILL,      {1 ,0}, {  3,   0}},
-    {VKD3D_SM1_OP_TEX,          1, 0, VKD3DSIH_TEX,          {0, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEX,          1, 1, VKD3DSIH_TEX,          {1, 4}, {  1,   4}},
-    {VKD3D_SM1_OP_TEX,          1, 2, VKD3DSIH_TEX,          {2, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_TEXBEM,       1, 1, VKD3DSIH_TEXBEM,       {0, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXBEML,      1, 1, VKD3DSIH_TEXBEML,      {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXREG2AR,    1, 1, VKD3DSIH_TEXREG2AR,    {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXREG2GB,    1, 1, VKD3DSIH_TEXREG2GB,    {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXREG2RGB,   1, 1, VKD3DSIH_TEXREG2RGB,   {1, 2}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x2PAD,   1, 1, VKD3DSIH_TEXM3x2PAD,   {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x2TEX,   1, 1, VKD3DSIH_TEXM3x2TEX,   {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x3PAD,   1, 1, VKD3DSIH_TEXM3x3PAD,   {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x3DIFF,  1, 1, VKD3DSIH_TEXM3x3DIFF,  {0, 0}, {  0,   0}},
-    {VKD3D_SM1_OP_TEXM3x3SPEC,  1, 2, VKD3DSIH_TEXM3x3SPEC,  {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x3VSPEC, 1, 1, VKD3DSIH_TEXM3x3VSPEC, {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x3TEX,   1, 1, VKD3DSIH_TEXM3x3TEX,   {1, 0}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXDP3TEX,    1, 1, VKD3DSIH_TEXDP3TEX,    {1, 2}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x2DEPTH, 1, 1, VKD3DSIH_TEXM3x2DEPTH, {1, 3}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXDP3,       1, 1, VKD3DSIH_TEXDP3,       {1, 2}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXM3x3,      1, 1, VKD3DSIH_TEXM3x3,      {1, 2}, {  1,   3}},
-    {VKD3D_SM1_OP_TEXDEPTH,     1, 0, VKD3DSIH_TEXDEPTH,     {1, 4}, {  1,   4}},
-    {VKD3D_SM1_OP_BEM,          1, 2, VKD3DSIH_BEM,          {1, 4}, {  1,   4}},
-    {VKD3D_SM1_OP_DSX,          1, 1, VKD3DSIH_DSX,          {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_DSY,          1, 1, VKD3DSIH_DSY,          {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_TEXLDD,       1, 4, VKD3DSIH_TEXLDD,       {2, 1}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_SETP,         1, 2, VKD3DSIH_SETP},
-    {VKD3D_SM1_OP_TEXLDL,       1, 2, VKD3DSIH_TEXLDL,       {3, 0}, {~0u, ~0u}},
-    {VKD3D_SM1_OP_PHASE,        0, 0, VKD3DSIH_PHASE},
+    {VKD3D_SM1_OP_TEXCOORD,     1, 0, VKD3DSIH_TEXCOORD,     {0, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXCOORD,     1, 1, VKD3DSIH_TEXCOORD,     {1, 4}, {1, 4}},
+    {VKD3D_SM1_OP_TEXKILL,      1, 0, VKD3DSIH_TEXKILL,      {1, 0}},
+    {VKD3D_SM1_OP_TEX,          1, 0, VKD3DSIH_TEX,          {0, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEX,          1, 1, VKD3DSIH_TEX,          {1, 4}, {1, 4}},
+    {VKD3D_SM1_OP_TEX,          1, 2, VKD3DSIH_TEX,          {2, 0}},
+    {VKD3D_SM1_OP_TEXBEM,       1, 1, VKD3DSIH_TEXBEM,       {0, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXBEML,      1, 1, VKD3DSIH_TEXBEML,      {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXREG2AR,    1, 1, VKD3DSIH_TEXREG2AR,    {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXREG2GB,    1, 1, VKD3DSIH_TEXREG2GB,    {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXREG2RGB,   1, 1, VKD3DSIH_TEXREG2RGB,   {1, 2}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x2PAD,   1, 1, VKD3DSIH_TEXM3x2PAD,   {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x2TEX,   1, 1, VKD3DSIH_TEXM3x2TEX,   {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x3PAD,   1, 1, VKD3DSIH_TEXM3x3PAD,   {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x3DIFF,  1, 1, VKD3DSIH_TEXM3x3DIFF,  {0, 0}, {0, 0}},
+    {VKD3D_SM1_OP_TEXM3x3SPEC,  1, 2, VKD3DSIH_TEXM3x3SPEC,  {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x3VSPEC, 1, 1, VKD3DSIH_TEXM3x3VSPEC, {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x3TEX,   1, 1, VKD3DSIH_TEXM3x3TEX,   {1, 0}, {1, 3}},
+    {VKD3D_SM1_OP_TEXDP3TEX,    1, 1, VKD3DSIH_TEXDP3TEX,    {1, 2}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x2DEPTH, 1, 1, VKD3DSIH_TEXM3x2DEPTH, {1, 3}, {1, 3}},
+    {VKD3D_SM1_OP_TEXDP3,       1, 1, VKD3DSIH_TEXDP3,       {1, 2}, {1, 3}},
+    {VKD3D_SM1_OP_TEXM3x3,      1, 1, VKD3DSIH_TEXM3x3,      {1, 2}, {1, 3}},
+    {VKD3D_SM1_OP_TEXDEPTH,     1, 0, VKD3DSIH_TEXDEPTH,     {1, 4}, {1, 4}},
+    {VKD3D_SM1_OP_BEM,          1, 2, VKD3DSIH_BEM,          {1, 4}, {1, 4}},
+    {VKD3D_SM1_OP_DSX,          1, 1, VKD3DSIH_DSX,          {2, 1}},
+    {VKD3D_SM1_OP_DSY,          1, 1, VKD3DSIH_DSY,          {2, 1}},
+    {VKD3D_SM1_OP_TEXLDD,       1, 4, VKD3DSIH_TEXLDD,       {2, 1}},
+    {VKD3D_SM1_OP_SETP,         1, 2, VKD3DSIH_SETP,         {2, 1}},
+    {VKD3D_SM1_OP_TEXLDL,       1, 2, VKD3DSIH_TEXLDL,       {3, 0}},
+    {VKD3D_SM1_OP_PHASE,        0, 0, VKD3DSIH_PHASE,        {1, 4}, {1, 4}},
     {0,                         0, 0, VKD3DSIH_INVALID},
 };
 
+static const struct
+{
+    enum vkd3d_sm1_register_type d3dbc_type;
+    enum vkd3d_shader_register_type vsir_type;
+}
+register_types[] =
+{
+    {VKD3D_SM1_REG_TEMP,        VKD3DSPR_TEMP},
+    {VKD3D_SM1_REG_INPUT,       VKD3DSPR_INPUT},
+    {VKD3D_SM1_REG_CONST,       VKD3DSPR_CONST},
+    {VKD3D_SM1_REG_ADDR,        VKD3DSPR_ADDR},
+    {VKD3D_SM1_REG_TEXTURE,     VKD3DSPR_TEXTURE},
+    {VKD3D_SM1_REG_RASTOUT,     VKD3DSPR_RASTOUT},
+    {VKD3D_SM1_REG_ATTROUT,     VKD3DSPR_ATTROUT},
+    {VKD3D_SM1_REG_OUTPUT,      VKD3DSPR_OUTPUT},
+    {VKD3D_SM1_REG_TEXCRDOUT,   VKD3DSPR_TEXCRDOUT},
+    {VKD3D_SM1_REG_CONSTINT,    VKD3DSPR_CONSTINT},
+    {VKD3D_SM1_REG_COLOROUT,    VKD3DSPR_COLOROUT},
+    {VKD3D_SM1_REG_DEPTHOUT,    VKD3DSPR_DEPTHOUT},
+    {VKD3D_SM1_REG_SAMPLER,     VKD3DSPR_COMBINED_SAMPLER},
+    {VKD3D_SM1_REG_CONSTBOOL,   VKD3DSPR_CONSTBOOL},
+    {VKD3D_SM1_REG_LOOP,        VKD3DSPR_LOOP},
+    {VKD3D_SM1_REG_TEMPFLOAT16, VKD3DSPR_TEMPFLOAT16},
+    {VKD3D_SM1_REG_MISCTYPE,    VKD3DSPR_MISCTYPE},
+    {VKD3D_SM1_REG_LABEL,       VKD3DSPR_LABEL},
+    {VKD3D_SM1_REG_PREDICATE,   VKD3DSPR_PREDICATE},
+};
+
 static const enum vkd3d_shader_resource_type resource_type_table[] =
 {
     /* VKD3D_SM1_RESOURCE_UNKNOWN */      VKD3D_SHADER_RESOURCE_NONE,
@@ -458,6 +507,7 @@ static unsigned int idx_count_from_reg_type(enum vkd3d_shader_register_type reg_
     switch (reg_type)
     {
         case VKD3DSPR_DEPTHOUT:
+        case VKD3DSPR_ADDR:
             return 0;
 
         default:
@@ -465,52 +515,82 @@ static unsigned int idx_count_from_reg_type(enum vkd3d_shader_register_type reg_
     }
 }
 
-static void shader_sm1_parse_src_param(uint32_t param, struct vkd3d_shader_src_param *rel_addr,
-        struct vkd3d_shader_src_param *src)
+static enum vkd3d_shader_register_type parse_register_type(
+        struct vkd3d_shader_sm1_parser *sm1, uint32_t param, unsigned int *index_offset)
 {
-    enum vkd3d_shader_register_type reg_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
+    enum vkd3d_sm1_register_type d3dbc_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
             | ((param & VKD3D_SM1_REGISTER_TYPE_MASK2) >> VKD3D_SM1_REGISTER_TYPE_SHIFT2);
-    unsigned int idx_count = idx_count_from_reg_type(reg_type);
 
-    vsir_register_init(&src->reg, reg_type, VKD3D_DATA_FLOAT, idx_count);
-    src->reg.precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
-    src->reg.non_uniform = false;
-    if (idx_count == 1)
+    *index_offset = 0;
+
+    if (d3dbc_type == VKD3D_SM1_REG_CONST2)
     {
-        src->reg.idx[0].offset = param & VKD3D_SM1_REGISTER_NUMBER_MASK;
-        src->reg.idx[0].rel_addr = rel_addr;
+        *index_offset = 2048;
+        return VKD3DSPR_CONST;
     }
-    if (src->reg.type == VKD3DSPR_SAMPLER)
-        src->reg.dimension = VSIR_DIMENSION_NONE;
-    else if (src->reg.type == VKD3DSPR_DEPTHOUT)
-        src->reg.dimension = VSIR_DIMENSION_SCALAR;
-    else
-        src->reg.dimension = VSIR_DIMENSION_VEC4;
-    src->swizzle = swizzle_from_sm1((param & VKD3D_SM1_SWIZZLE_MASK) >> VKD3D_SM1_SWIZZLE_SHIFT);
-    src->modifiers = (param & VKD3D_SM1_SRC_MODIFIER_MASK) >> VKD3D_SM1_SRC_MODIFIER_SHIFT;
+
+    if (d3dbc_type == VKD3D_SM1_REG_CONST3)
+    {
+        *index_offset = 4096;
+        return VKD3DSPR_CONST;
+    }
+
+    if (d3dbc_type == VKD3D_SM1_REG_CONST4)
+    {
+        *index_offset = 6144;
+        return VKD3DSPR_CONST;
+    }
+
+    if (d3dbc_type == VKD3D_SM1_REG_ADDR)
+        return sm1->p.program->shader_version.type == VKD3D_SHADER_TYPE_PIXEL ? VKD3DSPR_TEXTURE : VKD3DSPR_ADDR;
+    if (d3dbc_type == VKD3D_SM1_REG_TEXCRDOUT)
+        return vkd3d_shader_ver_ge(&sm1->p.program->shader_version, 3, 0) ? VKD3DSPR_OUTPUT : VKD3DSPR_TEXCRDOUT;
+
+    for (unsigned int i = 0; i < ARRAY_SIZE(register_types); ++i)
+    {
+        if (register_types[i].d3dbc_type == d3dbc_type)
+            return register_types[i].vsir_type;
+    }
+
+    return VKD3DSPR_INVALID;
 }
 
-static void shader_sm1_parse_dst_param(uint32_t param, struct vkd3d_shader_src_param *rel_addr,
-        struct vkd3d_shader_dst_param *dst)
+static void d3dbc_parse_register(struct vkd3d_shader_sm1_parser *d3dbc,
+        struct vkd3d_shader_register *reg, uint32_t param, struct vkd3d_shader_src_param *rel_addr)
 {
-    enum vkd3d_shader_register_type reg_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
-            | ((param & VKD3D_SM1_REGISTER_TYPE_MASK2) >> VKD3D_SM1_REGISTER_TYPE_SHIFT2);
-    unsigned int idx_count = idx_count_from_reg_type(reg_type);
+    enum vkd3d_shader_register_type reg_type;
+    unsigned int index_offset, idx_count;
 
-    vsir_register_init(&dst->reg, reg_type, VKD3D_DATA_FLOAT, idx_count);
-    dst->reg.precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
-    dst->reg.non_uniform = false;
+    reg_type = parse_register_type(d3dbc, param, &index_offset);
+    idx_count = idx_count_from_reg_type(reg_type);
+    vsir_register_init(reg, reg_type, VKD3D_DATA_FLOAT, idx_count);
+    reg->precision = VKD3D_SHADER_REGISTER_PRECISION_DEFAULT;
+    reg->non_uniform = false;
     if (idx_count == 1)
     {
-        dst->reg.idx[0].offset = param & VKD3D_SM1_REGISTER_NUMBER_MASK;
-        dst->reg.idx[0].rel_addr = rel_addr;
+        reg->idx[0].offset = index_offset + (param & VKD3D_SM1_REGISTER_NUMBER_MASK);
+        reg->idx[0].rel_addr = rel_addr;
     }
-    if (dst->reg.type == VKD3DSPR_SAMPLER)
-        dst->reg.dimension = VSIR_DIMENSION_NONE;
-    else if (dst->reg.type == VKD3DSPR_DEPTHOUT)
-        dst->reg.dimension = VSIR_DIMENSION_SCALAR;
+    if (reg->type == VKD3DSPR_SAMPLER)
+        reg->dimension = VSIR_DIMENSION_NONE;
+    else if (reg->type == VKD3DSPR_DEPTHOUT)
+        reg->dimension = VSIR_DIMENSION_SCALAR;
     else
-        dst->reg.dimension = VSIR_DIMENSION_VEC4;
+        reg->dimension = VSIR_DIMENSION_VEC4;
+}
+
+static void shader_sm1_parse_src_param(struct vkd3d_shader_sm1_parser *sm1, uint32_t param,
+        struct vkd3d_shader_src_param *rel_addr, struct vkd3d_shader_src_param *src)
+{
+    d3dbc_parse_register(sm1, &src->reg, param, rel_addr);
+    src->swizzle = swizzle_from_sm1((param & VKD3D_SM1_SWIZZLE_MASK) >> VKD3D_SM1_SWIZZLE_SHIFT);
+    src->modifiers = (param & VKD3D_SM1_SRC_MODIFIER_MASK) >> VKD3D_SM1_SRC_MODIFIER_SHIFT;
+}
+
+static void shader_sm1_parse_dst_param(struct vkd3d_shader_sm1_parser *sm1, uint32_t param,
+        struct vkd3d_shader_src_param *rel_addr, struct vkd3d_shader_dst_param *dst)
+{
+    d3dbc_parse_register(sm1, &dst->reg, param, rel_addr);
     dst->modifiers = (param & VKD3D_SM1_DST_MODIFIER_MASK) >> VKD3D_SM1_DST_MODIFIER_SHIFT;
     dst->shift = (param & VKD3D_SM1_DSTSHIFT_MASK) >> VKD3D_SM1_DSTSHIFT_SHIFT;
 
@@ -638,7 +718,32 @@ static void add_signature_mask(struct vkd3d_shader_sm1_parser *sm1, bool output,
         return;
     }
 
+    /* Normally VSIR mandates that the register mask is a subset of the usage
+     * mask, and the usage mask is a subset of the signature mask. This is
+     * doesn't always happen with SM1-3 registers, because of the limited
+     * flexibility with expressing swizzles.
+     *
+     * For example it's easy to find shaders like this:
+     *   ps_3_0
+     *   [...]
+     *   dcl_texcoord0 v0
+     *   [...]
+     *   texld r2.xyzw, v0.xyzw, s1.xyzw
+     *   [...]
+     *
+     * The dcl_textcoord0 instruction secretly has a .xy mask, which is used to
+     * compute the signature mask, but the texld instruction apparently uses all
+     * the components. Of course the last two components are ignored, but
+     * formally they seem to be used. So we end up with a signature element with
+     * mask .xy and usage mask .xyzw.
+     *
+     * In order to avoid this problem, when generating VSIR code with SM4
+     * normalisation level we remove the unused components in the write mask. We
+     * don't do that when targetting the SM1 normalisation level (i.e., when
+     * disassembling) so as to generate the same disassembly code as native. */
     element->used_mask |= mask;
+    if (program->normalisation_level >= VSIR_NORMALISED_SM4)
+        element->used_mask &= element->mask;
 }
 
 static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *sm1,
@@ -666,26 +771,18 @@ static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *
                     VKD3D_SHADER_SV_NONE, SM1_COLOR_REGISTER_OFFSET + register_index, is_dcl, mask);
 
         case VKD3DSPR_TEXTURE:
-            /* For vertex shaders, this is ADDR. */
-            if (version->type == VKD3D_SHADER_TYPE_VERTEX)
-                return true;
             return add_signature_element(sm1, false, "TEXCOORD", register_index,
                     VKD3D_SHADER_SV_NONE, register_index, is_dcl, mask);
 
+        case VKD3DSPR_TEXCRDOUT:
+            return add_signature_element(sm1, true, "TEXCOORD", register_index,
+                    VKD3D_SHADER_SV_NONE, register_index, is_dcl, mask);
+
         case VKD3DSPR_OUTPUT:
             if (version->type == VKD3D_SHADER_TYPE_VERTEX)
             {
-                /* For sm < 2 vertex shaders, this is TEXCRDOUT.
-                 *
-                 * For sm3 vertex shaders, this is OUTPUT, but we already
-                 * should have had a DCL instruction. */
-                if (version->major == 3)
-                {
-                    add_signature_mask(sm1, true, register_index, mask);
-                    return true;
-                }
-                return add_signature_element(sm1, true, "TEXCOORD", register_index,
-                        VKD3D_SHADER_SV_NONE, register_index, is_dcl, mask);
+                add_signature_mask(sm1, true, register_index, mask);
+                return true;
             }
             /* fall through */
 
@@ -822,18 +919,6 @@ static void shader_sm1_scan_register(struct vkd3d_shader_sm1_parser *sm1,
             record_constant_register(sm1, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, register_index, from_def);
             break;
 
-        case VKD3DSPR_CONST2:
-            record_constant_register(sm1, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 2048 + register_index, from_def);
-            break;
-
-        case VKD3DSPR_CONST3:
-            record_constant_register(sm1, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 4096 + register_index, from_def);
-            break;
-
-        case VKD3DSPR_CONST4:
-            record_constant_register(sm1, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 6144 + register_index, from_def);
-            break;
-
         case VKD3DSPR_CONSTINT:
             record_constant_register(sm1, VKD3D_SHADER_D3DBC_INT_CONSTANT_REGISTER, register_index, from_def);
             break;
@@ -941,9 +1026,9 @@ static void shader_sm1_read_src_param(struct vkd3d_shader_sm1_parser *sm1, const
             sm1->abort = true;
             return;
         }
-        shader_sm1_parse_src_param(addr_token, NULL, src_rel_addr);
+        shader_sm1_parse_src_param(sm1, addr_token, NULL, src_rel_addr);
     }
-    shader_sm1_parse_src_param(token, src_rel_addr, src_param);
+    shader_sm1_parse_src_param(sm1, token, src_rel_addr, src_param);
 }
 
 static void shader_sm1_read_dst_param(struct vkd3d_shader_sm1_parser *sm1, const uint32_t **ptr,
@@ -962,12 +1047,14 @@ static void shader_sm1_read_dst_param(struct vkd3d_shader_sm1_parser *sm1, const
             sm1->abort = true;
             return;
         }
-        shader_sm1_parse_src_param(addr_token, NULL, dst_rel_addr);
+        shader_sm1_parse_src_param(sm1, addr_token, NULL, dst_rel_addr);
     }
-    shader_sm1_parse_dst_param(token, dst_rel_addr, dst_param);
+    shader_sm1_parse_dst_param(sm1, token, dst_rel_addr, dst_param);
 
     if (dst_param->reg.type == VKD3DSPR_RASTOUT && dst_param->reg.idx[0].offset == VSIR_RASTOUT_POINT_SIZE)
         sm1->p.program->has_point_size = true;
+    if (dst_param->reg.type == VKD3DSPR_RASTOUT && dst_param->reg.idx[0].offset == VSIR_RASTOUT_FOG)
+        sm1->p.program->has_fog = true;
 }
 
 static void shader_sm1_read_semantic(struct vkd3d_shader_sm1_parser *sm1,
@@ -1005,7 +1092,7 @@ static void shader_sm1_read_semantic(struct vkd3d_shader_sm1_parser *sm1,
     semantic->resource_data_type[1] = VKD3D_DATA_FLOAT;
     semantic->resource_data_type[2] = VKD3D_DATA_FLOAT;
     semantic->resource_data_type[3] = VKD3D_DATA_FLOAT;
-    shader_sm1_parse_dst_param(dst_token, NULL, &semantic->resource.reg);
+    shader_sm1_parse_dst_param(sm1, dst_token, NULL, &semantic->resource.reg);
     range = &semantic->resource.range;
     range->space = 0;
     range->first = range->last = semantic->resource.reg.reg.idx[0].offset;
@@ -1268,6 +1355,7 @@ static enum vkd3d_result shader_sm1_init(struct vkd3d_shader_sm1_parser *sm1, st
         const struct vkd3d_shader_compile_info *compile_info, struct vkd3d_shader_message_context *message_context)
 {
     const struct vkd3d_shader_location location = {.source_name = compile_info->source_name};
+    enum vsir_normalisation_level normalisation_level;
     const uint32_t *code = compile_info->source.code;
     size_t code_size = compile_info->source.size;
     struct vkd3d_shader_version version;
@@ -1318,9 +1406,13 @@ static enum vkd3d_result shader_sm1_init(struct vkd3d_shader_sm1_parser *sm1, st
     sm1->start = &code[1];
     sm1->end = &code[token_count];
 
+    normalisation_level = VSIR_NORMALISED_SM1;
+    if (compile_info->target_type != VKD3D_SHADER_TARGET_D3D_ASM)
+        normalisation_level = VSIR_NORMALISED_SM4;
+
     /* Estimate instruction count to avoid reallocation in most shaders. */
     if (!vsir_program_init(program, compile_info, &version,
-            code_size != ~(size_t)0 ? token_count / 4u + 4 : 16, VSIR_CF_STRUCTURED, VSIR_NOT_NORMALISED))
+            code_size != ~(size_t)0 ? token_count / 4u + 4 : 16, VSIR_CF_STRUCTURED, normalisation_level))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
     vkd3d_shader_parser_init(&sm1->p, program, message_context, compile_info->source_name);
@@ -1525,555 +1617,208 @@ static uint32_t sm1_version(enum vkd3d_shader_type type, unsigned int major, uns
             type == VKD3D_SHADER_TYPE_VERTEX ? VKD3D_SM1_VS : VKD3D_SM1_PS);
 }
 
-D3DXPARAMETER_CLASS hlsl_sm1_class(const struct hlsl_type *type)
+static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info_from_vsir(
+        struct d3dbc_compiler *d3dbc, enum vkd3d_shader_opcode vkd3d_opcode)
 {
-    switch (type->class)
-    {
-        case HLSL_CLASS_ARRAY:
-            return hlsl_sm1_class(type->e.array.type);
-        case HLSL_CLASS_MATRIX:
-            VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
-            if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
-                return D3DXPC_MATRIX_COLUMNS;
-            else
-                return D3DXPC_MATRIX_ROWS;
-        case HLSL_CLASS_SCALAR:
-            return D3DXPC_SCALAR;
-        case HLSL_CLASS_STRUCT:
-            return D3DXPC_STRUCT;
-        case HLSL_CLASS_VECTOR:
-            return D3DXPC_VECTOR;
-        case HLSL_CLASS_PIXEL_SHADER:
-        case HLSL_CLASS_SAMPLER:
-        case HLSL_CLASS_STRING:
-        case HLSL_CLASS_TEXTURE:
-        case HLSL_CLASS_VERTEX_SHADER:
-            return D3DXPC_OBJECT;
-        case HLSL_CLASS_DEPTH_STENCIL_STATE:
-        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
-        case HLSL_CLASS_EFFECT_GROUP:
-        case HLSL_CLASS_ERROR:
-        case HLSL_CLASS_PASS:
-        case HLSL_CLASS_RASTERIZER_STATE:
-        case HLSL_CLASS_RENDER_TARGET_VIEW:
-        case HLSL_CLASS_TECHNIQUE:
-        case HLSL_CLASS_UAV:
-        case HLSL_CLASS_VOID:
-        case HLSL_CLASS_CONSTANT_BUFFER:
-        case HLSL_CLASS_COMPUTE_SHADER:
-        case HLSL_CLASS_DOMAIN_SHADER:
-        case HLSL_CLASS_HULL_SHADER:
-        case HLSL_CLASS_GEOMETRY_SHADER:
-        case HLSL_CLASS_BLEND_STATE:
-        case HLSL_CLASS_NULL:
-            break;
-    }
-
-    vkd3d_unreachable();
-}
+    const struct vkd3d_shader_version *version = &d3dbc->program->shader_version;
+    const struct vkd3d_sm1_opcode_info *info;
+    unsigned int i = 0;
 
-D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type)
-{
-    switch (type->class)
+    for (;;)
     {
-        case HLSL_CLASS_SCALAR:
-        case HLSL_CLASS_VECTOR:
-        case HLSL_CLASS_MATRIX:
-            switch (type->e.numeric.type)
-            {
-                case HLSL_TYPE_BOOL:
-                    return D3DXPT_BOOL;
-                /* Actually double behaves differently depending on DLL version:
-                 * For <= 36, it maps to D3DXPT_FLOAT.
-                 * For 37-40, it maps to zero (D3DXPT_VOID).
-                 * For >= 41, it maps to 39, which is D3D_SVT_DOUBLE (note D3D_SVT_*
-                 *            values are mostly compatible with D3DXPT_*).
-                 * However, the latter two cases look like bugs, and a reasonable
-                 * application certainly wouldn't know what to do with them.
-                 * For fx_2_0 it's always D3DXPT_FLOAT regardless of DLL version. */
-                case HLSL_TYPE_DOUBLE:
-                case HLSL_TYPE_FLOAT:
-                case HLSL_TYPE_HALF:
-                    return D3DXPT_FLOAT;
-                case HLSL_TYPE_INT:
-                case HLSL_TYPE_UINT:
-                    return D3DXPT_INT;
-                default:
-                    vkd3d_unreachable();
-            }
-
-        case HLSL_CLASS_SAMPLER:
-            switch (type->sampler_dim)
-            {
-                case HLSL_SAMPLER_DIM_1D:
-                    return D3DXPT_SAMPLER1D;
-                case HLSL_SAMPLER_DIM_2D:
-                    return D3DXPT_SAMPLER2D;
-                case HLSL_SAMPLER_DIM_3D:
-                    return D3DXPT_SAMPLER3D;
-                case HLSL_SAMPLER_DIM_CUBE:
-                    return D3DXPT_SAMPLERCUBE;
-                case HLSL_SAMPLER_DIM_GENERIC:
-                    return D3DXPT_SAMPLER;
-                default:
-                    ERR("Invalid dimension %#x.\n", type->sampler_dim);
-                    vkd3d_unreachable();
-            }
-            break;
-
-        case HLSL_CLASS_TEXTURE:
-            switch (type->sampler_dim)
-            {
-                case HLSL_SAMPLER_DIM_1D:
-                    return D3DXPT_TEXTURE1D;
-                case HLSL_SAMPLER_DIM_2D:
-                    return D3DXPT_TEXTURE2D;
-                case HLSL_SAMPLER_DIM_3D:
-                    return D3DXPT_TEXTURE3D;
-                case HLSL_SAMPLER_DIM_CUBE:
-                    return D3DXPT_TEXTURECUBE;
-                case HLSL_SAMPLER_DIM_GENERIC:
-                    return D3DXPT_TEXTURE;
-                default:
-                    ERR("Invalid dimension %#x.\n", type->sampler_dim);
-                    vkd3d_unreachable();
-            }
-            break;
+        info = &d3dbc->opcode_table[i++];
+        if (info->vkd3d_opcode == VKD3DSIH_INVALID)
+            return NULL;
 
-        case HLSL_CLASS_ARRAY:
-            return hlsl_sm1_base_type(type->e.array.type);
-
-        case HLSL_CLASS_STRUCT:
-            return D3DXPT_VOID;
-
-        case HLSL_CLASS_STRING:
-            return D3DXPT_STRING;
-
-        case HLSL_CLASS_PIXEL_SHADER:
-            return D3DXPT_PIXELSHADER;
-
-        case HLSL_CLASS_VERTEX_SHADER:
-            return D3DXPT_VERTEXSHADER;
-
-        case HLSL_CLASS_DEPTH_STENCIL_STATE:
-        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
-        case HLSL_CLASS_EFFECT_GROUP:
-        case HLSL_CLASS_ERROR:
-        case HLSL_CLASS_PASS:
-        case HLSL_CLASS_RASTERIZER_STATE:
-        case HLSL_CLASS_RENDER_TARGET_VIEW:
-        case HLSL_CLASS_TECHNIQUE:
-        case HLSL_CLASS_UAV:
-        case HLSL_CLASS_VOID:
-        case HLSL_CLASS_CONSTANT_BUFFER:
-        case HLSL_CLASS_COMPUTE_SHADER:
-        case HLSL_CLASS_DOMAIN_SHADER:
-        case HLSL_CLASS_HULL_SHADER:
-        case HLSL_CLASS_GEOMETRY_SHADER:
-        case HLSL_CLASS_BLEND_STATE:
-        case HLSL_CLASS_NULL:
-            break;
+        if (vkd3d_opcode == info->vkd3d_opcode
+                && vkd3d_shader_ver_ge(version, info->min_version.major, info->min_version.minor)
+                && (vkd3d_shader_ver_le(version, info->max_version.major, info->max_version.minor)
+                        || !info->max_version.major))
+            return info;
     }
-
-    vkd3d_unreachable();
 }
 
-static void write_sm1_type(struct vkd3d_bytecode_buffer *buffer, struct hlsl_type *type, unsigned int ctab_start)
+static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info_from_vsir_instruction(
+        struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_instruction *ins)
 {
-    const struct hlsl_type *array_type = hlsl_get_multiarray_element_type(type);
-    unsigned int array_size = hlsl_get_multiarray_size(type);
-    unsigned int field_count = 0;
-    size_t fields_offset = 0;
-    size_t i;
-
-    if (type->bytecode_offset)
-        return;
+    const struct vkd3d_sm1_opcode_info *info;
 
-    if (array_type->class == HLSL_CLASS_STRUCT)
+    if (!(info = shader_sm1_get_opcode_info_from_vsir(d3dbc, ins->opcode)))
     {
-        field_count = array_type->e.record.field_count;
-
-        for (i = 0; i < field_count; ++i)
-        {
-            struct hlsl_struct_field *field = &array_type->e.record.fields[i];
-
-            field->name_bytecode_offset = put_string(buffer, field->name);
-            write_sm1_type(buffer, field->type, ctab_start);
-        }
-
-        fields_offset = bytecode_align(buffer) - ctab_start;
-
-        for (i = 0; i < field_count; ++i)
-        {
-            struct hlsl_struct_field *field = &array_type->e.record.fields[i];
-
-            put_u32(buffer, field->name_bytecode_offset - ctab_start);
-            put_u32(buffer, field->type->bytecode_offset - ctab_start);
-        }
+        vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_INVALID_OPCODE,
+                "Opcode %#x not supported for shader profile.", ins->opcode);
+        d3dbc->failed = true;
+        return NULL;
     }
 
-    type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(hlsl_sm1_class(type), hlsl_sm1_base_type(array_type)));
-    put_u32(buffer, vkd3d_make_u32(type->dimy, type->dimx));
-    put_u32(buffer, vkd3d_make_u32(array_size, field_count));
-    put_u32(buffer, fields_offset);
-}
-
-static void sm1_sort_extern(struct list *sorted, struct hlsl_ir_var *to_sort)
-{
-    struct hlsl_ir_var *var;
-
-    list_remove(&to_sort->extern_entry);
-
-    LIST_FOR_EACH_ENTRY(var, sorted, struct hlsl_ir_var, extern_entry)
+    if (ins->dst_count != info->dst_count)
     {
-        if (strcmp(to_sort->name, var->name) < 0)
-        {
-            list_add_before(&var->extern_entry, &to_sort->extern_entry);
-            return;
-        }
+        vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_INVALID_REGISTER_COUNT,
+                "Invalid destination count %u for vsir instruction %#x (expected %u).",
+                ins->dst_count, ins->opcode, info->dst_count);
+        d3dbc->failed = true;
+        return NULL;
     }
-
-    list_add_tail(sorted, &to_sort->extern_entry);
-}
-
-static void sm1_sort_externs(struct hlsl_ctx *ctx)
-{
-    struct list sorted = LIST_INIT(sorted);
-    struct hlsl_ir_var *var, *next;
-
-    LIST_FOR_EACH_ENTRY_SAFE(var, next, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    if (ins->src_count != info->src_count)
     {
-        if (var->is_uniform)
-            sm1_sort_extern(&sorted, var);
+        vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_INVALID_REGISTER_COUNT,
+                "Invalid source count %u for vsir instruction %#x (expected %u).",
+                ins->src_count, ins->opcode, info->src_count);
+        d3dbc->failed = true;
+        return NULL;
     }
-    list_move_tail(&ctx->extern_vars, &sorted);
+
+    return info;
 }
 
-void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer)
+static void d3dbc_write_comment(struct d3dbc_compiler *d3dbc,
+        uint32_t tag, const struct vkd3d_shader_code *comment)
 {
-    size_t ctab_offset, ctab_start, ctab_end, vars_offset, vars_start, size_offset, creator_offset, offset;
-    unsigned int uniform_count = 0;
-    struct hlsl_ir_var *var;
-
-    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
-    {
-        unsigned int r;
-
-        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
-        {
-            if (var->semantic.name || !var->regs[r].allocated || !var->last_read)
-                continue;
-
-            ++uniform_count;
-
-            if (var->is_param && var->is_uniform)
-            {
-                char *new_name;
-
-                if (!(new_name = hlsl_sprintf_alloc(ctx, "$%s", var->name)))
-                    return;
-                vkd3d_free((char *)var->name);
-                var->name = new_name;
-            }
-        }
-    }
-
-    sm1_sort_externs(ctx);
+    struct vkd3d_bytecode_buffer *buffer = &d3dbc->buffer;
+    size_t offset, start, end;
 
-    size_offset = put_u32(buffer, 0);
-    ctab_offset = put_u32(buffer, VKD3D_MAKE_TAG('C','T','A','B'));
+    offset = put_u32(buffer, 0);
 
-    ctab_start = put_u32(buffer, 7 * sizeof(uint32_t)); /* CTAB header size. */
-    creator_offset = put_u32(buffer, 0);
-    put_u32(buffer, sm1_version(ctx->profile->type, ctx->profile->major_version, ctx->profile->minor_version));
-    put_u32(buffer, uniform_count);
-    vars_offset = put_u32(buffer, 0);
-    put_u32(buffer, 0); /* FIXME: flags */
-    put_u32(buffer, 0); /* FIXME: target string */
+    start = put_u32(buffer, tag);
+    bytecode_put_bytes(buffer, comment->code, comment->size);
+    end = bytecode_align(buffer);
 
-    vars_start = bytecode_align(buffer);
-    set_u32(buffer, vars_offset, vars_start - ctab_start);
+    set_u32(buffer, offset, vkd3d_make_u32(VKD3D_SM1_OP_COMMENT, (end - start) / sizeof(uint32_t)));
+}
 
-    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+static enum vkd3d_sm1_register_type d3dbc_register_type_from_vsir(const struct vkd3d_shader_register *reg)
+{
+    if (reg->type == VKD3DSPR_CONST)
     {
-        unsigned int r;
-
-        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
-        {
-            if (var->semantic.name || !var->regs[r].allocated || !var->last_read)
-                continue;
-
-            put_u32(buffer, 0); /* name */
-            if (r == HLSL_REGSET_NUMERIC)
-            {
-                put_u32(buffer, vkd3d_make_u32(D3DXRS_FLOAT4, var->regs[r].id));
-                put_u32(buffer, var->bind_count[r]);
-            }
-            else
-            {
-                put_u32(buffer, vkd3d_make_u32(D3DXRS_SAMPLER, var->regs[r].index));
-                put_u32(buffer, var->bind_count[r]);
-            }
-            put_u32(buffer, 0); /* type */
-            put_u32(buffer, 0); /* default value */
-        }
+        if (reg->idx[0].offset >= 6144)
+            return VKD3D_SM1_REG_CONST4;
+        if (reg->idx[0].offset >= 4096)
+            return VKD3D_SM1_REG_CONST3;
+        if (reg->idx[0].offset >= 2048)
+            return VKD3D_SM1_REG_CONST2;
     }
 
-    uniform_count = 0;
-
-    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    for (unsigned int i = 0; i < ARRAY_SIZE(register_types); ++i)
     {
-        unsigned int r;
-
-        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
-        {
-            size_t var_offset, name_offset;
-
-            if (var->semantic.name || !var->regs[r].allocated || !var->last_read)
-                continue;
-
-            var_offset = vars_start + (uniform_count * 5 * sizeof(uint32_t));
-
-            name_offset = put_string(buffer, var->name);
-            set_u32(buffer, var_offset, name_offset - ctab_start);
-
-            write_sm1_type(buffer, var->data_type, ctab_start);
-            set_u32(buffer, var_offset + 3 * sizeof(uint32_t), var->data_type->bytecode_offset - ctab_start);
-
-            if (var->default_values)
-            {
-                unsigned int reg_size = var->data_type->reg_size[HLSL_REGSET_NUMERIC];
-                unsigned int comp_count = hlsl_type_component_count(var->data_type);
-                unsigned int default_value_offset;
-                unsigned int k;
-
-                default_value_offset = bytecode_reserve_bytes(buffer, reg_size * sizeof(uint32_t));
-                set_u32(buffer, var_offset + 4 * sizeof(uint32_t), default_value_offset - ctab_start);
-
-                for (k = 0; k < comp_count; ++k)
-                {
-                    struct hlsl_type *comp_type = hlsl_type_get_component_type(ctx, var->data_type, k);
-                    unsigned int comp_offset;
-                    enum hlsl_regset regset;
-
-                    comp_offset = hlsl_type_get_component_offset(ctx, var->data_type, k, &regset);
-                    if (regset == HLSL_REGSET_NUMERIC)
-                    {
-                        union
-                        {
-                            uint32_t u;
-                            float f;
-                        } uni;
-
-                        switch (comp_type->e.numeric.type)
-                        {
-                            case HLSL_TYPE_DOUBLE:
-                                if (ctx->double_as_float_alias)
-                                    uni.u = var->default_values[k].number.u;
-                                else
-                                    uni.u = 0;
-                                break;
-
-                            case HLSL_TYPE_INT:
-                                uni.f = var->default_values[k].number.i;
-                                break;
-
-                            case HLSL_TYPE_UINT:
-                            case HLSL_TYPE_BOOL:
-                                uni.f = var->default_values[k].number.u;
-                                break;
-
-                            case HLSL_TYPE_HALF:
-                            case HLSL_TYPE_FLOAT:
-                                uni.u = var->default_values[k].number.u;
-                                break;
-
-                            default:
-                                vkd3d_unreachable();
-                        }
-
-                        set_u32(buffer, default_value_offset + comp_offset * sizeof(uint32_t), uni.u);
-                    }
-                }
-            }
-
-            ++uniform_count;
-        }
+        if (register_types[i].vsir_type == reg->type)
+            return register_types[i].d3dbc_type;
     }
 
-    offset = put_string(buffer, vkd3d_shader_get_version(NULL, NULL));
-    set_u32(buffer, creator_offset, offset - ctab_start);
-
-    ctab_end = bytecode_align(buffer);
-    set_u32(buffer, size_offset, vkd3d_make_u32(VKD3D_SM1_OP_COMMENT, (ctab_end - ctab_offset) / sizeof(uint32_t)));
+    vkd3d_unreachable();
 }
 
-static uint32_t sm1_encode_register_type(enum vkd3d_shader_register_type type)
+static uint32_t sm1_encode_register_type(const struct vkd3d_shader_register *reg)
 {
-    return ((type << VKD3D_SM1_REGISTER_TYPE_SHIFT) & VKD3D_SM1_REGISTER_TYPE_MASK)
-            | ((type << VKD3D_SM1_REGISTER_TYPE_SHIFT2) & VKD3D_SM1_REGISTER_TYPE_MASK2);
+    enum vkd3d_sm1_register_type sm1_type = d3dbc_register_type_from_vsir(reg);
+
+    return ((sm1_type << VKD3D_SM1_REGISTER_TYPE_SHIFT) & VKD3D_SM1_REGISTER_TYPE_MASK)
+            | ((sm1_type << VKD3D_SM1_REGISTER_TYPE_SHIFT2) & VKD3D_SM1_REGISTER_TYPE_MASK2);
 }
 
-struct sm1_instruction
+static uint32_t swizzle_from_vsir(uint32_t swizzle)
 {
-    enum vkd3d_sm1_opcode opcode;
-    unsigned int flags;
-
-    struct sm1_dst_register
-    {
-        enum vkd3d_shader_register_type type;
-        enum vkd3d_shader_dst_modifier mod;
-        unsigned int writemask;
-        uint32_t reg;
-    } dst;
+    uint32_t x = vsir_swizzle_get_component(swizzle, 0);
+    uint32_t y = vsir_swizzle_get_component(swizzle, 1);
+    uint32_t z = vsir_swizzle_get_component(swizzle, 2);
+    uint32_t w = vsir_swizzle_get_component(swizzle, 3);
 
-    struct sm1_src_register
-    {
-        enum vkd3d_shader_register_type type;
-        enum vkd3d_shader_src_modifier mod;
-        unsigned int swizzle;
-        uint32_t reg;
-    } srcs[4];
-    unsigned int src_count;
+    if (x & ~0x3u || y & ~0x3u || z & ~0x3u || w & ~0x3u)
+        ERR("Unexpected vsir swizzle: 0x%08x.\n", swizzle);
 
-    unsigned int has_dst;
-};
+    return ((x & 0x3u) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(0))
+            | ((y & 0x3) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(1))
+            | ((z & 0x3) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(2))
+            | ((w & 0x3) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(3));
+}
 
-static bool is_inconsequential_instr(const struct sm1_instruction *instr)
+static bool is_inconsequential_instr(const struct vkd3d_shader_instruction *ins)
 {
-    const struct sm1_src_register *src = &instr->srcs[0];
-    const struct sm1_dst_register *dst = &instr->dst;
+    const struct vkd3d_shader_dst_param *dst = &ins->dst[0];
+    const struct vkd3d_shader_src_param *src = &ins->src[0];
     unsigned int i;
 
-    if (instr->opcode != VKD3D_SM1_OP_MOV)
+    if (ins->opcode != VKD3DSIH_MOV)
         return false;
-    if (dst->mod != VKD3DSPDM_NONE)
+    if (dst->modifiers != VKD3DSPDM_NONE)
         return false;
-    if (src->mod != VKD3DSPSM_NONE)
+    if (src->modifiers != VKD3DSPSM_NONE)
         return false;
-    if (src->type != dst->type)
+    if (src->reg.type != dst->reg.type)
         return false;
-    if (src->reg != dst->reg)
+    if (src->reg.idx[0].offset != dst->reg.idx[0].offset)
         return false;
 
     for (i = 0; i < 4; ++i)
     {
-        if ((dst->writemask & (1 << i)) && (vsir_swizzle_get_component(src->swizzle, i) != i))
+        if ((dst->write_mask & (1u << i)) && (vsir_swizzle_get_component(src->swizzle, i) != i))
             return false;
     }
 
     return true;
 }
 
-static void write_sm1_dst_register(struct vkd3d_bytecode_buffer *buffer, const struct sm1_dst_register *reg)
+static void write_sm1_dst_register(struct vkd3d_bytecode_buffer *buffer, const struct vkd3d_shader_dst_param *reg)
 {
-    VKD3D_ASSERT(reg->writemask);
+    VKD3D_ASSERT(reg->write_mask);
     put_u32(buffer, VKD3D_SM1_INSTRUCTION_PARAMETER
-            | sm1_encode_register_type(reg->type)
-            | (reg->mod << VKD3D_SM1_DST_MODIFIER_SHIFT)
-            | (reg->writemask << VKD3D_SM1_WRITEMASK_SHIFT) | reg->reg);
+            | sm1_encode_register_type(&reg->reg)
+            | (reg->modifiers << VKD3D_SM1_DST_MODIFIER_SHIFT)
+            | (reg->write_mask << VKD3D_SM1_WRITEMASK_SHIFT)
+            | (reg->reg.idx[0].offset & VKD3D_SM1_REGISTER_NUMBER_MASK));
 }
 
-static void write_sm1_src_register(struct vkd3d_bytecode_buffer *buffer,
-        const struct sm1_src_register *reg)
+static void write_sm1_src_register(struct vkd3d_bytecode_buffer *buffer, const struct vkd3d_shader_src_param *reg)
 {
     put_u32(buffer, VKD3D_SM1_INSTRUCTION_PARAMETER
-            | sm1_encode_register_type(reg->type)
-            | (reg->mod << VKD3D_SM1_SRC_MODIFIER_SHIFT)
-            | (reg->swizzle << VKD3D_SM1_SWIZZLE_SHIFT) | reg->reg);
+            | sm1_encode_register_type(&reg->reg)
+            | (reg->modifiers << VKD3D_SM1_SRC_MODIFIER_SHIFT)
+            | (swizzle_from_vsir(reg->swizzle) << VKD3D_SM1_SWIZZLE_SHIFT)
+            | (reg->reg.idx[0].offset & VKD3D_SM1_REGISTER_NUMBER_MASK));
 }
 
-static void d3dbc_write_instruction(struct d3dbc_compiler *d3dbc, const struct sm1_instruction *instr)
+static void d3dbc_write_instruction(struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_instruction *ins)
 {
     const struct vkd3d_shader_version *version = &d3dbc->program->shader_version;
     struct vkd3d_bytecode_buffer *buffer = &d3dbc->buffer;
-    uint32_t token = instr->opcode;
+    const struct vkd3d_sm1_opcode_info *info;
     unsigned int i;
+    uint32_t token;
+
+    if (!(info = shader_sm1_get_opcode_info_from_vsir_instruction(d3dbc, ins)))
+        return;
 
-    if (is_inconsequential_instr(instr))
+    if (is_inconsequential_instr(ins))
         return;
 
-    token |= VKD3D_SM1_INSTRUCTION_FLAGS_MASK & (instr->flags << VKD3D_SM1_INSTRUCTION_FLAGS_SHIFT);
+    token = info->sm1_opcode;
+    token |= VKD3D_SM1_INSTRUCTION_FLAGS_MASK & (ins->flags << VKD3D_SM1_INSTRUCTION_FLAGS_SHIFT);
 
     if (version->major > 1)
-        token |= (instr->has_dst + instr->src_count) << VKD3D_SM1_INSTRUCTION_LENGTH_SHIFT;
+        token |= (ins->dst_count + ins->src_count) << VKD3D_SM1_INSTRUCTION_LENGTH_SHIFT;
     put_u32(buffer, token);
 
-    if (instr->has_dst)
-        write_sm1_dst_register(buffer, &instr->dst);
-
-    for (i = 0; i < instr->src_count; ++i)
-        write_sm1_src_register(buffer, &instr->srcs[i]);
-};
-
-static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info_from_vsir(
-        struct d3dbc_compiler *d3dbc, enum vkd3d_shader_opcode vkd3d_opcode)
-{
-    const struct vkd3d_shader_version *version = &d3dbc->program->shader_version;
-    const struct vkd3d_sm1_opcode_info *info;
-    unsigned int i = 0;
-
-    for (;;)
+    for (i = 0; i < ins->dst_count; ++i)
     {
-        info = &d3dbc->opcode_table[i++];
-        if (info->vkd3d_opcode == VKD3DSIH_INVALID)
-            return NULL;
-
-        if (vkd3d_opcode == info->vkd3d_opcode
-                && vkd3d_shader_ver_ge(version, info->min_version.major, info->min_version.minor)
-                && (vkd3d_shader_ver_le(version, info->max_version.major, info->max_version.minor)
-                        || !info->max_version.major))
-            return info;
-    }
-}
-
-static uint32_t swizzle_from_vsir(uint32_t swizzle)
-{
-    uint32_t x = vsir_swizzle_get_component(swizzle, 0);
-    uint32_t y = vsir_swizzle_get_component(swizzle, 1);
-    uint32_t z = vsir_swizzle_get_component(swizzle, 2);
-    uint32_t w = vsir_swizzle_get_component(swizzle, 3);
-
-    if (x & ~0x3u || y & ~0x3u || z & ~0x3u || w & ~0x3u)
-        ERR("Unexpected vsir swizzle: 0x%08x.\n", swizzle);
-
-    return ((x & 0x3u) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(0))
-            | ((y & 0x3) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(1))
-            | ((z & 0x3) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(2))
-            | ((w & 0x3) << VKD3D_SM1_SWIZZLE_COMPONENT_SHIFT(3));
-}
-
-static void sm1_src_reg_from_vsir(struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_src_param *param,
-        struct sm1_src_register *src, const struct vkd3d_shader_location *loc)
-{
-    src->mod = param->modifiers;
-    src->reg = param->reg.idx[0].offset;
-    src->type = param->reg.type;
-    src->swizzle = swizzle_from_vsir(param->swizzle);
-
-    if (param->reg.idx[0].rel_addr)
-    {
-        vkd3d_shader_error(d3dbc->message_context, loc, VKD3D_SHADER_ERROR_D3DBC_NOT_IMPLEMENTED,
-                "Unhandled relative addressing on source register.");
-        d3dbc->failed = true;
+        if (ins->dst[i].reg.idx[0].rel_addr)
+        {
+            vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_NOT_IMPLEMENTED,
+                    "Unhandled relative addressing on destination register.");
+            d3dbc->failed = true;
+        }
+        write_sm1_dst_register(buffer, &ins->dst[i]);
     }
-}
-
-static void sm1_dst_reg_from_vsir(struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_dst_param *param,
-        struct sm1_dst_register *dst, const struct vkd3d_shader_location *loc)
-{
-    dst->mod = param->modifiers;
-    dst->reg = param->reg.idx[0].offset;
-    dst->type = param->reg.type;
-    dst->writemask = param->write_mask;
 
-    if (param->reg.idx[0].rel_addr)
+    for (i = 0; i < ins->src_count; ++i)
     {
-        vkd3d_shader_error(d3dbc->message_context, loc, VKD3D_SHADER_ERROR_D3DBC_NOT_IMPLEMENTED,
-                "Unhandled relative addressing on destination register.");
-        d3dbc->failed = true;
+        if (ins->src[i].reg.idx[0].rel_addr)
+        {
+            vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_NOT_IMPLEMENTED,
+                    "Unhandled relative addressing on source register.");
+            d3dbc->failed = true;
+        }
+        write_sm1_src_register(buffer, &ins->src[i]);
     }
-}
+};
 
 static void d3dbc_write_vsir_def(struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_instruction *ins)
 {
@@ -2081,11 +1826,11 @@ static void d3dbc_write_vsir_def(struct d3dbc_compiler *d3dbc, const struct vkd3
     struct vkd3d_bytecode_buffer *buffer = &d3dbc->buffer;
     uint32_t token;
 
-    const struct sm1_dst_register reg =
+    const struct vkd3d_shader_dst_param reg =
     {
-        .type = VKD3DSPR_CONST,
-        .writemask = VKD3DSP_WRITEMASK_ALL,
-        .reg = ins->dst[0].reg.idx[0].offset,
+        .reg.type = VKD3DSPR_CONST,
+        .write_mask = VKD3DSP_WRITEMASK_ALL,
+        .reg.idx[0].offset = ins->dst[0].reg.idx[0].offset,
     };
 
     token = VKD3D_SM1_OP_DEF;
@@ -2103,7 +1848,7 @@ static void d3dbc_write_vsir_sampler_dcl(struct d3dbc_compiler *d3dbc,
 {
     const struct vkd3d_shader_version *version = &d3dbc->program->shader_version;
     struct vkd3d_bytecode_buffer *buffer = &d3dbc->buffer;
-    struct sm1_dst_register reg = {0};
+    struct vkd3d_shader_dst_param reg = {0};
     uint32_t token;
 
     token = VKD3D_SM1_OP_DCL;
@@ -2115,9 +1860,9 @@ static void d3dbc_write_vsir_sampler_dcl(struct d3dbc_compiler *d3dbc,
     token |= res_type << VKD3D_SM1_RESOURCE_TYPE_SHIFT;
     put_u32(buffer, token);
 
-    reg.type = VKD3DSPR_COMBINED_SAMPLER;
-    reg.writemask = VKD3DSP_WRITEMASK_ALL;
-    reg.reg = reg_id;
+    reg.reg.type = VKD3DSPR_COMBINED_SAMPLER;
+    reg.write_mask = VKD3DSP_WRITEMASK_ALL;
+    reg.reg.idx[0].offset = reg_id;
 
     write_sm1_dst_register(buffer, &reg);
 }
@@ -2163,61 +1908,6 @@ static void d3dbc_write_vsir_dcl(struct d3dbc_compiler *d3dbc, const struct vkd3
     }
 }
 
-static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info_from_vsir_instruction(
-        struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_instruction *ins)
-{
-    const struct vkd3d_sm1_opcode_info *info;
-
-    if (!(info = shader_sm1_get_opcode_info_from_vsir(d3dbc, ins->opcode)))
-    {
-        vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_INVALID_OPCODE,
-                "Opcode %#x not supported for shader profile.", ins->opcode);
-        d3dbc->failed = true;
-        return NULL;
-    }
-
-    if (ins->dst_count != info->dst_count)
-    {
-        vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_INVALID_REGISTER_COUNT,
-                "Invalid destination count %u for vsir instruction %#x (expected %u).",
-                ins->dst_count, ins->opcode, info->dst_count);
-        d3dbc->failed = true;
-        return NULL;
-    }
-    if (ins->src_count != info->src_count)
-    {
-        vkd3d_shader_error(d3dbc->message_context, &ins->location, VKD3D_SHADER_ERROR_D3DBC_INVALID_REGISTER_COUNT,
-                "Invalid source count %u for vsir instruction %#x (expected %u).",
-                ins->src_count, ins->opcode, info->src_count);
-        d3dbc->failed = true;
-        return NULL;
-    }
-
-    return info;
-}
-
-static void d3dbc_write_vsir_simple_instruction(struct d3dbc_compiler *d3dbc,
-        const struct vkd3d_shader_instruction *ins)
-{
-    struct sm1_instruction instr = {0};
-    const struct vkd3d_sm1_opcode_info *info;
-
-    if (!(info = shader_sm1_get_opcode_info_from_vsir_instruction(d3dbc, ins)))
-        return;
-
-    instr.opcode = info->sm1_opcode;
-    instr.flags = ins->flags;
-    instr.has_dst = info->dst_count;
-    instr.src_count = info->src_count;
-
-    if (instr.has_dst)
-        sm1_dst_reg_from_vsir(d3dbc, &ins->dst[0], &instr.dst, &ins->location);
-    for (unsigned int i = 0; i < instr.src_count; ++i)
-        sm1_src_reg_from_vsir(d3dbc, &ins->src[i], &instr.srcs[i], &ins->location);
-
-    d3dbc_write_instruction(d3dbc, &instr);
-}
-
 static void d3dbc_write_vsir_instruction(struct d3dbc_compiler *d3dbc, const struct vkd3d_shader_instruction *ins)
 {
     uint32_t writemask;
@@ -2254,7 +1944,7 @@ static void d3dbc_write_vsir_instruction(struct d3dbc_compiler *d3dbc, const str
         case VKD3DSIH_TEX:
         case VKD3DSIH_TEXKILL:
         case VKD3DSIH_TEXLDD:
-            d3dbc_write_vsir_simple_instruction(d3dbc, ins);
+            d3dbc_write_instruction(d3dbc, ins);
             break;
 
         case VKD3DSIH_EXP:
@@ -2271,7 +1961,7 @@ static void d3dbc_write_vsir_instruction(struct d3dbc_compiler *d3dbc, const str
                         writemask, ins->opcode);
                 d3dbc->failed = true;
             }
-            d3dbc_write_vsir_simple_instruction(d3dbc, ins);
+            d3dbc_write_instruction(d3dbc, ins);
             break;
 
         default:
@@ -2287,13 +1977,13 @@ static void d3dbc_write_semantic_dcl(struct d3dbc_compiler *d3dbc,
 {
     const struct vkd3d_shader_version *version = &d3dbc->program->shader_version;
     struct vkd3d_bytecode_buffer *buffer = &d3dbc->buffer;
-    struct sm1_dst_register reg = {0};
+    struct vkd3d_shader_dst_param reg = {0};
     enum vkd3d_decl_usage usage;
     uint32_t token, usage_idx;
     bool ret;
 
     if (sm1_register_from_semantic_name(version, element->semantic_name,
-            element->semantic_index, output, &reg.type, &reg.reg))
+            element->semantic_index, output, &reg.reg.type, &reg.reg.idx[0].offset))
     {
         usage = 0;
         usage_idx = 0;
@@ -2302,8 +1992,8 @@ static void d3dbc_write_semantic_dcl(struct d3dbc_compiler *d3dbc,
     {
         ret = sm1_usage_from_semantic_name(element->semantic_name, element->semantic_index, &usage, &usage_idx);
         VKD3D_ASSERT(ret);
-        reg.type = output ? VKD3DSPR_OUTPUT : VKD3DSPR_INPUT;
-        reg.reg = element->register_index;
+        reg.reg.type = output ? VKD3DSPR_OUTPUT : VKD3DSPR_INPUT;
+        reg.reg.idx[0].offset = element->register_index;
     }
 
     token = VKD3D_SM1_OP_DCL;
@@ -2316,7 +2006,7 @@ static void d3dbc_write_semantic_dcl(struct d3dbc_compiler *d3dbc,
     token |= usage_idx << VKD3D_SM1_DCL_USAGE_INDEX_SHIFT;
     put_u32(buffer, token);
 
-    reg.writemask = element->mask;
+    reg.write_mask = element->mask;
     write_sm1_dst_register(buffer, &reg);
 }
 
@@ -2384,9 +2074,7 @@ int d3dbc_compile(struct vsir_program *program, uint64_t config_flags,
     }
 
     put_u32(buffer, sm1_version(version->type, version->major, version->minor));
-
-    bytecode_put_bytes(buffer, ctab->code, ctab->size);
-
+    d3dbc_write_comment(&d3dbc, VKD3D_MAKE_TAG('C','T','A','B'), ctab);
     d3dbc_write_semantic_dcls(&d3dbc);
     d3dbc_write_program_instructions(&d3dbc);
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxbc.c b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
index f6ac8e0829e..81af62f7810 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -115,6 +115,14 @@ static uint32_t read_u32(const char **ptr)
     return ret;
 }
 
+static uint64_t read_u64(const char **ptr)
+{
+    uint64_t ret;
+    memcpy(&ret, *ptr, sizeof(ret));
+    *ptr += sizeof(ret);
+    return ret;
+}
+
 static float read_float(const char **ptr)
 {
     union
@@ -502,6 +510,28 @@ int shader_parse_input_signature(const struct vkd3d_shader_code *dxbc,
     return ret;
 }
 
+static int shdr_parse_features(const struct vkd3d_shader_dxbc_section_desc *section,
+        struct vkd3d_shader_message_context *message_context, struct vsir_features *f)
+{
+    const char *data = section->data.code;
+    const char *ptr = data;
+    uint64_t flags;
+
+    if (!require_space(0, 1, sizeof(uint64_t), section->data.size))
+    {
+        WARN("Invalid data size %#zx.\n", section->data.size);
+        vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_DXBC_INVALID_CHUNK_SIZE,
+                "SFI0 section size %zu is too small to contain flags.\n", section->data.size);
+        return VKD3D_ERROR_INVALID_ARGUMENT;
+    }
+    flags = read_u64(&ptr);
+
+    if (flags & DXBC_SFI0_REQUIRES_ROVS)
+        f->rovs = true;
+
+    return VKD3D_OK;
+}
+
 static int shdr_handler(const struct vkd3d_shader_dxbc_section_desc *section,
         struct vkd3d_shader_message_context *message_context, void *context)
 {
@@ -558,6 +588,11 @@ static int shdr_handler(const struct vkd3d_shader_dxbc_section_desc *section,
             desc->byte_code_size = section->data.size;
             break;
 
+        case TAG_SFI0:
+            if ((ret = shdr_parse_features(section, message_context, &desc->features)) < 0)
+                return ret;
+            break;
+
         case TAG_AON9:
             TRACE("Skipping AON9 shader code chunk.\n");
             break;
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index 7099bcc9ce2..399c2b67eae 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -430,6 +430,8 @@ enum dx_intrinsic_opcode
     DX_DERIV_COARSEY                =  84,
     DX_DERIV_FINEX                  =  85,
     DX_DERIV_FINEY                  =  86,
+    DX_EVAL_SAMPLE_INDEX            =  88,
+    DX_EVAL_CENTROID                =  89,
     DX_SAMPLE_INDEX                 =  90,
     DX_COVERAGE                     =  91,
     DX_THREAD_ID                    =  93,
@@ -3824,7 +3826,7 @@ static void src_params_init_from_operands(struct vkd3d_shader_src_param *src_par
 }
 
 static enum vkd3d_shader_register_type register_type_from_dxil_semantic_kind(
-        enum vkd3d_shader_sysval_semantic sysval_semantic)
+        enum vkd3d_shader_sysval_semantic sysval_semantic, bool is_input)
 {
     switch (sysval_semantic)
     {
@@ -3834,7 +3836,7 @@ static enum vkd3d_shader_register_type register_type_from_dxil_semantic_kind(
         case VKD3D_SHADER_SV_SAMPLE_INDEX:
             return VKD3DSPR_NULL;
         case VKD3D_SHADER_SV_COVERAGE:
-            return VKD3DSPR_COVERAGE;
+            return is_input ? VKD3DSPR_COVERAGE : VKD3DSPR_SAMPLEMASK;
         case VKD3D_SHADER_SV_DEPTH:
             return VKD3DSPR_DEPTHOUT;
         case VKD3D_SHADER_SV_DEPTH_GREATER_EQUAL:
@@ -3884,7 +3886,7 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
         param = &params[i];
 
         if (e->register_index == UINT_MAX
-                && (io_reg_type = register_type_from_dxil_semantic_kind(e->sysval_semantic)) != VKD3DSPR_NULL)
+                && (io_reg_type = register_type_from_dxil_semantic_kind(e->sysval_semantic, is_input)) != VKD3DSPR_NULL)
         {
             dst_param_io_init(param, e, io_reg_type);
             continue;
@@ -5098,6 +5100,53 @@ static void sm6_parser_emit_dx_dot(struct sm6_parser *sm6, enum dx_intrinsic_opc
     instruction_dst_param_init_ssa_scalar(ins, sm6);
 }
 
+static void sm6_parser_emit_dx_eval_attrib(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
+{
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_src_param *src_params;
+    const struct shader_signature *signature;
+    unsigned int row_index, column_index;
+    const struct signature_element *e;
+
+    row_index = sm6_value_get_constant_uint(operands[0]);
+    column_index = sm6_value_get_constant_uint(operands[2]);
+
+    signature = &sm6->p.program->input_signature;
+    if (row_index >= signature->element_count)
+    {
+        WARN("Invalid row index %u.\n", row_index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Invalid input row index %u for an attribute evaluation.", row_index);
+        return;
+    }
+
+    e = &signature->elements[row_index];
+    if (column_index >= VKD3D_VEC4_SIZE || !(e->mask & (1 << column_index)))
+    {
+        WARN("Invalid column index %u.\n", column_index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Invalid input column index %u for an attribute evaluation.", column_index);
+        return;
+    }
+
+    vsir_instruction_init(ins, &sm6->p.location, (op == DX_EVAL_CENTROID)
+            ? VKD3DSIH_EVAL_CENTROID : VKD3DSIH_EVAL_SAMPLE_INDEX);
+
+    if (!(src_params = instruction_src_params_alloc(ins, 1 + (op == DX_EVAL_SAMPLE_INDEX), sm6)))
+        return;
+
+    src_params[0].reg = sm6->input_params[row_index].reg;
+    src_param_init_scalar(&src_params[0], column_index);
+    if (e->register_count > 1)
+        register_index_address_init(&src_params[0].reg.idx[0], operands[1], sm6);
+
+    if (op == DX_EVAL_SAMPLE_INDEX)
+        src_param_init_from_value(&src_params[1], operands[3]);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
 static void sm6_parser_emit_dx_fabs(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const struct sm6_value **operands, struct function_emission_state *state)
 {
@@ -6288,6 +6337,8 @@ static const struct sm6_dx_opcode_info sm6_dx_op_table[] =
     [DX_DOT4                          ] = {"g", "RRRRRRRR", sm6_parser_emit_dx_dot},
     [DX_EMIT_STREAM                   ] = {"v", "c",    sm6_parser_emit_dx_stream},
     [DX_EMIT_THEN_CUT_STREAM          ] = {"v", "c",    sm6_parser_emit_dx_stream},
+    [DX_EVAL_CENTROID                 ] = {"o", "cic",  sm6_parser_emit_dx_eval_attrib},
+    [DX_EVAL_SAMPLE_INDEX             ] = {"o", "cici", sm6_parser_emit_dx_eval_attrib},
     [DX_EXP                           ] = {"g", "R",    sm6_parser_emit_dx_unary},
     [DX_FABS                          ] = {"g", "R",    sm6_parser_emit_dx_fabs},
     [DX_FIRST_BIT_HI                  ] = {"i", "m",    sm6_parser_emit_dx_unary},
@@ -9348,7 +9399,7 @@ static void signature_element_read_additional_element_values(struct signature_el
 }
 
 static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const struct sm6_metadata_value *m,
-        struct shader_signature *s, enum vkd3d_tessellator_domain tessellator_domain)
+        struct shader_signature *s, enum vkd3d_tessellator_domain tessellator_domain, bool is_input)
 {
     unsigned int i, j, column_count, operand_count, index;
     const struct sm6_metadata_node *node, *element_node;
@@ -9466,7 +9517,7 @@ static enum vkd3d_result sm6_parser_read_signature(struct sm6_parser *sm6, const
 
         if ((is_register = e->register_index == UINT_MAX))
         {
-            if (register_type_from_dxil_semantic_kind(e->sysval_semantic) == VKD3DSPR_INVALID)
+            if (register_type_from_dxil_semantic_kind(e->sysval_semantic, is_input) == VKD3DSPR_INVALID)
             {
                 WARN("Unhandled I/O register semantic kind %u.\n", j);
                 vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_SIGNATURE,
@@ -9578,17 +9629,17 @@ static enum vkd3d_result sm6_parser_signatures_init(struct sm6_parser *sm6, cons
     }
 
     if (m->u.node->operand_count && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[0],
-            &program->input_signature, tessellator_domain)) < 0)
+            &program->input_signature, tessellator_domain, true)) < 0)
     {
         return ret;
     }
     if (m->u.node->operand_count > 1 && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[1],
-            &program->output_signature, tessellator_domain)) < 0)
+            &program->output_signature, tessellator_domain, false)) < 0)
     {
         return ret;
     }
     if (m->u.node->operand_count > 1 && (ret = sm6_parser_read_signature(sm6, m->u.node->operands[2],
-            &program->patch_constant_signature, tessellator_domain)) < 0)
+            &program->patch_constant_signature, tessellator_domain, false)) < 0)
     {
         return ret;
     }
@@ -9717,12 +9768,13 @@ static void sm6_parser_emit_dcl_tessellator_domain(struct sm6_parser *sm6,
 
     ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_TESSELLATOR_DOMAIN);
     ins->declaration.tessellator_domain = tessellator_domain;
+    sm6->p.program->tess_domain = tessellator_domain;
 }
 
-static void sm6_parser_validate_control_point_count(struct sm6_parser *sm6, unsigned int count,
-        const char *type)
+static void sm6_parser_validate_control_point_count(struct sm6_parser *sm6,
+        unsigned int count, bool allow_zero, const char *type)
 {
-    if (!count || count > 32)
+    if ((!count && !allow_zero) || count > 32)
     {
         WARN("%s control point count %u invalid.\n", type, count);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
@@ -9744,6 +9796,8 @@ static void sm6_parser_emit_dcl_tessellator_partitioning(struct sm6_parser *sm6,
 
     ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_TESSELLATOR_PARTITIONING);
     ins->declaration.tessellator_partitioning = tessellator_partitioning;
+
+    sm6->p.program->tess_partitioning = tessellator_partitioning;
 }
 
 static void sm6_parser_emit_dcl_tessellator_output_primitive(struct sm6_parser *sm6,
@@ -9760,6 +9814,8 @@ static void sm6_parser_emit_dcl_tessellator_output_primitive(struct sm6_parser *
 
     ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_TESSELLATOR_OUTPUT_PRIMITIVE);
     ins->declaration.tessellator_output_primitive = primitive;
+
+    sm6->p.program->tess_output_primitive = primitive;
 }
 
 static void sm6_parser_emit_dcl_max_tessellation_factor(struct sm6_parser *sm6, struct sm6_metadata_value *m)
@@ -9951,7 +10007,7 @@ static enum vkd3d_tessellator_domain sm6_parser_ds_properties_init(struct sm6_pa
     }
 
     sm6_parser_emit_dcl_tessellator_domain(sm6, operands[0]);
-    sm6_parser_validate_control_point_count(sm6, operands[1], "Domain shader input");
+    sm6_parser_validate_control_point_count(sm6, operands[1], true, "Domain shader input");
     sm6->p.program->input_control_point_count = operands[1];
 
     return operands[0];
@@ -10010,9 +10066,9 @@ static enum vkd3d_tessellator_domain sm6_parser_hs_properties_init(struct sm6_pa
         }
     }
 
-    sm6_parser_validate_control_point_count(sm6, operands[1], "Hull shader input");
+    sm6_parser_validate_control_point_count(sm6, operands[1], false, "Hull shader input");
     program->input_control_point_count = operands[1];
-    sm6_parser_validate_control_point_count(sm6, operands[2], "Hull shader output");
+    sm6_parser_validate_control_point_count(sm6, operands[2], false, "Hull shader output");
     sm6_parser_emit_dcl_count(sm6, VKD3DSIH_DCL_OUTPUT_CONTROL_POINT_COUNT, operands[2]);
     program->output_control_point_count = operands[2];
     sm6_parser_emit_dcl_tessellator_domain(sm6, operands[3]);
@@ -10351,7 +10407,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, struct vsir_pro
     /* Estimate instruction count to avoid reallocation in most shaders. */
     count = max(token_count, 400) - 400;
     if (!vsir_program_init(program, compile_info, &version,
-            (count + (count >> 2)) / 2u + 10, VSIR_CF_BLOCKS, VSIR_FULLY_NORMALISED_IO))
+            (count + (count >> 2)) / 2u + 10, VSIR_CF_BLOCKS, VSIR_NORMALISED_SM6))
         return VKD3D_ERROR_OUT_OF_MEMORY;
     vkd3d_shader_parser_init(&sm6->p, program, message_context, compile_info->source_name);
     sm6->ptr = &sm6->start[1];
@@ -10378,6 +10434,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, struct vsir_pro
     *input_signature = dxbc_desc->input_signature;
     *output_signature = dxbc_desc->output_signature;
     *patch_constant_signature = dxbc_desc->patch_constant_signature;
+    program->features = dxbc_desc->features;
     memset(dxbc_desc, 0, sizeof(*dxbc_desc));
 
     block = &sm6->root_block;
diff --git a/libs/vkd3d/libs/vkd3d-shader/fx.c b/libs/vkd3d/libs/vkd3d-shader/fx.c
index e22177e1e30..779ffa1e156 100644
--- a/libs/vkd3d/libs/vkd3d-shader/fx.c
+++ b/libs/vkd3d/libs/vkd3d-shader/fx.c
@@ -36,6 +36,16 @@ struct fx_4_binary_type
     uint32_t typeinfo;
 };
 
+struct fx_5_shader
+{
+    uint32_t offset;
+    uint32_t sodecl[4];
+    uint32_t sodecl_count;
+    uint32_t rast_stream;
+    uint32_t iface_bindings_count;
+    uint32_t iface_bindings;
+};
+
 struct string_entry
 {
     struct rb_entry entry;
@@ -550,6 +560,8 @@ enum fx_4_type_constants
     FX_4_ASSIGNMENT_VARIABLE = 0x2,
     FX_4_ASSIGNMENT_ARRAY_CONSTANT_INDEX = 0x3,
     FX_4_ASSIGNMENT_ARRAY_VARIABLE_INDEX = 0x4,
+    FX_4_ASSIGNMENT_INLINE_SHADER = 0x7,
+    FX_5_ASSIGNMENT_INLINE_SHADER = 0x8,
 };
 
 static const uint32_t fx_4_numeric_base_types[] =
@@ -598,8 +610,8 @@ static uint32_t get_fx_4_numeric_type_description(const struct hlsl_type *type,
             return 0;
     }
 
-    value |= (type->dimy & 0x7) << FX_4_NUMERIC_ROWS_SHIFT;
-    value |= (type->dimx & 0x7) << FX_4_NUMERIC_COLUMNS_SHIFT;
+    value |= (type->e.numeric.dimy & 0x7) << FX_4_NUMERIC_ROWS_SHIFT;
+    value |= (type->e.numeric.dimx & 0x7) << FX_4_NUMERIC_COLUMNS_SHIFT;
     if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
         value |= FX_4_NUMERIC_COLUMN_MAJOR_MASK;
 
@@ -762,6 +774,7 @@ static uint32_t write_fx_4_type(const struct hlsl_type *type, struct fx_write_co
         case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_CONSTANT_BUFFER:
         case HLSL_CLASS_NULL:
+        case HLSL_CLASS_STREAM_OUTPUT:
             vkd3d_unreachable();
 
         case HLSL_CLASS_VOID:
@@ -1008,8 +1021,8 @@ static uint32_t get_fx_2_type_class(const struct hlsl_type *type)
     return hlsl_sm1_class(type);
 }
 
-static uint32_t write_fx_2_parameter(const struct hlsl_type *type, const char *name, const struct hlsl_semantic *semantic,
-        struct fx_write_context *fx)
+static uint32_t write_fx_2_parameter(const struct hlsl_type *type, const char *name,
+        const struct hlsl_semantic *semantic, bool is_combined_sampler, struct fx_write_context *fx)
 {
     struct vkd3d_bytecode_buffer *buffer = &fx->unstructured;
     uint32_t semantic_offset, offset, elements_count = 0, name_offset;
@@ -1025,7 +1038,7 @@ static uint32_t write_fx_2_parameter(const struct hlsl_type *type, const char *n
     name_offset = write_string(name, fx);
     semantic_offset = semantic->raw_name ? write_string(semantic->raw_name, fx) : 0;
 
-    offset = put_u32(buffer, hlsl_sm1_base_type(type));
+    offset = put_u32(buffer, hlsl_sm1_base_type(type, is_combined_sampler));
     put_u32(buffer, get_fx_2_type_class(type));
     put_u32(buffer, name_offset);
     put_u32(buffer, semantic_offset);
@@ -1034,13 +1047,13 @@ static uint32_t write_fx_2_parameter(const struct hlsl_type *type, const char *n
     switch (type->class)
     {
         case HLSL_CLASS_VECTOR:
-            put_u32(buffer, type->dimx);
-            put_u32(buffer, type->dimy);
+            put_u32(buffer, type->e.numeric.dimx);
+            put_u32(buffer, type->e.numeric.dimy);
             break;
         case HLSL_CLASS_SCALAR:
         case HLSL_CLASS_MATRIX:
-            put_u32(buffer, type->dimy);
-            put_u32(buffer, type->dimx);
+            put_u32(buffer, type->e.numeric.dimy);
+            put_u32(buffer, type->e.numeric.dimx);
             break;
         case HLSL_CLASS_STRUCT:
             put_u32(buffer, type->e.record.field_count);
@@ -1061,7 +1074,7 @@ static uint32_t write_fx_2_parameter(const struct hlsl_type *type, const char *n
 
             /* Validated in check_invalid_object_fields(). */
             VKD3D_ASSERT(hlsl_is_numeric_type(field->type));
-            write_fx_2_parameter(field->type, field->name, &field->semantic, fx);
+            write_fx_2_parameter(field->type, field->name, &field->semantic, false, fx);
         }
     }
 
@@ -1298,6 +1311,7 @@ static bool is_type_supported_fx_2(struct hlsl_ctx *ctx, const struct hlsl_type
         case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_CONSTANT_BUFFER:
         case HLSL_CLASS_NULL:
+        case HLSL_CLASS_STREAM_OUTPUT:
             /* This cannot appear as an extern variable. */
             break;
     }
@@ -1321,7 +1335,7 @@ static void write_fx_2_parameters(struct fx_write_context *fx)
         if (!is_type_supported_fx_2(ctx, var->data_type, &var->loc))
             continue;
 
-        desc_offset = write_fx_2_parameter(var->data_type, var->name, &var->semantic, fx);
+        desc_offset = write_fx_2_parameter(var->data_type, var->name, &var->semantic, var->is_combined_sampler, fx);
         value_offset = write_fx_2_initial_value(var, fx);
 
         flags = 0;
@@ -1344,7 +1358,7 @@ static void write_fx_2_annotation(struct hlsl_ir_var *var, struct fx_write_conte
     struct vkd3d_bytecode_buffer *buffer = &fx->structured;
     uint32_t desc_offset, value_offset;
 
-    desc_offset = write_fx_2_parameter(var->data_type, var->name, &var->semantic, fx);
+    desc_offset = write_fx_2_parameter(var->data_type, var->name, &var->semantic, var->is_combined_sampler, fx);
     value_offset = write_fx_2_initial_value(var, fx);
 
     put_u32(buffer, desc_offset);
@@ -1834,6 +1848,7 @@ enum state_property_component_type
     FX_BLEND,
     FX_VERTEXSHADER,
     FX_PIXELSHADER,
+    FX_GEOMETRYSHADER,
     FX_COMPONENT_TYPE_COUNT,
 };
 
@@ -2065,6 +2080,7 @@ fx_4_states[] =
 
     { "VertexShader",          HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_VERTEXSHADER,     1, 1, 6 },
     { "PixelShader",           HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_PIXELSHADER,      1, 1, 7 },
+    { "GeometryShader",        HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_GEOMETRYSHADER,   1, 1, 8 },
     { "DS_StencilRef",         HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 9 },
     { "AB_BlendFactor",        HLSL_CLASS_PASS, HLSL_CLASS_VECTOR, FX_FLOAT, 4, 1, 10 },
     { "AB_SampleMask",         HLSL_CLASS_PASS, HLSL_CLASS_SCALAR, FX_UINT,  1, 1, 11 },
@@ -2951,7 +2967,7 @@ static void VKD3D_PRINTF_FUNC(3, 4) fx_parser_error(struct fx_parser *parser, en
 
 static int fx_2_parse(struct fx_parser *parser)
 {
-    fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_NOT_IMPLEMENTED, "Parsing fx_2_0 binaries is not implemented.\n");
+    fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_NOT_IMPLEMENTED, "Parsing fx_2_0 binaries is not implemented.");
 
     return -1;
 }
@@ -3120,7 +3136,7 @@ static void fx_parse_fx_4_annotations(struct fx_parser *parser)
         else
         {
             fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_DATA,
-                    "Only numeric and string types are supported in annotations.\n");
+                    "Only numeric and string types are supported in annotations.");
         }
 
         if (type.element_count)
@@ -3210,27 +3226,13 @@ static void fx_parse_buffers(struct fx_parser *parser)
     }
 }
 
-static void fx_4_parse_shader_initializer(struct fx_parser *parser, unsigned int object_type)
+static void fx_4_parse_shader_blob(struct fx_parser *parser, unsigned int object_type, const struct fx_5_shader *shader)
 {
     struct vkd3d_shader_compile_info info = { 0 };
     struct vkd3d_shader_code output;
-    uint32_t data_size, offset;
     const void *data = NULL;
     const char *p, *q, *end;
-    struct fx_5_shader
-    {
-        uint32_t offset;
-        uint32_t sodecl[4];
-        uint32_t sodecl_count;
-        uint32_t rast_stream;
-        uint32_t iface_bindings_count;
-        uint32_t iface_bindings;
-    } shader5;
-    struct fx_4_gs_so
-    {
-        uint32_t offset;
-        uint32_t sodecl;
-    } gs_so;
+    uint32_t data_size;
     int ret;
 
     static const struct vkd3d_shader_compile_option options[] =
@@ -3238,35 +3240,9 @@ static void fx_4_parse_shader_initializer(struct fx_parser *parser, unsigned int
         {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_14},
     };
 
-    switch (object_type)
-    {
-        case FX_4_OBJECT_TYPE_PIXEL_SHADER:
-        case FX_4_OBJECT_TYPE_VERTEX_SHADER:
-        case FX_4_OBJECT_TYPE_GEOMETRY_SHADER:
-            offset = fx_parser_read_u32(parser);
-            break;
-
-        case FX_4_OBJECT_TYPE_GEOMETRY_SHADER_SO:
-            fx_parser_read_u32s(parser, &gs_so, sizeof(gs_so));
-            offset = gs_so.offset;
-            break;
-
-        case FX_5_OBJECT_TYPE_GEOMETRY_SHADER:
-        case FX_5_OBJECT_TYPE_COMPUTE_SHADER:
-        case FX_5_OBJECT_TYPE_HULL_SHADER:
-        case FX_5_OBJECT_TYPE_DOMAIN_SHADER:
-            fx_parser_read_u32s(parser, &shader5, sizeof(shader5));
-            offset = shader5.offset;
-            break;
-
-        default:
-            parser->failed = true;
-            return;
-    }
-
-    fx_parser_read_unstructured(parser, &data_size, offset, sizeof(data_size));
+    fx_parser_read_unstructured(parser, &data_size, shader->offset, sizeof(data_size));
     if (data_size)
-        data = fx_parser_get_unstructured_ptr(parser, offset + 4, data_size);
+        data = fx_parser_get_unstructured_ptr(parser, shader->offset + 4, data_size);
 
     if (!data)
         return;
@@ -3283,7 +3259,7 @@ static void fx_4_parse_shader_initializer(struct fx_parser *parser, unsigned int
     if ((ret = vkd3d_shader_compile(&info, &output, NULL)) < 0)
     {
         fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_DATA,
-                "Failed to disassemble shader blob.\n");
+                "Failed to disassemble shader blob.");
         return;
     }
     parse_fx_print_indent(parser);
@@ -3307,26 +3283,58 @@ static void fx_4_parse_shader_initializer(struct fx_parser *parser, unsigned int
 
     parse_fx_print_indent(parser);
     vkd3d_string_buffer_printf(&parser->buffer, "}");
-    if (object_type == FX_4_OBJECT_TYPE_GEOMETRY_SHADER_SO && gs_so.sodecl)
+    if (object_type == FX_4_OBJECT_TYPE_GEOMETRY_SHADER_SO && shader->sodecl[0])
     {
         vkd3d_string_buffer_printf(&parser->buffer, "\n/* Stream output declaration: \"%s\" */",
-                fx_4_get_string(parser, gs_so.sodecl));
+                fx_4_get_string(parser, shader->sodecl[0]));
     }
     else if (object_type == FX_5_OBJECT_TYPE_GEOMETRY_SHADER)
     {
-        for (unsigned int i = 0; i < ARRAY_SIZE(shader5.sodecl); ++i)
+        for (unsigned int i = 0; i < ARRAY_SIZE(shader->sodecl); ++i)
         {
-           if (shader5.sodecl[i])
+           if (shader->sodecl[i])
                vkd3d_string_buffer_printf(&parser->buffer, "\n/* Stream output %u declaration: \"%s\" */",
-                       i, fx_4_get_string(parser, shader5.sodecl[i]));
+                       i, fx_4_get_string(parser, shader->sodecl[i]));
         }
-        if (shader5.sodecl_count)
-            vkd3d_string_buffer_printf(&parser->buffer, "\n/* Rasterized stream %u */", shader5.rast_stream);
+        if (shader->sodecl_count)
+            vkd3d_string_buffer_printf(&parser->buffer, "\n/* Rasterized stream %u */", shader->rast_stream);
     }
 
     vkd3d_shader_free_shader_code(&output);
 }
 
+static void fx_4_parse_shader_initializer(struct fx_parser *parser, unsigned int object_type)
+{
+    struct fx_5_shader shader = { 0 };
+
+    switch (object_type)
+    {
+        case FX_4_OBJECT_TYPE_PIXEL_SHADER:
+        case FX_4_OBJECT_TYPE_VERTEX_SHADER:
+        case FX_4_OBJECT_TYPE_GEOMETRY_SHADER:
+            shader.offset = fx_parser_read_u32(parser);
+            break;
+
+        case FX_4_OBJECT_TYPE_GEOMETRY_SHADER_SO:
+            shader.offset    = fx_parser_read_u32(parser);
+            shader.sodecl[0] = fx_parser_read_u32(parser);
+            break;
+
+        case FX_5_OBJECT_TYPE_GEOMETRY_SHADER:
+        case FX_5_OBJECT_TYPE_COMPUTE_SHADER:
+        case FX_5_OBJECT_TYPE_HULL_SHADER:
+        case FX_5_OBJECT_TYPE_DOMAIN_SHADER:
+            fx_parser_read_u32s(parser, &shader, sizeof(shader));
+            break;
+
+        default:
+            parser->failed = true;
+            return;
+    }
+
+    fx_4_parse_shader_blob(parser, object_type, &shader);
+}
+
 static bool fx_4_object_has_initializer(const struct fx_4_binary_type *type)
 {
     switch (type->typeinfo)
@@ -3390,6 +3398,8 @@ static void fx_4_parse_state_object_initializer(struct fx_parser *parser, uint32
         [FX_UINT8] = "byte",
     };
     const struct rhs_named_value *named_value;
+    struct fx_5_shader shader = { 0 };
+    unsigned int shader_type = 0;
     uint32_t i, j, comp_count;
     struct fx_4_state *state;
 
@@ -3400,7 +3410,7 @@ static void fx_4_parse_state_object_initializer(struct fx_parser *parser, uint32
         if (!(state = bsearch(&entry.id, fx_4_states, ARRAY_SIZE(fx_4_states),
                 sizeof(*fx_4_states), fx_4_state_id_compare)))
         {
-            fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_DATA, "Unrecognized state id %#x.\n", entry.id);
+            fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_INVALID_DATA, "Unrecognized state id %#x.", entry.id);
             break;
         }
 
@@ -3486,9 +3496,38 @@ static void fx_4_parse_state_object_initializer(struct fx_parser *parser, uint32
                 vkd3d_string_buffer_printf(&parser->buffer, "%s[%s]", fx_4_get_string(parser, index.name),
                         fx_4_get_string(parser, index.index));
                 break;
+            case FX_4_ASSIGNMENT_INLINE_SHADER:
+            case FX_5_ASSIGNMENT_INLINE_SHADER:
+            {
+                bool shader5 = entry.type == FX_5_ASSIGNMENT_INLINE_SHADER;
+
+                if (shader5)
+                    fx_parser_read_unstructured(parser, &shader, entry.value, sizeof(shader));
+                else
+                    fx_parser_read_unstructured(parser, &shader, entry.value, 2 * sizeof(uint32_t));
+
+                if (state->type == FX_PIXELSHADER)
+                    shader_type = FX_4_OBJECT_TYPE_PIXEL_SHADER;
+                else if (state->type == FX_VERTEXSHADER)
+                    shader_type = FX_4_OBJECT_TYPE_VERTEX_SHADER;
+                else if (state->type == FX_GEOMETRYSHADER)
+                    shader_type = shader5 ? FX_5_OBJECT_TYPE_GEOMETRY_SHADER : FX_4_OBJECT_TYPE_GEOMETRY_SHADER_SO;
+                else if (state->type == FX_HULLSHADER)
+                    shader_type = FX_5_OBJECT_TYPE_HULL_SHADER;
+                else if (state->type == FX_DOMAINSHADER)
+                    shader_type = FX_5_OBJECT_TYPE_DOMAIN_SHADER;
+                else if (state->type == FX_COMPUTESHADER)
+                    shader_type = FX_5_OBJECT_TYPE_COMPUTE_SHADER;
+
+                vkd3d_string_buffer_printf(&parser->buffer, "\n");
+                parse_fx_start_indent(parser);
+                fx_4_parse_shader_blob(parser, shader_type, &shader);
+                parse_fx_end_indent(parser);
+                break;
+            }
             default:
                 fx_parser_error(parser, VKD3D_SHADER_ERROR_FX_NOT_IMPLEMENTED,
-                        "Unsupported assignment type %u.\n", entry.type);
+                        "Unsupported assignment type %u.", entry.type);
         }
         vkd3d_string_buffer_printf(&parser->buffer, ";\n");
     }
diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index 0df0e30f399..ab6604bd703 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -1507,13 +1507,6 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *gen,
         case VKD3DSIH_DCL_INDEXABLE_TEMP:
             shader_glsl_dcl_indexable_temp(gen, ins);
             break;
-        case VKD3DSIH_DCL_INPUT:
-        case VKD3DSIH_DCL_INPUT_PS:
-        case VKD3DSIH_DCL_INPUT_PS_SGV:
-        case VKD3DSIH_DCL_INPUT_PS_SIV:
-        case VKD3DSIH_DCL_INPUT_SGV:
-        case VKD3DSIH_DCL_OUTPUT:
-        case VKD3DSIH_DCL_OUTPUT_SIV:
         case VKD3DSIH_NOP:
             break;
         case VKD3DSIH_DEFAULT:
@@ -2476,7 +2469,7 @@ int glsl_compile(struct vsir_program *program, uint64_t config_flags,
     if ((ret = vsir_program_transform(program, config_flags, compile_info, message_context)) < 0)
         return ret;
 
-    VKD3D_ASSERT(program->normalisation_level == VSIR_FULLY_NORMALISED_IO);
+    VKD3D_ASSERT(program->normalisation_level == VSIR_NORMALISED_SM6);
 
     vkd3d_glsl_generator_init(&generator, program, compile_info,
             descriptor_info, combined_sampler_info, message_context);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 96de18dc886..858186a1071 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -192,18 +192,20 @@ bool hlsl_type_is_row_major(const struct hlsl_type *type)
 
 unsigned int hlsl_type_minor_size(const struct hlsl_type *type)
 {
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
     if (type->class != HLSL_CLASS_MATRIX || hlsl_type_is_row_major(type))
-        return type->dimx;
+        return type->e.numeric.dimx;
     else
-        return type->dimy;
+        return type->e.numeric.dimy;
 }
 
 unsigned int hlsl_type_major_size(const struct hlsl_type *type)
 {
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
     if (type->class != HLSL_CLASS_MATRIX || hlsl_type_is_row_major(type))
-        return type->dimy;
+        return type->e.numeric.dimy;
     else
-        return type->dimx;
+        return type->e.numeric.dimx;
 }
 
 unsigned int hlsl_type_element_count(const struct hlsl_type *type)
@@ -211,7 +213,7 @@ unsigned int hlsl_type_element_count(const struct hlsl_type *type)
     switch (type->class)
     {
         case HLSL_CLASS_VECTOR:
-            return type->dimx;
+            return type->e.numeric.dimx;
         case HLSL_CLASS_MATRIX:
             return hlsl_type_major_size(type);
         case HLSL_CLASS_ARRAY:
@@ -287,6 +289,7 @@ bool hlsl_type_is_shader(const struct hlsl_type *type)
         case HLSL_CLASS_UAV:
         case HLSL_CLASS_CONSTANT_BUFFER:
         case HLSL_CLASS_BLEND_STATE:
+        case HLSL_CLASS_STREAM_OUTPUT:
         case HLSL_CLASS_VOID:
         case HLSL_CLASS_NULL:
             return false;
@@ -354,14 +357,24 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
     {
         case HLSL_CLASS_SCALAR:
         case HLSL_CLASS_VECTOR:
-            type->reg_size[HLSL_REGSET_NUMERIC] = is_sm4 ? type->dimx : 4;
+            type->reg_size[HLSL_REGSET_NUMERIC] = is_sm4 ? type->e.numeric.dimx : 4;
             break;
 
         case HLSL_CLASS_MATRIX:
             if (hlsl_type_is_row_major(type))
-                type->reg_size[HLSL_REGSET_NUMERIC] = is_sm4 ? (4 * (type->dimy - 1) + type->dimx) : (4 * type->dimy);
+            {
+                if (is_sm4)
+                    type->reg_size[HLSL_REGSET_NUMERIC] = 4 * (type->e.numeric.dimy - 1) + type->e.numeric.dimx;
+                else
+                    type->reg_size[HLSL_REGSET_NUMERIC] = 4 * type->e.numeric.dimy;
+            }
             else
-                type->reg_size[HLSL_REGSET_NUMERIC] = is_sm4 ? (4 * (type->dimx - 1) + type->dimy) : (4 * type->dimx);
+            {
+                if (is_sm4)
+                    type->reg_size[HLSL_REGSET_NUMERIC] = 4 * (type->e.numeric.dimx - 1) + type->e.numeric.dimy;
+                else
+                    type->reg_size[HLSL_REGSET_NUMERIC] = 4 * type->e.numeric.dimx;
+            }
             break;
 
         case HLSL_CLASS_ARRAY:
@@ -386,7 +399,6 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
         {
             unsigned int i;
 
-            type->dimx = 0;
             for (i = 0; i < type->e.record.field_count; ++i)
             {
                 struct hlsl_struct_field *field = &type->e.record.fields[i];
@@ -398,8 +410,6 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
                     field->reg_offset[k] = type->reg_size[k];
                     type->reg_size[k] += field->type->reg_size[k];
                 }
-
-                type->dimx += field->type->dimx * field->type->dimy * hlsl_get_multiarray_size(field->type);
             }
             break;
         }
@@ -434,6 +444,7 @@ static void hlsl_type_calculate_reg_size(struct hlsl_ctx *ctx, struct hlsl_type
         case HLSL_CLASS_HULL_SHADER:
         case HLSL_CLASS_GEOMETRY_SHADER:
         case HLSL_CLASS_BLEND_STATE:
+        case HLSL_CLASS_STREAM_OUTPUT:
         case HLSL_CLASS_NULL:
             break;
     }
@@ -481,8 +492,8 @@ static struct hlsl_type *hlsl_new_type(struct hlsl_ctx *ctx, const char *name, e
     }
     type->class = type_class;
     type->e.numeric.type = base_type;
-    type->dimx = dimx;
-    type->dimy = dimy;
+    type->e.numeric.dimx = dimx;
+    type->e.numeric.dimy = dimy;
     hlsl_type_calculate_reg_size(ctx, type);
 
     list_add_tail(&ctx->types, &type->entry);
@@ -525,6 +536,7 @@ static bool type_is_single_component(const struct hlsl_type *type)
         case HLSL_CLASS_PASS:
         case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
+        case HLSL_CLASS_STREAM_OUTPUT:
             break;
     }
     vkd3d_unreachable();
@@ -549,18 +561,19 @@ static unsigned int traverse_path_from_component_index(struct hlsl_ctx *ctx,
     switch (type->class)
     {
         case HLSL_CLASS_VECTOR:
-            VKD3D_ASSERT(index < type->dimx);
+            VKD3D_ASSERT(index < type->e.numeric.dimx);
             *type_ptr = hlsl_get_scalar_type(ctx, type->e.numeric.type);
             *index_ptr = 0;
             return index;
 
         case HLSL_CLASS_MATRIX:
         {
-            unsigned int y = index / type->dimx, x = index % type->dimx;
+            unsigned int y = index / type->e.numeric.dimx, x = index % type->e.numeric.dimx;
             bool row_major = hlsl_type_is_row_major(type);
 
-            VKD3D_ASSERT(index < type->dimx * type->dimy);
-            *type_ptr = hlsl_get_vector_type(ctx, type->e.numeric.type, row_major ? type->dimx : type->dimy);
+            VKD3D_ASSERT(index < type->e.numeric.dimx * type->e.numeric.dimy);
+            *type_ptr = hlsl_get_vector_type(ctx, type->e.numeric.type,
+                    row_major ? type->e.numeric.dimx : type->e.numeric.dimy);
             *index_ptr = row_major ? x : y;
             return row_major ? y : x;
         }
@@ -680,6 +693,7 @@ unsigned int hlsl_type_get_component_offset(struct hlsl_ctx *ctx, struct hlsl_ty
             case HLSL_CLASS_SCALAR:
             case HLSL_CLASS_CONSTANT_BUFFER:
             case HLSL_CLASS_NULL:
+            case HLSL_CLASS_STREAM_OUTPUT:
                 vkd3d_unreachable();
         }
         type = next_type;
@@ -857,9 +871,9 @@ struct hlsl_type *hlsl_get_element_type_from_path_index(struct hlsl_ctx *ctx, co
 
         case HLSL_CLASS_MATRIX:
             if (hlsl_type_is_row_major(type))
-                return hlsl_get_vector_type(ctx, type->e.numeric.type, type->dimx);
+                return hlsl_get_vector_type(ctx, type->e.numeric.type, type->e.numeric.dimx);
             else
-                return hlsl_get_vector_type(ctx, type->e.numeric.type, type->dimy);
+                return hlsl_get_vector_type(ctx, type->e.numeric.type, type->e.numeric.dimy);
 
         case HLSL_CLASS_ARRAY:
             return type->e.array.type;
@@ -888,8 +902,6 @@ struct hlsl_type *hlsl_new_array_type(struct hlsl_ctx *ctx, struct hlsl_type *ba
     type->modifiers = basic_type->modifiers;
     type->e.array.elements_count = array_size;
     type->e.array.type = basic_type;
-    type->dimx = basic_type->dimx;
-    type->dimy = basic_type->dimy;
     type->sampler_dim = basic_type->sampler_dim;
     hlsl_type_calculate_reg_size(ctx, type);
 
@@ -898,6 +910,22 @@ struct hlsl_type *hlsl_new_array_type(struct hlsl_ctx *ctx, struct hlsl_type *ba
     return type;
 }
 
+struct hlsl_type *hlsl_new_stream_output_type(struct hlsl_ctx *ctx,
+        enum hlsl_so_object_type so_type, struct hlsl_type *data_type)
+{
+    struct hlsl_type *type;
+
+    if (!(type = hlsl_alloc(ctx, sizeof(*type))))
+        return NULL;
+    type->class = HLSL_CLASS_STREAM_OUTPUT;
+    type->e.so.so_type = so_type;
+    type->e.so.type = data_type;
+
+    list_add_tail(&ctx->types, &type->entry);
+
+    return type;
+}
+
 struct hlsl_type *hlsl_new_struct_type(struct hlsl_ctx *ctx, const char *name,
         struct hlsl_struct_field *fields, size_t field_count)
 {
@@ -907,7 +935,6 @@ struct hlsl_type *hlsl_new_struct_type(struct hlsl_ctx *ctx, const char *name,
         return NULL;
     type->class = HLSL_CLASS_STRUCT;
     type->name = name;
-    type->dimy = 1;
     type->e.record.fields = fields;
     type->e.record.field_count = field_count;
     hlsl_type_calculate_reg_size(ctx, type);
@@ -925,8 +952,6 @@ struct hlsl_type *hlsl_new_texture_type(struct hlsl_ctx *ctx, enum hlsl_sampler_
     if (!(type = hlsl_alloc(ctx, sizeof(*type))))
         return NULL;
     type->class = HLSL_CLASS_TEXTURE;
-    type->dimx = 4;
-    type->dimy = 1;
     type->sampler_dim = dim;
     type->e.resource.format = format;
     type->sample_count = sample_count;
@@ -943,8 +968,6 @@ struct hlsl_type *hlsl_new_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim
     if (!(type = hlsl_alloc(ctx, sizeof(*type))))
         return NULL;
     type->class = HLSL_CLASS_UAV;
-    type->dimx = format->dimx;
-    type->dimy = 1;
     type->sampler_dim = dim;
     type->e.resource.format = format;
     type->e.resource.rasteriser_ordered = rasteriser_ordered;
@@ -960,7 +983,6 @@ struct hlsl_type *hlsl_new_cb_type(struct hlsl_ctx *ctx, struct hlsl_type *forma
     if (!(type = hlsl_alloc(ctx, sizeof(*type))))
         return NULL;
     type->class = HLSL_CLASS_CONSTANT_BUFFER;
-    type->dimy = 1;
     type->e.resource.format = format;
     hlsl_type_calculate_reg_size(ctx, type);
     list_add_tail(&ctx->types, &type->entry);
@@ -1046,7 +1068,7 @@ unsigned int hlsl_type_component_count(const struct hlsl_type *type)
         case HLSL_CLASS_SCALAR:
         case HLSL_CLASS_VECTOR:
         case HLSL_CLASS_MATRIX:
-            return type->dimx * type->dimy;
+            return type->e.numeric.dimx * type->e.numeric.dimy;
 
         case HLSL_CLASS_STRUCT:
         {
@@ -1086,6 +1108,7 @@ unsigned int hlsl_type_component_count(const struct hlsl_type *type)
         case HLSL_CLASS_PASS:
         case HLSL_CLASS_TECHNIQUE:
         case HLSL_CLASS_VOID:
+        case HLSL_CLASS_STREAM_OUTPUT:
             break;
     }
 
@@ -1110,9 +1133,9 @@ bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2
             if ((t1->modifiers & HLSL_MODIFIER_ROW_MAJOR)
                     != (t2->modifiers & HLSL_MODIFIER_ROW_MAJOR))
                 return false;
-            if (t1->dimx != t2->dimx)
+            if (t1->e.numeric.dimx != t2->e.numeric.dimx)
                 return false;
-            if (t1->dimy != t2->dimy)
+            if (t1->e.numeric.dimy != t2->e.numeric.dimy)
                 return false;
             return true;
 
@@ -1157,6 +1180,11 @@ bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2
         case HLSL_CLASS_CONSTANT_BUFFER:
             return hlsl_types_are_equal(t1->e.resource.format, t2->e.resource.format);
 
+        case HLSL_CLASS_STREAM_OUTPUT:
+            if (t1->e.so.so_type != t2->e.so.so_type)
+                return false;
+            return hlsl_types_are_equal(t1->e.so.type, t2->e.so.type);
+
         case HLSL_CLASS_DEPTH_STENCIL_STATE:
         case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_EFFECT_GROUP:
@@ -1198,8 +1226,6 @@ struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
         }
     }
     type->class = old->class;
-    type->dimx = old->dimx;
-    type->dimy = old->dimy;
     type->modifiers = old->modifiers | modifiers;
     if (!(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK))
         type->modifiers |= default_majority;
@@ -1212,6 +1238,8 @@ struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
         case HLSL_CLASS_SCALAR:
         case HLSL_CLASS_VECTOR:
         case HLSL_CLASS_MATRIX:
+            type->e.numeric.dimx = old->e.numeric.dimx;
+            type->e.numeric.dimy = old->e.numeric.dimy;
             type->e.numeric.type = old->e.numeric.type;
             break;
 
@@ -1471,7 +1499,7 @@ struct hlsl_ir_node *hlsl_new_store_index(struct hlsl_ctx *ctx, const struct hls
     hlsl_src_from_node(&store->rhs, rhs);
 
     if (!writemask && type_is_single_reg(rhs->data_type))
-        writemask = (1 << rhs->data_type->dimx) - 1;
+        writemask = (1 << rhs->data_type->e.numeric.dimx) - 1;
     store->writemask = writemask;
 
     return &store->node;
@@ -1498,7 +1526,7 @@ bool hlsl_new_store_component(struct hlsl_ctx *ctx, struct hlsl_block *block,
     hlsl_src_from_node(&store->rhs, rhs);
 
     if (type_is_single_reg(rhs->data_type))
-        store->writemask = (1 << rhs->data_type->dimx) - 1;
+        store->writemask = (1 << rhs->data_type->e.numeric.dimx) - 1;
 
     hlsl_block_add_instr(block, &store->node);
 
@@ -1695,22 +1723,6 @@ struct hlsl_ir_node *hlsl_new_switch(struct hlsl_ctx *ctx, struct hlsl_ir_node *
     return &s->node;
 }
 
-struct hlsl_ir_node *hlsl_new_vsir_instruction_ref(struct hlsl_ctx *ctx, unsigned int vsir_instr_idx,
-        struct hlsl_type *type, const struct hlsl_reg *reg, const struct vkd3d_shader_location *loc)
-{
-    struct hlsl_ir_vsir_instruction_ref *vsir_instr;
-
-    if (!(vsir_instr = hlsl_alloc(ctx, sizeof(*vsir_instr))))
-        return NULL;
-    init_node(&vsir_instr->node, HLSL_IR_VSIR_INSTRUCTION_REF, type, loc);
-    vsir_instr->vsir_instr_idx = vsir_instr_idx;
-
-    if (reg)
-        vsir_instr->node.reg = *reg;
-
-    return &vsir_instr->node;
-}
-
 struct hlsl_ir_load *hlsl_new_load_index(struct hlsl_ctx *ctx, const struct hlsl_deref *deref,
         struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc)
 {
@@ -1844,22 +1856,45 @@ struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct
     return &store->node;
 }
 
-struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int components,
+struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int component_count,
         struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_swizzle *swizzle;
     struct hlsl_type *type;
 
+    VKD3D_ASSERT(val->data_type->class <= HLSL_CLASS_VECTOR);
+
     if (!(swizzle = hlsl_alloc(ctx, sizeof(*swizzle))))
         return NULL;
-    VKD3D_ASSERT(hlsl_is_numeric_type(val->data_type));
-    if (components == 1)
+    if (component_count > 1)
+        type = hlsl_get_vector_type(ctx, val->data_type->e.numeric.type, component_count);
+    else
         type = hlsl_get_scalar_type(ctx, val->data_type->e.numeric.type);
+    init_node(&swizzle->node, HLSL_IR_SWIZZLE, type, loc);
+    hlsl_src_from_node(&swizzle->val, val);
+    swizzle->u.vector = s;
+
+    return &swizzle->node;
+}
+
+struct hlsl_ir_node *hlsl_new_matrix_swizzle(struct hlsl_ctx *ctx, struct hlsl_matrix_swizzle s,
+        unsigned int component_count, struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_swizzle *swizzle;
+    struct hlsl_type *type;
+
+    VKD3D_ASSERT(val->data_type->class == HLSL_CLASS_MATRIX);
+
+    if (!(swizzle = hlsl_alloc(ctx, sizeof(*swizzle))))
+        return NULL;
+    if (component_count > 1)
+        type = hlsl_get_vector_type(ctx, val->data_type->e.numeric.type, component_count);
     else
-        type = hlsl_get_vector_type(ctx, val->data_type->e.numeric.type, components);
+        type = hlsl_get_scalar_type(ctx, val->data_type->e.numeric.type);
     init_node(&swizzle->node, HLSL_IR_SWIZZLE, type, loc);
     hlsl_src_from_node(&swizzle->val, val);
-    swizzle->swizzle = s;
+    swizzle->u.matrix = s;
+
     return &swizzle->node;
 }
 
@@ -2031,7 +2066,7 @@ struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *v
     if (type->class == HLSL_CLASS_TEXTURE || type->class == HLSL_CLASS_UAV)
         type = type->e.resource.format;
     else if (type->class == HLSL_CLASS_MATRIX)
-        type = hlsl_get_vector_type(ctx, type->e.numeric.type, type->dimx);
+        type = hlsl_get_vector_type(ctx, type->e.numeric.type, type->e.numeric.dimx);
     else
         type = hlsl_get_element_type_from_path_index(ctx, type, idx);
 
@@ -2054,8 +2089,8 @@ struct hlsl_ir_node *hlsl_new_jump(struct hlsl_ctx *ctx, enum hlsl_ir_jump_type
     return &jump->node;
 }
 
-struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx,
-        struct hlsl_block *block, enum hlsl_ir_loop_unroll_type unroll_type,
+struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter,
+        struct hlsl_block *block, enum hlsl_loop_unroll_type unroll_type,
         unsigned int unroll_limit, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_loop *loop;
@@ -2066,6 +2101,10 @@ struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx,
     hlsl_block_init(&loop->body);
     hlsl_block_add_block(&loop->body, block);
 
+    hlsl_block_init(&loop->iter);
+    if (iter)
+        hlsl_block_add_block(&loop->iter, iter);
+
     loop->unroll_type = unroll_type;
     loop->unroll_limit = unroll_limit;
     return &loop->node;
@@ -2221,14 +2260,21 @@ static struct hlsl_ir_node *clone_load(struct hlsl_ctx *ctx, struct clone_instr_
 
 static struct hlsl_ir_node *clone_loop(struct hlsl_ctx *ctx, struct clone_instr_map *map, struct hlsl_ir_loop *src)
 {
+    struct hlsl_block iter, body;
     struct hlsl_ir_node *dst;
-    struct hlsl_block body;
+
+    if (!clone_block(ctx, &iter, &src->iter, map))
+        return NULL;
 
     if (!clone_block(ctx, &body, &src->body, map))
+    {
+        hlsl_block_cleanup(&iter);
         return NULL;
+    }
 
-    if (!(dst = hlsl_new_loop(ctx, &body, src->unroll_type, src->unroll_limit, &src->node.loc)))
+    if (!(dst = hlsl_new_loop(ctx, &iter, &body, src->unroll_type, src->unroll_limit, &src->node.loc)))
     {
+        hlsl_block_cleanup(&iter);
         hlsl_block_cleanup(&body);
         return NULL;
     }
@@ -2310,8 +2356,12 @@ static struct hlsl_ir_node *clone_store(struct hlsl_ctx *ctx, struct clone_instr
 static struct hlsl_ir_node *clone_swizzle(struct hlsl_ctx *ctx,
         struct clone_instr_map *map, struct hlsl_ir_swizzle *src)
 {
-    return hlsl_new_swizzle(ctx, src->swizzle, src->node.data_type->dimx,
-            map_instr(map, src->val.node), &src->node.loc);
+    if (src->val.node->data_type->class == HLSL_CLASS_MATRIX)
+        return hlsl_new_matrix_swizzle(ctx, src->u.matrix, src->node.data_type->e.numeric.dimx,
+                map_instr(map, src->val.node), &src->node.loc);
+    else
+        return hlsl_new_swizzle(ctx, src->u.vector, src->node.data_type->e.numeric.dimx,
+                map_instr(map, src->val.node), &src->node.loc);
 }
 
 static struct hlsl_ir_node *clone_index(struct hlsl_ctx *ctx, struct clone_instr_map *map,
@@ -2533,9 +2583,6 @@ static struct hlsl_ir_node *clone_instr(struct hlsl_ctx *ctx,
 
         case HLSL_IR_STATEBLOCK_CONSTANT:
             return clone_stateblock_constant(ctx, map, hlsl_ir_stateblock_constant(instr));
-
-        case HLSL_IR_VSIR_INSTRUCTION_REF:
-            vkd3d_unreachable();
     }
 
     vkd3d_unreachable();
@@ -2693,10 +2740,8 @@ struct hlsl_ir_function_decl *hlsl_get_func_decl(struct hlsl_ctx *ctx, const cha
     return NULL;
 }
 
-struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const struct hlsl_type *type)
+static void hlsl_dump_type(struct vkd3d_string_buffer *buffer, const struct hlsl_type *type)
 {
-    struct vkd3d_string_buffer *string, *inner_string;
-
     static const char *const base_types[] =
     {
         [HLSL_TYPE_FLOAT] = "float",
@@ -2720,31 +2765,29 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
         [HLSL_SAMPLER_DIM_CUBEARRAY] = "CubeArray",
     };
 
-    if (!(string = hlsl_get_string_buffer(ctx)))
-        return NULL;
-
     if (type->name)
     {
-        vkd3d_string_buffer_printf(string, "%s", type->name);
-        return string;
+        vkd3d_string_buffer_printf(buffer, "%s", type->name);
+        return;
     }
 
     switch (type->class)
     {
         case HLSL_CLASS_SCALAR:
             VKD3D_ASSERT(type->e.numeric.type < ARRAY_SIZE(base_types));
-            vkd3d_string_buffer_printf(string, "%s", base_types[type->e.numeric.type]);
-            return string;
+            vkd3d_string_buffer_printf(buffer, "%s", base_types[type->e.numeric.type]);
+            return;
 
         case HLSL_CLASS_VECTOR:
             VKD3D_ASSERT(type->e.numeric.type < ARRAY_SIZE(base_types));
-            vkd3d_string_buffer_printf(string, "%s%u", base_types[type->e.numeric.type], type->dimx);
-            return string;
+            vkd3d_string_buffer_printf(buffer, "%s%u", base_types[type->e.numeric.type], type->e.numeric.dimx);
+            return;
 
         case HLSL_CLASS_MATRIX:
             VKD3D_ASSERT(type->e.numeric.type < ARRAY_SIZE(base_types));
-            vkd3d_string_buffer_printf(string, "%s%ux%u", base_types[type->e.numeric.type], type->dimy, type->dimx);
-            return string;
+            vkd3d_string_buffer_printf(buffer, "%s%ux%u", base_types[type->e.numeric.type],
+                    type->e.numeric.dimy, type->e.numeric.dimx);
+            return;
 
         case HLSL_CLASS_ARRAY:
         {
@@ -2753,88 +2796,85 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
             for (t = type; t->class == HLSL_CLASS_ARRAY; t = t->e.array.type)
                 ;
 
-            if ((inner_string = hlsl_type_to_string(ctx, t)))
-            {
-                vkd3d_string_buffer_printf(string, "%s", inner_string->buffer);
-                hlsl_release_string_buffer(ctx, inner_string);
-            }
-
+            hlsl_dump_type(buffer, t);
             for (t = type; t->class == HLSL_CLASS_ARRAY; t = t->e.array.type)
             {
                 if (t->e.array.elements_count == HLSL_ARRAY_ELEMENTS_COUNT_IMPLICIT)
-                    vkd3d_string_buffer_printf(string, "[]");
+                    vkd3d_string_buffer_printf(buffer, "[]");
                 else
-                    vkd3d_string_buffer_printf(string, "[%u]", t->e.array.elements_count);
+                    vkd3d_string_buffer_printf(buffer, "[%u]", t->e.array.elements_count);
             }
-            return string;
+            return;
         }
 
         case HLSL_CLASS_STRUCT:
-            vkd3d_string_buffer_printf(string, "<anonymous struct>");
-            return string;
+            vkd3d_string_buffer_printf(buffer, "<anonymous struct>");
+            return;
 
         case HLSL_CLASS_TEXTURE:
             if (type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
             {
-                vkd3d_string_buffer_printf(string, "ByteAddressBuffer");
-                return string;
+                vkd3d_string_buffer_printf(buffer, "ByteAddressBuffer");
+                return;
             }
 
             if (type->sampler_dim == HLSL_SAMPLER_DIM_GENERIC)
             {
-                vkd3d_string_buffer_printf(string, "Texture");
-                return string;
+                vkd3d_string_buffer_printf(buffer, "Texture");
+                return;
             }
 
             VKD3D_ASSERT(hlsl_is_numeric_type(type->e.resource.format));
             VKD3D_ASSERT(type->e.resource.format->e.numeric.type < ARRAY_SIZE(base_types));
             if (type->sampler_dim == HLSL_SAMPLER_DIM_BUFFER)
             {
-                vkd3d_string_buffer_printf(string, "Buffer");
+                vkd3d_string_buffer_printf(buffer, "Buffer<");
             }
             else
             {
                 VKD3D_ASSERT(type->sampler_dim < ARRAY_SIZE(dimensions));
-                vkd3d_string_buffer_printf(string, "Texture%s", dimensions[type->sampler_dim]);
+                vkd3d_string_buffer_printf(buffer, "Texture%s<", dimensions[type->sampler_dim]);
             }
-            if ((inner_string = hlsl_type_to_string(ctx, type->e.resource.format)))
-            {
-                vkd3d_string_buffer_printf(string, "<%s>", inner_string->buffer);
-                hlsl_release_string_buffer(ctx, inner_string);
-            }
-            return string;
+            hlsl_dump_type(buffer, type->e.resource.format);
+            vkd3d_string_buffer_printf(buffer, ">");
+            return;
 
         case HLSL_CLASS_UAV:
             if (type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
             {
-                vkd3d_string_buffer_printf(string, "RWByteAddressBuffer");
-                return string;
+                vkd3d_string_buffer_printf(buffer, "RWByteAddressBuffer");
+                return;
             }
             if (type->sampler_dim == HLSL_SAMPLER_DIM_BUFFER)
-                vkd3d_string_buffer_printf(string, "RWBuffer");
+                vkd3d_string_buffer_printf(buffer, "RWBuffer<");
             else if (type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
-                vkd3d_string_buffer_printf(string, "RWStructuredBuffer");
+                vkd3d_string_buffer_printf(buffer, "RWStructuredBuffer<");
             else
-                vkd3d_string_buffer_printf(string, "RWTexture%s", dimensions[type->sampler_dim]);
-            if ((inner_string = hlsl_type_to_string(ctx, type->e.resource.format)))
-            {
-                vkd3d_string_buffer_printf(string, "<%s>", inner_string->buffer);
-                hlsl_release_string_buffer(ctx, inner_string);
-            }
-            return string;
+                vkd3d_string_buffer_printf(buffer, "RWTexture%s<", dimensions[type->sampler_dim]);
+            hlsl_dump_type(buffer, type->e.resource.format);
+            vkd3d_string_buffer_printf(buffer, ">");
+            return;
 
         case HLSL_CLASS_CONSTANT_BUFFER:
-            vkd3d_string_buffer_printf(string, "ConstantBuffer");
-            if ((inner_string = hlsl_type_to_string(ctx, type->e.resource.format)))
-            {
-                vkd3d_string_buffer_printf(string, "<%s>", inner_string->buffer);
-                hlsl_release_string_buffer(ctx, inner_string);
-            }
-            return string;
+            vkd3d_string_buffer_printf(buffer, "ConstantBuffer<");
+            hlsl_dump_type(buffer, type->e.resource.format);
+            vkd3d_string_buffer_printf(buffer, ">");
+            return;
 
         case HLSL_CLASS_ERROR:
-            vkd3d_string_buffer_printf(string, "<error type>");
-            return string;
+            vkd3d_string_buffer_printf(buffer, "<error type>");
+            return;
+
+        case HLSL_CLASS_STREAM_OUTPUT:
+            if (type->e.so.so_type == HLSL_STREAM_OUTPUT_POINT_STREAM)
+                vkd3d_string_buffer_printf(buffer, "PointStream<");
+            else if (type->e.so.so_type == HLSL_STREAM_OUTPUT_LINE_STREAM)
+                vkd3d_string_buffer_printf(buffer, "LineStream<");
+            else
+                vkd3d_string_buffer_printf(buffer, "TriangleStream<");
+            hlsl_dump_type(buffer, type->e.so.type);
+            vkd3d_string_buffer_printf(buffer, ">");
+            return;
 
         case HLSL_CLASS_DEPTH_STENCIL_STATE:
         case HLSL_CLASS_DEPTH_STENCIL_VIEW:
@@ -2857,8 +2897,17 @@ struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const stru
             break;
     }
 
-    vkd3d_string_buffer_printf(string, "<unexpected type>");
-    return string;
+    vkd3d_string_buffer_printf(buffer, "<unexpected type>");
+}
+
+struct vkd3d_string_buffer *hlsl_type_to_string(struct hlsl_ctx *ctx, const struct hlsl_type *type)
+{
+    struct vkd3d_string_buffer *buffer;
+
+    if (!(buffer = hlsl_get_string_buffer(ctx)))
+        return NULL;
+    hlsl_dump_type(buffer, type);
+    return buffer;
 }
 
 struct vkd3d_string_buffer *hlsl_component_to_string(struct hlsl_ctx *ctx, const struct hlsl_ir_var *var,
@@ -2968,7 +3017,6 @@ const char *hlsl_node_type_to_string(enum hlsl_ir_node_type type)
         [HLSL_IR_COMPILE]             = "HLSL_IR_COMPILE",
         [HLSL_IR_SAMPLER_STATE]       = "HLSL_IR_SAMPLER_STATE",
         [HLSL_IR_STATEBLOCK_CONSTANT] = "HLSL_IR_STATEBLOCK_CONSTANT",
-        [HLSL_IR_VSIR_INSTRUCTION_REF] = "HLSL_IR_VSIR_INSTRUCTION_REF",
     };
 
     if (type >= ARRAY_SIZE(names))
@@ -3022,7 +3070,8 @@ static void dump_ir_var(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer
             vkd3d_string_buffer_printf(buffer, "%s ", string->buffer);
         hlsl_release_string_buffer(ctx, string);
     }
-    vkd3d_string_buffer_printf(buffer, "%s %s", debug_hlsl_type(ctx, var->data_type), var->name);
+    hlsl_dump_type(buffer, var->data_type);
+    vkd3d_string_buffer_printf(buffer, " %s", var->name);
     if (var->semantic.name)
         vkd3d_string_buffer_printf(buffer, " : %s%u", var->semantic.name, var->semantic.index);
 }
@@ -3103,42 +3152,36 @@ const char *debug_hlsl_swizzle(uint32_t swizzle, unsigned int size)
     return vkd3d_dbg_sprintf(".%s", string);
 }
 
-static void dump_ir_call(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer, const struct hlsl_ir_call *call)
+void hlsl_dump_ir_function_decl(struct hlsl_ctx *ctx,
+        struct vkd3d_string_buffer *buffer, const struct hlsl_ir_function_decl *f)
 {
-    const struct hlsl_ir_function_decl *decl = call->decl;
-    struct vkd3d_string_buffer *string;
     size_t i;
 
-    if (!(string = hlsl_type_to_string(ctx, decl->return_type)))
-        return;
-
-    vkd3d_string_buffer_printf(buffer, "call %s %s(", string->buffer, decl->func->name);
-    hlsl_release_string_buffer(ctx, string);
-
-    for (i = 0; i < decl->parameters.count; ++i)
+    hlsl_dump_type(buffer, f->return_type);
+    vkd3d_string_buffer_printf(buffer, " %s(", f->func->name);
+    for (i = 0; i < f->parameters.count; ++i)
     {
-        const struct hlsl_ir_var *param = decl->parameters.vars[i];
-
-        if (!(string = hlsl_type_to_string(ctx, param->data_type)))
-            return;
-
         if (i)
             vkd3d_string_buffer_printf(buffer, ", ");
-        vkd3d_string_buffer_printf(buffer, "%s", string->buffer);
-
-        hlsl_release_string_buffer(ctx, string);
+        dump_ir_var(ctx, buffer, f->parameters.vars[i]);
     }
     vkd3d_string_buffer_printf(buffer, ")");
 }
 
+static void dump_ir_call(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer, const struct hlsl_ir_call *call)
+{
+    vkd3d_string_buffer_printf(buffer, "call ");
+    hlsl_dump_ir_function_decl(ctx, buffer, call->decl);
+}
+
 static void dump_ir_constant(struct vkd3d_string_buffer *buffer, const struct hlsl_ir_constant *constant)
 {
     struct hlsl_type *type = constant->node.data_type;
     unsigned int x;
 
-    if (type->dimx != 1)
+    if (type->e.numeric.dimx != 1)
         vkd3d_string_buffer_printf(buffer, "{");
-    for (x = 0; x < type->dimx; ++x)
+    for (x = 0; x < type->e.numeric.dimx; ++x)
     {
         const union hlsl_constant_value_component *value = &constant->value.u[x];
 
@@ -3164,12 +3207,9 @@ static void dump_ir_constant(struct vkd3d_string_buffer *buffer, const struct hl
             case HLSL_TYPE_UINT:
                 vkd3d_string_buffer_printf(buffer, "%u ", value->u);
                 break;
-
-            default:
-                vkd3d_unreachable();
         }
     }
-    if (type->dimx != 1)
+    if (type->e.numeric.dimx != 1)
         vkd3d_string_buffer_printf(buffer, "}");
 }
 
@@ -3201,13 +3241,11 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP1_LOG2]         = "log2",
         [HLSL_OP1_LOGIC_NOT]    = "!",
         [HLSL_OP1_NEG]          = "-",
-        [HLSL_OP1_NRM]          = "nrm",
         [HLSL_OP1_RCP]          = "rcp",
         [HLSL_OP1_REINTERPRET]  = "reinterpret",
         [HLSL_OP1_ROUND]        = "round",
         [HLSL_OP1_RSQ]          = "rsq",
         [HLSL_OP1_SAT]          = "sat",
-        [HLSL_OP1_SIGN]         = "sign",
         [HLSL_OP1_SIN]          = "sin",
         [HLSL_OP1_SIN_REDUCED]  = "sin_reduced",
         [HLSL_OP1_SQRT]         = "sqrt",
@@ -3217,7 +3255,6 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP2_BIT_AND]     = "&",
         [HLSL_OP2_BIT_OR]      = "|",
         [HLSL_OP2_BIT_XOR]     = "^",
-        [HLSL_OP2_CRS]         = "crs",
         [HLSL_OP2_DIV]         = "/",
         [HLSL_OP2_DOT]         = "dot",
         [HLSL_OP2_EQUAL]       = "==",
@@ -3398,15 +3435,17 @@ static void dump_ir_swizzle(struct vkd3d_string_buffer *buffer, const struct hls
     unsigned int i;
 
     dump_src(buffer, &swizzle->val);
-    if (swizzle->val.node->data_type->dimy > 1)
+    if (swizzle->val.node->data_type->e.numeric.dimy > 1)
     {
         vkd3d_string_buffer_printf(buffer, ".");
-        for (i = 0; i < swizzle->node.data_type->dimx; ++i)
-            vkd3d_string_buffer_printf(buffer, "_m%u%u", (swizzle->swizzle >> i * 8) & 0xf, (swizzle->swizzle >> (i * 8 + 4)) & 0xf);
+        for (i = 0; i < swizzle->node.data_type->e.numeric.dimx; ++i)
+            vkd3d_string_buffer_printf(buffer, "_m%u%u",
+                    swizzle->u.matrix.components[i].y, swizzle->u.matrix.components[i].x);
     }
     else
     {
-        vkd3d_string_buffer_printf(buffer, "%s", debug_hlsl_swizzle(swizzle->swizzle, swizzle->node.data_type->dimx));
+        vkd3d_string_buffer_printf(buffer, "%s",
+                debug_hlsl_swizzle(swizzle->u.vector, swizzle->node.data_type->e.numeric.dimx));
     }
 }
 
@@ -3562,11 +3601,6 @@ static void dump_instr(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer,
         case HLSL_IR_STATEBLOCK_CONSTANT:
             dump_ir_stateblock_constant(buffer, hlsl_ir_stateblock_constant(instr));
             break;
-
-        case HLSL_IR_VSIR_INSTRUCTION_REF:
-            vkd3d_string_buffer_printf(buffer, "vsir_program instruction %u",
-                    hlsl_ir_vsir_instruction_ref(instr)->vsir_instr_idx);
-            break;
     }
 }
 
@@ -3625,10 +3659,15 @@ void hlsl_dump_var_default_values(const struct hlsl_ir_var *var)
 
 void hlsl_replace_node(struct hlsl_ir_node *old, struct hlsl_ir_node *new)
 {
+    const struct hlsl_type *old_type = old->data_type, *new_type = new->data_type;
     struct hlsl_src *src, *next;
 
-    VKD3D_ASSERT(old->data_type == new->data_type || old->data_type->dimx == new->data_type->dimx);
-    VKD3D_ASSERT(old->data_type == new->data_type || old->data_type->dimy == new->data_type->dimy);
+    if (hlsl_is_numeric_type(old_type))
+    {
+        VKD3D_ASSERT(hlsl_is_numeric_type(new_type));
+        VKD3D_ASSERT(old_type->e.numeric.dimx == new_type->e.numeric.dimx);
+        VKD3D_ASSERT(old_type->e.numeric.dimy == new_type->e.numeric.dimy);
+    }
 
     LIST_FOR_EACH_ENTRY_SAFE(src, next, &old->uses, struct hlsl_src, entry)
     {
@@ -3719,6 +3758,7 @@ static void free_ir_load(struct hlsl_ir_load *load)
 static void free_ir_loop(struct hlsl_ir_loop *loop)
 {
     hlsl_block_cleanup(&loop->body);
+    hlsl_block_cleanup(&loop->iter);
     vkd3d_free(loop);
 }
 
@@ -3875,10 +3915,6 @@ void hlsl_free_instr(struct hlsl_ir_node *node)
         case HLSL_IR_STATEBLOCK_CONSTANT:
             free_ir_stateblock_constant(hlsl_ir_stateblock_constant(node));
             break;
-
-        case HLSL_IR_VSIR_INSTRUCTION_REF:
-            vkd3d_free(hlsl_ir_vsir_instruction_ref(node));
-            break;
     }
 }
 
@@ -3977,8 +4013,8 @@ void hlsl_add_function(struct hlsl_ctx *ctx, char *name, struct hlsl_ir_function
 
 uint32_t hlsl_map_swizzle(uint32_t swizzle, unsigned int writemask)
 {
+    unsigned int src_component = 0;
     uint32_t ret = 0;
-    unsigned int i;
 
     /* Leave replicate swizzles alone; some instructions need them. */
     if (swizzle == HLSL_SWIZZLE(X, X, X, X)
@@ -3987,13 +4023,10 @@ uint32_t hlsl_map_swizzle(uint32_t swizzle, unsigned int writemask)
             || swizzle == HLSL_SWIZZLE(W, W, W, W))
         return swizzle;
 
-    for (i = 0; i < 4; ++i)
+    for (unsigned int dst_component = 0; dst_component < 4; ++dst_component)
     {
-        if (writemask & (1 << i))
-        {
-            ret |= (swizzle & 3) << (i * 2);
-            swizzle >>= 2;
-        }
+        if (writemask & (1 << dst_component))
+            hlsl_swizzle_set_component(&ret, dst_component, hlsl_swizzle_get_component(swizzle, src_component++));
     }
     return ret;
 }
@@ -4046,7 +4079,7 @@ uint32_t hlsl_combine_swizzles(uint32_t first, uint32_t second, unsigned int dim
     for (i = 0; i < dim; ++i)
     {
         unsigned int s = hlsl_swizzle_get_component(second, i);
-        ret |= hlsl_swizzle_get_component(first, s) << HLSL_SWIZZLE_SHIFT(i);
+        hlsl_swizzle_set_component(&ret, i, hlsl_swizzle_get_component(first, s));
     }
     return ret;
 }
@@ -4304,7 +4337,7 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
     }
 
     ctx->builtin_types.Void = hlsl_new_simple_type(ctx, "void", HLSL_CLASS_VOID);
-    ctx->builtin_types.null = hlsl_new_type(ctx, "NULL", HLSL_CLASS_NULL, HLSL_TYPE_UINT, 1, 1);
+    ctx->builtin_types.null = hlsl_new_simple_type(ctx, "NULL", HLSL_CLASS_NULL);
     ctx->builtin_types.string = hlsl_new_simple_type(ctx, "string", HLSL_CLASS_STRING);
     ctx->builtin_types.error = hlsl_new_simple_type(ctx, "<error type>", HLSL_CLASS_ERROR);
     hlsl_scope_add_type(ctx->globals, ctx->builtin_types.string);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 075c76cb0e2..d712a325322 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -22,7 +22,6 @@
 
 #include "vkd3d_shader_private.h"
 #include "wine/rbtree.h"
-#include "d3dcommon.h"
 #include "d3dx9shader.h"
 
 /* The general IR structure is inspired by Mesa GLSL hir, even though the code
@@ -51,31 +50,17 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
-#define HLSL_SWIZZLE_X (0u)
-#define HLSL_SWIZZLE_Y (1u)
-#define HLSL_SWIZZLE_Z (2u)
-#define HLSL_SWIZZLE_W (3u)
-
-#define HLSL_SWIZZLE(x, y, z, w) \
-        (((HLSL_SWIZZLE_ ## x) << 0) \
-        | ((HLSL_SWIZZLE_ ## y) << 2) \
-        | ((HLSL_SWIZZLE_ ## z) << 4) \
-        | ((HLSL_SWIZZLE_ ## w) << 6))
-
-#define HLSL_SWIZZLE_MASK (0x3u)
-#define HLSL_SWIZZLE_SHIFT(idx) (2u * (idx))
+#define HLSL_SWIZZLE VKD3D_SHADER_SWIZZLE
 
 static inline unsigned int hlsl_swizzle_get_component(uint32_t swizzle, unsigned int idx)
 {
-    return (swizzle >> HLSL_SWIZZLE_SHIFT(idx)) & HLSL_SWIZZLE_MASK;
+    return vsir_swizzle_get_component(swizzle, idx);
 }
 
-static inline uint32_t vsir_swizzle_from_hlsl(uint32_t swizzle)
+static inline void hlsl_swizzle_set_component(uint32_t *swizzle, unsigned int idx, unsigned int component)
 {
-    return vkd3d_shader_create_swizzle(hlsl_swizzle_get_component(swizzle, 0),
-            hlsl_swizzle_get_component(swizzle, 1),
-            hlsl_swizzle_get_component(swizzle, 2),
-            hlsl_swizzle_get_component(swizzle, 3));
+    *swizzle &= ~(VKD3D_SHADER_SWIZZLE_MASK << VKD3D_SHADER_SWIZZLE_SHIFT(idx));
+    *swizzle |= component << VKD3D_SHADER_SWIZZLE_SHIFT(idx);
 }
 
 enum hlsl_type_class
@@ -105,6 +90,7 @@ enum hlsl_type_class
     HLSL_CLASS_GEOMETRY_SHADER,
     HLSL_CLASS_CONSTANT_BUFFER,
     HLSL_CLASS_BLEND_STATE,
+    HLSL_CLASS_STREAM_OUTPUT,
     HLSL_CLASS_VOID,
     HLSL_CLASS_NULL,
     HLSL_CLASS_ERROR,
@@ -142,6 +128,13 @@ enum hlsl_sampler_dim
     /* NOTE: Remember to update object_methods[] in hlsl.y if this enum is modified. */
 };
 
+enum hlsl_so_object_type
+{
+    HLSL_STREAM_OUTPUT_POINT_STREAM,
+    HLSL_STREAM_OUTPUT_LINE_STREAM,
+    HLSL_STREAM_OUTPUT_TRIANGLE_STREAM,
+};
+
 enum hlsl_regset
 {
     HLSL_REGSET_SAMPLERS,
@@ -176,16 +169,6 @@ struct hlsl_type
      * Modifiers that don't fall inside this mask are to be stored in the variable in
      *   hlsl_ir_var.modifiers, or in the struct field in hlsl_ir_field.modifiers. */
     uint32_t modifiers;
-    /* Size of the type values on each dimension. For non-numeric types, they are set for the
-     *   convenience of the sm1/sm4 backends.
-     * If type is HLSL_CLASS_SCALAR, then both dimx = 1 and dimy = 1.
-     * If type is HLSL_CLASS_VECTOR, then dimx is the size of the vector, and dimy = 1.
-     * If type is HLSL_CLASS_MATRIX, then dimx is the number of columns, and dimy the number of rows.
-     * If type is HLSL_CLASS_ARRAY, then dimx and dimy have the same value as in the type of the array elements.
-     * If type is HLSL_CLASS_STRUCT, then dimx is the sum of (dimx * dimy) of every component, and dimy = 1.
-     */
-    unsigned int dimx;
-    unsigned int dimy;
     /* Sample count for HLSL_SAMPLER_DIM_2DMS or HLSL_SAMPLER_DIM_2DMSARRAY. */
     unsigned int sample_count;
 
@@ -195,6 +178,10 @@ struct hlsl_type
         struct
         {
             enum hlsl_base_type type;
+            /* For scalars, dimx == dimy == 1.
+             * For vectors, dimx == vector width; dimy == 1.
+             * For matrices, dimx == column count; dimy == row count. */
+            unsigned int dimx, dimy;
         } numeric;
         /* Additional information if type is HLSL_CLASS_STRUCT. */
         struct
@@ -220,6 +207,12 @@ struct hlsl_type
         } resource;
         /* Additional field to distinguish object types. Currently used only for technique types. */
         unsigned int version;
+        /* Additional information if type is HLSL_CLASS_STREAM_OUTPUT. */
+        struct
+        {
+            struct hlsl_type *type;
+            enum hlsl_so_object_type so_type;
+        } so;
     } e;
 
     /* Number of numeric register components used by one value of this type, for each regset.
@@ -330,8 +323,6 @@ enum hlsl_ir_node_type
     HLSL_IR_COMPILE,
     HLSL_IR_SAMPLER_STATE,
     HLSL_IR_STATEBLOCK_CONSTANT,
-
-    HLSL_IR_VSIR_INSTRUCTION_REF,
 };
 
 /* Common data for every type of IR instruction node. */
@@ -524,6 +515,10 @@ struct hlsl_ir_var
      * element of a struct, and thus needs to be aligned when packed in the signature. */
     bool force_align;
 
+    /* Whether this is a sampler that was created from the combination of a
+     * sampler and a texture for SM<4 backwards compatibility. */
+    bool is_combined_sampler;
+
     uint32_t is_input_semantic : 1;
     uint32_t is_output_semantic : 1;
     uint32_t is_uniform : 1;
@@ -644,21 +639,30 @@ struct hlsl_ir_if
     struct hlsl_block else_block;
 };
 
-enum hlsl_ir_loop_unroll_type
+enum hlsl_loop_unroll_type
+{
+    HLSL_LOOP_UNROLL,
+    HLSL_LOOP_FORCE_UNROLL,
+    HLSL_LOOP_FORCE_LOOP
+};
+
+enum hlsl_loop_type
 {
-    HLSL_IR_LOOP_UNROLL,
-    HLSL_IR_LOOP_FORCE_UNROLL,
-    HLSL_IR_LOOP_FORCE_LOOP
+    HLSL_LOOP_FOR,
+    HLSL_LOOP_WHILE,
+    HLSL_LOOP_DO_WHILE
 };
 
 struct hlsl_ir_loop
 {
     struct hlsl_ir_node node;
+    struct hlsl_block iter;
     /* loop condition is stored in the body (as "if (!condition) break;") */
     struct hlsl_block body;
+    enum hlsl_loop_type type;
     unsigned int next_index; /* liveness index of the end of the loop */
     unsigned int unroll_limit;
-    enum hlsl_ir_loop_unroll_type unroll_type;
+    enum hlsl_loop_unroll_type unroll_type;
 };
 
 struct hlsl_ir_switch_case
@@ -703,13 +707,11 @@ enum hlsl_ir_expr_op
     HLSL_OP1_LOG2,
     HLSL_OP1_LOGIC_NOT,
     HLSL_OP1_NEG,
-    HLSL_OP1_NRM,
     HLSL_OP1_RCP,
     HLSL_OP1_REINTERPRET,
     HLSL_OP1_ROUND,
     HLSL_OP1_RSQ,
     HLSL_OP1_SAT,
-    HLSL_OP1_SIGN,
     HLSL_OP1_SIN,
     HLSL_OP1_SIN_REDUCED,    /* Reduced range [-pi, pi], writes to .y */
     HLSL_OP1_SQRT,
@@ -719,7 +721,6 @@ enum hlsl_ir_expr_op
     HLSL_OP2_BIT_AND,
     HLSL_OP2_BIT_OR,
     HLSL_OP2_BIT_XOR,
-    HLSL_OP2_CRS,
     HLSL_OP2_DIV,
     HLSL_OP2_DOT,
     HLSL_OP2_EQUAL,
@@ -781,7 +782,17 @@ struct hlsl_ir_swizzle
 {
     struct hlsl_ir_node node;
     struct hlsl_src val;
-    uint32_t swizzle;
+    union
+    {
+        uint32_t vector;
+        struct hlsl_matrix_swizzle
+        {
+            struct
+            {
+                uint8_t x, y;
+            } components[4];
+        } matrix;
+    } u;
 };
 
 struct hlsl_ir_index
@@ -844,6 +855,10 @@ enum hlsl_resource_load_type
     HLSL_RESOURCE_GATHER_GREEN,
     HLSL_RESOURCE_GATHER_BLUE,
     HLSL_RESOURCE_GATHER_ALPHA,
+    HLSL_RESOURCE_GATHER_CMP_RED,
+    HLSL_RESOURCE_GATHER_CMP_GREEN,
+    HLSL_RESOURCE_GATHER_CMP_BLUE,
+    HLSL_RESOURCE_GATHER_CMP_ALPHA,
     HLSL_RESOURCE_SAMPLE_INFO,
     HLSL_RESOURCE_RESINFO,
 };
@@ -934,16 +949,6 @@ struct hlsl_ir_stateblock_constant
     char *name;
 };
 
-/* A vkd3d_shader_instruction that can be inserted in a hlsl_block.
- * Only used for the HLSL IR to vsir translation, might be removed once this translation is complete. */
-struct hlsl_ir_vsir_instruction_ref
-{
-    struct hlsl_ir_node node;
-
-    /* Index to a vkd3d_shader_instruction within a vkd3d_shader_instruction_array in a vsir_program. */
-    unsigned int vsir_instr_idx;
-};
-
 struct hlsl_scope
 {
     /* Item entry for hlsl_ctx.scopes. */
@@ -1259,12 +1264,6 @@ static inline struct hlsl_ir_stateblock_constant *hlsl_ir_stateblock_constant(co
     return CONTAINING_RECORD(node, struct hlsl_ir_stateblock_constant, node);
 }
 
-static inline struct hlsl_ir_vsir_instruction_ref *hlsl_ir_vsir_instruction_ref(const struct hlsl_ir_node *node)
-{
-    VKD3D_ASSERT(node->type == HLSL_IR_VSIR_INSTRUCTION_REF);
-    return CONTAINING_RECORD(node, struct hlsl_ir_vsir_instruction_ref, node);
-}
-
 static inline void hlsl_block_init(struct hlsl_block *block)
 {
     list_init(&block->instrs);
@@ -1442,6 +1441,8 @@ void hlsl_block_cleanup(struct hlsl_block *block);
 bool hlsl_clone_block(struct hlsl_ctx *ctx, struct hlsl_block *dst_block, const struct hlsl_block *src_block);
 
 void hlsl_dump_function(struct hlsl_ctx *ctx, const struct hlsl_ir_function_decl *func);
+void hlsl_dump_ir_function_decl(struct hlsl_ctx *ctx,
+        struct vkd3d_string_buffer *buffer, const struct hlsl_ir_function_decl *f);
 void hlsl_dump_var_default_values(const struct hlsl_ir_var *var);
 
 bool hlsl_state_block_add_entry(struct hlsl_state_block *state_block,
@@ -1519,6 +1520,8 @@ struct hlsl_ir_node *hlsl_new_if(struct hlsl_ctx *ctx, struct hlsl_ir_node *cond
 struct hlsl_ir_node *hlsl_new_int_constant(struct hlsl_ctx *ctx, int32_t n, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_jump(struct hlsl_ctx *ctx,
         enum hlsl_ir_jump_type type, struct hlsl_ir_node *condition, const struct vkd3d_shader_location *loc);
+struct hlsl_type *hlsl_new_stream_output_type(struct hlsl_ctx *ctx,
+        enum hlsl_so_object_type so_type, struct hlsl_type *type);
 struct hlsl_ir_node *hlsl_new_ternary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op,
         struct hlsl_ir_node *arg1, struct hlsl_ir_node *arg2, struct hlsl_ir_node *arg3);
 
@@ -1550,8 +1553,11 @@ struct hlsl_ir_node *hlsl_new_compile(struct hlsl_ctx *ctx, enum hlsl_compile_ty
         struct hlsl_block *args_instrs, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *val,
         struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc);
-struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx,
-        struct hlsl_block *block, enum hlsl_ir_loop_unroll_type unroll_type, unsigned int unroll_limit, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter,
+        struct hlsl_block *block, enum hlsl_loop_unroll_type unroll_type,
+        unsigned int unroll_limit, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_new_matrix_swizzle(struct hlsl_ctx *ctx, struct hlsl_matrix_swizzle s,
+        unsigned int width, struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_resource_load(struct hlsl_ctx *ctx,
         const struct hlsl_resource_load_params *params, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct hlsl_deref *resource,
@@ -1588,9 +1594,6 @@ struct hlsl_ir_switch_case *hlsl_new_switch_case(struct hlsl_ctx *ctx, unsigned
 struct hlsl_ir_node *hlsl_new_switch(struct hlsl_ctx *ctx, struct hlsl_ir_node *selector,
         struct list *cases, const struct vkd3d_shader_location *loc);
 
-struct hlsl_ir_node *hlsl_new_vsir_instruction_ref(struct hlsl_ctx *ctx, unsigned int vsir_instr_idx,
-        struct hlsl_type *type, const struct hlsl_reg *reg, const struct vkd3d_shader_location *loc);
-
 void hlsl_error(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc,
         enum vkd3d_shader_error error, const char *fmt, ...) VKD3D_PRINTF_FUNC(4, 5);
 void hlsl_fixme(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc,
@@ -1645,24 +1648,35 @@ struct hlsl_reg hlsl_reg_from_deref(struct hlsl_ctx *ctx, const struct hlsl_dere
 bool hlsl_copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *block);
 bool hlsl_fold_constant_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context);
 bool hlsl_fold_constant_identities(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context);
+bool hlsl_normalize_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context);
 bool hlsl_fold_constant_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context);
 bool hlsl_transform_ir(struct hlsl_ctx *ctx, bool (*func)(struct hlsl_ctx *ctx, struct hlsl_ir_node *, void *),
         struct hlsl_block *block, void *context);
 
 D3DXPARAMETER_CLASS hlsl_sm1_class(const struct hlsl_type *type);
-D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type);
+D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type, bool is_combined_sampler);
+
+struct extern_resource
+{
+    /* "var" is only not NULL if this resource is a whole variable, so it may
+     * be responsible for more than one component. */
+    const struct hlsl_ir_var *var;
+    const struct hlsl_buffer *buffer;
 
-void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer);
-int d3dbc_compile(struct vsir_program *program, uint64_t config_flags,
-        const struct vkd3d_shader_compile_info *compile_info, const struct vkd3d_shader_code *ctab,
-        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
+    char *name;
+    bool is_user_packed;
 
-int tpf_compile(struct vsir_program *program, uint64_t config_flags,
-        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context,
-        struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func);
+    /* The data type of a single component of the resource. This might be
+     * different from the data type of the resource itself in 4.0 profiles,
+     * where an array (or multi-dimensional array) is handled as a single
+     * resource, unlike in 5.0. */
+    struct hlsl_type *component_type;
 
-enum vkd3d_shader_interpolation_mode sm4_get_interpolation_mode(struct hlsl_type *type,
-        unsigned int storage_modifiers);
+    enum hlsl_regset regset;
+    unsigned int id, space, index, bind_count;
+
+    struct vkd3d_shader_location loc;
+};
 
 struct hlsl_ir_function_decl *hlsl_compile_internal_function(struct hlsl_ctx *ctx, const char *name, const char *hlsl);
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.l b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
index 8dace11916a..31fb30521e9 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.l
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
@@ -104,6 +104,7 @@ if                      {return KW_IF;                  }
 in                      {return KW_IN;                  }
 inline                  {return KW_INLINE;              }
 inout                   {return KW_INOUT;               }
+LineStream              {return KW_LINESTREAM;          }
 linear                  {return KW_LINEAR;              }
 matrix                  {return KW_MATRIX;              }
 namespace               {return KW_NAMESPACE;           }
@@ -114,6 +115,7 @@ out                     {return KW_OUT;                 }
 packoffset              {return KW_PACKOFFSET;          }
 pass                    {return KW_PASS;                }
 PixelShader             {return KW_PIXELSHADER;         }
+PointStream             {return KW_POINTSTREAM;         }
 pixelshader             {return KW_PIXELSHADER;         }
 RasterizerOrderedBuffer           {return KW_RASTERIZERORDEREDBUFFER;            }
 RasterizerOrderedStructuredBuffer {return KW_RASTERIZERORDEREDSTRUCTUREDBUFFER;  }
@@ -170,6 +172,7 @@ texture3D               {return KW_TEXTURE3D;           }
 TextureCube             {return KW_TEXTURECUBE;         }
 textureCUBE             {return KW_TEXTURECUBE;         }
 TextureCubeArray        {return KW_TEXTURECUBEARRAY;    }
+TriangleStream          {return KW_TRIANGLESTREAM;      }
 true                    {return KW_TRUE;                }
 typedef                 {return KW_TYPEDEF;             }
 unsigned                {return KW_UNSIGNED;            }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 60aade732db..e6eaac78994 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -247,18 +247,19 @@ static bool type_contains_only_numerics(const struct hlsl_type *type)
 
 static bool explicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_type *src, struct hlsl_type *dst)
 {
-    if (hlsl_is_numeric_type(src) && src->dimx == 1 && src->dimy == 1 && type_contains_only_numerics(dst))
+    if (hlsl_is_numeric_type(src) && src->e.numeric.dimx == 1 && src->e.numeric.dimy == 1
+            && type_contains_only_numerics(dst))
         return true;
 
     if (src->class == HLSL_CLASS_MATRIX && dst->class == HLSL_CLASS_MATRIX
-            && src->dimx >= dst->dimx && src->dimy >= dst->dimy)
+            && src->e.numeric.dimx >= dst->e.numeric.dimx && src->e.numeric.dimy >= dst->e.numeric.dimy)
         return true;
 
-    if ((src->class == HLSL_CLASS_MATRIX && src->dimx > 1 && src->dimy > 1)
+    if ((src->class == HLSL_CLASS_MATRIX && src->e.numeric.dimx > 1 && src->e.numeric.dimy > 1)
             && hlsl_type_component_count(src) != hlsl_type_component_count(dst))
         return false;
 
-    if ((dst->class == HLSL_CLASS_MATRIX && dst->dimy > 1)
+    if ((dst->class == HLSL_CLASS_MATRIX && dst->e.numeric.dimy > 1)
             && hlsl_type_component_count(src) != hlsl_type_component_count(dst))
         return false;
 
@@ -273,16 +274,16 @@ static bool implicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_typ
     if (hlsl_is_numeric_type(src))
     {
         /* Scalar vars can be converted to any other numeric data type */
-        if (src->dimx == 1 && src->dimy == 1)
+        if (src->e.numeric.dimx == 1 && src->e.numeric.dimy == 1)
             return true;
         /* The other way around is true too */
-        if (dst->dimx == 1 && dst->dimy == 1)
+        if (dst->e.numeric.dimx == 1 && dst->e.numeric.dimy == 1)
             return true;
 
         if (src->class == HLSL_CLASS_MATRIX || dst->class == HLSL_CLASS_MATRIX)
         {
             if (src->class == HLSL_CLASS_MATRIX && dst->class == HLSL_CLASS_MATRIX)
-                return src->dimx >= dst->dimx && src->dimy >= dst->dimy;
+                return src->e.numeric.dimx >= dst->e.numeric.dimx && src->e.numeric.dimy >= dst->e.numeric.dimy;
 
             /* Matrix-vector conversion is apparently allowed if they have
             * the same components count, or if the matrix is 1xN or Nx1
@@ -292,8 +293,8 @@ static bool implicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_typ
                 if (hlsl_type_component_count(src) == hlsl_type_component_count(dst))
                     return true;
 
-                if ((src->class == HLSL_CLASS_VECTOR || src->dimx == 1 || src->dimy == 1) &&
-                        (dst->class == HLSL_CLASS_VECTOR || dst->dimx == 1 || dst->dimy == 1))
+                if ((src->class == HLSL_CLASS_VECTOR || src->e.numeric.dimx == 1 || src->e.numeric.dimy == 1)
+                        && (dst->class == HLSL_CLASS_VECTOR || dst->e.numeric.dimx == 1 || dst->e.numeric.dimy == 1))
                     return hlsl_type_component_count(src) >= hlsl_type_component_count(dst);
             }
 
@@ -301,7 +302,7 @@ static bool implicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_typ
         }
         else
         {
-            return src->dimx >= dst->dimx;
+            return src->e.numeric.dimx >= dst->e.numeric.dimx;
         }
     }
 
@@ -335,7 +336,7 @@ static void check_condition_type(struct hlsl_ctx *ctx, const struct hlsl_ir_node
     if (type->class == HLSL_CLASS_ERROR)
         return;
 
-    if (type->class > HLSL_CLASS_LAST_NUMERIC || type->dimx > 1 || type->dimy > 1)
+    if (type->class > HLSL_CLASS_LAST_NUMERIC || type->e.numeric.dimx > 1 || type->e.numeric.dimy > 1)
     {
         struct vkd3d_string_buffer *string;
 
@@ -368,14 +369,14 @@ static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *bl
         struct hlsl_ir_var *var;
         unsigned int dst_idx;
 
-        broadcast = hlsl_is_numeric_type(src_type) && src_type->dimx == 1 && src_type->dimy == 1;
+        broadcast = hlsl_is_numeric_type(src_type) && src_type->e.numeric.dimx == 1 && src_type->e.numeric.dimy == 1;
         matrix_cast = !broadcast && dst_comp_count != src_comp_count
                 && src_type->class == HLSL_CLASS_MATRIX && dst_type->class == HLSL_CLASS_MATRIX;
         VKD3D_ASSERT(src_comp_count >= dst_comp_count || broadcast);
         if (matrix_cast)
         {
-            VKD3D_ASSERT(dst_type->dimx <= src_type->dimx);
-            VKD3D_ASSERT(dst_type->dimy <= src_type->dimy);
+            VKD3D_ASSERT(dst_type->e.numeric.dimx <= src_type->e.numeric.dimx);
+            VKD3D_ASSERT(dst_type->e.numeric.dimy <= src_type->e.numeric.dimy);
         }
 
         if (!(var = hlsl_new_synthetic_var(ctx, "cast", dst_type, loc)))
@@ -395,9 +396,9 @@ static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *bl
             }
             else if (matrix_cast)
             {
-                unsigned int x = dst_idx % dst_type->dimx, y = dst_idx / dst_type->dimx;
+                unsigned int x = dst_idx % dst_type->e.numeric.dimx, y = dst_idx / dst_type->e.numeric.dimx;
 
-                src_idx = y * src_type->dimx + x;
+                src_idx = y * src_type->e.numeric.dimx + x;
             }
             else
             {
@@ -458,7 +459,9 @@ static struct hlsl_ir_node *add_implicit_conversion(struct hlsl_ctx *ctx, struct
         return NULL;
     }
 
-    if (dst_type->dimx * dst_type->dimy < src_type->dimx * src_type->dimy && ctx->warn_implicit_truncation)
+    if (hlsl_is_numeric_type(dst_type) && hlsl_is_numeric_type(src_type)
+            && dst_type->e.numeric.dimx * dst_type->e.numeric.dimy < src_type->e.numeric.dimx * src_type->e.numeric.dimy
+            && ctx->warn_implicit_truncation)
         hlsl_warning(ctx, loc, VKD3D_SHADER_WARNING_HLSL_IMPLICIT_TRUNCATION, "Implicit truncation of %s type.",
                 src_type->class == HLSL_CLASS_VECTOR ? "vector" : "matrix");
 
@@ -475,7 +478,11 @@ static bool add_explicit_conversion(struct hlsl_ctx *ctx, struct hlsl_block *blo
     for (i = 0; i < arrays->count; ++i)
     {
         if (arrays->sizes[i] == HLSL_ARRAY_ELEMENTS_COUNT_IMPLICIT)
+        {
             hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Implicit size arrays not allowed in casts.");
+            dst_type = ctx->builtin_types.error;
+            break;
+        }
         dst_type = hlsl_new_array_type(ctx, dst_type, arrays->sizes[i]);
     }
 
@@ -551,13 +558,6 @@ static bool append_conditional_break(struct hlsl_ctx *ctx, struct hlsl_block *co
     return true;
 }
 
-enum loop_type
-{
-    LOOP_FOR,
-    LOOP_WHILE,
-    LOOP_DO_WHILE
-};
-
 static void check_attribute_list_for_duplicates(struct hlsl_ctx *ctx, const struct parse_attribute_list *attrs)
 {
     unsigned int i, j;
@@ -573,8 +573,8 @@ static void check_attribute_list_for_duplicates(struct hlsl_ctx *ctx, const stru
     }
 }
 
-static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block, enum loop_type type,
-        struct hlsl_block *cond, struct hlsl_block *iter)
+static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        enum hlsl_loop_type type, struct hlsl_block *cond)
 {
     struct hlsl_ir_node *instr, *next;
 
@@ -584,8 +584,8 @@ static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block
         {
             struct hlsl_ir_if *iff = hlsl_ir_if(instr);
 
-            resolve_loop_continue(ctx, &iff->then_block, type, cond, iter);
-            resolve_loop_continue(ctx, &iff->else_block, type, cond, iter);
+            resolve_loop_continue(ctx, &iff->then_block, type, cond);
+            resolve_loop_continue(ctx, &iff->else_block, type, cond);
         }
         else if (instr->type == HLSL_IR_JUMP)
         {
@@ -595,7 +595,7 @@ static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block
             if (jump->type != HLSL_IR_JUMP_UNRESOLVED_CONTINUE)
                 continue;
 
-            if (type == LOOP_DO_WHILE)
+            if (type == HLSL_LOOP_DO_WHILE)
             {
                 if (!hlsl_clone_block(ctx, &cond_block, cond))
                     return;
@@ -606,13 +606,6 @@ static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block
                 }
                 list_move_before(&instr->entry, &cond_block.instrs);
             }
-            else if (type == LOOP_FOR)
-            {
-                if (!hlsl_clone_block(ctx, &cond_block, iter))
-                    return;
-                list_move_before(&instr->entry, &cond_block.instrs);
-            }
-            jump->type = HLSL_IR_JUMP_CONTINUE;
         }
     }
 }
@@ -678,8 +671,6 @@ static struct hlsl_default_value evaluate_static_expression(struct hlsl_ctx *ctx
                 hlsl_error(ctx, &node->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
                         "Expected literal expression.");
                 break;
-            case HLSL_IR_VSIR_INSTRUCTION_REF:
-                vkd3d_unreachable();
         }
     }
 
@@ -738,11 +729,11 @@ static unsigned int evaluate_static_expression_as_uint(struct hlsl_ctx *ctx, str
     return res.number.u;
 }
 
-static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
+static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum hlsl_loop_type type,
         const struct parse_attribute_list *attributes, struct hlsl_block *init, struct hlsl_block *cond,
         struct hlsl_block *iter, struct hlsl_block *body, const struct vkd3d_shader_location *loc)
 {
-    enum hlsl_ir_loop_unroll_type unroll_type = HLSL_IR_LOOP_UNROLL;
+    enum hlsl_loop_unroll_type unroll_type = HLSL_LOOP_UNROLL;
     unsigned int i, unroll_limit = 0;
     struct hlsl_ir_node *loop;
 
@@ -773,11 +764,11 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
                 hlsl_block_cleanup(&expr);
             }
 
-            unroll_type = HLSL_IR_LOOP_FORCE_UNROLL;
+            unroll_type = HLSL_LOOP_FORCE_UNROLL;
         }
         else if (!strcmp(attr->name, "loop"))
         {
-            unroll_type = HLSL_IR_LOOP_FORCE_LOOP;
+            unroll_type = HLSL_LOOP_FORCE_LOOP;
         }
         else if (!strcmp(attr->name, "fastopt")
                 || !strcmp(attr->name, "allow_uav_condition"))
@@ -790,7 +781,7 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
         }
     }
 
-    resolve_loop_continue(ctx, body, type, cond, iter);
+    resolve_loop_continue(ctx, body, type, cond);
 
     if (!init && !(init = make_empty_block(ctx)))
         goto oom;
@@ -798,15 +789,12 @@ static struct hlsl_block *create_loop(struct hlsl_ctx *ctx, enum loop_type type,
     if (!append_conditional_break(ctx, cond))
         goto oom;
 
-    if (iter)
-        hlsl_block_add_block(body, iter);
-
-    if (type == LOOP_DO_WHILE)
+    if (type == HLSL_LOOP_DO_WHILE)
         list_move_tail(&body->instrs, &cond->instrs);
     else
         list_move_head(&body->instrs, &cond->instrs);
 
-    if (!(loop = hlsl_new_loop(ctx, body, unroll_type, unroll_limit, loc)))
+    if (!(loop = hlsl_new_loop(ctx, iter, body, unroll_type, unroll_limit, loc)))
         goto oom;
     hlsl_block_add_instr(init, loop);
 
@@ -860,6 +848,7 @@ static struct hlsl_ir_node *get_swizzle(struct hlsl_ctx *ctx, struct hlsl_ir_nod
     if (value->data_type->class == HLSL_CLASS_MATRIX)
     {
         /* Matrix swizzle */
+        struct hlsl_matrix_swizzle s;
         bool m_swizzle;
         unsigned int inc, x, y;
 
@@ -888,12 +877,13 @@ static struct hlsl_ir_node *get_swizzle(struct hlsl_ctx *ctx, struct hlsl_ir_nod
                 x = swizzle[i + 2] - '1';
             }
 
-            if (x >= value->data_type->dimx || y >= value->data_type->dimy)
+            if (x >= value->data_type->e.numeric.dimx || y >= value->data_type->e.numeric.dimy)
                 return NULL;
-            swiz |= (y << 4 | x) << component * 8;
+            s.components[component].x = x;
+            s.components[component].y = y;
             component++;
         }
-        return hlsl_new_swizzle(ctx, swiz, component, value, loc);
+        return hlsl_new_matrix_swizzle(ctx, s, component, value, loc);
     }
 
     /* Vector swizzle */
@@ -920,10 +910,9 @@ static struct hlsl_ir_node *get_swizzle(struct hlsl_ctx *ctx, struct hlsl_ir_nod
                 break;
             }
 
-            if (s >= value->data_type->dimx)
+            if (s >= value->data_type->e.numeric.dimx)
                 return NULL;
-            swiz |= s << component * 2;
-            component++;
+            hlsl_swizzle_set_component(&swiz, component++, s);
         }
         if (valid)
             return hlsl_new_swizzle(ctx, swiz, component, value, loc);
@@ -1035,7 +1024,7 @@ static bool add_array_access(struct hlsl_ctx *ctx, struct hlsl_block *block, str
     {
         unsigned int dim_count = hlsl_sampler_dim_count(expr_type->sampler_dim);
 
-        if (index_type->class > HLSL_CLASS_VECTOR || index_type->dimx != dim_count)
+        if (index_type->class > HLSL_CLASS_VECTOR || index_type->e.numeric.dimx != dim_count)
         {
             struct vkd3d_string_buffer *string;
 
@@ -1192,6 +1181,8 @@ static bool gen_struct_fields(struct hlsl_ctx *ctx, struct parse_fields *fields,
                 {
                     hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Implicit size arrays not allowed in struct fields.");
+                    field->type = ctx->builtin_types.error;
+                    break;
                 }
 
                 field->type = hlsl_new_array_type(ctx, field->type, v->arrays.sizes[k]);
@@ -1282,6 +1273,12 @@ static bool add_typedef(struct hlsl_ctx *ctx, struct hlsl_type *const orig_type,
             {
                 hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                         "Implicit size arrays not allowed in typedefs.");
+                if (!(type = hlsl_type_clone(ctx, ctx->builtin_types.error, 0, 0)))
+                {
+                    free_parse_variable_def(v);
+                    ret = false;
+                }
+                break;
             }
 
             if (!(type = hlsl_new_array_type(ctx, type, v->arrays.sizes[i])))
@@ -1580,7 +1577,7 @@ static struct hlsl_block *make_block(struct hlsl_ctx *ctx, struct hlsl_ir_node *
 static bool expr_compatible_data_types(struct hlsl_type *t1, struct hlsl_type *t2)
 {
     /* Scalar vars can be converted to pretty much everything */
-    if ((t1->dimx == 1 && t1->dimy == 1) || (t2->dimx == 1 && t2->dimy == 1))
+    if ((t1->e.numeric.dimx == 1 && t1->e.numeric.dimy == 1) || (t2->e.numeric.dimx == 1 && t2->e.numeric.dimy == 1))
         return true;
 
     if (t1->class == HLSL_CLASS_VECTOR && t2->class == HLSL_CLASS_VECTOR)
@@ -1595,13 +1592,13 @@ static bool expr_compatible_data_types(struct hlsl_type *t1, struct hlsl_type *t
             if (hlsl_type_component_count(t1) == hlsl_type_component_count(t2))
                 return true;
 
-            return (t1->class == HLSL_CLASS_MATRIX && (t1->dimx == 1 || t1->dimy == 1))
-                    || (t2->class == HLSL_CLASS_MATRIX && (t2->dimx == 1 || t2->dimy == 1));
+            return (t1->class == HLSL_CLASS_MATRIX && (t1->e.numeric.dimx == 1 || t1->e.numeric.dimy == 1))
+                    || (t2->class == HLSL_CLASS_MATRIX && (t2->e.numeric.dimx == 1 || t2->e.numeric.dimy == 1));
         }
 
         /* Both matrices */
-        if ((t1->dimx >= t2->dimx && t1->dimy >= t2->dimy)
-                || (t1->dimx <= t2->dimx && t1->dimy <= t2->dimy))
+        if ((t1->e.numeric.dimx >= t2->e.numeric.dimx && t1->e.numeric.dimy >= t2->e.numeric.dimy)
+                || (t1->e.numeric.dimx <= t2->e.numeric.dimx && t1->e.numeric.dimy <= t2->e.numeric.dimy))
             return true;
     }
 
@@ -1661,37 +1658,37 @@ static bool expr_common_shape(struct hlsl_ctx *ctx, struct hlsl_type *t1, struct
         return false;
     }
 
-    if (t1->dimx == 1 && t1->dimy == 1)
+    if (t1->e.numeric.dimx == 1 && t1->e.numeric.dimy == 1)
     {
         *type = t2->class;
-        *dimx = t2->dimx;
-        *dimy = t2->dimy;
+        *dimx = t2->e.numeric.dimx;
+        *dimy = t2->e.numeric.dimy;
     }
-    else if (t2->dimx == 1 && t2->dimy == 1)
+    else if (t2->e.numeric.dimx == 1 && t2->e.numeric.dimy == 1)
     {
         *type = t1->class;
-        *dimx = t1->dimx;
-        *dimy = t1->dimy;
+        *dimx = t1->e.numeric.dimx;
+        *dimy = t1->e.numeric.dimy;
     }
     else if (t1->class == HLSL_CLASS_MATRIX && t2->class == HLSL_CLASS_MATRIX)
     {
         *type = HLSL_CLASS_MATRIX;
-        *dimx = min(t1->dimx, t2->dimx);
-        *dimy = min(t1->dimy, t2->dimy);
+        *dimx = min(t1->e.numeric.dimx, t2->e.numeric.dimx);
+        *dimy = min(t1->e.numeric.dimy, t2->e.numeric.dimy);
     }
     else
     {
-        if (t1->dimx * t1->dimy <= t2->dimx * t2->dimy)
+        if (t1->e.numeric.dimx * t1->e.numeric.dimy <= t2->e.numeric.dimx * t2->e.numeric.dimy)
         {
             *type = t1->class;
-            *dimx = t1->dimx;
-            *dimy = t1->dimy;
+            *dimx = t1->e.numeric.dimx;
+            *dimy = t1->e.numeric.dimy;
         }
         else
         {
             *type = t2->class;
-            *dimx = t2->dimx;
-            *dimy = t2->dimy;
+            *dimx = t2->e.numeric.dimx;
+            *dimy = t2->e.numeric.dimy;
         }
     }
 
@@ -1719,7 +1716,7 @@ static struct hlsl_ir_node *add_expr(struct hlsl_ctx *ctx, struct hlsl_block *bl
             return NULL;
         hlsl_init_simple_deref_from_var(&var_deref, var);
 
-        for (i = 0; i < type->dimy * type->dimx; ++i)
+        for (i = 0; i < type->e.numeric.dimy * type->e.numeric.dimx; ++i)
         {
             struct hlsl_ir_node *value, *cell_operands[HLSL_MAX_OPERANDS] = { NULL };
             struct hlsl_block store_block;
@@ -1822,7 +1819,7 @@ static struct hlsl_ir_node *add_unary_logical_expr(struct hlsl_ctx *ctx, struct
         return arg;
 
     bool_type = hlsl_get_numeric_type(ctx, arg->data_type->class, HLSL_TYPE_BOOL,
-            arg->data_type->dimx, arg->data_type->dimy);
+            arg->data_type->e.numeric.dimx, arg->data_type->e.numeric.dimy);
 
     if (!(args[0] = add_implicit_conversion(ctx, block, arg, bool_type, loc)))
         return NULL;
@@ -1985,11 +1982,11 @@ static struct hlsl_ir_node *add_binary_dot_expr(struct hlsl_ctx *ctx, struct hls
     }
 
     if (arg1->data_type->class == HLSL_CLASS_SCALAR)
-        dim = arg2->data_type->dimx;
+        dim = arg2->data_type->e.numeric.dimx;
     else if (arg2->data_type->class == HLSL_CLASS_SCALAR)
-        dim = arg1->data_type->dimx;
+        dim = arg1->data_type->e.numeric.dimx;
     else
-        dim = min(arg1->data_type->dimx, arg2->data_type->dimx);
+        dim = min(arg1->data_type->e.numeric.dimx, arg2->data_type->e.numeric.dimx);
 
     if (dim == 1)
         op = HLSL_OP2_MUL;
@@ -2092,8 +2089,8 @@ static bool invert_swizzle(uint32_t *swizzle, unsigned int *writemask, unsigned
     {
         if (*writemask & (1 << i))
         {
-            unsigned int s = (*swizzle >> (i * 2)) & 3;
-            new_swizzle |= s << (bit++ * 2);
+            unsigned int s = hlsl_swizzle_get_component(*swizzle, i);
+            hlsl_swizzle_set_component(&new_swizzle, bit++, s);
             if (new_writemask & (1 << s))
                 return false;
             new_writemask |= 1 << s;
@@ -2107,9 +2104,9 @@ static bool invert_swizzle(uint32_t *swizzle, unsigned int *writemask, unsigned
     {
         for (j = 0; j < width; ++j)
         {
-            unsigned int s = (new_swizzle >> (j * 2)) & 3;
+            unsigned int s = hlsl_swizzle_get_component(new_swizzle, j);
             if (s == i)
-                inverted |= j << (bit++ * 2);
+                hlsl_swizzle_set_component(&inverted, bit++, j);
         }
     }
 
@@ -2119,22 +2116,22 @@ static bool invert_swizzle(uint32_t *swizzle, unsigned int *writemask, unsigned
     return true;
 }
 
-static bool invert_swizzle_matrix(uint32_t *swizzle, unsigned int *writemask, unsigned int *ret_width)
+static bool invert_swizzle_matrix(const struct hlsl_matrix_swizzle *swizzle,
+        uint32_t *ret_inverted, unsigned int *writemask, unsigned int *ret_width)
 {
-    /* swizzle is 8 bits per component, each component is (from LSB) 4 bits X, then 4 bits Y.
-     * components are indexed by their sources. i.e. the first component comes from the first
-     * component of the rhs. */
-    unsigned int i, j, bit = 0, inverted = 0, width, new_writemask = 0, new_swizzle = 0;
+    unsigned int i, j, bit = 0, inverted = 0, width, new_writemask = 0;
+    struct hlsl_matrix_swizzle new_swizzle = {0};
 
     /* First, we filter the swizzle to remove components that aren't enabled by writemask. */
     for (i = 0; i < 4; ++i)
     {
         if (*writemask & (1 << i))
         {
-            unsigned int s = (*swizzle >> (i * 8)) & 0xff;
-            unsigned int x = s & 0xf, y = (s >> 4) & 0xf;
+            unsigned int x = swizzle->components[i].x;
+            unsigned int y = swizzle->components[i].y;
             unsigned int idx = x + y * 4;
-            new_swizzle |= s << (bit++ * 8);
+
+            new_swizzle.components[bit++] = swizzle->components[i];
             if (new_writemask & (1 << idx))
                 return false;
             new_writemask |= 1 << idx;
@@ -2142,22 +2139,22 @@ static bool invert_swizzle_matrix(uint32_t *swizzle, unsigned int *writemask, un
     }
     width = bit;
 
-    /* Then we invert the swizzle. The resulting swizzle has 2 bits per component, because it's for the
-     * incoming vector. */
+    /* Then we invert the swizzle. The resulting swizzle uses a uint32_t
+     * vector format, because it's for the incoming vector. */
     bit = 0;
     for (i = 0; i < 16; ++i)
     {
         for (j = 0; j < width; ++j)
         {
-            unsigned int s = (new_swizzle >> (j * 8)) & 0xff;
-            unsigned int x = s & 0xf, y = (s >> 4) & 0xf;
+            unsigned int x = new_swizzle.components[j].x;
+            unsigned int y = new_swizzle.components[j].y;
             unsigned int idx = x + y * 4;
             if (idx == i)
-                inverted |= j << (bit++ * 2);
+                hlsl_swizzle_set_component(&inverted, bit++, j);
         }
     }
 
-    *swizzle = inverted;
+    *ret_inverted = inverted;
     *writemask = new_writemask;
     *ret_width = width;
     return true;
@@ -2193,8 +2190,8 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
 
     if (hlsl_is_numeric_type(lhs_type))
     {
-        writemask = (1 << lhs_type->dimx) - 1;
-        width = lhs_type->dimx;
+        writemask = (1 << lhs_type->e.numeric.dimx) - 1;
+        width = lhs_type->e.numeric.dimx;
     }
 
     if (!(rhs = add_implicit_conversion(ctx, block, rhs, lhs_type, &rhs->loc)))
@@ -2211,28 +2208,34 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
         {
             struct hlsl_ir_swizzle *swizzle = hlsl_ir_swizzle(lhs);
             struct hlsl_ir_node *new_swizzle;
-            uint32_t s = swizzle->swizzle;
+            uint32_t s;
 
             VKD3D_ASSERT(!matrix_writemask);
 
             if (swizzle->val.node->data_type->class == HLSL_CLASS_MATRIX)
             {
+                struct hlsl_matrix_swizzle ms = swizzle->u.matrix;
+
                 if (swizzle->val.node->type != HLSL_IR_LOAD && swizzle->val.node->type != HLSL_IR_INDEX)
                 {
                     hlsl_fixme(ctx, &lhs->loc, "Unhandled source of matrix swizzle.");
                     return false;
                 }
-                if (!invert_swizzle_matrix(&s, &writemask, &width))
+                if (!invert_swizzle_matrix(&ms, &s, &writemask, &width))
                 {
                     hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK, "Invalid writemask for matrix.");
                     return false;
                 }
                 matrix_writemask = true;
             }
-            else if (!invert_swizzle(&s, &writemask, &width))
+            else
             {
-                hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK, "Invalid writemask.");
-                return false;
+                s = swizzle->u.vector;
+                if (!invert_swizzle(&s, &writemask, &width))
+                {
+                    hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK, "Invalid writemask.");
+                    return false;
+                }
             }
 
             if (!(new_swizzle = hlsl_new_swizzle(ctx, s, width, rhs, &swizzle->node.loc)))
@@ -2275,13 +2278,13 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
 
         dim_count = hlsl_sampler_dim_count(resource_type->sampler_dim);
 
-        if (width != resource_type->e.resource.format->dimx * resource_type->e.resource.format->dimy)
+        if (width != resource_type->e.resource.format->e.numeric.dimx * resource_type->e.resource.format->e.numeric.dimy)
             hlsl_error(ctx, &lhs->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_WRITEMASK,
                     "Resource store expressions must write to all components.");
 
         VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
         VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
-        VKD3D_ASSERT(coords->data_type->dimx == dim_count);
+        VKD3D_ASSERT(coords->data_type->e.numeric.dimx == dim_count);
 
         if (!(store = hlsl_new_resource_store(ctx, &resource_deref, coords, rhs, &lhs->loc)))
         {
@@ -2298,14 +2301,14 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
 
         hlsl_init_deref_from_index_chain(ctx, &deref, lhs);
 
-        for (i = 0; i < lhs->data_type->dimy; ++i)
+        for (i = 0; i < lhs->data_type->e.numeric.dimy; ++i)
         {
-            for (j = 0; j < lhs->data_type->dimx; ++j)
+            for (j = 0; j < lhs->data_type->e.numeric.dimx; ++j)
             {
                 struct hlsl_ir_node *load;
                 struct hlsl_block store_block;
                 const unsigned int idx = i * 4 + j;
-                const unsigned int component = i * lhs->data_type->dimx + j;
+                const unsigned int component = i * lhs->data_type->e.numeric.dimx + j;
 
                 if (!(writemask & (1 << idx)))
                     continue;
@@ -2335,7 +2338,7 @@ static bool add_assignment(struct hlsl_ctx *ctx, struct hlsl_block *block, struc
 
         VKD3D_ASSERT(!matrix_writemask);
 
-        for (i = 0; i < mat->data_type->dimx; ++i)
+        for (i = 0; i < mat->data_type->e.numeric.dimx; ++i)
         {
             struct hlsl_ir_node *cell, *load, *store, *c;
             struct hlsl_deref deref;
@@ -2670,26 +2673,30 @@ static void declare_var(struct hlsl_ctx *ctx, struct parse_variable_def *v)
                 {
                     hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Only innermost array size can be implicit.");
-                    v->initializer.args_count = 0;
+                    type = ctx->builtin_types.error;
+                    break;
                 }
                 else if (elem_components == 0)
                 {
                     hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Cannot declare an implicit size array of a size 0 type.");
-                    v->initializer.args_count = 0;
+                    type = ctx->builtin_types.error;
+                    break;
                 }
                 else if (size == 0)
                 {
                     hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Implicit size arrays need to be initialized.");
-                    v->initializer.args_count = 0;
+                    type = ctx->builtin_types.error;
+                    break;
                 }
                 else if (size % elem_components != 0)
                 {
                     hlsl_error(ctx, &v->loc, VKD3D_SHADER_ERROR_HLSL_WRONG_PARAMETER_COUNT,
                             "Cannot initialize implicit size array with %u components, expected a multiple of %u.",
                             size, elem_components);
-                    v->initializer.args_count = 0;
+                    type = ctx->builtin_types.error;
+                    break;
                 }
                 else
                 {
@@ -2908,7 +2915,8 @@ static struct hlsl_block *initialize_vars(struct hlsl_ctx *ctx, struct list *var
                 v->initializer.args[0] = node_from_block(v->initializer.instrs);
             }
 
-            initialize_var(ctx, var, &v->initializer, is_default_values_initializer);
+            if (var->data_type->class != HLSL_CLASS_ERROR)
+                initialize_var(ctx, var, &v->initializer, is_default_values_initializer);
 
             if (is_default_values_initializer)
             {
@@ -2993,13 +3001,137 @@ static bool func_is_compatible_match(struct hlsl_ctx *ctx, const struct hlsl_ir_
     return true;
 }
 
+static enum hlsl_base_type hlsl_base_type_class(enum hlsl_base_type t)
+{
+    switch (t)
+    {
+        case HLSL_TYPE_HALF:
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_DOUBLE:
+            return HLSL_TYPE_FLOAT;
+
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_UINT:
+            return HLSL_TYPE_INT;
+
+        case HLSL_TYPE_BOOL:
+            return HLSL_TYPE_BOOL;
+    }
+
+    return 0;
+}
+
+static unsigned int hlsl_base_type_width(enum hlsl_base_type t)
+{
+    switch (t)
+    {
+        case HLSL_TYPE_HALF:
+            return 16;
+
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_INT:
+        case HLSL_TYPE_UINT:
+        case HLSL_TYPE_BOOL:
+            return 32;
+
+        case HLSL_TYPE_DOUBLE:
+            return 64;
+    }
+
+    return 0;
+}
+
+static int function_parameter_compare(const struct hlsl_ir_var *candidate,
+        const struct hlsl_ir_var *ref, const struct hlsl_ir_node *arg)
+{
+    struct
+    {
+        enum hlsl_base_type type;
+        enum hlsl_base_type class;
+        unsigned int count, width;
+    } c, r, a;
+    int ret;
+
+    /* TODO: Non-numeric types. */
+    if (!hlsl_is_numeric_type(arg->data_type))
+        return 0;
+
+    c.type = candidate->data_type->e.numeric.type;
+    c.class = hlsl_base_type_class(c.type);
+    c.count = hlsl_type_component_count(candidate->data_type);
+    c.width = hlsl_base_type_width(c.type);
+
+    r.type = ref->data_type->e.numeric.type;
+    r.class = hlsl_base_type_class(r.type);
+    r.count = hlsl_type_component_count(ref->data_type);
+    r.width = hlsl_base_type_width(r.type);
+
+    a.type = arg->data_type->e.numeric.type;
+    a.class = hlsl_base_type_class(a.type);
+    a.count = hlsl_type_component_count(arg->data_type);
+    a.width = hlsl_base_type_width(a.type);
+
+    /* Prefer candidates without component count narrowing. E.g., given an
+     * float4 argument, half4 is a better match than float2. */
+    if ((ret = (a.count > r.count) - (a.count > c.count)))
+        return ret;
+
+    /* Prefer candidates with matching component type classes. E.g., given a
+     * float argument, double is a better match than int. */
+    if ((ret = (a.class == c.class) - (a.class == r.class)))
+        return ret;
+
+    /* Prefer candidates with matching component types. E.g., given an int
+     * argument, int4 is a better match than uint4. */
+    if ((ret = (a.type == c.type) - (a.type == r.type)))
+        return ret;
+
+    /* Prefer candidates without component type narrowing. E.g., given a float
+     * argument, double is a better match than half. */
+    if ((ret = (a.width > r.width) - (a.width > c.width)))
+        return ret;
+
+    /* Prefer candidates without component count widening. E.g. given a float
+     * argument, float is a better match than float2. */
+    return (a.count < r.count) - (a.count < c.count);
+}
+
+static int function_compare(const struct hlsl_ir_function_decl *candidate,
+        const struct hlsl_ir_function_decl *ref, const struct parse_initializer *args)
+{
+    bool any_worse = false, any_better = false;
+    unsigned int i;
+    int ret;
+
+    for (i = 0; i < args->args_count; ++i)
+    {
+        ret = function_parameter_compare(candidate->parameters.vars[i], ref->parameters.vars[i], args->args[i]);
+        if (ret < 0)
+            any_worse = true;
+        else if (ret > 0)
+            any_better = true;
+    }
+
+    /* We consider a candidate better if at least one parameter is a better
+     * match, and none are a worse match. */
+    return any_better - any_worse;
+}
+
 static struct hlsl_ir_function_decl *find_function_call(struct hlsl_ctx *ctx,
         const char *name, const struct parse_initializer *args, bool is_compile,
         const struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_function_decl *decl, *compatible_match = NULL;
+    struct hlsl_ir_function_decl *decl;
+    struct vkd3d_string_buffer *s;
     struct hlsl_ir_function *func;
     struct rb_entry *entry;
+    int compare;
+    size_t i;
+    struct
+    {
+        struct hlsl_ir_function_decl **candidates;
+        size_t count, capacity;
+    } candidates = {0};
 
     if (!(entry = rb_get(&ctx->functions, name)))
         return NULL;
@@ -3007,18 +3139,58 @@ static struct hlsl_ir_function_decl *find_function_call(struct hlsl_ctx *ctx,
 
     LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
     {
-        if (func_is_compatible_match(ctx, decl, is_compile, args))
+        if (!func_is_compatible_match(ctx, decl, is_compile, args))
+            continue;
+
+        if (candidates.count)
         {
-            if (compatible_match)
+            compare = function_compare(decl, candidates.candidates[0], args);
+
+            /* The candidate is worse; skip it. */
+            if (compare < 0)
+                continue;
+
+            /* The candidate is better; replace the current candidates. */
+            if (compare > 0)
             {
-                hlsl_fixme(ctx, loc, "Prioritize between multiple compatible function overloads.");
-                break;
+                candidates.candidates[0] = decl;
+                candidates.count = 1;
+                continue;
             }
-            compatible_match = decl;
         }
+
+        if (!(hlsl_array_reserve(ctx, (void **)&candidates.candidates,
+                &candidates.capacity, candidates.count + 1, sizeof(decl))))
+        {
+            vkd3d_free(candidates.candidates);
+            return NULL;
+        }
+        candidates.candidates[candidates.count++] = decl;
     }
 
-    return compatible_match;
+    if (!candidates.count)
+        return NULL;
+
+    if (candidates.count > 1)
+    {
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_AMBIGUOUS_CALL, "Ambiguous function call.");
+        if ((s = hlsl_get_string_buffer(ctx)))
+        {
+            hlsl_note(ctx, loc, VKD3D_SHADER_LOG_ERROR, "Candidates are:");
+            for (i = 0; i < candidates.count; ++i)
+            {
+                hlsl_dump_ir_function_decl(ctx, s, candidates.candidates[i]);
+                hlsl_note(ctx, loc, VKD3D_SHADER_LOG_ERROR, "    %s;", s->buffer);
+                vkd3d_string_buffer_clear(s);
+            }
+            hlsl_release_string_buffer(ctx, s);
+        }
+    }
+
+    decl = candidates.candidates[0];
+    vkd3d_free(candidates.candidates);
+
+    return decl;
 }
 
 static struct hlsl_ir_node *hlsl_new_void_expr(struct hlsl_ctx *ctx, const struct vkd3d_shader_location *loc)
@@ -3164,7 +3336,7 @@ static struct hlsl_ir_node *intrinsic_float_convert_arg(struct hlsl_ctx *ctx,
     if (!type_is_integer(type->e.numeric.type))
         return arg;
 
-    type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_FLOAT, type->dimx, type->dimy);
+    type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_FLOAT, type->e.numeric.dimx, type->e.numeric.dimy);
     return add_implicit_conversion(ctx, params->instrs, arg, type, loc);
 }
 
@@ -3203,13 +3375,13 @@ static struct hlsl_type *elementwise_intrinsic_get_common_type(struct hlsl_ctx *
         if (arg_type->class == HLSL_CLASS_VECTOR)
         {
             vectors = true;
-            dimx = min(dimx, arg_type->dimx);
+            dimx = min(dimx, arg_type->e.numeric.dimx);
         }
         else if (arg_type->class == HLSL_CLASS_MATRIX)
         {
             matrices = true;
-            dimx = min(dimx, arg_type->dimx);
-            dimy = min(dimy, arg_type->dimy);
+            dimx = min(dimx, arg_type->e.numeric.dimx);
+            dimy = min(dimy, arg_type->e.numeric.dimy);
         }
     }
 
@@ -3254,7 +3426,7 @@ static bool elementwise_intrinsic_float_convert_args(struct hlsl_ctx *ctx,
     if (!(type = elementwise_intrinsic_get_common_type(ctx, params, loc)))
         return false;
     if (type_is_integer(type->e.numeric.type))
-        type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_FLOAT, type->dimx, type->dimy);
+        type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_FLOAT, type->e.numeric.dimx, type->e.numeric.dimy);
 
     return convert_args(ctx, params, type, loc);
 }
@@ -3267,7 +3439,7 @@ static bool elementwise_intrinsic_uint_convert_args(struct hlsl_ctx *ctx,
     if (!(type = elementwise_intrinsic_get_common_type(ctx, params, loc)))
         return false;
 
-    type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->dimx, type->dimy);
+    type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->e.numeric.dimx, type->e.numeric.dimy);
 
     return convert_args(ctx, params, type, loc);
 }
@@ -3334,7 +3506,7 @@ static bool intrinsic_acos(struct hlsl_ctx *ctx,
 static struct hlsl_type *convert_numeric_type(const struct hlsl_ctx *ctx,
         const struct hlsl_type *type, enum hlsl_base_type base_type)
 {
-    return hlsl_get_numeric_type(ctx, type->class, base_type, type->dimx, type->dimy);
+    return hlsl_get_numeric_type(ctx, type->class, base_type, type->e.numeric.dimx, type->e.numeric.dimy);
 }
 
 static bool add_combine_components(struct hlsl_ctx *ctx, const struct parse_initializer *params,
@@ -3855,7 +4027,7 @@ static bool intrinsic_determinant(struct hlsl_ctx *ctx,
     if (!(arg = intrinsic_float_convert_arg(ctx, params, arg, loc)))
         return false;
 
-    dim = min(type->dimx, type->dimy);
+    dim = min(type->e.numeric.dimx, type->e.numeric.dimy);
     if (dim == 1)
         return hlsl_add_load_component(ctx, params->instrs, arg, 0, loc);
 
@@ -3939,7 +4111,7 @@ static bool intrinsic_dst(struct hlsl_ctx *ctx, const struct parse_initializer *
         return false;
     type = params->args[0]->data_type;
     if (!(type->class == HLSL_CLASS_SCALAR
-            || (type->class == HLSL_CLASS_VECTOR && type->dimx == 4)))
+            || (type->class == HLSL_CLASS_VECTOR && type->e.numeric.dimx == 4)))
     {
         struct vkd3d_string_buffer *string;
         if ((string = hlsl_type_to_string(ctx, type)))
@@ -4371,15 +4543,15 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
     if (arg1->data_type->class == HLSL_CLASS_VECTOR)
     {
         vect_count++;
-        cast_type1 = hlsl_get_matrix_type(ctx, base, arg1->data_type->dimx, 1);
+        cast_type1 = hlsl_get_matrix_type(ctx, base, arg1->data_type->e.numeric.dimx, 1);
     }
     if (arg2->data_type->class == HLSL_CLASS_VECTOR)
     {
         vect_count++;
-        cast_type2 = hlsl_get_matrix_type(ctx, base, 1, arg2->data_type->dimx);
+        cast_type2 = hlsl_get_matrix_type(ctx, base, 1, arg2->data_type->e.numeric.dimx);
     }
 
-    matrix_type = hlsl_get_matrix_type(ctx, base, cast_type2->dimx, cast_type1->dimy);
+    matrix_type = hlsl_get_matrix_type(ctx, base, cast_type2->e.numeric.dimx, cast_type1->e.numeric.dimy);
 
     if (vect_count == 0)
     {
@@ -4387,12 +4559,12 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
     }
     else if (vect_count == 1)
     {
-        VKD3D_ASSERT(matrix_type->dimx == 1 || matrix_type->dimy == 1);
-        ret_type = hlsl_get_vector_type(ctx, base, matrix_type->dimx * matrix_type->dimy);
+        VKD3D_ASSERT(matrix_type->e.numeric.dimx == 1 || matrix_type->e.numeric.dimy == 1);
+        ret_type = hlsl_get_vector_type(ctx, base, matrix_type->e.numeric.dimx * matrix_type->e.numeric.dimy);
     }
     else
     {
-        VKD3D_ASSERT(matrix_type->dimx == 1 && matrix_type->dimy == 1);
+        VKD3D_ASSERT(matrix_type->e.numeric.dimx == 1 && matrix_type->e.numeric.dimy == 1);
         ret_type = hlsl_get_scalar_type(ctx, base);
     }
 
@@ -4406,23 +4578,23 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
         return false;
     hlsl_init_simple_deref_from_var(&var_deref, var);
 
-    for (i = 0; i < matrix_type->dimx; ++i)
+    for (i = 0; i < matrix_type->e.numeric.dimx; ++i)
     {
-        for (j = 0; j < matrix_type->dimy; ++j)
+        for (j = 0; j < matrix_type->e.numeric.dimy; ++j)
         {
             struct hlsl_ir_node *instr = NULL;
             struct hlsl_block block;
 
-            for (k = 0; k < cast_type1->dimx && k < cast_type2->dimy; ++k)
+            for (k = 0; k < cast_type1->e.numeric.dimx && k < cast_type2->e.numeric.dimy; ++k)
             {
                 struct hlsl_ir_node *value1, *value2, *mul;
 
                 if (!(value1 = hlsl_add_load_component(ctx, params->instrs,
-                        cast1, j * cast1->data_type->dimx + k, loc)))
+                        cast1, j * cast1->data_type->e.numeric.dimx + k, loc)))
                     return false;
 
                 if (!(value2 = hlsl_add_load_component(ctx, params->instrs,
-                        cast2, k * cast2->data_type->dimx + i, loc)))
+                        cast2, k * cast2->data_type->e.numeric.dimx + i, loc)))
                     return false;
 
                 if (!(mul = add_binary_arithmetic_expr(ctx, params->instrs, HLSL_OP2_MUL, value1, value2, loc)))
@@ -4439,7 +4611,7 @@ static bool intrinsic_mul(struct hlsl_ctx *ctx,
                 }
             }
 
-            if (!hlsl_new_store_component(ctx, &block, &var_deref, j * matrix_type->dimx + i, instr))
+            if (!hlsl_new_store_component(ctx, &block, &var_deref, j * matrix_type->e.numeric.dimx + i, instr))
                 return false;
             hlsl_block_add_block(params->instrs, &block);
         }
@@ -4632,7 +4804,7 @@ static bool intrinsic_sign(struct hlsl_ctx *ctx,
     static const struct hlsl_constant_value zero_value;
 
     struct hlsl_type *int_type = hlsl_get_numeric_type(ctx, arg->data_type->class, HLSL_TYPE_INT,
-            arg->data_type->dimx, arg->data_type->dimy);
+            arg->data_type->e.numeric.dimx, arg->data_type->e.numeric.dimy);
 
     if (!(zero = hlsl_new_constant(ctx, hlsl_get_scalar_type(ctx, arg->data_type->e.numeric.type), &zero_value, loc)))
         return false;
@@ -5086,22 +5258,23 @@ static bool intrinsic_transpose(struct hlsl_ctx *ctx,
         return true;
     }
 
-    mat_type = hlsl_get_matrix_type(ctx, arg_type->e.numeric.type, arg_type->dimy, arg_type->dimx);
+    mat_type = hlsl_get_matrix_type(ctx, arg_type->e.numeric.type, arg_type->e.numeric.dimy, arg_type->e.numeric.dimx);
 
     if (!(var = hlsl_new_synthetic_var(ctx, "transpose", mat_type, loc)))
         return false;
     hlsl_init_simple_deref_from_var(&var_deref, var);
 
-    for (i = 0; i < arg_type->dimx; ++i)
+    for (i = 0; i < arg_type->e.numeric.dimx; ++i)
     {
-        for (j = 0; j < arg_type->dimy; ++j)
+        for (j = 0; j < arg_type->e.numeric.dimy; ++j)
         {
             struct hlsl_block block;
 
-            if (!(load = hlsl_add_load_component(ctx, params->instrs, arg, j * arg->data_type->dimx + i, loc)))
+            if (!(load = hlsl_add_load_component(ctx, params->instrs, arg,
+                    j * arg->data_type->e.numeric.dimx + i, loc)))
                 return false;
 
-            if (!hlsl_new_store_component(ctx, &block, &var_deref, i * var->data_type->dimx + j, load))
+            if (!hlsl_new_store_component(ctx, &block, &var_deref, i * var->data_type->e.numeric.dimx + j, load))
                 return false;
             hlsl_block_add_block(params->instrs, &block);
         }
@@ -5131,7 +5304,8 @@ static bool intrinsic_d3dcolor_to_ubyte4(struct hlsl_ctx *ctx,
     struct hlsl_ir_node *arg = params->args[0], *ret, *c, *swizzle;
     struct hlsl_type *arg_type = arg->data_type;
 
-    if (arg_type->class != HLSL_CLASS_SCALAR && !(arg_type->class == HLSL_CLASS_VECTOR && arg_type->dimx == 4))
+    if (arg_type->class != HLSL_CLASS_SCALAR && !(arg_type->class == HLSL_CLASS_VECTOR
+            && arg_type->e.numeric.dimx == 4))
     {
         struct vkd3d_string_buffer *string;
 
@@ -5447,6 +5621,17 @@ static struct hlsl_block *add_constructor(struct hlsl_ctx *ctx, struct hlsl_type
     struct hlsl_ir_load *load;
     struct hlsl_ir_var *var;
 
+    if (!hlsl_is_numeric_type(type))
+    {
+        struct vkd3d_string_buffer *string;
+
+        if ((string = hlsl_type_to_string(ctx, type)))
+            hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "Constructor data type %s is not numeric.", string->buffer);
+        hlsl_release_string_buffer(ctx, string);
+        return NULL;
+    }
+
     if (!(var = hlsl_new_synthetic_var(ctx, "constructor", type, loc)))
         return NULL;
 
@@ -5483,6 +5668,7 @@ static bool add_ternary(struct hlsl_ctx *ctx, struct hlsl_block *block,
             hlsl_error(ctx, &cond->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                     "Ternary condition type '%s' is not numeric.", string->buffer);
         hlsl_release_string_buffer(ctx, string);
+        return false;
     }
 
     if (first->data_type->class <= HLSL_CLASS_LAST_NUMERIC
@@ -5491,21 +5677,22 @@ static bool add_ternary(struct hlsl_ctx *ctx, struct hlsl_block *block,
         if (!(common_type = get_common_numeric_type(ctx, first, second, &first->loc)))
             return false;
 
-        if (cond_type->dimx == 1 && cond_type->dimy == 1)
+        if (cond_type->e.numeric.dimx == 1 && cond_type->e.numeric.dimy == 1)
         {
             cond_type = hlsl_get_numeric_type(ctx, common_type->class,
-                    HLSL_TYPE_BOOL, common_type->dimx, common_type->dimy);
+                    HLSL_TYPE_BOOL, common_type->e.numeric.dimx, common_type->e.numeric.dimy);
             if (!(cond = add_implicit_conversion(ctx, block, cond, cond_type, &cond->loc)))
                 return false;
         }
         else
         {
-            if (common_type->dimx == 1 && common_type->dimy == 1)
+            if (common_type->e.numeric.dimx == 1 && common_type->e.numeric.dimy == 1)
             {
                 common_type = hlsl_get_numeric_type(ctx, cond_type->class,
-                        common_type->e.numeric.type, cond_type->dimx, cond_type->dimy);
+                        common_type->e.numeric.type, cond_type->e.numeric.dimx, cond_type->e.numeric.dimy);
             }
-            else if (cond_type->dimx != common_type->dimx || cond_type->dimy != common_type->dimy)
+            else if (cond_type->e.numeric.dimx != common_type->e.numeric.dimx
+                    || cond_type->e.numeric.dimy != common_type->e.numeric.dimy)
             {
                 /* This condition looks wrong but is correct.
                 * floatN is compatible with float1xN, but not with floatNx1. */
@@ -5523,7 +5710,7 @@ static bool add_ternary(struct hlsl_ctx *ctx, struct hlsl_block *block,
             }
 
             cond_type = hlsl_get_numeric_type(ctx, common_type->class, HLSL_TYPE_BOOL,
-                    common_type->dimx, common_type->dimy);
+                    common_type->e.numeric.dimx, common_type->e.numeric.dimy);
             if (!(cond = add_implicit_conversion(ctx, block, cond, cond_type, &cond->loc)))
                 return false;
         }
@@ -5551,7 +5738,7 @@ static bool add_ternary(struct hlsl_ctx *ctx, struct hlsl_block *block,
         }
 
         cond_type = hlsl_get_numeric_type(ctx, cond_type->class, HLSL_TYPE_BOOL,
-                cond_type->dimx, cond_type->dimy);
+                cond_type->e.numeric.dimx, cond_type->e.numeric.dimy);
         if (!(cond = add_implicit_conversion(ctx, block, cond, cond_type, &cond->loc)))
             return false;
 
@@ -5923,7 +6110,7 @@ static bool add_gather_method_call(struct hlsl_ctx *ctx, struct hlsl_block *bloc
         return false;
     }
 
-    if (read_channel >= object_type->e.resource.format->dimx)
+    if (read_channel >= object_type->e.resource.format->e.numeric.dimx)
     {
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                 "Method %s() requires at least %u channels.", name, read_channel + 1);
@@ -5944,6 +6131,87 @@ static bool add_gather_method_call(struct hlsl_ctx *ctx, struct hlsl_block *bloc
     return true;
 }
 
+static bool add_gather_cmp_method_call(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_node *object,
+        const char *name, const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    const struct hlsl_type *object_type = object->data_type;
+    struct hlsl_resource_load_params load_params = {0};
+    unsigned int sampler_dim, offset_dim;
+    const struct hlsl_type *sampler_type;
+    struct hlsl_ir_node *load;
+
+    sampler_dim = hlsl_sampler_dim_count(object_type->sampler_dim);
+    offset_dim = hlsl_offset_dim_count(object_type->sampler_dim);
+
+    if (!strcmp(name, "GatherCmpGreen"))
+        load_params.type = HLSL_RESOURCE_GATHER_CMP_GREEN;
+    else if (!strcmp(name, "GatherCmpBlue"))
+        load_params.type = HLSL_RESOURCE_GATHER_CMP_BLUE;
+    else if (!strcmp(name, "GatherCmpAlpha"))
+        load_params.type = HLSL_RESOURCE_GATHER_CMP_ALPHA;
+    else
+        load_params.type = HLSL_RESOURCE_GATHER_CMP_RED;
+
+    if (!strcmp(name, "GatherCmp") || !offset_dim)
+    {
+        if (params->args_count < 3 || params->args_count > 4 + !!offset_dim)
+        {
+            hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_WRONG_PARAMETER_COUNT,
+                    "Wrong number of arguments to method '%s': expected from 3 to %u, but got %u.",
+                    name, 4 + !!offset_dim, params->args_count);
+            return false;
+        }
+    }
+    else if (params->args_count < 3 || params->args_count == 6 || params->args_count > 8)
+    {
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_WRONG_PARAMETER_COUNT,
+                "Wrong number of arguments to method '%s': expected 3, 4, 5, 7, or 8, but got %u.",
+                name, params->args_count);
+        return false;
+    }
+
+    if (params->args_count == 5 || params->args_count == 8)
+    {
+        hlsl_fixme(ctx, loc, "Tiled resource status argument.");
+    }
+    else if (offset_dim && params->args_count > 3)
+    {
+        if (!(load_params.texel_offset = add_implicit_conversion(ctx, block, params->args[3],
+                hlsl_get_vector_type(ctx, HLSL_TYPE_INT, offset_dim), loc)))
+            return false;
+    }
+
+    sampler_type = params->args[0]->data_type;
+    if (sampler_type->class != HLSL_CLASS_SAMPLER || sampler_type->sampler_dim != HLSL_SAMPLER_DIM_COMPARISON)
+    {
+        struct vkd3d_string_buffer *string;
+
+        if ((string = hlsl_type_to_string(ctx, sampler_type)))
+            hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "Wrong type for argument 0 of %s(): expected 'SamplerComparisonState', but got '%s'.",
+                    name, string->buffer);
+        hlsl_release_string_buffer(ctx, string);
+        return false;
+    }
+
+    if (!(load_params.coords = add_implicit_conversion(ctx, block, params->args[1],
+            hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, sampler_dim), loc)))
+        return false;
+
+    if (!(load_params.cmp = add_implicit_conversion(ctx, block, params->args[2],
+            hlsl_get_scalar_type(ctx, HLSL_TYPE_FLOAT), loc)))
+        return false;
+
+    load_params.format = hlsl_get_vector_type(ctx, object_type->e.resource.format->e.numeric.type, 4);
+    load_params.resource = object;
+    load_params.sampler = params->args[0];
+
+    if (!(load = hlsl_new_resource_load(ctx, &load_params, loc)))
+        return false;
+    hlsl_block_add_instr(block, load);
+    return true;
+}
+
 static bool add_assignment_from_component(struct hlsl_ctx *ctx, struct hlsl_block *instrs, struct hlsl_ir_node *dest,
         struct hlsl_ir_node *src, unsigned int component, const struct vkd3d_shader_location *loc)
 {
@@ -6311,6 +6579,11 @@ texture_methods[] =
     { "Gather",             add_gather_method_call,        "00010101001000" },
     { "GatherAlpha",        add_gather_method_call,        "00010101001000" },
     { "GatherBlue",         add_gather_method_call,        "00010101001000" },
+    { "GatherCmp",          add_gather_cmp_method_call,    "00010101001000" },
+    { "GatherCmpAlpha",     add_gather_cmp_method_call,    "00010101001000" },
+    { "GatherCmpBlue",      add_gather_cmp_method_call,    "00010101001000" },
+    { "GatherCmpGreen",     add_gather_cmp_method_call,    "00010101001000" },
+    { "GatherCmpRed",       add_gather_cmp_method_call,    "00010101001000" },
     { "GatherGreen",        add_gather_method_call,        "00010101001000" },
     { "GatherRed",          add_gather_method_call,        "00010101001000" },
 
@@ -6553,6 +6826,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
     struct hlsl_semantic semantic;
     enum hlsl_buffer_type buffer_type;
     enum hlsl_sampler_dim sampler_dim;
+    enum hlsl_so_object_type so_type;
     struct hlsl_attribute *attr;
     struct parse_attribute_list attr_list;
     struct hlsl_ir_switch_case *switch_case;
@@ -6596,6 +6870,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 %token KW_INLINE
 %token KW_INOUT
 %token KW_LINEAR
+%token KW_LINESTREAM
 %token KW_MATRIX
 %token KW_NAMESPACE
 %token KW_NOINTERPOLATION
@@ -6605,6 +6880,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 %token KW_PACKOFFSET
 %token KW_PASS
 %token KW_PIXELSHADER
+%token KW_POINTSTREAM
 %token KW_RASTERIZERORDEREDBUFFER
 %token KW_RASTERIZERORDEREDSTRUCTUREDBUFFER
 %token KW_RASTERIZERORDEREDTEXTURE1D
@@ -6654,6 +6930,7 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 %token KW_TEXTURE3D
 %token KW_TEXTURECUBE
 %token KW_TEXTURECUBEARRAY
+%token KW_TRIANGLESTREAM
 %token KW_TRUE
 %token KW_TYPEDEF
 %token KW_UNSIGNED
@@ -6784,6 +7061,8 @@ static void validate_uav_type(struct hlsl_ctx *ctx, enum hlsl_sampler_dim dim,
 
 %type <semantic> semantic
 
+%type <so_type> so_type
+
 %type <state_block> state_block
 
 %type <state_block_index> state_block_index_opt
@@ -7684,7 +7963,10 @@ parameter_decl:
                 {
                     hlsl_error(ctx, &@3, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Implicit size arrays not allowed in function parameters.");
+                    type = ctx->builtin_types.error;
+                    break;
                 }
+
                 type = hlsl_new_array_type(ctx, type, $4.sizes[i]);
             }
             vkd3d_free($4.sizes);
@@ -7805,6 +8087,20 @@ rov_type:
             $$ = HLSL_SAMPLER_DIM_3D;
         }
 
+so_type:
+      KW_POINTSTREAM
+        {
+            $$ = HLSL_STREAM_OUTPUT_POINT_STREAM;
+        }
+    | KW_LINESTREAM
+        {
+            $$ = HLSL_STREAM_OUTPUT_LINE_STREAM;
+        }
+    | KW_TRIANGLESTREAM
+        {
+            $$ = HLSL_STREAM_OUTPUT_TRIANGLE_STREAM;
+        }
+
 resource_format:
       var_modifiers type
         {
@@ -7948,6 +8244,10 @@ type_no_void:
             validate_uav_type(ctx, $1, $3, &@4);
             $$ = hlsl_new_uav_type(ctx, $1, $3, true);
         }
+    | so_type '<' type '>'
+        {
+            $$ = hlsl_new_stream_output_type(ctx, $1, $3);
+        }
     | KW_RWBYTEADDRESSBUFFER
         {
             $$ = hlsl_new_uav_type(ctx, HLSL_SAMPLER_DIM_RAW_BUFFER, hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT), false);
@@ -8088,14 +8388,9 @@ typedef:
             }
 
             if (modifiers)
-            {
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
                         "Storage modifiers are not allowed on typedefs.");
-                LIST_FOR_EACH_ENTRY_SAFE(v, v_next, $4, struct parse_variable_def, entry)
-                    vkd3d_free(v);
-                vkd3d_free($4);
-                YYABORT;
-            }
+
             if (!add_typedef(ctx, type, $4))
                 YYABORT;
         }
@@ -8753,25 +9048,25 @@ if_body:
 loop_statement:
       attribute_list_optional loop_scope_start KW_WHILE '(' expr ')' statement
         {
-            $$ = create_loop(ctx, LOOP_WHILE, &$1, NULL, $5, NULL, $7, &@3);
+            $$ = create_loop(ctx, HLSL_LOOP_WHILE, &$1, NULL, $5, NULL, $7, &@3);
             hlsl_pop_scope(ctx);
             cleanup_parse_attribute_list(&$1);
         }
     | attribute_list_optional loop_scope_start KW_DO statement KW_WHILE '(' expr ')' ';'
         {
-            $$ = create_loop(ctx, LOOP_DO_WHILE, &$1, NULL, $7, NULL, $4, &@3);
+            $$ = create_loop(ctx, HLSL_LOOP_DO_WHILE, &$1, NULL, $7, NULL, $4, &@3);
             hlsl_pop_scope(ctx);
             cleanup_parse_attribute_list(&$1);
         }
     | attribute_list_optional loop_scope_start KW_FOR '(' expr_statement expr_statement expr_optional ')' statement
         {
-            $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
+            $$ = create_loop(ctx, HLSL_LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
             hlsl_pop_scope(ctx);
             cleanup_parse_attribute_list(&$1);
         }
     | attribute_list_optional loop_scope_start KW_FOR '(' declaration expr_statement expr_optional ')' statement
         {
-            $$ = create_loop(ctx, LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
+            $$ = create_loop(ctx, HLSL_LOOP_FOR, &$1, $5, $6, $7, $9, &@3);
             hlsl_pop_scope(ctx);
             cleanup_parse_attribute_list(&$1);
         }
@@ -8979,17 +9274,24 @@ primary_expr:
             struct hlsl_ir_load *load;
             struct hlsl_ir_var *var;
 
-            if (!(var = hlsl_get_var(ctx->cur_scope, $1)))
+            if ((var = hlsl_get_var(ctx->cur_scope, $1)))
+            {
+                vkd3d_free($1);
+
+                if (!(load = hlsl_new_var_load(ctx, var, &@1)))
+                    YYABORT;
+                if (!($$ = make_block(ctx, &load->node)))
+                    YYABORT;
+            }
+            else
             {
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_NOT_DEFINED, "Variable \"%s\" is not defined.", $1);
                 vkd3d_free($1);
-                YYABORT;
+
+                if (!($$ = make_empty_block(ctx)))
+                    YYABORT;
+                $$->value = ctx->error_instr;
             }
-            vkd3d_free($1);
-            if (!(load = hlsl_new_var_load(ctx, var, &@1)))
-                YYABORT;
-            if (!($$ = make_block(ctx, &load->node)))
-                YYABORT;
         }
     | '(' expr ')'
         {
@@ -9149,23 +9451,8 @@ postfix_expr:
     | var_modifiers type '(' initializer_expr_list ')'
         {
             if ($1)
-            {
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
                         "Modifiers are not allowed on constructors.");
-                free_parse_initializer(&$4);
-                YYABORT;
-            }
-            if (!hlsl_is_numeric_type($2))
-            {
-                struct vkd3d_string_buffer *string;
-
-                if ((string = hlsl_type_to_string(ctx, $2)))
-                    hlsl_error(ctx, &@2, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                            "Constructor data type %s is not numeric.", string->buffer);
-                hlsl_release_string_buffer(ctx, string);
-                free_parse_initializer(&$4);
-                YYABORT;
-            }
 
             if (!($$ = add_constructor(ctx, $2, &$4, &@2)))
             {
@@ -9233,11 +9520,8 @@ unary_expr:
     | '(' var_modifiers type arrays ')' unary_expr
         {
             if ($2)
-            {
                 hlsl_error(ctx, &@2, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
                         "Modifiers are not allowed on casts.");
-                YYABORT;
-            }
 
             if (!add_explicit_conversion(ctx, $6, $3, &$4, &@3))
             {
@@ -9381,10 +9665,7 @@ assignment_expr:
             struct hlsl_ir_node *lhs = node_from_block($1), *rhs = node_from_block($3);
 
             if (lhs->data_type->modifiers & HLSL_MODIFIER_CONST)
-            {
                 hlsl_error(ctx, &@2, VKD3D_SHADER_ERROR_HLSL_MODIFIES_CONST, "Statement modifies a const expression.");
-                YYABORT;
-            }
             hlsl_block_add_block($3, $1);
             destroy_block($1);
             if (!add_assignment(ctx, $3, lhs, $2, rhs))
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index d11ff481f6b..c666599b342 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -19,9 +19,14 @@
  */
 
 #include "hlsl.h"
+#include "vkd3d_shader_private.h"
+#include "d3dcommon.h"
 #include <stdio.h>
 #include <math.h>
 
+/* The shift that corresponds to the D3D_SIF_TEXTURE_COMPONENTS mask. */
+#define VKD3D_SM4_SIF_TEXTURE_COMPONENTS_SHIFT 2
+
 /* TODO: remove when no longer needed, only used for new_offset_instr_from_deref() */
 static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_type *type, struct hlsl_ir_node *base_offset, struct hlsl_ir_node *idx,
@@ -269,7 +274,7 @@ static bool types_are_semantic_equivalent(struct hlsl_ctx *ctx, const struct hls
     if (ctx->profile->major_version < 4)
         return true;
 
-    if (type1->dimx != type2->dimx)
+    if (type1->e.numeric.dimx != type2->e.numeric.dimx)
         return false;
 
     return base_type_get_semantic_equivalent(type1->e.numeric.type)
@@ -291,6 +296,9 @@ static struct hlsl_ir_var *add_semantic_var(struct hlsl_ctx *ctx, struct hlsl_ir
     {
         if (!ascii_strcasecmp(ext_var->name, new_name))
         {
+            VKD3D_ASSERT(ext_var->data_type->class <= HLSL_CLASS_VECTOR);
+            VKD3D_ASSERT(type->class <= HLSL_CLASS_VECTOR);
+
             if (output)
             {
                 if (index >= semantic->reported_duplicated_output_next_index)
@@ -1031,7 +1039,7 @@ static bool lower_calls(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *
 static struct hlsl_ir_node *add_zero_mipmap_level(struct hlsl_ctx *ctx, struct hlsl_ir_node *index,
         const struct vkd3d_shader_location *loc)
 {
-    unsigned int dim_count = index->data_type->dimx;
+    unsigned int dim_count = index->data_type->e.numeric.dimx;
     struct hlsl_ir_node *store, *zero;
     struct hlsl_ir_load *coords_load;
     struct hlsl_deref coords_deref;
@@ -1075,7 +1083,7 @@ static bool lower_matrix_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
     struct hlsl_deref var_deref;
     struct hlsl_type *matrix_type;
     struct hlsl_ir_var *var;
-    unsigned int x, y, k, i;
+    unsigned int k, i;
 
     if (instr->type != HLSL_IR_SWIZZLE)
         return false;
@@ -1088,14 +1096,12 @@ static bool lower_matrix_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
         return false;
     hlsl_init_simple_deref_from_var(&var_deref, var);
 
-    for (i = 0; i < instr->data_type->dimx; ++i)
+    for (i = 0; i < instr->data_type->e.numeric.dimx; ++i)
     {
         struct hlsl_block store_block;
         struct hlsl_ir_node *load;
 
-        y = (swizzle->swizzle >> (8 * i + 4)) & 0xf;
-        x = (swizzle->swizzle >> 8 * i) & 0xf;
-        k = y * matrix_type->dimx + x;
+        k = swizzle->u.matrix.components[i].y * matrix_type->e.numeric.dimx + swizzle->u.matrix.components[i].x;
 
         if (!(load = hlsl_add_load_component(ctx, block, swizzle->val.node, k, &instr->loc)))
             return false;
@@ -1140,7 +1146,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
 
         VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
         VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
-        VKD3D_ASSERT(coords->data_type->dimx == dim_count);
+        VKD3D_ASSERT(coords->data_type->e.numeric.dimx == dim_count);
 
         if (!(coords = add_zero_mipmap_level(ctx, coords, &instr->loc)))
             return false;
@@ -1176,7 +1182,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
             return false;
         hlsl_init_simple_deref_from_var(&row_deref, var);
 
-        for (i = 0; i < mat->data_type->dimx; ++i)
+        for (i = 0; i < mat->data_type->e.numeric.dimx; ++i)
         {
             struct hlsl_ir_node *c;
 
@@ -1225,7 +1231,7 @@ static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, s
     src_type = cast->operands[0].node->data_type;
     dst_type = cast->node.data_type;
 
-    if (src_type->class <= HLSL_CLASS_VECTOR && dst_type->class <= HLSL_CLASS_VECTOR && src_type->dimx == 1)
+    if (src_type->class <= HLSL_CLASS_VECTOR && dst_type->class <= HLSL_CLASS_VECTOR && src_type->e.numeric.dimx == 1)
     {
         struct hlsl_ir_node *new_cast, *swizzle;
 
@@ -1236,9 +1242,10 @@ static bool lower_broadcasts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, s
             return false;
         hlsl_block_add_instr(block, new_cast);
 
-        if (dst_type->dimx != 1)
+        if (dst_type->e.numeric.dimx != 1)
         {
-            if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), dst_type->dimx, new_cast, &cast->node.loc)))
+            if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X),
+                    dst_type->e.numeric.dimx, new_cast, &cast->node.loc)))
                 return false;
             hlsl_block_add_instr(block, swizzle);
         }
@@ -1358,8 +1365,10 @@ struct copy_propagation_var_def
 
 struct copy_propagation_state
 {
-    struct rb_tree var_defs;
-    struct copy_propagation_state *parent;
+    struct rb_tree *scope_var_defs;
+    size_t scope_count, scopes_capacity;
+    struct hlsl_ir_node *stop;
+    bool stopped;
 };
 
 static int copy_propagation_var_def_compare(const void *key, const struct rb_entry *entry)
@@ -1381,6 +1390,38 @@ static void copy_propagation_var_def_destroy(struct rb_entry *entry, void *conte
     vkd3d_free(var_def);
 }
 
+static size_t copy_propagation_push_scope(struct copy_propagation_state *state, struct hlsl_ctx *ctx)
+{
+    if (!(hlsl_array_reserve(ctx, (void **)&state->scope_var_defs, &state->scopes_capacity,
+            state->scope_count + 1, sizeof(*state->scope_var_defs))))
+        return false;
+
+    rb_init(&state->scope_var_defs[state->scope_count++], copy_propagation_var_def_compare);
+
+    return state->scope_count;
+}
+
+static size_t copy_propagation_pop_scope(struct copy_propagation_state *state)
+{
+    rb_destroy(&state->scope_var_defs[--state->scope_count], copy_propagation_var_def_destroy, NULL);
+
+    return state->scope_count;
+}
+
+static bool copy_propagation_state_init(struct copy_propagation_state *state, struct hlsl_ctx *ctx)
+{
+    memset(state, 0, sizeof(*state));
+
+    return copy_propagation_push_scope(state, ctx);
+}
+
+static void copy_propagation_state_destroy(struct copy_propagation_state *state)
+{
+    while (copy_propagation_pop_scope(state));
+
+    vkd3d_free(state->scope_var_defs);
+}
+
 static struct copy_propagation_value *copy_propagation_get_value_at_time(
         struct copy_propagation_component_trace *trace, unsigned int time)
 {
@@ -1398,9 +1439,10 @@ static struct copy_propagation_value *copy_propagation_get_value_at_time(
 static struct copy_propagation_value *copy_propagation_get_value(const struct copy_propagation_state *state,
         const struct hlsl_ir_var *var, unsigned int component, unsigned int time)
 {
-    for (; state; state = state->parent)
+    for (size_t i = state->scope_count - 1; i < state->scope_count; i--)
     {
-        struct rb_entry *entry = rb_get(&state->var_defs, var);
+        struct rb_tree *tree = &state->scope_var_defs[i];
+        struct rb_entry *entry = rb_get(tree, var);
         if (entry)
         {
             struct copy_propagation_var_def *var_def = RB_ENTRY_VALUE(entry, struct copy_propagation_var_def, entry);
@@ -1426,7 +1468,8 @@ static struct copy_propagation_value *copy_propagation_get_value(const struct co
 static struct copy_propagation_var_def *copy_propagation_create_var_def(struct hlsl_ctx *ctx,
         struct copy_propagation_state *state, struct hlsl_ir_var *var)
 {
-    struct rb_entry *entry = rb_get(&state->var_defs, var);
+    struct rb_tree *tree = &state->scope_var_defs[state->scope_count - 1];
+    struct rb_entry *entry = rb_get(tree, var);
     struct copy_propagation_var_def *var_def;
     unsigned int component_count = hlsl_type_component_count(var->data_type);
     int res;
@@ -1439,7 +1482,7 @@ static struct copy_propagation_var_def *copy_propagation_create_var_def(struct h
 
     var_def->var = var;
 
-    res = rb_put(&state->var_defs, var, &var_def->entry);
+    res = rb_put(tree, var, &var_def->entry);
     VKD3D_ASSERT(!res);
 
     return var_def;
@@ -1596,7 +1639,7 @@ static bool copy_propagation_replace_with_single_instr(struct hlsl_ctx *ctx,
                     var->name, start, start + count, debug_hlsl_swizzle(swizzle, instr_component_count));
             return false;
         }
-        ret_swizzle |= value->component << HLSL_SWIZZLE_SHIFT(i);
+        hlsl_swizzle_set_component(&ret_swizzle, i, value->component);
     }
 
     TRACE("Load from %s[%u-%u]%s propagated as instruction %p%s.\n",
@@ -1678,6 +1721,7 @@ static bool copy_propagation_transform_load(struct hlsl_ctx *ctx,
         case HLSL_CLASS_DEPTH_STENCIL_VIEW:
         case HLSL_CLASS_GEOMETRY_SHADER:
         case HLSL_CLASS_BLEND_STATE:
+        case HLSL_CLASS_STREAM_OUTPUT:
         case HLSL_CLASS_NULL:
             break;
 
@@ -1719,10 +1763,10 @@ static bool copy_propagation_transform_swizzle(struct hlsl_ctx *ctx,
         return false;
     load = hlsl_ir_load(swizzle->val.node);
 
-    if (copy_propagation_replace_with_constant_vector(ctx, state, load, swizzle->swizzle, &swizzle->node))
+    if (copy_propagation_replace_with_constant_vector(ctx, state, load, swizzle->u.vector, &swizzle->node))
         return true;
 
-    if (copy_propagation_replace_with_single_instr(ctx, state, load, swizzle->swizzle, &swizzle->node))
+    if (copy_propagation_replace_with_single_instr(ctx, state, load, swizzle->u.vector, &swizzle->node))
         return true;
 
     return false;
@@ -1818,18 +1862,6 @@ static void copy_propagation_record_store(struct hlsl_ctx *ctx, struct hlsl_ir_s
     }
 }
 
-static void copy_propagation_state_init(struct hlsl_ctx *ctx, struct copy_propagation_state *state,
-        struct copy_propagation_state *parent)
-{
-    rb_init(&state->var_defs, copy_propagation_var_def_compare);
-    state->parent = parent;
-}
-
-static void copy_propagation_state_destroy(struct copy_propagation_state *state)
-{
-    rb_destroy(&state->var_defs, copy_propagation_var_def_destroy, NULL);
-}
-
 static void copy_propagation_invalidate_from_block(struct hlsl_ctx *ctx, struct copy_propagation_state *state,
         struct hlsl_block *block, unsigned int time)
 {
@@ -1898,16 +1930,19 @@ static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_b
 static bool copy_propagation_process_if(struct hlsl_ctx *ctx, struct hlsl_ir_if *iff,
         struct copy_propagation_state *state)
 {
-    struct copy_propagation_state inner_state;
     bool progress = false;
 
-    copy_propagation_state_init(ctx, &inner_state, state);
-    progress |= copy_propagation_transform_block(ctx, &iff->then_block, &inner_state);
-    copy_propagation_state_destroy(&inner_state);
+    copy_propagation_push_scope(state, ctx);
+    progress |= copy_propagation_transform_block(ctx, &iff->then_block, state);
+    if (state->stopped)
+        return progress;
+    copy_propagation_pop_scope(state);
 
-    copy_propagation_state_init(ctx, &inner_state, state);
-    progress |= copy_propagation_transform_block(ctx, &iff->else_block, &inner_state);
-    copy_propagation_state_destroy(&inner_state);
+    copy_propagation_push_scope(state, ctx);
+    progress |= copy_propagation_transform_block(ctx, &iff->else_block, state);
+    if (state->stopped)
+        return progress;
+    copy_propagation_pop_scope(state);
 
     /* Ideally we'd invalidate the outer state looking at what was
      * touched in the two inner states, but this doesn't work for
@@ -1922,14 +1957,16 @@ static bool copy_propagation_process_if(struct hlsl_ctx *ctx, struct hlsl_ir_if
 static bool copy_propagation_process_loop(struct hlsl_ctx *ctx, struct hlsl_ir_loop *loop,
         struct copy_propagation_state *state)
 {
-    struct copy_propagation_state inner_state;
     bool progress = false;
 
     copy_propagation_invalidate_from_block(ctx, state, &loop->body, loop->node.index);
+    copy_propagation_invalidate_from_block(ctx, state, &loop->iter, loop->node.index);
 
-    copy_propagation_state_init(ctx, &inner_state, state);
-    progress |= copy_propagation_transform_block(ctx, &loop->body, &inner_state);
-    copy_propagation_state_destroy(&inner_state);
+    copy_propagation_push_scope(state, ctx);
+    progress |= copy_propagation_transform_block(ctx, &loop->body, state);
+    if (state->stopped)
+        return progress;
+    copy_propagation_pop_scope(state);
 
     return progress;
 }
@@ -1937,15 +1974,16 @@ static bool copy_propagation_process_loop(struct hlsl_ctx *ctx, struct hlsl_ir_l
 static bool copy_propagation_process_switch(struct hlsl_ctx *ctx, struct hlsl_ir_switch *s,
         struct copy_propagation_state *state)
 {
-    struct copy_propagation_state inner_state;
     struct hlsl_ir_switch_case *c;
     bool progress = false;
 
     LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
     {
-        copy_propagation_state_init(ctx, &inner_state, state);
-        progress |= copy_propagation_transform_block(ctx, &c->body, &inner_state);
-        copy_propagation_state_destroy(&inner_state);
+        copy_propagation_push_scope(state, ctx);
+        progress |= copy_propagation_transform_block(ctx, &c->body, state);
+        if (state->stopped)
+            return progress;
+        copy_propagation_pop_scope(state);
     }
 
     LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
@@ -1964,6 +2002,12 @@ static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_b
 
     LIST_FOR_EACH_ENTRY_SAFE(instr, next, &block->instrs, struct hlsl_ir_node, entry)
     {
+        if (instr == state->stop)
+        {
+            state->stopped = true;
+            return progress;
+        }
+
         switch (instr->type)
         {
             case HLSL_IR_LOAD:
@@ -2001,6 +2045,9 @@ static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_b
             default:
                 break;
         }
+
+        if (state->stopped)
+            return progress;
     }
 
     return progress;
@@ -2013,7 +2060,7 @@ bool hlsl_copy_propagation_execute(struct hlsl_ctx *ctx, struct hlsl_block *bloc
 
     index_instructions(block, 2);
 
-    copy_propagation_state_init(ctx, &state, NULL);
+    copy_propagation_state_init(&state, ctx);
 
     progress = copy_propagation_transform_block(ctx, block, &state);
 
@@ -2053,10 +2100,10 @@ static enum validation_result validate_component_index_range_from_deref(struct h
         switch (type->class)
         {
             case HLSL_CLASS_VECTOR:
-                if (idx >= type->dimx)
+                if (idx >= type->e.numeric.dimx)
                 {
                     hlsl_error(ctx, &path_node->loc, VKD3D_SHADER_ERROR_HLSL_OFFSET_OUT_OF_BOUNDS,
-                            "Vector index is out of bounds. %u/%u", idx, type->dimx);
+                            "Vector index is out of bounds. %u/%u", idx, type->e.numeric.dimx);
                     return DEREF_VALIDATION_OUT_OF_BOUNDS;
                 }
                 break;
@@ -2187,7 +2234,7 @@ static bool validate_dereferences(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
 
 static bool is_vec1(const struct hlsl_type *type)
 {
-    return (type->class == HLSL_CLASS_SCALAR) || (type->class == HLSL_CLASS_VECTOR && type->dimx == 1);
+    return (type->class == HLSL_CLASS_SCALAR) || (type->class == HLSL_CLASS_VECTOR && type->e.numeric.dimx == 1);
 }
 
 static bool fold_redundant_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
@@ -2364,18 +2411,20 @@ static bool lower_narrowing_casts(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
     src_type = cast->operands[0].node->data_type;
     dst_type = cast->node.data_type;
 
-    if (src_type->class <= HLSL_CLASS_VECTOR && dst_type->class <= HLSL_CLASS_VECTOR && dst_type->dimx < src_type->dimx)
+    if (src_type->class <= HLSL_CLASS_VECTOR && dst_type->class <= HLSL_CLASS_VECTOR
+            && dst_type->e.numeric.dimx < src_type->e.numeric.dimx)
     {
         struct hlsl_ir_node *new_cast, *swizzle;
 
-        dst_vector_type = hlsl_get_vector_type(ctx, dst_type->e.numeric.type, src_type->dimx);
+        dst_vector_type = hlsl_get_vector_type(ctx, dst_type->e.numeric.type, src_type->e.numeric.dimx);
         /* We need to preserve the cast since it might be doing more than just
          * narrowing the vector. */
         if (!(new_cast = hlsl_new_cast(ctx, cast->operands[0].node, dst_vector_type, &cast->node.loc)))
             return false;
         hlsl_block_add_instr(block, new_cast);
 
-        if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, Y, Z, W), dst_type->dimx, new_cast, &cast->node.loc)))
+        if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, Y, Z, W),
+                dst_type->e.numeric.dimx, new_cast, &cast->node.loc)))
             return false;
         hlsl_block_add_instr(block, swizzle);
 
@@ -2401,11 +2450,12 @@ static bool fold_swizzle_chains(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         struct hlsl_ir_node *new_swizzle;
         uint32_t combined_swizzle;
 
-        combined_swizzle = hlsl_combine_swizzles(hlsl_ir_swizzle(next_instr)->swizzle,
-                swizzle->swizzle, instr->data_type->dimx);
+        combined_swizzle = hlsl_combine_swizzles(hlsl_ir_swizzle(next_instr)->u.vector,
+                swizzle->u.vector, instr->data_type->e.numeric.dimx);
         next_instr = hlsl_ir_swizzle(next_instr)->val.node;
 
-        if (!(new_swizzle = hlsl_new_swizzle(ctx, combined_swizzle, instr->data_type->dimx, next_instr, &instr->loc)))
+        if (!(new_swizzle = hlsl_new_swizzle(ctx, combined_swizzle,
+                instr->data_type->e.numeric.dimx, next_instr, &instr->loc)))
             return false;
 
         list_add_before(&instr->entry, &new_swizzle->entry);
@@ -2425,11 +2475,11 @@ static bool remove_trivial_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *i
         return false;
     swizzle = hlsl_ir_swizzle(instr);
 
-    if (instr->data_type->dimx != swizzle->val.node->data_type->dimx)
+    if (instr->data_type->e.numeric.dimx != swizzle->val.node->data_type->e.numeric.dimx)
         return false;
 
-    for (i = 0; i < instr->data_type->dimx; ++i)
-        if (hlsl_swizzle_get_component(swizzle->swizzle, i) != i)
+    for (i = 0; i < instr->data_type->e.numeric.dimx; ++i)
+        if (hlsl_swizzle_get_component(swizzle->u.vector, i) != i)
             return false;
 
     hlsl_replace_node(instr, swizzle->val.node);
@@ -2589,6 +2639,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
     if (type->class == HLSL_CLASS_VECTOR && idx->type != HLSL_IR_CONSTANT)
     {
         struct hlsl_ir_node *eq, *swizzle, *dot, *c, *operands[HLSL_MAX_OPERANDS] = {0};
+        unsigned int width = type->e.numeric.dimx;
         struct hlsl_constant_value value;
         struct hlsl_ir_load *vector_load;
         enum hlsl_ir_expr_op op;
@@ -2597,7 +2648,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
             return false;
         hlsl_block_add_instr(block, &vector_load->node);
 
-        if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), type->dimx, idx, &instr->loc)))
+        if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), width, idx, &instr->loc)))
             return false;
         hlsl_block_add_instr(block, swizzle);
 
@@ -2605,14 +2656,14 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
         value.u[1].u = 1;
         value.u[2].u = 2;
         value.u[3].u = 3;
-        if (!(c = hlsl_new_constant(ctx, hlsl_get_vector_type(ctx, HLSL_TYPE_UINT, type->dimx), &value, &instr->loc)))
+        if (!(c = hlsl_new_constant(ctx, hlsl_get_vector_type(ctx, HLSL_TYPE_UINT, width), &value, &instr->loc)))
             return false;
         hlsl_block_add_instr(block, c);
 
         operands[0] = swizzle;
         operands[1] = c;
         if (!(eq = hlsl_new_expr(ctx, HLSL_OP2_EQUAL, operands,
-                hlsl_get_vector_type(ctx, HLSL_TYPE_BOOL, type->dimx), &instr->loc)))
+                hlsl_get_vector_type(ctx, HLSL_TYPE_BOOL, width), &instr->loc)))
             return false;
         hlsl_block_add_instr(block, eq);
 
@@ -2621,7 +2672,7 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
         hlsl_block_add_instr(block, eq);
 
         op = HLSL_OP2_DOT;
-        if (type->dimx == 1)
+        if (width == 1)
             op = type->e.numeric.type == HLSL_TYPE_BOOL ? HLSL_OP2_LOGIC_AND : HLSL_OP2_MUL;
 
         /* Note: We may be creating a DOT for bool vectors here, which we need to lower to
@@ -2748,7 +2799,8 @@ static bool lower_nonconstant_array_loads(struct hlsl_ctx *ctx, struct hlsl_ir_n
             return false;
         hlsl_block_add_instr(block, equals);
 
-        if (!(equals = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), var->data_type->dimx, equals, &cut_index->loc)))
+        if (!(equals = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X),
+                var->data_type->e.numeric.dimx, equals, &cut_index->loc)))
             return false;
         hlsl_block_add_instr(block, equals);
 
@@ -2788,6 +2840,108 @@ static bool lower_nonconstant_array_loads(struct hlsl_ctx *ctx, struct hlsl_ir_n
 
     return true;
 }
+
+static struct hlsl_type *clone_texture_array_as_combined_sampler_array(struct hlsl_ctx *ctx, struct hlsl_type *type)
+{
+    struct hlsl_type *sampler_type;
+
+    if (type->class == HLSL_CLASS_ARRAY)
+    {
+        if (!(sampler_type = clone_texture_array_as_combined_sampler_array(ctx, type->e.array.type)))
+            return NULL;
+
+        return hlsl_new_array_type(ctx, sampler_type, type->e.array.elements_count);
+    }
+
+    return ctx->builtin_types.sampler[type->sampler_dim];
+}
+
+static bool deref_offset_is_zero(struct hlsl_ctx *ctx, const struct hlsl_deref *deref)
+{
+    enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
+    unsigned int index;
+
+    if (!hlsl_regset_index_from_deref(ctx, deref, regset, &index))
+        return false;
+    return index == 0;
+}
+
+/* Lower samples from separate texture and sampler variables to samples from
+ * synthetized combined samplers. That is, translate SM4-style samples in the
+ * source to SM1-style samples in the bytecode. */
+static bool lower_separate_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+{
+    struct hlsl_ir_var *var, *resource, *sampler;
+    struct hlsl_ir_resource_load *load;
+    struct vkd3d_string_buffer *name;
+    struct hlsl_type *sampler_type;
+
+    if (instr->type != HLSL_IR_RESOURCE_LOAD)
+        return false;
+    load = hlsl_ir_resource_load(instr);
+
+    if (load->load_type != HLSL_RESOURCE_SAMPLE
+            && load->load_type != HLSL_RESOURCE_SAMPLE_LOD
+            && load->load_type != HLSL_RESOURCE_SAMPLE_LOD_BIAS)
+        return false;
+
+    if (!load->sampler.var)
+        return false;
+    resource = load->resource.var;
+    sampler = load->sampler.var;
+
+    VKD3D_ASSERT(hlsl_type_is_resource(resource->data_type));
+    VKD3D_ASSERT(hlsl_type_is_resource(sampler->data_type));
+    if (sampler->data_type->class == HLSL_CLASS_ARRAY && !deref_offset_is_zero(ctx, &load->sampler))
+    {
+        /* Not supported by d3dcompiler. */
+        hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_NOT_IMPLEMENTED,
+                "Lower separated samples with sampler arrays.");
+        return false;
+    }
+    if (!resource->is_uniform)
+        return false;
+    if(!sampler->is_uniform)
+        return false;
+
+    if (!(name = hlsl_get_string_buffer(ctx)))
+        return false;
+    vkd3d_string_buffer_printf(name, "%s+%s", sampler->name, resource->name);
+
+    TRACE("Lowering to combined sampler %s.\n", debugstr_a(name->buffer));
+
+    if (!(var = hlsl_get_var(ctx->globals, name->buffer)))
+    {
+        if (!(sampler_type = clone_texture_array_as_combined_sampler_array(ctx, resource->data_type)))
+        {
+            hlsl_release_string_buffer(ctx, name);
+            return false;
+        }
+
+        if (!(var = hlsl_new_synthetic_var_named(ctx, name->buffer, sampler_type, &instr->loc, false)))
+        {
+            hlsl_release_string_buffer(ctx, name);
+            return false;
+        }
+        var->storage_modifiers |= HLSL_STORAGE_UNIFORM;
+        var->is_combined_sampler = true;
+        var->is_uniform = 1;
+
+        list_remove(&var->scope_entry);
+        list_add_after(&sampler->scope_entry, &var->scope_entry);
+
+        list_add_after(&sampler->extern_entry, &var->extern_entry);
+    }
+    hlsl_release_string_buffer(ctx, name);
+
+    /* Only change the deref's var, keep the path. */
+    load->resource.var = var;
+    hlsl_cleanup_deref(&load->sampler);
+    load->sampler.var = NULL;
+
+    return true;
+}
+
 /* Lower combined samples and sampler variables to synthesized separated textures and samplers.
  * That is, translate SM1-style samples in the source to SM4-style samples in the bytecode. */
 static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
@@ -2808,6 +2962,10 @@ static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         case HLSL_RESOURCE_GATHER_GREEN:
         case HLSL_RESOURCE_GATHER_BLUE:
         case HLSL_RESOURCE_GATHER_ALPHA:
+        case HLSL_RESOURCE_GATHER_CMP_RED:
+        case HLSL_RESOURCE_GATHER_CMP_GREEN:
+        case HLSL_RESOURCE_GATHER_CMP_BLUE:
+        case HLSL_RESOURCE_GATHER_CMP_ALPHA:
         case HLSL_RESOURCE_RESINFO:
         case HLSL_RESOURCE_SAMPLE_CMP:
         case HLSL_RESOURCE_SAMPLE_CMP_LZ:
@@ -2899,6 +3057,27 @@ static void insert_ensuring_decreasing_bind_count(struct list *list, struct hlsl
     list_add_tail(list, &to_add->extern_entry);
 }
 
+static bool sort_synthetic_combined_samplers_first(struct hlsl_ctx *ctx)
+{
+    struct list separated_resources;
+    struct hlsl_ir_var *var, *next;
+
+    list_init(&separated_resources);
+
+    LIST_FOR_EACH_ENTRY_SAFE(var, next, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        if (var->is_combined_sampler)
+        {
+            list_remove(&var->extern_entry);
+            insert_ensuring_decreasing_bind_count(&separated_resources, var, HLSL_REGSET_SAMPLERS);
+        }
+    }
+
+    list_move_head(&ctx->extern_vars, &separated_resources);
+
+    return false;
+}
+
 static bool sort_synthetic_separated_samplers_first(struct hlsl_ctx *ctx)
 {
     struct list separated_resources;
@@ -3010,7 +3189,7 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
     arg2 = expr->operands[1].node;
     if (expr->op != HLSL_OP2_DOT)
         return false;
-    if (arg1->data_type->dimx != 2)
+    if (arg1->data_type->e.numeric.dimx != 2)
         return false;
 
     if (ctx->profile->type == VKD3D_SHADER_TYPE_PIXEL)
@@ -3034,11 +3213,13 @@ static bool lower_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
             return false;
         hlsl_block_add_instr(block, mul);
 
-        if (!(add_x = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), instr->data_type->dimx, mul, &expr->node.loc)))
+        if (!(add_x = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X),
+                instr->data_type->e.numeric.dimx, mul, &expr->node.loc)))
             return false;
         hlsl_block_add_instr(block, add_x);
 
-        if (!(add_y = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(Y, Y, Y, Y), instr->data_type->dimx, mul, &expr->node.loc)))
+        if (!(add_y = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(Y, Y, Y, Y),
+                instr->data_type->e.numeric.dimx, mul, &expr->node.loc)))
             return false;
         hlsl_block_add_instr(block, add_y);
 
@@ -3202,7 +3383,7 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
     type = arg->data_type;
 
     /* Reduce the range of the input angles to [-pi, pi]. */
-    for (i = 0; i < type->dimx; ++i)
+    for (i = 0; i < type->e.numeric.dimx; ++i)
     {
         half_value.u[i].f = 0.5;
         two_pi_value.u[i].f = 2.0 * M_PI;
@@ -3230,7 +3411,7 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
         return false;
     hlsl_block_add_instr(block, reduced);
 
-    if (type->dimx == 1)
+    if (type->e.numeric.dimx == 1)
     {
         if (!(sincos = hlsl_new_unary_expr(ctx, op, reduced, &instr->loc)))
             return false;
@@ -3243,7 +3424,7 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
         struct hlsl_deref var_deref;
         struct hlsl_ir_load *var_load;
 
-        for (i = 0; i < type->dimx; ++i)
+        for (i = 0; i < type->e.numeric.dimx; ++i)
         {
             uint32_t s = hlsl_swizzle_from_writemask(1 << i);
 
@@ -3256,7 +3437,7 @@ static bool lower_trig(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct
             return false;
         hlsl_init_simple_deref_from_var(&var_deref, var);
 
-        for (i = 0; i < type->dimx; ++i)
+        for (i = 0; i < type->e.numeric.dimx; ++i)
         {
             struct hlsl_block store_block;
 
@@ -3292,7 +3473,7 @@ static bool lower_logic_not(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, st
         return false;
 
     arg = expr->operands[0].node;
-    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, arg->data_type->dimx);
+    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, arg->data_type->e.numeric.dimx);
 
     /* If this is happens, it means we failed to cast the argument to boolean somewhere. */
     VKD3D_ASSERT(arg->data_type->e.numeric.type == HLSL_TYPE_BOOL);
@@ -3354,7 +3535,7 @@ static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
     VKD3D_ASSERT(cond->data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
     type = hlsl_get_numeric_type(ctx, instr->data_type->class, HLSL_TYPE_FLOAT,
-            instr->data_type->dimx, instr->data_type->dimy);
+            instr->data_type->e.numeric.dimx, instr->data_type->e.numeric.dimy);
 
     if (!(float_cond = hlsl_new_cast(ctx, cond, type, &instr->loc)))
         return false;
@@ -3375,6 +3556,51 @@ static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
     return true;
 }
 
+static bool lower_resource_load_bias(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+{
+    struct hlsl_ir_node *swizzle, *store;
+    struct hlsl_ir_resource_load *load;
+    struct hlsl_ir_load *tmp_load;
+    struct hlsl_ir_var *tmp_var;
+    struct hlsl_deref deref;
+
+    if (instr->type != HLSL_IR_RESOURCE_LOAD)
+        return false;
+    load = hlsl_ir_resource_load(instr);
+    if (load->load_type != HLSL_RESOURCE_SAMPLE_LOD
+            && load->load_type != HLSL_RESOURCE_SAMPLE_LOD_BIAS)
+        return false;
+
+    if (!load->lod.node)
+        return false;
+
+    if (!(tmp_var = hlsl_new_synthetic_var(ctx, "coords-with-lod",
+            hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, 4), &instr->loc)))
+        return false;
+
+    if (!(swizzle = hlsl_new_swizzle(ctx, HLSL_SWIZZLE(X, X, X, X), 4, load->lod.node, &load->lod.node->loc)))
+        return false;
+    list_add_before(&instr->entry, &swizzle->entry);
+
+    if (!(store = hlsl_new_simple_store(ctx, tmp_var, swizzle)))
+        return false;
+    list_add_before(&instr->entry, &store->entry);
+
+    hlsl_init_simple_deref_from_var(&deref, tmp_var);
+    if (!(store = hlsl_new_store_index(ctx, &deref, NULL, load->coords.node, 0, &instr->loc)))
+        return false;
+    list_add_before(&instr->entry, &store->entry);
+
+    if (!(tmp_load = hlsl_new_var_load(ctx, tmp_var, &instr->loc)))
+        return false;
+    list_add_before(&instr->entry, &tmp_load->node.entry);
+
+    hlsl_src_remove(&load->coords);
+    hlsl_src_from_node(&load->coords, &tmp_load->node);
+    hlsl_src_remove(&load->lod);
+    return true;
+}
+
 static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         struct hlsl_block *block)
 {
@@ -3393,7 +3619,7 @@ static bool lower_comparison_operators(struct hlsl_ctx *ctx, struct hlsl_ir_node
 
     arg1 = expr->operands[0].node;
     arg2 = expr->operands[1].node;
-    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->dimx);
+    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
 
     if (!(arg1_cast = hlsl_new_cast(ctx, arg1, float_type, &instr->loc)))
         return false;
@@ -3519,7 +3745,7 @@ static bool lower_slt(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
 
     arg1 = expr->operands[0].node;
     arg2 = expr->operands[1].node;
-    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->dimx);
+    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
 
     if (!(arg1_cast = hlsl_new_cast(ctx, arg1, float_type, &instr->loc)))
         return false;
@@ -3579,7 +3805,7 @@ static bool lower_cmp(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct h
     if (expr->op != HLSL_OP3_CMP)
         return false;
 
-    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->dimx);
+    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
 
     for (i = 0; i < 3; ++i)
     {
@@ -3649,7 +3875,7 @@ static bool lower_casts_to_bool(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         return false;
 
     /* Narrowing casts should have already been lowered. */
-    VKD3D_ASSERT(type->dimx == arg_type->dimx);
+    VKD3D_ASSERT(type->e.numeric.dimx == arg_type->e.numeric.dimx);
 
     zero = hlsl_new_constant(ctx, arg_type, &zero_value, &instr->loc);
     if (!zero)
@@ -3675,7 +3901,8 @@ struct hlsl_ir_node *hlsl_add_conditional(struct hlsl_ctx *ctx, struct hlsl_bloc
 
     if (cond_type->e.numeric.type != HLSL_TYPE_BOOL)
     {
-        cond_type = hlsl_get_numeric_type(ctx, cond_type->class, HLSL_TYPE_BOOL, cond_type->dimx, cond_type->dimy);
+        cond_type = hlsl_get_numeric_type(ctx, cond_type->class, HLSL_TYPE_BOOL,
+                cond_type->e.numeric.dimx, cond_type->e.numeric.dimy);
 
         if (!(condition = hlsl_new_cast(ctx, condition, cond_type, &condition->loc)))
             return NULL;
@@ -3711,13 +3938,13 @@ static bool lower_int_division(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
     if (type->e.numeric.type != HLSL_TYPE_INT)
         return false;
-    utype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->dimx, type->dimy);
+    utype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->e.numeric.dimx, type->e.numeric.dimy);
 
     if (!(xor = hlsl_new_binary_expr(ctx, HLSL_OP2_BIT_XOR, arg1, arg2)))
         return false;
     hlsl_block_add_instr(block, xor);
 
-    for (i = 0; i < type->dimx; ++i)
+    for (i = 0; i < type->e.numeric.dimx; ++i)
         high_bit_value.u[i].u = 0x80000000;
     if (!(high_bit = hlsl_new_constant(ctx, type, &high_bit_value, &instr->loc)))
         return false;
@@ -3777,9 +4004,9 @@ static bool lower_int_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         return false;
     if (type->e.numeric.type != HLSL_TYPE_INT)
         return false;
-    utype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->dimx, type->dimy);
+    utype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_UINT, type->e.numeric.dimx, type->e.numeric.dimy);
 
-    for (i = 0; i < type->dimx; ++i)
+    for (i = 0; i < type->e.numeric.dimx; ++i)
         high_bit_value.u[i].u = 0x80000000;
     if (!(high_bit = hlsl_new_constant(ctx, type, &high_bit_value, &instr->loc)))
         return false;
@@ -3870,8 +4097,8 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
     {
         arg1 = expr->operands[0].node;
         arg2 = expr->operands[1].node;
-        VKD3D_ASSERT(arg1->data_type->dimx == arg2->data_type->dimx);
-        dimx = arg1->data_type->dimx;
+        VKD3D_ASSERT(arg1->data_type->e.numeric.dimx == arg2->data_type->e.numeric.dimx);
+        dimx = arg1->data_type->e.numeric.dimx;
         is_bool = type->e.numeric.type == HLSL_TYPE_BOOL;
 
         if (!(mult = hlsl_new_binary_expr(ctx, is_bool ? HLSL_OP2_LOGIC_AND : HLSL_OP2_MUL, arg1, arg2)))
@@ -3920,7 +4147,7 @@ static bool lower_float_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
         return false;
     if (type->e.numeric.type != HLSL_TYPE_FLOAT)
         return false;
-    btype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_BOOL, type->dimx, type->dimy);
+    btype = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_BOOL, type->e.numeric.dimx, type->e.numeric.dimy);
 
     if (!(mul1 = hlsl_new_binary_expr(ctx, HLSL_OP2_MUL, arg2, arg1)))
         return false;
@@ -3942,7 +4169,7 @@ static bool lower_float_modulus(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
     if (!(cond = hlsl_add_conditional(ctx, block, ge, arg2, neg2)))
         return false;
 
-    for (i = 0; i < type->dimx; ++i)
+    for (i = 0; i < type->e.numeric.dimx; ++i)
         one_value.u[i].f = 1.0f;
     if (!(one = hlsl_new_constant(ctx, type, &one_value, &instr->loc)))
         return false;
@@ -4000,7 +4227,7 @@ static bool lower_nonfloat_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
                 if (!arg)
                     continue;
 
-                float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, arg->data_type->dimx);
+                float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, arg->data_type->e.numeric.dimx);
                 if (!(arg_cast = hlsl_new_cast(ctx, arg, float_type, &instr->loc)))
                     return false;
                 hlsl_block_add_instr(block, arg_cast);
@@ -4008,7 +4235,7 @@ static bool lower_nonfloat_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
                 operands[i] = arg_cast;
             }
 
-            float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->dimx);
+            float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, instr->data_type->e.numeric.dimx);
             if (!(float_expr = hlsl_new_expr(ctx, expr->op, operands, float_type, &instr->loc)))
                 return false;
             hlsl_block_add_instr(block, float_expr);
@@ -4049,7 +4276,8 @@ static bool lower_discard_neg(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
 
     operands[0] = jump->condition.node;
     operands[1] = zero;
-    cmp_type = hlsl_get_numeric_type(ctx, arg_type->class, HLSL_TYPE_BOOL, arg_type->dimx, arg_type->dimy);
+    cmp_type = hlsl_get_numeric_type(ctx, arg_type->class, HLSL_TYPE_BOOL,
+            arg_type->e.numeric.dimx, arg_type->e.numeric.dimy);
     if (!(cmp = hlsl_new_expr(ctx, HLSL_OP2_LESS, operands, cmp_type, &instr->loc)))
         return false;
     hlsl_block_add_instr(&block, cmp);
@@ -4093,7 +4321,7 @@ static bool lower_discard_nz(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, v
         return false;
 
     cond = jump->condition.node;
-    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, cond->data_type->dimx);
+    float_type = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, cond->data_type->e.numeric.dimx);
 
     hlsl_block_init(&block);
 
@@ -4162,9 +4390,6 @@ static bool dce(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
         case HLSL_IR_STATEBLOCK_CONSTANT:
             /* Stateblock constants should not appear in the shader program. */
             vkd3d_unreachable();
-        case HLSL_IR_VSIR_INSTRUCTION_REF:
-            /* HLSL IR nodes are not translated to hlsl_ir_vsir_instruction_ref at this point. */
-            vkd3d_unreachable();
     }
 
     return false;
@@ -4304,9 +4529,6 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
         case HLSL_IR_STATEBLOCK_CONSTANT:
             /* Stateblock constants should not appear in the shader program. */
             vkd3d_unreachable();
-        case HLSL_IR_VSIR_INSTRUCTION_REF:
-            /* HLSL IR nodes are not translated to hlsl_ir_vsir_instruction_ref at this point. */
-            vkd3d_unreachable();
 
         case HLSL_IR_STORE:
         {
@@ -4494,6 +4716,9 @@ struct register_allocator
 
         /* Two allocations with different mode can't share the same register. */
         int mode;
+        /* If an allocation is VIP, no new allocations can be made in the
+         * register unless they are VIP as well. */
+        bool vip;
     } *allocations;
     size_t count, capacity;
 
@@ -4513,7 +4738,7 @@ struct register_allocator
 };
 
 static unsigned int get_available_writemask(const struct register_allocator *allocator,
-        unsigned int first_write, unsigned int last_read, uint32_t reg_idx, int mode)
+        unsigned int first_write, unsigned int last_read, uint32_t reg_idx, int mode, bool vip)
 {
     unsigned int writemask = VKD3DSP_WRITEMASK_ALL;
     size_t i;
@@ -4532,6 +4757,8 @@ static unsigned int get_available_writemask(const struct register_allocator *all
             writemask &= ~allocation->writemask;
             if (allocation->mode != mode)
                 writemask = 0;
+            if (allocation->vip && !vip)
+                writemask = 0;
         }
 
         if (!writemask)
@@ -4542,7 +4769,7 @@ static unsigned int get_available_writemask(const struct register_allocator *all
 }
 
 static void record_allocation(struct hlsl_ctx *ctx, struct register_allocator *allocator, uint32_t reg_idx,
-        unsigned int writemask, unsigned int first_write, unsigned int last_read, int mode)
+        unsigned int writemask, unsigned int first_write, unsigned int last_read, int mode, bool vip)
 {
     struct allocation *allocation;
 
@@ -4556,16 +4783,25 @@ static void record_allocation(struct hlsl_ctx *ctx, struct register_allocator *a
     allocation->first_write = first_write;
     allocation->last_read = last_read;
     allocation->mode = mode;
+    allocation->vip = vip;
 
     allocator->reg_count = max(allocator->reg_count, reg_idx + 1);
 }
 
-/* reg_size is the number of register components to be reserved, while component_count is the number
- * of components for the register's writemask. In SM1, floats and vectors allocate the whole
- * register, even if they don't use it completely. */
+/* Allocates a register (or some components of it) within the register allocator.
+ * 'reg_size' is the number of register components to be reserved.
+ * 'component_count' is the number of components for the hlsl_reg's
+ *      writemask, which can be smaller than 'reg_size'. For instance, sm1
+ *      floats and vectors allocate the whole register even if they are not
+ *      using all components.
+ * 'mode' can be provided to avoid allocating on a register that already has an
+ *      allocation with a different mode.
+ * 'force_align' can be used so that the allocation always start in '.x'.
+ * 'vip' can be used so that no new allocations can be made in the given register
+ *      unless they are 'vip' as well. */
 static struct hlsl_reg allocate_register(struct hlsl_ctx *ctx, struct register_allocator *allocator,
         unsigned int first_write, unsigned int last_read, unsigned int reg_size,
-        unsigned int component_count, int mode, bool force_align)
+        unsigned int component_count, int mode, bool force_align, bool vip)
 {
     struct hlsl_reg ret = {.allocation_size = 1, .allocated = true};
     unsigned int required_size = force_align ? 4 : reg_size;
@@ -4579,7 +4815,7 @@ static struct hlsl_reg allocate_register(struct hlsl_ctx *ctx, struct register_a
         for (uint32_t reg_idx = 0; reg_idx < allocator->reg_count; ++reg_idx)
         {
             unsigned int available_writemask = get_available_writemask(allocator,
-                    first_write, last_read, reg_idx, mode);
+                    first_write, last_read, reg_idx, mode, vip);
 
             if (vkd3d_popcount(available_writemask) >= pref)
             {
@@ -4589,7 +4825,8 @@ static struct hlsl_reg allocate_register(struct hlsl_ctx *ctx, struct register_a
                 ret.id = reg_idx;
                 ret.writemask = hlsl_combine_writemasks(writemask,
                         vkd3d_write_mask_from_component_count(component_count));
-                record_allocation(ctx, allocator, reg_idx, writemask, first_write, last_read, mode);
+
+                record_allocation(ctx, allocator, reg_idx, writemask, first_write, last_read, mode, vip);
                 return ret;
             }
         }
@@ -4598,13 +4835,14 @@ static struct hlsl_reg allocate_register(struct hlsl_ctx *ctx, struct register_a
     ret.id = allocator->reg_count;
     ret.writemask = vkd3d_write_mask_from_component_count(component_count);
     record_allocation(ctx, allocator, allocator->reg_count,
-            vkd3d_write_mask_from_component_count(reg_size), first_write, last_read, mode);
+            vkd3d_write_mask_from_component_count(reg_size), first_write, last_read, mode, vip);
     return ret;
 }
 
 /* Allocate a register with writemask, while reserving reg_writemask. */
-static struct hlsl_reg allocate_register_with_masks(struct hlsl_ctx *ctx, struct register_allocator *allocator,
-        unsigned int first_write, unsigned int last_read, uint32_t reg_writemask, uint32_t writemask, int mode)
+static struct hlsl_reg allocate_register_with_masks(struct hlsl_ctx *ctx,
+        struct register_allocator *allocator, unsigned int first_write, unsigned int last_read,
+        uint32_t reg_writemask, uint32_t writemask, int mode, bool vip)
 {
     struct hlsl_reg ret = {0};
     uint32_t reg_idx;
@@ -4614,11 +4852,11 @@ static struct hlsl_reg allocate_register_with_masks(struct hlsl_ctx *ctx, struct
     for (reg_idx = 0;; ++reg_idx)
     {
         if ((get_available_writemask(allocator, first_write, last_read,
-                reg_idx, mode) & reg_writemask) == reg_writemask)
+                reg_idx, mode, vip) & reg_writemask) == reg_writemask)
             break;
     }
 
-    record_allocation(ctx, allocator, reg_idx, reg_writemask, first_write, last_read, mode);
+    record_allocation(ctx, allocator, reg_idx, reg_writemask, first_write, last_read, mode, vip);
 
     ret.id = reg_idx;
     ret.allocation_size = 1;
@@ -4628,7 +4866,7 @@ static struct hlsl_reg allocate_register_with_masks(struct hlsl_ctx *ctx, struct
 }
 
 static bool is_range_available(const struct register_allocator *allocator, unsigned int first_write,
-        unsigned int last_read, uint32_t reg_idx, unsigned int reg_size, int mode)
+        unsigned int last_read, uint32_t reg_idx, unsigned int reg_size, int mode, bool vip)
 {
     unsigned int last_reg_mask = (1u << (reg_size % 4)) - 1;
     unsigned int writemask;
@@ -4636,18 +4874,18 @@ static bool is_range_available(const struct register_allocator *allocator, unsig
 
     for (i = 0; i < (reg_size / 4); ++i)
     {
-        writemask = get_available_writemask(allocator, first_write, last_read, reg_idx + i, mode);
+        writemask = get_available_writemask(allocator, first_write, last_read, reg_idx + i, mode, vip);
         if (writemask != VKD3DSP_WRITEMASK_ALL)
             return false;
     }
-    writemask = get_available_writemask(allocator, first_write, last_read, reg_idx + (reg_size / 4), mode);
+    writemask = get_available_writemask(allocator, first_write, last_read, reg_idx + (reg_size / 4), mode, vip);
     if ((writemask & last_reg_mask) != last_reg_mask)
         return false;
     return true;
 }
 
 static struct hlsl_reg allocate_range(struct hlsl_ctx *ctx, struct register_allocator *allocator,
-        unsigned int first_write, unsigned int last_read, unsigned int reg_size, int mode)
+        unsigned int first_write, unsigned int last_read, unsigned int reg_size, int mode, bool vip)
 {
     struct hlsl_reg ret = {0};
     uint32_t reg_idx;
@@ -4655,15 +4893,15 @@ static struct hlsl_reg allocate_range(struct hlsl_ctx *ctx, struct register_allo
 
     for (reg_idx = 0;; ++reg_idx)
     {
-        if (is_range_available(allocator, first_write, last_read, reg_idx, reg_size, mode))
+        if (is_range_available(allocator, first_write, last_read, reg_idx, reg_size, mode, vip))
             break;
     }
 
     for (i = 0; i < reg_size / 4; ++i)
-        record_allocation(ctx, allocator, reg_idx + i, VKD3DSP_WRITEMASK_ALL, first_write, last_read, mode);
+        record_allocation(ctx, allocator, reg_idx + i, VKD3DSP_WRITEMASK_ALL, first_write, last_read, mode, vip);
     if (reg_size % 4)
         record_allocation(ctx, allocator, reg_idx + (reg_size / 4),
-                (1u << (reg_size % 4)) - 1, first_write, last_read, mode);
+                (1u << (reg_size % 4)) - 1, first_write, last_read, mode, vip);
 
     ret.id = reg_idx;
     ret.allocation_size = align(reg_size, 4) / 4;
@@ -4679,9 +4917,10 @@ static struct hlsl_reg allocate_numeric_registers_for_type(struct hlsl_ctx *ctx,
     /* FIXME: We could potentially pack structs or arrays more efficiently... */
 
     if (type->class <= HLSL_CLASS_VECTOR)
-        return allocate_register(ctx, allocator, first_write, last_read, type->dimx, type->dimx, 0, false);
+        return allocate_register(ctx, allocator, first_write, last_read,
+                type->e.numeric.dimx, type->e.numeric.dimx, 0, false, false);
     else
-        return allocate_range(ctx, allocator, first_write, last_read, reg_size, 0);
+        return allocate_range(ctx, allocator, first_write, last_read, reg_size, 0, false);
 }
 
 static const char *debug_register(char class, struct hlsl_reg reg, const struct hlsl_type *type)
@@ -4859,8 +5098,8 @@ static void allocate_instr_temp_register(struct hlsl_ctx *ctx,
     }
 
     if (reg_writemask)
-        instr->reg = allocate_register_with_masks(ctx, allocator,
-                instr->index, instr->last_read, reg_writemask, dst_writemask, 0);
+        instr->reg = allocate_register_with_masks(ctx, allocator, instr->index,
+                instr->last_read, reg_writemask, dst_writemask, 0, false);
     else
         instr->reg = allocate_numeric_registers_for_type(ctx, allocator,
                 instr->index, instr->last_read, instr->data_type);
@@ -5006,13 +5245,13 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
                 TRACE("Allocated constant @%u to %s.\n", instr->index, debug_register('c', constant->reg, type));
 
                 VKD3D_ASSERT(hlsl_is_numeric_type(type));
-                VKD3D_ASSERT(type->dimy == 1);
+                VKD3D_ASSERT(type->e.numeric.dimy == 1);
                 VKD3D_ASSERT(constant->reg.writemask);
 
                 for (x = 0, i = 0; x < 4; ++x)
                 {
                     const union hlsl_constant_value_component *value;
-                    float f;
+                    float f = 0;
 
                     if (!(constant->reg.writemask & (1u << x)))
                         continue;
@@ -5040,9 +5279,6 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
                         case HLSL_TYPE_DOUBLE:
                             FIXME("Double constant.\n");
                             return;
-
-                        default:
-                            vkd3d_unreachable();
                     }
 
                     record_constant(ctx, constant->reg.id * 4 + x, f, &constant->node.loc);
@@ -5084,7 +5320,7 @@ static void allocate_const_registers_recurse(struct hlsl_ctx *ctx,
     }
 }
 
-static void sort_uniform_by_numeric_bind_count(struct list *sorted, struct hlsl_ir_var *to_sort)
+static void sort_uniform_by_bind_count(struct list *sorted, struct hlsl_ir_var *to_sort, enum hlsl_regset regset)
 {
     struct hlsl_ir_var *var;
 
@@ -5092,8 +5328,8 @@ static void sort_uniform_by_numeric_bind_count(struct list *sorted, struct hlsl_
 
     LIST_FOR_EACH_ENTRY(var, sorted, struct hlsl_ir_var, extern_entry)
     {
-        uint32_t to_sort_size = to_sort->bind_count[HLSL_REGSET_NUMERIC];
-        uint32_t var_size = var->bind_count[HLSL_REGSET_NUMERIC];
+        uint32_t to_sort_size = to_sort->bind_count[regset];
+        uint32_t var_size = var->bind_count[regset];
 
         if (to_sort_size > var_size)
         {
@@ -5105,7 +5341,7 @@ static void sort_uniform_by_numeric_bind_count(struct list *sorted, struct hlsl_
     list_add_tail(sorted, &to_sort->extern_entry);
 }
 
-static void sort_uniforms_by_numeric_bind_count(struct hlsl_ctx *ctx)
+static void sort_uniforms_by_bind_count(struct hlsl_ctx *ctx, enum hlsl_regset regset)
 {
     struct list sorted = LIST_INIT(sorted);
     struct hlsl_ir_var *var, *next;
@@ -5113,7 +5349,7 @@ static void sort_uniforms_by_numeric_bind_count(struct hlsl_ctx *ctx)
     LIST_FOR_EACH_ENTRY_SAFE(var, next, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
     {
         if (var->is_uniform)
-            sort_uniform_by_numeric_bind_count(&sorted, var);
+            sort_uniform_by_bind_count(&sorted, var, regset);
     }
     list_move_tail(&ctx->extern_vars, &sorted);
 }
@@ -5161,7 +5397,7 @@ static void allocate_const_registers(struct hlsl_ctx *ctx, struct hlsl_ir_functi
     struct register_allocator allocator = {0};
     struct hlsl_ir_var *var;
 
-    sort_uniforms_by_numeric_bind_count(ctx);
+    sort_uniforms_by_bind_count(ctx, HLSL_REGSET_NUMERIC);
 
     LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
     {
@@ -5181,14 +5417,15 @@ static void allocate_const_registers(struct hlsl_ctx *ctx, struct hlsl_ir_functi
             {
                 if (i < bind_count)
                 {
-                    if (get_available_writemask(&allocator_used, 1, UINT_MAX, reg_idx + i, 0) != VKD3DSP_WRITEMASK_ALL)
+                    if (get_available_writemask(&allocator_used, 1, UINT_MAX,
+                            reg_idx + i, 0, false) != VKD3DSP_WRITEMASK_ALL)
                     {
                         hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_RESERVATION,
                                 "Overlapping register() reservations on 'c%u'.", reg_idx + i);
                     }
-                    record_allocation(ctx, &allocator_used, reg_idx + i, VKD3DSP_WRITEMASK_ALL, 1, UINT_MAX, 0);
+                    record_allocation(ctx, &allocator_used, reg_idx + i, VKD3DSP_WRITEMASK_ALL, 1, UINT_MAX, 0, false);
                 }
-                record_allocation(ctx, &allocator, reg_idx + i, VKD3DSP_WRITEMASK_ALL, 1, UINT_MAX, 0);
+                record_allocation(ctx, &allocator, reg_idx + i, VKD3DSP_WRITEMASK_ALL, 1, UINT_MAX, 0, false);
             }
 
             var->regs[HLSL_REGSET_NUMERIC].id = reg_idx;
@@ -5211,7 +5448,7 @@ static void allocate_const_registers(struct hlsl_ctx *ctx, struct hlsl_ir_functi
 
         if (!var->regs[HLSL_REGSET_NUMERIC].allocated)
         {
-            var->regs[HLSL_REGSET_NUMERIC] = allocate_range(ctx, &allocator, 1, UINT_MAX, alloc_size, 0);
+            var->regs[HLSL_REGSET_NUMERIC] = allocate_range(ctx, &allocator, 1, UINT_MAX, alloc_size, 0, false);
             TRACE("Allocated %s to %s.\n", var->name,
                     debug_register('c', var->regs[HLSL_REGSET_NUMERIC], var->data_type));
         }
@@ -5254,7 +5491,8 @@ static uint32_t allocate_temp_registers(struct hlsl_ctx *ctx, struct hlsl_ir_fun
             var = entry_func->parameters.vars[i];
             if (var->is_output_semantic)
             {
-                record_allocation(ctx, &allocator, 0, VKD3DSP_WRITEMASK_ALL, var->first_write, var->last_read, 0);
+                record_allocation(ctx, &allocator, 0, VKD3DSP_WRITEMASK_ALL,
+                        var->first_write, var->last_read, 0, false);
                 break;
             }
         }
@@ -5266,7 +5504,8 @@ static uint32_t allocate_temp_registers(struct hlsl_ctx *ctx, struct hlsl_ir_fun
     return allocator.reg_count;
 }
 
-enum vkd3d_shader_interpolation_mode sm4_get_interpolation_mode(struct hlsl_type *type, unsigned int storage_modifiers)
+static enum vkd3d_shader_interpolation_mode sm4_get_interpolation_mode(struct hlsl_type *type,
+        unsigned int storage_modifiers)
 {
     unsigned int i;
 
@@ -5311,6 +5550,8 @@ static void allocate_semantic_register(struct hlsl_ctx *ctx, struct hlsl_ir_var
 
     enum vkd3d_shader_register_type type;
     struct vkd3d_shader_version version;
+    bool special_interpolation = false;
+    bool vip_allocation = false;
     uint32_t reg;
     bool builtin;
 
@@ -5363,6 +5604,14 @@ static void allocate_semantic_register(struct hlsl_ctx *ctx, struct hlsl_ir_var
              * domains, it is allocated as if it was 'float[1]'. */
             var->force_align = true;
         }
+
+        if (semantic == VKD3D_SHADER_SV_RENDER_TARGET_ARRAY_INDEX
+                || semantic == VKD3D_SHADER_SV_VIEWPORT_ARRAY_INDEX
+                || semantic == VKD3D_SHADER_SV_PRIMITIVE_ID)
+            vip_allocation = true;
+
+        if (semantic == VKD3D_SHADER_SV_IS_FRONT_FACE || semantic == VKD3D_SHADER_SV_SAMPLE_INDEX)
+            special_interpolation = true;
     }
 
     if (builtin)
@@ -5374,10 +5623,13 @@ static void allocate_semantic_register(struct hlsl_ctx *ctx, struct hlsl_ir_var
     {
         int mode = (ctx->profile->major_version < 4)
                 ? 0 : sm4_get_interpolation_mode(var->data_type, var->storage_modifiers);
-        unsigned int reg_size = optimize ? var->data_type->dimx : 4;
+        unsigned int reg_size = optimize ? var->data_type->e.numeric.dimx : 4;
+
+        if (special_interpolation)
+            mode = VKD3DSIM_NONE;
 
-        var->regs[HLSL_REGSET_NUMERIC] = allocate_register(ctx, allocator, 1,
-                UINT_MAX, reg_size, var->data_type->dimx, mode, var->force_align);
+        var->regs[HLSL_REGSET_NUMERIC] = allocate_register(ctx, allocator, 1, UINT_MAX,
+                reg_size, var->data_type->e.numeric.dimx, mode, var->force_align, vip_allocation);
 
         TRACE("Allocated %s to %s (mode %d).\n", var->name, debug_register(output ? 'o' : 'v',
                 var->regs[HLSL_REGSET_NUMERIC], var->data_type), mode);
@@ -5831,7 +6083,7 @@ bool hlsl_component_index_range_from_deref(struct hlsl_ctx *ctx, const struct hl
         switch (type->class)
         {
             case HLSL_CLASS_VECTOR:
-                if (idx >= type->dimx)
+                if (idx >= type->e.numeric.dimx)
                     return false;
                 *start += idx;
                 break;
@@ -5840,9 +6092,9 @@ bool hlsl_component_index_range_from_deref(struct hlsl_ctx *ctx, const struct hl
                 if (idx >= hlsl_type_major_size(type))
                     return false;
                 if (hlsl_type_is_row_major(type))
-                    *start += idx * type->dimx;
+                    *start += idx * type->e.numeric.dimx;
                 else
-                    *start += idx * type->dimy;
+                    *start += idx * type->e.numeric.dimy;
                 break;
 
             case HLSL_CLASS_ARRAY:
@@ -6419,6 +6671,7 @@ void hlsl_run_const_passes(struct hlsl_ctx *ctx, struct hlsl_block *body)
     {
         progress = hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL);
         progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_identities, body, NULL);
+        progress |= hlsl_transform_ir(ctx, hlsl_normalize_binary_exprs, body, NULL);
         progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_swizzles, body, NULL);
         progress |= hlsl_copy_propagation_execute(ctx, body);
         progress |= hlsl_transform_ir(ctx, fold_swizzle_chains, body, NULL);
@@ -6430,8 +6683,8 @@ void hlsl_run_const_passes(struct hlsl_ctx *ctx, struct hlsl_block *body)
 static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_program *program,
         struct shader_signature *signature, bool output, bool is_patch_constant_func, struct hlsl_ir_var *var)
 {
+    enum vkd3d_shader_component_type component_type = VKD3D_SHADER_COMPONENT_VOID;
     enum vkd3d_shader_sysval_semantic sysval = VKD3D_SHADER_SV_NONE;
-    enum vkd3d_shader_component_type component_type;
     unsigned int register_index, mask, use_mask;
     const char *name = var->semantic.name;
     enum vkd3d_shader_register_type type;
@@ -6451,7 +6704,7 @@ static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_prog
         if (sm4_register_from_semantic_name(&program->shader_version, var->semantic.name, output, &type, &has_idx))
         {
             register_index = has_idx ? var->semantic.index : ~0u;
-            mask = (1u << var->data_type->dimx) - 1;
+            mask = (1u << var->data_type->e.numeric.dimx) - 1;
         }
         else
         {
@@ -6478,12 +6731,11 @@ static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_prog
                 component_type = VKD3D_SHADER_COMPONENT_UINT;
                 break;
 
-            default:
+            case HLSL_TYPE_DOUBLE:
                 if ((string = hlsl_type_to_string(ctx, var->data_type)))
                     hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "Invalid data type %s for semantic variable %s.", string->buffer, var->name);
                 hlsl_release_string_buffer(ctx, string);
-                component_type = VKD3D_SHADER_COMPONENT_VOID;
                 break;
         }
 
@@ -6519,19 +6771,19 @@ static void generate_vsir_signature_entry(struct hlsl_ctx *ctx, struct vsir_prog
                 sysval = VKD3D_SHADER_SV_POSITION;
         }
 
-        mask = (1 << var->data_type->dimx) - 1;
+        mask = (1 << var->data_type->e.numeric.dimx) - 1;
 
         if (!ascii_strcasecmp(var->semantic.name, "PSIZE") && output
                 && program->shader_version.type == VKD3D_SHADER_TYPE_VERTEX)
         {
-            if (var->data_type->dimx > 1)
+            if (var->data_type->e.numeric.dimx > 1)
                 hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SEMANTIC,
                         "PSIZE output must have only 1 component in this shader model.");
             /* For some reason the writemask has all components set. */
             mask = VKD3DSP_WRITEMASK_ALL;
         }
         if (!ascii_strcasecmp(var->semantic.name, "FOG") && output && program->shader_version.major < 3
-                && program->shader_version.type == VKD3D_SHADER_TYPE_VERTEX && var->data_type->dimx > 1)
+                && program->shader_version.type == VKD3D_SHADER_TYPE_VERTEX && var->data_type->e.numeric.dimx > 1)
             hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SEMANTIC,
                     "FOG output must have only 1 component in this shader model.");
 
@@ -6636,7 +6888,6 @@ static uint32_t generate_vsir_get_src_swizzle(uint32_t src_writemask, uint32_t d
 
     swizzle = hlsl_swizzle_from_writemask(src_writemask);
     swizzle = hlsl_map_swizzle(swizzle, dst_writemask);
-    swizzle = vsir_swizzle_from_hlsl(swizzle);
     return swizzle;
 }
 
@@ -6812,7 +7063,7 @@ static void vsir_src_from_hlsl_constant_value(struct vkd3d_shader_src_param *src
 }
 
 static void vsir_src_from_hlsl_node(struct vkd3d_shader_src_param *src,
-        struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, uint32_t map_writemask)
+        struct hlsl_ctx *ctx, const struct hlsl_ir_node *instr, uint32_t map_writemask)
 {
     struct hlsl_ir_constant *constant;
 
@@ -6821,7 +7072,7 @@ static void vsir_src_from_hlsl_node(struct vkd3d_shader_src_param *src,
         /* In SM4 constants are inlined */
         constant = hlsl_ir_constant(instr);
         vsir_src_from_hlsl_constant_value(src, ctx, &constant->value,
-                vsir_data_type_from_hlsl_instruction(ctx, instr), instr->data_type->dimx, map_writemask);
+                vsir_data_type_from_hlsl_instruction(ctx, instr), instr->data_type->e.numeric.dimx, map_writemask);
     }
     else
     {
@@ -6832,89 +7083,325 @@ static void vsir_src_from_hlsl_node(struct vkd3d_shader_src_param *src,
     }
 }
 
-static void vsir_dst_from_hlsl_node(struct vkd3d_shader_dst_param *dst,
-        struct hlsl_ctx *ctx, const struct hlsl_ir_node *instr)
-{
-    VKD3D_ASSERT(instr->reg.allocated);
-    vsir_dst_param_init(dst, VKD3DSPR_TEMP, vsir_data_type_from_hlsl_instruction(ctx, instr), 1);
-    dst->reg.idx[0].offset = instr->reg.id;
-    dst->reg.dimension = VSIR_DIMENSION_VEC4;
-    dst->write_mask = instr->reg.writemask;
-}
-
-static void sm1_generate_vsir_instr_constant(struct hlsl_ctx *ctx,
-        struct vsir_program *program, struct hlsl_ir_constant *constant)
+static bool sm4_generate_vsir_numeric_reg_from_deref(struct hlsl_ctx *ctx, struct vsir_program *program,
+        struct vkd3d_shader_register *reg, uint32_t *writemask, const struct hlsl_deref *deref)
 {
-    struct hlsl_ir_node *instr = &constant->node;
-    struct vkd3d_shader_dst_param *dst_param;
-    struct vkd3d_shader_src_param *src_param;
-    struct vkd3d_shader_instruction *ins;
-
-    VKD3D_ASSERT(instr->reg.allocated);
-    VKD3D_ASSERT(constant->reg.allocated);
+    const struct hlsl_ir_var *var = deref->var;
+    unsigned int offset_const_deref;
 
-    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_MOV, 1, 1)))
-        return;
+    reg->type = var->indexable ? VKD3DSPR_IDXTEMP : VKD3DSPR_TEMP;
+    reg->idx[0].offset = var->regs[HLSL_REGSET_NUMERIC].id;
+    reg->dimension = VSIR_DIMENSION_VEC4;
 
-    src_param = &ins->src[0];
-    vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
-    src_param->reg.idx[0].offset = constant->reg.id;
-    src_param->swizzle = generate_vsir_get_src_swizzle(constant->reg.writemask, instr->reg.writemask);
+    VKD3D_ASSERT(var->regs[HLSL_REGSET_NUMERIC].allocated);
 
-    dst_param = &ins->dst[0];
-    vsir_register_init(&dst_param->reg, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
-    dst_param->reg.idx[0].offset = instr->reg.id;
-    dst_param->write_mask = instr->reg.writemask;
-}
+    if (!var->indexable)
+    {
+        offset_const_deref = hlsl_offset_from_deref_safe(ctx, deref);
+        reg->idx[0].offset += offset_const_deref / 4;
+        reg->idx_count = 1;
+    }
+    else
+    {
+        offset_const_deref = deref->const_offset;
+        reg->idx[1].offset = offset_const_deref / 4;
+        reg->idx_count = 2;
 
-static void sm4_generate_vsir_rasterizer_sample_count(struct hlsl_ctx *ctx,
-        struct vsir_program *program, struct hlsl_ir_expr *expr)
-{
-    struct vkd3d_shader_src_param *src_param;
-    struct hlsl_ir_node *instr = &expr->node;
-    struct vkd3d_shader_instruction *ins;
+        if (deref->rel_offset.node)
+        {
+            struct vkd3d_shader_src_param *idx_src;
 
-    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_SAMPLE_INFO, 1, 1)))
-        return;
-    ins->flags = VKD3DSI_SAMPLE_INFO_UINT;
+            if (!(idx_src = vsir_program_get_src_params(program, 1)))
+            {
+                ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
+                return false;
+            }
+            memset(idx_src, 0, sizeof(*idx_src));
+            reg->idx[1].rel_addr = idx_src;
 
-    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+            vsir_src_from_hlsl_node(idx_src, ctx, deref->rel_offset.node, VKD3DSP_WRITEMASK_ALL);
+        }
+    }
 
-    src_param = &ins->src[0];
-    vsir_src_param_init(src_param, VKD3DSPR_RASTERIZER, VKD3D_DATA_UNUSED, 0);
-    src_param->reg.dimension = VSIR_DIMENSION_VEC4;
-    src_param->swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+    *writemask = 0xf & (0xf << (offset_const_deref % 4));
+    if (var->regs[HLSL_REGSET_NUMERIC].writemask)
+        *writemask = hlsl_combine_writemasks(var->regs[HLSL_REGSET_NUMERIC].writemask, *writemask);
+    return true;
 }
 
-/* Translate ops that can be mapped to a single vsir instruction with only one dst register. */
-static void generate_vsir_instr_expr_single_instr_op(struct hlsl_ctx *ctx,
-        struct vsir_program *program, struct hlsl_ir_expr *expr, enum vkd3d_shader_opcode opcode,
-        uint32_t src_mod, uint32_t dst_mod, bool map_src_swizzles)
+static bool sm4_generate_vsir_reg_from_deref(struct hlsl_ctx *ctx, struct vsir_program *program,
+        struct vkd3d_shader_register *reg, uint32_t *writemask, const struct hlsl_deref *deref)
 {
-    struct hlsl_ir_node *instr = &expr->node;
-    struct vkd3d_shader_dst_param *dst_param;
-    struct vkd3d_shader_src_param *src_param;
-    struct vkd3d_shader_instruction *ins;
-    unsigned int i, src_count = 0;
-
-    VKD3D_ASSERT(instr->reg.allocated);
+    const struct vkd3d_shader_version *version = &program->shader_version;
+    const struct hlsl_type *data_type = hlsl_deref_get_type(ctx, deref);
+    const struct hlsl_ir_var *var = deref->var;
 
-    for (i = 0; i < HLSL_MAX_OPERANDS; ++i)
+    if (var->is_uniform)
     {
-        if (expr->operands[i].node)
-            src_count = i + 1;
-    }
-    VKD3D_ASSERT(!src_mod || src_count == 1);
-
-    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, opcode, 1, src_count)))
-        return;
+        enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
 
-    dst_param = &ins->dst[0];
-    vsir_dst_from_hlsl_node(dst_param, ctx, instr);
-    dst_param->modifiers = dst_mod;
+        if (regset == HLSL_REGSET_TEXTURES)
+        {
+            reg->type = VKD3DSPR_RESOURCE;
+            reg->dimension = VSIR_DIMENSION_VEC4;
+            if (vkd3d_shader_ver_ge(version, 5, 1))
+            {
+                reg->idx[0].offset = var->regs[HLSL_REGSET_TEXTURES].id;
+                reg->idx[1].offset = var->regs[HLSL_REGSET_TEXTURES].index; /* FIXME: array index */
+                reg->idx_count = 2;
+            }
+            else
+            {
+                reg->idx[0].offset = var->regs[HLSL_REGSET_TEXTURES].index;
+                reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
+                reg->idx_count = 1;
+            }
+            VKD3D_ASSERT(regset == HLSL_REGSET_TEXTURES);
+            *writemask = VKD3DSP_WRITEMASK_ALL;
+        }
+        else if (regset == HLSL_REGSET_UAVS)
+        {
+            reg->type = VKD3DSPR_UAV;
+            reg->dimension = VSIR_DIMENSION_VEC4;
+            if (vkd3d_shader_ver_ge(version, 5, 1))
+            {
+                reg->idx[0].offset = var->regs[HLSL_REGSET_UAVS].id;
+                reg->idx[1].offset = var->regs[HLSL_REGSET_UAVS].index; /* FIXME: array index */
+                reg->idx_count = 2;
+            }
+            else
+            {
+                reg->idx[0].offset = var->regs[HLSL_REGSET_UAVS].index;
+                reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
+                reg->idx_count = 1;
+            }
+            VKD3D_ASSERT(regset == HLSL_REGSET_UAVS);
+            *writemask = VKD3DSP_WRITEMASK_ALL;
+        }
+        else if (regset == HLSL_REGSET_SAMPLERS)
+        {
+            reg->type = VKD3DSPR_SAMPLER;
+            reg->dimension = VSIR_DIMENSION_NONE;
+            if (vkd3d_shader_ver_ge(version, 5, 1))
+            {
+                reg->idx[0].offset = var->regs[HLSL_REGSET_SAMPLERS].id;
+                reg->idx[1].offset = var->regs[HLSL_REGSET_SAMPLERS].index; /* FIXME: array index */
+                reg->idx_count = 2;
+            }
+            else
+            {
+                reg->idx[0].offset = var->regs[HLSL_REGSET_SAMPLERS].index;
+                reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
+                reg->idx_count = 1;
+            }
+            VKD3D_ASSERT(regset == HLSL_REGSET_SAMPLERS);
+            *writemask = VKD3DSP_WRITEMASK_ALL;
+        }
+        else
+        {
+            unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref) + var->buffer_offset;
 
-    for (i = 0; i < src_count; ++i)
-    {
+            VKD3D_ASSERT(data_type->class <= HLSL_CLASS_VECTOR);
+            reg->type = VKD3DSPR_CONSTBUFFER;
+            reg->dimension = VSIR_DIMENSION_VEC4;
+            if (vkd3d_shader_ver_ge(version, 5, 1))
+            {
+                reg->idx[0].offset = var->buffer->reg.id;
+                reg->idx[1].offset = var->buffer->reg.index; /* FIXME: array index */
+                reg->idx[2].offset = offset / 4;
+                reg->idx_count = 3;
+            }
+            else
+            {
+                reg->idx[0].offset = var->buffer->reg.index;
+                reg->idx[1].offset = offset / 4;
+                reg->idx_count = 2;
+            }
+            *writemask = ((1u << data_type->e.numeric.dimx) - 1) << (offset & 3);
+        }
+    }
+    else if (var->is_input_semantic)
+    {
+        bool has_idx;
+
+        if (sm4_register_from_semantic_name(version, var->semantic.name, false, &reg->type, &has_idx))
+        {
+            unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
+
+            if (has_idx)
+            {
+                reg->idx[0].offset = var->semantic.index + offset / 4;
+                reg->idx_count = 1;
+            }
+
+            if (shader_sm4_is_scalar_register(reg))
+                reg->dimension = VSIR_DIMENSION_SCALAR;
+            else
+                reg->dimension = VSIR_DIMENSION_VEC4;
+            *writemask = ((1u << data_type->e.numeric.dimx) - 1) << (offset % 4);
+        }
+        else
+        {
+            struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
+
+            VKD3D_ASSERT(hlsl_reg.allocated);
+
+            if (version->type == VKD3D_SHADER_TYPE_DOMAIN)
+                reg->type = VKD3DSPR_PATCHCONST;
+            else
+                reg->type = VKD3DSPR_INPUT;
+            reg->dimension = VSIR_DIMENSION_VEC4;
+            reg->idx[0].offset = hlsl_reg.id;
+            reg->idx_count = 1;
+            *writemask = hlsl_reg.writemask;
+        }
+    }
+    else if (var->is_output_semantic)
+    {
+        bool has_idx;
+
+        if (sm4_register_from_semantic_name(version, var->semantic.name, true, &reg->type, &has_idx))
+        {
+            unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
+
+            if (has_idx)
+            {
+                reg->idx[0].offset = var->semantic.index + offset / 4;
+                reg->idx_count = 1;
+            }
+
+            if (shader_sm4_is_scalar_register(reg))
+                reg->dimension = VSIR_DIMENSION_SCALAR;
+            else
+                reg->dimension = VSIR_DIMENSION_VEC4;
+            *writemask = ((1u << data_type->e.numeric.dimx) - 1) << (offset % 4);
+        }
+        else
+        {
+            struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
+
+            VKD3D_ASSERT(hlsl_reg.allocated);
+            reg->type = VKD3DSPR_OUTPUT;
+            reg->dimension = VSIR_DIMENSION_VEC4;
+            reg->idx[0].offset = hlsl_reg.id;
+            reg->idx_count = 1;
+            *writemask = hlsl_reg.writemask;
+        }
+    }
+    else
+    {
+        return sm4_generate_vsir_numeric_reg_from_deref(ctx, program, reg, writemask, deref);
+    }
+    return true;
+}
+
+static bool sm4_generate_vsir_init_src_param_from_deref(struct hlsl_ctx *ctx, struct vsir_program *program,
+        struct vkd3d_shader_src_param *src_param, const struct hlsl_deref *deref,
+        unsigned int dst_writemask, const struct vkd3d_shader_location *loc)
+{
+    uint32_t writemask;
+
+    if (!sm4_generate_vsir_reg_from_deref(ctx, program, &src_param->reg, &writemask, deref))
+        return false;
+    src_param->swizzle = generate_vsir_get_src_swizzle(writemask, dst_writemask);
+    return true;
+}
+
+static bool sm4_generate_vsir_init_dst_param_from_deref(struct hlsl_ctx *ctx, struct vsir_program *program,
+        struct vkd3d_shader_dst_param *dst_param, const struct hlsl_deref *deref,
+        const struct vkd3d_shader_location *loc, unsigned int writemask)
+{
+    uint32_t reg_writemask;
+
+    if (!sm4_generate_vsir_reg_from_deref(ctx, program, &dst_param->reg, &reg_writemask, deref))
+        return false;
+    dst_param->write_mask = hlsl_combine_writemasks(reg_writemask, writemask);
+    return true;
+}
+
+static void vsir_dst_from_hlsl_node(struct vkd3d_shader_dst_param *dst,
+        struct hlsl_ctx *ctx, const struct hlsl_ir_node *instr)
+{
+    VKD3D_ASSERT(instr->reg.allocated);
+    vsir_dst_param_init(dst, VKD3DSPR_TEMP, vsir_data_type_from_hlsl_instruction(ctx, instr), 1);
+    dst->reg.idx[0].offset = instr->reg.id;
+    dst->reg.dimension = VSIR_DIMENSION_VEC4;
+    dst->write_mask = instr->reg.writemask;
+}
+
+static void sm1_generate_vsir_instr_constant(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_constant *constant)
+{
+    struct hlsl_ir_node *instr = &constant->node;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_instruction *ins;
+
+    VKD3D_ASSERT(instr->reg.allocated);
+    VKD3D_ASSERT(constant->reg.allocated);
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_MOV, 1, 1)))
+        return;
+
+    src_param = &ins->src[0];
+    vsir_register_init(&src_param->reg, VKD3DSPR_CONST, VKD3D_DATA_FLOAT, 1);
+    src_param->reg.idx[0].offset = constant->reg.id;
+    src_param->swizzle = generate_vsir_get_src_swizzle(constant->reg.writemask, instr->reg.writemask);
+
+    dst_param = &ins->dst[0];
+    vsir_register_init(&dst_param->reg, VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+    dst_param->reg.idx[0].offset = instr->reg.id;
+    dst_param->write_mask = instr->reg.writemask;
+}
+
+static void sm4_generate_vsir_rasterizer_sample_count(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_expr *expr)
+{
+    struct vkd3d_shader_src_param *src_param;
+    struct hlsl_ir_node *instr = &expr->node;
+    struct vkd3d_shader_instruction *ins;
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_SAMPLE_INFO, 1, 1)))
+        return;
+    ins->flags = VKD3DSI_SAMPLE_INFO_UINT;
+
+    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+
+    src_param = &ins->src[0];
+    vsir_src_param_init(src_param, VKD3DSPR_RASTERIZER, VKD3D_DATA_UNUSED, 0);
+    src_param->reg.dimension = VSIR_DIMENSION_VEC4;
+    src_param->swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+}
+
+/* Translate ops that can be mapped to a single vsir instruction with only one dst register. */
+static void generate_vsir_instr_expr_single_instr_op(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_expr *expr, enum vkd3d_shader_opcode opcode,
+        uint32_t src_mod, uint32_t dst_mod, bool map_src_swizzles)
+{
+    struct hlsl_ir_node *instr = &expr->node;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_instruction *ins;
+    unsigned int i, src_count = 0;
+
+    VKD3D_ASSERT(instr->reg.allocated);
+
+    for (i = 0; i < HLSL_MAX_OPERANDS; ++i)
+    {
+        if (expr->operands[i].node)
+            src_count = i + 1;
+    }
+    VKD3D_ASSERT(!src_mod || src_count == 1);
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, opcode, 1, src_count)))
+        return;
+
+    dst_param = &ins->dst[0];
+    vsir_dst_from_hlsl_node(dst_param, ctx, instr);
+    dst_param->modifiers = dst_mod;
+
+    for (i = 0; i < src_count; ++i)
+    {
         struct hlsl_ir_node *operand = expr->operands[i].node;
 
         src_param = &ins->src[i];
@@ -7014,7 +7501,7 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
     dst_type = instr->data_type;
 
     /* Narrowing casts were already lowered. */
-    VKD3D_ASSERT(src_type->dimx == dst_type->dimx);
+    VKD3D_ASSERT(src_type->e.numeric.dimx == dst_type->e.numeric.dimx);
 
     switch (dst_type->e.numeric.type)
     {
@@ -7040,9 +7527,6 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                     hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
                             "The 'double' type is not supported for the %s profile.", ctx->profile->name);
                     break;
-
-                default:
-                    vkd3d_unreachable();
             }
             break;
 
@@ -7059,19 +7543,13 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
 
                 case HLSL_TYPE_INT:
                 case HLSL_TYPE_UINT:
+                case HLSL_TYPE_BOOL:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_MOV, 0, 0, true);
                     return true;
 
-                case HLSL_TYPE_BOOL:
-                    hlsl_fixme(ctx, &instr->loc, "SM1 cast from bool to integer.");
-                    break;
-
                 case HLSL_TYPE_DOUBLE:
                     hlsl_fixme(ctx, &instr->loc, "SM1 cast from double to integer.");
                     break;
-
-                default:
-                    vkd3d_unreachable();
             }
             break;
 
@@ -7096,7 +7574,6 @@ static bool sm1_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
 
         case HLSL_TYPE_BOOL:
             /* Casts to bool should have already been lowered. */
-        default:
             hlsl_fixme(ctx, &expr->node.loc, "SM1 cast from %s to %s.",
                 debug_hlsl_type(ctx, src_type), debug_hlsl_type(ctx, dst_type));
             break;
@@ -7178,7 +7655,7 @@ static bool sm1_generate_vsir_instr_expr(struct hlsl_ctx *ctx, struct vsir_progr
             break;
 
         case HLSL_OP2_DOT:
-            switch (expr->operands[0].node->data_type->dimx)
+            switch (expr->operands[0].node->data_type->e.numeric.dimx)
             {
                 case 3:
                     generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_DP3, 0, 0, false);
@@ -7276,7 +7753,7 @@ static void sm1_generate_vsir_init_dst_param_from_deref(struct hlsl_ctx *ctx,
             register_index = reg.id;
         }
         else
-            writemask = (1u << deref->var->data_type->dimx) - 1;
+            writemask = (1u << deref->var->data_type->e.numeric.dimx) - 1;
 
         if (version.type == VKD3D_SHADER_TYPE_PIXEL && (!ascii_strcasecmp(semantic_name, "PSIZE")
                 || (!ascii_strcasecmp(semantic_name, "FOG") && version.major < 3)))
@@ -7334,7 +7811,7 @@ static void sm1_generate_vsir_init_src_param_from_deref(struct hlsl_ctx *ctx,
         if (sm1_register_from_semantic_name(&version, deref->var->semantic.name,
                 deref->var->semantic.index, false, &type, &register_index))
         {
-            writemask = (1 << deref->var->data_type->dimx) - 1;
+            writemask = (1 << deref->var->data_type->e.numeric.dimx) - 1;
         }
         else
         {
@@ -7472,9 +7949,8 @@ static void generate_vsir_instr_swizzle(struct hlsl_ctx *ctx,
     dst_param->write_mask = instr->reg.writemask;
 
     swizzle = hlsl_swizzle_from_writemask(val->reg.writemask);
-    swizzle = hlsl_combine_swizzles(swizzle, swizzle_instr->swizzle, instr->data_type->dimx);
+    swizzle = hlsl_combine_swizzles(swizzle, swizzle_instr->u.vector, instr->data_type->e.numeric.dimx);
     swizzle = hlsl_map_swizzle(swizzle, ins->dst[0].write_mask);
-    swizzle = vsir_swizzle_from_hlsl(swizzle);
 
     src_param = &ins->src[0];
     VKD3D_ASSERT(val->type != HLSL_IR_CONSTANT);
@@ -7539,7 +8015,7 @@ static void sm1_generate_vsir_instr_if(struct hlsl_ctx *ctx, struct vsir_program
         hlsl_fixme(ctx, &instr->loc, "Flatten \"if\" conditionals branches.");
         return;
     }
-    VKD3D_ASSERT(condition->data_type->dimx == 1 && condition->data_type->dimy == 1);
+    VKD3D_ASSERT(condition->data_type->e.numeric.dimx == 1 && condition->data_type->e.numeric.dimy == 1);
 
     if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_IFC, 0, 2)))
         return;
@@ -7624,31 +8100,20 @@ static void sm1_generate_vsir_block(struct hlsl_ctx *ctx, struct hlsl_block *blo
 }
 
 static void sm1_generate_vsir(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func,
-        uint64_t config_flags, struct vsir_program *program, struct vkd3d_shader_code *ctab)
+        uint64_t config_flags, struct vsir_program *program)
 {
     struct vkd3d_shader_version version = {0};
-    struct vkd3d_bytecode_buffer buffer = {0};
     struct hlsl_block block;
 
     version.major = ctx->profile->major_version;
     version.minor = ctx->profile->minor_version;
     version.type = ctx->profile->type;
-    if (!vsir_program_init(program, NULL, &version, 0, VSIR_CF_STRUCTURED, VSIR_NOT_NORMALISED))
+    if (!vsir_program_init(program, NULL, &version, 0, VSIR_CF_STRUCTURED, VSIR_NORMALISED_SM4))
     {
         ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
         return;
     }
 
-    write_sm1_uniforms(ctx, &buffer);
-    if (buffer.status)
-    {
-        vkd3d_free(buffer.data);
-        ctx->result = buffer.status;
-        return;
-    }
-    ctab->code = buffer.data;
-    ctab->size = buffer.size;
-
     generate_vsir_signature(ctx, program, entry_func);
 
     hlsl_block_init(&block);
@@ -7659,66 +8124,434 @@ static void sm1_generate_vsir(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl
     sm1_generate_vsir_block(ctx, &entry_func->body, program);
 }
 
-static void add_last_vsir_instr_to_block(struct hlsl_ctx *ctx, struct vsir_program *program, struct hlsl_block *block)
+D3DXPARAMETER_CLASS hlsl_sm1_class(const struct hlsl_type *type)
 {
-    struct vkd3d_shader_location *loc;
-    struct hlsl_ir_node *vsir_instr;
-
-    loc = &program->instructions.elements[program->instructions.count - 1].location;
-
-    if (!(vsir_instr = hlsl_new_vsir_instruction_ref(ctx, program->instructions.count - 1, NULL, NULL, loc)))
+    switch (type->class)
     {
-        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
-        return;
+        case HLSL_CLASS_ARRAY:
+            return hlsl_sm1_class(type->e.array.type);
+        case HLSL_CLASS_MATRIX:
+            VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+            if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
+                return D3DXPC_MATRIX_COLUMNS;
+            else
+                return D3DXPC_MATRIX_ROWS;
+        case HLSL_CLASS_SCALAR:
+            return D3DXPC_SCALAR;
+        case HLSL_CLASS_STRUCT:
+            return D3DXPC_STRUCT;
+        case HLSL_CLASS_VECTOR:
+            return D3DXPC_VECTOR;
+        case HLSL_CLASS_PIXEL_SHADER:
+        case HLSL_CLASS_SAMPLER:
+        case HLSL_CLASS_STRING:
+        case HLSL_CLASS_TEXTURE:
+        case HLSL_CLASS_VERTEX_SHADER:
+            return D3DXPC_OBJECT;
+        case HLSL_CLASS_DEPTH_STENCIL_STATE:
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_ERROR:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RASTERIZER_STATE:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+        case HLSL_CLASS_TECHNIQUE:
+        case HLSL_CLASS_UAV:
+        case HLSL_CLASS_VOID:
+        case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
+        case HLSL_CLASS_BLEND_STATE:
+        case HLSL_CLASS_STREAM_OUTPUT:
+        case HLSL_CLASS_NULL:
+            break;
     }
-    hlsl_block_add_instr(block, vsir_instr);
+
+    vkd3d_unreachable();
 }
 
-static void replace_instr_with_last_vsir_instr(struct hlsl_ctx *ctx,
-        struct vsir_program *program, struct hlsl_ir_node *instr)
+D3DXPARAMETER_TYPE hlsl_sm1_base_type(const struct hlsl_type *type, bool is_combined_sampler)
 {
-    struct vkd3d_shader_location *loc;
-    struct hlsl_ir_node *vsir_instr;
+    enum hlsl_type_class class = type->class;
 
-    loc = &program->instructions.elements[program->instructions.count - 1].location;
+    if (is_combined_sampler)
+        class = HLSL_CLASS_TEXTURE;
 
-    if (!(vsir_instr = hlsl_new_vsir_instruction_ref(ctx,
-            program->instructions.count - 1, instr->data_type, &instr->reg, loc)))
+    switch (class)
     {
-        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
-        return;
-    }
+        case HLSL_CLASS_SCALAR:
+        case HLSL_CLASS_VECTOR:
+        case HLSL_CLASS_MATRIX:
+            switch (type->e.numeric.type)
+            {
+                case HLSL_TYPE_BOOL:
+                    return D3DXPT_BOOL;
+                /* Actually double behaves differently depending on DLL version:
+                 * For <= 36, it maps to D3DXPT_FLOAT.
+                 * For 37-40, it maps to zero (D3DXPT_VOID).
+                 * For >= 41, it maps to 39, which is D3D_SVT_DOUBLE (note D3D_SVT_*
+                 * values are mostly compatible with D3DXPT_*).
+                 * However, the latter two cases look like bugs, and a reasonable
+                 * application certainly wouldn't know what to do with them.
+                 * For fx_2_0 it's always D3DXPT_FLOAT regardless of DLL version. */
+                case HLSL_TYPE_DOUBLE:
+                case HLSL_TYPE_FLOAT:
+                case HLSL_TYPE_HALF:
+                    return D3DXPT_FLOAT;
+                case HLSL_TYPE_INT:
+                case HLSL_TYPE_UINT:
+                    return D3DXPT_INT;
+            }
+            break;
 
-    list_add_before(&instr->entry, &vsir_instr->entry);
-    hlsl_replace_node(instr, vsir_instr);
-}
+        case HLSL_CLASS_SAMPLER:
+            switch (type->sampler_dim)
+            {
+                case HLSL_SAMPLER_DIM_1D:
+                    return D3DXPT_SAMPLER1D;
+                case HLSL_SAMPLER_DIM_2D:
+                    return D3DXPT_SAMPLER2D;
+                case HLSL_SAMPLER_DIM_3D:
+                    return D3DXPT_SAMPLER3D;
+                case HLSL_SAMPLER_DIM_CUBE:
+                    return D3DXPT_SAMPLERCUBE;
+                case HLSL_SAMPLER_DIM_GENERIC:
+                    return D3DXPT_SAMPLER;
+                default:
+                    ERR("Invalid dimension %#x.\n", type->sampler_dim);
+                    vkd3d_unreachable();
+            }
+            break;
 
-static void sm4_generate_vsir_instr_dcl_semantic(struct hlsl_ctx *ctx, struct vsir_program *program,
-        const struct hlsl_ir_var *var, bool is_patch_constant_func, struct hlsl_block *block,
-        const struct vkd3d_shader_location *loc)
-{
-    const struct vkd3d_shader_version *version = &program->shader_version;
-    const bool output = var->is_output_semantic;
-    enum vkd3d_shader_sysval_semantic semantic;
-    struct vkd3d_shader_dst_param *dst_param;
-    struct vkd3d_shader_instruction *ins;
-    enum vkd3d_shader_register_type type;
-    enum vkd3d_shader_opcode opcode;
-    unsigned int idx = 0;
-    uint32_t write_mask;
-    bool has_idx;
+        case HLSL_CLASS_TEXTURE:
+            switch (type->sampler_dim)
+            {
+                case HLSL_SAMPLER_DIM_1D:
+                    return D3DXPT_TEXTURE1D;
+                case HLSL_SAMPLER_DIM_2D:
+                    return D3DXPT_TEXTURE2D;
+                case HLSL_SAMPLER_DIM_3D:
+                    return D3DXPT_TEXTURE3D;
+                case HLSL_SAMPLER_DIM_CUBE:
+                    return D3DXPT_TEXTURECUBE;
+                case HLSL_SAMPLER_DIM_GENERIC:
+                    return D3DXPT_TEXTURE;
+                default:
+                    ERR("Invalid dimension %#x.\n", type->sampler_dim);
+                    vkd3d_unreachable();
+            }
+            break;
 
-    sm4_sysval_semantic_from_semantic_name(&semantic, version, ctx->semantic_compat_mapping,
-            ctx->domain, var->semantic.name, var->semantic.index, output, is_patch_constant_func);
-    if (semantic == ~0u)
-        semantic = VKD3D_SHADER_SV_NONE;
+        case HLSL_CLASS_ARRAY:
+            return hlsl_sm1_base_type(type->e.array.type, is_combined_sampler);
 
-    if (var->is_input_semantic)
-    {
-        switch (semantic)
-        {
-            case VKD3D_SHADER_SV_NONE:
-                opcode = (version->type == VKD3D_SHADER_TYPE_PIXEL)
+        case HLSL_CLASS_STRUCT:
+            return D3DXPT_VOID;
+
+        case HLSL_CLASS_STRING:
+            return D3DXPT_STRING;
+
+        case HLSL_CLASS_PIXEL_SHADER:
+            return D3DXPT_PIXELSHADER;
+
+        case HLSL_CLASS_VERTEX_SHADER:
+            return D3DXPT_VERTEXSHADER;
+
+        case HLSL_CLASS_DEPTH_STENCIL_STATE:
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_ERROR:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_RASTERIZER_STATE:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+        case HLSL_CLASS_TECHNIQUE:
+        case HLSL_CLASS_UAV:
+        case HLSL_CLASS_VOID:
+        case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
+        case HLSL_CLASS_BLEND_STATE:
+        case HLSL_CLASS_STREAM_OUTPUT:
+        case HLSL_CLASS_NULL:
+            break;
+    }
+
+    vkd3d_unreachable();
+}
+
+static void write_sm1_type(struct vkd3d_bytecode_buffer *buffer,
+        struct hlsl_type *type, bool is_combined_sampler, unsigned int ctab_start)
+{
+    const struct hlsl_type *array_type = hlsl_get_multiarray_element_type(type);
+    unsigned int array_size = hlsl_get_multiarray_size(type);
+    struct hlsl_struct_field *field;
+    size_t i;
+
+    if (type->bytecode_offset)
+        return;
+
+    if (array_type->class == HLSL_CLASS_STRUCT)
+    {
+        unsigned int field_count = array_type->e.record.field_count;
+        size_t fields_offset;
+
+        for (i = 0; i < field_count; ++i)
+        {
+            field = &array_type->e.record.fields[i];
+            field->name_bytecode_offset = put_string(buffer, field->name);
+            write_sm1_type(buffer, field->type, false, ctab_start);
+        }
+
+        fields_offset = bytecode_align(buffer) - ctab_start;
+
+        for (i = 0; i < field_count; ++i)
+        {
+            field = &array_type->e.record.fields[i];
+            put_u32(buffer, field->name_bytecode_offset - ctab_start);
+            put_u32(buffer, field->type->bytecode_offset - ctab_start);
+        }
+
+        type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(D3DXPC_STRUCT, D3DXPT_VOID));
+        put_u32(buffer, vkd3d_make_u32(1, hlsl_type_component_count(array_type)));
+        put_u32(buffer, vkd3d_make_u32(array_size, field_count));
+        put_u32(buffer, fields_offset);
+    }
+    else
+    {
+        type->bytecode_offset = put_u32(buffer,
+                vkd3d_make_u32(hlsl_sm1_class(type), hlsl_sm1_base_type(array_type, is_combined_sampler)));
+        if (hlsl_is_numeric_type(array_type))
+            put_u32(buffer, vkd3d_make_u32(array_type->e.numeric.dimy, array_type->e.numeric.dimx));
+        else
+            put_u32(buffer, vkd3d_make_u32(1, 1));
+        put_u32(buffer, vkd3d_make_u32(array_size, 0));
+        put_u32(buffer, 1);
+    }
+}
+
+static void sm1_sort_extern(struct list *sorted, struct hlsl_ir_var *to_sort)
+{
+    struct hlsl_ir_var *var;
+
+    list_remove(&to_sort->extern_entry);
+
+    LIST_FOR_EACH_ENTRY(var, sorted, struct hlsl_ir_var, extern_entry)
+    {
+        if (strcmp(to_sort->name, var->name) < 0)
+        {
+            list_add_before(&var->extern_entry, &to_sort->extern_entry);
+            return;
+        }
+    }
+
+    list_add_tail(sorted, &to_sort->extern_entry);
+}
+
+static void sm1_sort_externs(struct hlsl_ctx *ctx)
+{
+    struct list sorted = LIST_INIT(sorted);
+    struct hlsl_ir_var *var, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(var, next, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        if (var->is_uniform)
+            sm1_sort_extern(&sorted, var);
+    }
+    list_move_tail(&ctx->extern_vars, &sorted);
+}
+
+static void write_sm1_uniforms(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer)
+{
+    size_t ctab_start, vars_offset, vars_start, creator_offset, offset;
+    unsigned int uniform_count = 0, r;
+    struct hlsl_ir_var *var;
+
+    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
+        {
+            if (var->semantic.name || !var->regs[r].allocated || !var->last_read)
+                continue;
+
+            ++uniform_count;
+
+            if (var->is_param && var->is_uniform)
+            {
+                char *new_name;
+
+                if (!(new_name = hlsl_sprintf_alloc(ctx, "$%s", var->name)))
+                    return;
+                vkd3d_free((char *)var->name);
+                var->name = new_name;
+            }
+        }
+    }
+
+    sm1_sort_externs(ctx);
+
+    ctab_start = put_u32(buffer, 7 * sizeof(uint32_t)); /* CTAB header size. */
+    creator_offset = put_u32(buffer, 0);
+    if (ctx->profile->type == VKD3D_SHADER_TYPE_VERTEX)
+        put_u32(buffer, D3DVS_VERSION(ctx->profile->major_version, ctx->profile->minor_version));
+    else
+        put_u32(buffer, D3DPS_VERSION(ctx->profile->major_version, ctx->profile->minor_version));
+    put_u32(buffer, uniform_count);
+    vars_offset = put_u32(buffer, 0);
+    put_u32(buffer, 0); /* FIXME: flags */
+    put_u32(buffer, 0); /* FIXME: target string */
+
+    vars_start = bytecode_align(buffer);
+    set_u32(buffer, vars_offset, vars_start - ctab_start);
+
+    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
+        {
+            if (var->semantic.name || !var->regs[r].allocated || !var->last_read)
+                continue;
+
+            put_u32(buffer, 0); /* name */
+            if (r == HLSL_REGSET_NUMERIC)
+            {
+                put_u32(buffer, vkd3d_make_u32(D3DXRS_FLOAT4, var->regs[r].id));
+                put_u32(buffer, var->bind_count[r]);
+            }
+            else
+            {
+                put_u32(buffer, vkd3d_make_u32(D3DXRS_SAMPLER, var->regs[r].index));
+                put_u32(buffer, var->bind_count[r]);
+            }
+            put_u32(buffer, 0); /* type */
+            put_u32(buffer, 0); /* default value */
+        }
+    }
+
+    uniform_count = 0;
+
+    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        for (r = 0; r <= HLSL_REGSET_LAST; ++r)
+        {
+            size_t var_offset, name_offset;
+
+            if (var->semantic.name || !var->regs[r].allocated || !var->last_read)
+                continue;
+
+            var_offset = vars_start + (uniform_count * 5 * sizeof(uint32_t));
+
+            name_offset = put_string(buffer, var->name);
+            set_u32(buffer, var_offset, name_offset - ctab_start);
+
+            write_sm1_type(buffer, var->data_type, var->is_combined_sampler, ctab_start);
+            set_u32(buffer, var_offset + 3 * sizeof(uint32_t), var->data_type->bytecode_offset - ctab_start);
+
+            if (var->default_values)
+            {
+                unsigned int reg_size = var->data_type->reg_size[HLSL_REGSET_NUMERIC];
+                unsigned int comp_count = hlsl_type_component_count(var->data_type);
+                unsigned int default_value_offset;
+                unsigned int k;
+
+                default_value_offset = bytecode_reserve_bytes(buffer, reg_size * sizeof(uint32_t));
+                set_u32(buffer, var_offset + 4 * sizeof(uint32_t), default_value_offset - ctab_start);
+
+                for (k = 0; k < comp_count; ++k)
+                {
+                    struct hlsl_type *comp_type = hlsl_type_get_component_type(ctx, var->data_type, k);
+                    unsigned int comp_offset;
+                    enum hlsl_regset regset;
+
+                    comp_offset = hlsl_type_get_component_offset(ctx, var->data_type, k, &regset);
+                    if (regset == HLSL_REGSET_NUMERIC)
+                    {
+                        union
+                        {
+                            uint32_t u;
+                            float f;
+                        } uni = {0};
+
+                        switch (comp_type->e.numeric.type)
+                        {
+                            case HLSL_TYPE_DOUBLE:
+                                if (ctx->double_as_float_alias)
+                                    uni.u = var->default_values[k].number.u;
+                                else
+                                    uni.u = 0;
+                                break;
+
+                            case HLSL_TYPE_INT:
+                                uni.f = var->default_values[k].number.i;
+                                break;
+
+                            case HLSL_TYPE_UINT:
+                            case HLSL_TYPE_BOOL:
+                                uni.f = var->default_values[k].number.u;
+                                break;
+
+                            case HLSL_TYPE_HALF:
+                            case HLSL_TYPE_FLOAT:
+                                uni.u = var->default_values[k].number.u;
+                                break;
+                        }
+
+                        set_u32(buffer, default_value_offset + comp_offset * sizeof(uint32_t), uni.u);
+                    }
+                }
+            }
+
+            ++uniform_count;
+        }
+    }
+
+    offset = put_string(buffer, vkd3d_shader_get_version(NULL, NULL));
+    set_u32(buffer, creator_offset, offset - ctab_start);
+}
+
+static void sm1_generate_ctab(struct hlsl_ctx *ctx, struct vkd3d_shader_code *ctab)
+{
+    struct vkd3d_bytecode_buffer buffer = {0};
+
+    write_sm1_uniforms(ctx, &buffer);
+    if (buffer.status)
+    {
+        vkd3d_free(buffer.data);
+        ctx->result = buffer.status;
+        return;
+    }
+    ctab->code = buffer.data;
+    ctab->size = buffer.size;
+}
+
+static void sm4_generate_vsir_instr_dcl_semantic(struct hlsl_ctx *ctx, struct vsir_program *program,
+        const struct hlsl_ir_var *var, bool is_patch_constant_func, struct hlsl_block *block,
+        const struct vkd3d_shader_location *loc)
+{
+    const struct vkd3d_shader_version *version = &program->shader_version;
+    const bool output = var->is_output_semantic;
+    enum vkd3d_shader_sysval_semantic semantic;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct vkd3d_shader_instruction *ins;
+    enum vkd3d_shader_register_type type;
+    enum vkd3d_shader_opcode opcode;
+    unsigned int idx = 0;
+    uint32_t write_mask;
+    bool has_idx;
+
+    sm4_sysval_semantic_from_semantic_name(&semantic, version, ctx->semantic_compat_mapping,
+            ctx->domain, var->semantic.name, var->semantic.index, output, is_patch_constant_func);
+    if (semantic == ~0u)
+        semantic = VKD3D_SHADER_SV_NONE;
+
+    if (var->is_input_semantic)
+    {
+        switch (semantic)
+        {
+            case VKD3D_SHADER_SV_NONE:
+                opcode = (version->type == VKD3D_SHADER_TYPE_PIXEL)
                         ? VKD3DSIH_DCL_INPUT_PS : VKD3DSIH_DCL_INPUT;
                 break;
 
@@ -7749,7 +8582,7 @@ static void sm4_generate_vsir_instr_dcl_semantic(struct hlsl_ctx *ctx, struct vs
     {
         if (has_idx)
             idx = var->semantic.index;
-        write_mask = (1u << var->data_type->dimx) - 1;
+        write_mask = (1u << var->data_type->e.numeric.dimx) - 1;
     }
     else
     {
@@ -7806,8 +8639,6 @@ static void sm4_generate_vsir_instr_dcl_semantic(struct hlsl_ctx *ctx, struct vs
 
     if (var->is_input_semantic && version->type == VKD3D_SHADER_TYPE_PIXEL)
         ins->flags = sm4_get_interpolation_mode(var->data_type, var->storage_modifiers);
-
-    add_last_vsir_instr_to_block(ctx, program, block);
 }
 
 static void sm4_generate_vsir_instr_dcl_temps(struct hlsl_ctx *ctx, struct vsir_program *program,
@@ -7819,8 +8650,6 @@ static void sm4_generate_vsir_instr_dcl_temps(struct hlsl_ctx *ctx, struct vsir_
         return;
 
     ins->declaration.count = temp_count;
-
-    add_last_vsir_instr_to_block(ctx, program, block);
 }
 
 static void sm4_generate_vsir_instr_dcl_indexable_temp(struct hlsl_ctx *ctx,
@@ -7838,8 +8667,6 @@ static void sm4_generate_vsir_instr_dcl_indexable_temp(struct hlsl_ctx *ctx,
     ins->declaration.indexable_temp.data_type = VKD3D_DATA_FLOAT;
     ins->declaration.indexable_temp.component_count = comp_count;
     ins->declaration.indexable_temp.has_function_scope = false;
-
-    add_last_vsir_instr_to_block(ctx, program, block);
 }
 
 static bool type_is_float(const struct hlsl_type *type)
@@ -7891,7 +8718,7 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
     } one = { .f = 1.0 };
 
     /* Narrowing casts were already lowered. */
-    VKD3D_ASSERT(src_type->dimx == dst_type->dimx);
+    VKD3D_ASSERT(src_type->e.numeric.dimx == dst_type->e.numeric.dimx);
 
     switch (dst_type->e.numeric.type)
     {
@@ -7919,9 +8746,6 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                 case HLSL_TYPE_DOUBLE:
                     hlsl_fixme(ctx, &expr->node.loc, "SM4 cast from double to float.");
                     return false;
-
-                default:
-                    vkd3d_unreachable();
             }
             break;
 
@@ -7945,9 +8769,6 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                 case HLSL_TYPE_DOUBLE:
                     hlsl_fixme(ctx, &expr->node.loc, "SM4 cast from double to int.");
                     return false;
-
-                default:
-                    vkd3d_unreachable();
             }
             break;
 
@@ -7971,9 +8792,6 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
                 case HLSL_TYPE_DOUBLE:
                     hlsl_fixme(ctx, &expr->node.loc, "SM4 cast from double to uint.");
                     return false;
-
-                default:
-                    vkd3d_unreachable();
             }
             break;
 
@@ -7983,9 +8801,10 @@ static bool sm4_generate_vsir_instr_expr_cast(struct hlsl_ctx *ctx,
 
         case HLSL_TYPE_BOOL:
             /* Casts to bool should have already been lowered. */
-        default:
-            vkd3d_unreachable();
+            break;
     }
+
+    vkd3d_unreachable();
 }
 
 static void sm4_generate_vsir_expr_with_two_destinations(struct hlsl_ctx *ctx, struct vsir_program *program,
@@ -8040,7 +8859,7 @@ static void sm4_generate_vsir_rcp_using_div(struct hlsl_ctx *ctx,
     value.u[2].f = 1.0f;
     value.u[3].f = 1.0f;
     vsir_src_from_hlsl_constant_value(&ins->src[0], ctx, &value,
-            VKD3D_DATA_FLOAT, instr->data_type->dimx, dst_param->write_mask);
+            VKD3D_DATA_FLOAT, instr->data_type->e.numeric.dimx, dst_param->write_mask);
 
     vsir_src_from_hlsl_node(&ins->src[1], ctx, operand, dst_param->write_mask);
 }
@@ -8270,7 +9089,7 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
             switch (dst_type->e.numeric.type)
             {
                 case HLSL_TYPE_FLOAT:
-                    switch (expr->operands[0].node->data_type->dimx)
+                    switch (expr->operands[0].node->data_type->e.numeric.dimx)
                     {
                         case 4:
                             generate_vsir_instr_expr_single_instr_op(ctx, program, expr, VKD3DSIH_DP4, 0, 0, false);
@@ -8505,188 +9324,1963 @@ static bool sm4_generate_vsir_instr_expr(struct hlsl_ctx *ctx,
     }
 }
 
-static void sm4_generate_vsir_block(struct hlsl_ctx *ctx, struct hlsl_block *block, struct vsir_program *program)
+static bool sm4_generate_vsir_instr_store(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_store *store)
 {
-    struct vkd3d_string_buffer *dst_type_string;
-    struct hlsl_ir_node *instr, *next;
-    struct hlsl_ir_switch_case *c;
+    struct hlsl_ir_node *instr = &store->node;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_instruction *ins;
 
-    LIST_FOR_EACH_ENTRY_SAFE(instr, next, &block->instrs, struct hlsl_ir_node, entry)
-    {
-        if (instr->data_type)
-        {
-            if (instr->data_type->class != HLSL_CLASS_SCALAR && instr->data_type->class != HLSL_CLASS_VECTOR)
-            {
-                hlsl_fixme(ctx, &instr->loc, "Class %#x should have been lowered or removed.", instr->data_type->class);
-                break;
-            }
-        }
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_MOV, 1, 1)))
+        return false;
 
-        switch (instr->type)
-        {
-            case HLSL_IR_CALL:
-                vkd3d_unreachable();
+    dst_param = &ins->dst[0];
+    if (!sm4_generate_vsir_init_dst_param_from_deref(ctx, program,
+            dst_param, &store->lhs, &instr->loc, store->writemask))
+        return false;
 
-            case HLSL_IR_CONSTANT:
-                /* In SM4 all constants are inlined. */
-                break;
+    src_param = &ins->src[0];
+    vsir_src_from_hlsl_node(src_param, ctx, store->rhs.node, dst_param->write_mask);
 
-            case HLSL_IR_EXPR:
-                if (!(dst_type_string = hlsl_type_to_string(ctx, instr->data_type)))
-                    break;
+    return true;
+}
 
-                if (sm4_generate_vsir_instr_expr(ctx, program, hlsl_ir_expr(instr), dst_type_string->buffer))
-                    replace_instr_with_last_vsir_instr(ctx, program, instr);
+/* Does this variable's data come directly from the API user, rather than
+ * being temporary or from a previous shader stage? I.e. is it a uniform or
+ * VS input? */
+static bool var_is_user_input(const struct vkd3d_shader_version *version, const struct hlsl_ir_var *var)
+{
+    if (var->is_uniform)
+        return true;
 
-                hlsl_release_string_buffer(ctx, dst_type_string);
-                break;
+    return var->is_input_semantic && version->type == VKD3D_SHADER_TYPE_VERTEX;
+}
 
-            case HLSL_IR_IF:
-                sm4_generate_vsir_block(ctx, &hlsl_ir_if(instr)->then_block, program);
-                sm4_generate_vsir_block(ctx, &hlsl_ir_if(instr)->else_block, program);
-                break;
+static bool sm4_generate_vsir_instr_load(struct hlsl_ctx *ctx, struct vsir_program *program, struct hlsl_ir_load *load)
+{
+    const struct vkd3d_shader_version *version = &program->shader_version;
+    const struct hlsl_type *type = load->node.data_type;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct hlsl_ir_node *instr = &load->node;
+    struct vkd3d_shader_instruction *ins;
+    struct hlsl_constant_value value;
 
-            case HLSL_IR_LOOP:
-                sm4_generate_vsir_block(ctx, &hlsl_ir_loop(instr)->body, program);
-                break;
+    VKD3D_ASSERT(hlsl_is_numeric_type(type));
+    if (type->e.numeric.type == HLSL_TYPE_BOOL && var_is_user_input(version, load->src.var))
+    {
+        /* Uniform bools can be specified as anything, but internal bools
+         * always have 0 for false and ~0 for true. Normalise that here. */
 
-            case HLSL_IR_SWITCH:
-                LIST_FOR_EACH_ENTRY(c, &hlsl_ir_switch(instr)->cases, struct hlsl_ir_switch_case, entry)
-                    sm4_generate_vsir_block(ctx, &c->body, program);
-                break;
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_MOVC, 1, 3)))
+            return false;
 
-            case HLSL_IR_SWIZZLE:
-                generate_vsir_instr_swizzle(ctx, program, hlsl_ir_swizzle(instr));
-                replace_instr_with_last_vsir_instr(ctx, program, instr);
-                break;
+        dst_param = &ins->dst[0];
+        vsir_dst_from_hlsl_node(dst_param, ctx, instr);
 
-            default:
-                break;
-        }
+        if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+                &ins->src[0], &load->src, dst_param->write_mask, &instr->loc))
+            return false;
+
+        memset(&value, 0xff, sizeof(value));
+        vsir_src_from_hlsl_constant_value(&ins->src[1], ctx, &value,
+                VKD3D_DATA_UINT, type->e.numeric.dimx, dst_param->write_mask);
+        memset(&value, 0x00, sizeof(value));
+        vsir_src_from_hlsl_constant_value(&ins->src[2], ctx, &value,
+                VKD3D_DATA_UINT, type->e.numeric.dimx, dst_param->write_mask);
+    }
+    else
+    {
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_MOV, 1, 1)))
+            return false;
+
+        dst_param = &ins->dst[0];
+        vsir_dst_from_hlsl_node(dst_param, ctx, instr);
+
+        if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+                &ins->src[0], &load->src, dst_param->write_mask, &instr->loc))
+            return false;
+    }
+    return true;
+}
+
+static bool sm4_generate_vsir_instr_resource_store(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_resource_store *store)
+{
+    struct hlsl_type *resource_type = hlsl_deref_get_type(ctx, &store->resource);
+    struct hlsl_ir_node *coords = store->coords.node, *value = store->value.node;
+    struct hlsl_ir_node *instr = &store->node;
+    struct vkd3d_shader_instruction *ins;
+    unsigned int writemask;
+
+    if (!store->resource.var->is_uniform)
+    {
+        hlsl_fixme(ctx, &store->node.loc, "Store to non-uniform resource variable.");
+        return false;
+    }
+
+    if (resource_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
+    {
+        hlsl_fixme(ctx, &store->node.loc, "Structured buffers store is not implemented.");
+        return false;
+    }
+
+    if (resource_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
+    {
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_STORE_RAW, 1, 2)))
+            return false;
+
+        writemask = vkd3d_write_mask_from_component_count(value->data_type->e.numeric.dimx);
+        if (!sm4_generate_vsir_init_dst_param_from_deref(ctx, program,
+                &ins->dst[0], &store->resource, &instr->loc, writemask))
+            return false;
+    }
+    else
+    {
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_STORE_UAV_TYPED, 1, 2)))
+            return false;
+
+        if (!sm4_generate_vsir_init_dst_param_from_deref(ctx, program,
+                &ins->dst[0], &store->resource, &instr->loc, VKD3DSP_WRITEMASK_ALL))
+            return false;
+    }
+
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, coords, VKD3DSP_WRITEMASK_ALL);
+    vsir_src_from_hlsl_node(&ins->src[1], ctx, value, VKD3DSP_WRITEMASK_ALL);
+
+    return true;
+}
+
+static bool sm4_generate_vsir_validate_texel_offset_aoffimmi(const struct hlsl_ir_node *texel_offset)
+{
+    struct hlsl_ir_constant *offset;
+
+    VKD3D_ASSERT(texel_offset);
+    if (texel_offset->type != HLSL_IR_CONSTANT)
+        return false;
+    offset = hlsl_ir_constant(texel_offset);
+
+    if (offset->value.u[0].i < -8 || offset->value.u[0].i > 7)
+        return false;
+    if (offset->node.data_type->e.numeric.dimx > 1 && (offset->value.u[1].i < -8 || offset->value.u[1].i > 7))
+        return false;
+    if (offset->node.data_type->e.numeric.dimx > 2 && (offset->value.u[2].i < -8 || offset->value.u[2].i > 7))
+        return false;
+    return true;
+}
+
+static void sm4_generate_vsir_encode_texel_offset_as_aoffimmi(
+        struct vkd3d_shader_instruction *ins, const struct hlsl_ir_node *texel_offset)
+{
+    struct hlsl_ir_constant *offset;
+
+    if (!texel_offset)
+        return;
+    offset = hlsl_ir_constant(texel_offset);
+
+    ins->texel_offset.u = offset->value.u[0].i;
+    ins->texel_offset.v = 0;
+    ins->texel_offset.w = 0;
+    if (offset->node.data_type->e.numeric.dimx > 1)
+        ins->texel_offset.v = offset->value.u[1].i;
+    if (offset->node.data_type->e.numeric.dimx > 2)
+        ins->texel_offset.w = offset->value.u[2].i;
+}
+
+static bool sm4_generate_vsir_instr_ld(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_resource_load *load)
+{
+    const struct hlsl_type *resource_type = hlsl_deref_get_type(ctx, &load->resource);
+    bool uav = (hlsl_deref_get_regset(ctx, &load->resource) == HLSL_REGSET_UAVS);
+    const struct vkd3d_shader_version *version = &program->shader_version;
+    bool raw = resource_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER;
+    const struct hlsl_ir_node *sample_index = load->sample_index.node;
+    const struct hlsl_ir_node *texel_offset = load->texel_offset.node;
+    const struct hlsl_ir_node *coords = load->coords.node;
+    unsigned int coords_writemask = VKD3DSP_WRITEMASK_ALL;
+    const struct hlsl_deref *resource = &load->resource;
+    const struct hlsl_ir_node *instr = &load->node;
+    enum hlsl_sampler_dim dim = load->sampling_dim;
+    struct vkd3d_shader_instruction *ins;
+    enum vkd3d_shader_opcode opcode;
+    bool multisampled;
+
+    VKD3D_ASSERT(load->load_type == HLSL_RESOURCE_LOAD);
+
+    multisampled = resource_type->class == HLSL_CLASS_TEXTURE
+            && (resource_type->sampler_dim == HLSL_SAMPLER_DIM_2DMS
+            || resource_type->sampler_dim == HLSL_SAMPLER_DIM_2DMSARRAY);
+
+    if (uav)
+        opcode = VKD3DSIH_LD_UAV_TYPED;
+    else if (raw)
+        opcode = VKD3DSIH_LD_RAW;
+    else
+        opcode = multisampled ? VKD3DSIH_LD2DMS : VKD3DSIH_LD;
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, opcode, 1, 2 + multisampled)))
+        return false;
+
+    if (texel_offset && !sm4_generate_vsir_validate_texel_offset_aoffimmi(texel_offset))
+    {
+        hlsl_error(ctx, &texel_offset->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TEXEL_OFFSET,
+                "Offset must resolve to integer literal in the range -8 to 7.");
+        return false;
+    }
+    sm4_generate_vsir_encode_texel_offset_as_aoffimmi(ins, texel_offset);
+
+    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+
+    if (!uav)
+    {
+        /* Mipmap level is in the last component in the IR, but needs to be in
+         * the W component in the instruction. */
+        unsigned int dim_count = hlsl_sampler_dim_count(dim);
+
+        if (dim_count == 1)
+            coords_writemask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_3;
+        if (dim_count == 2)
+            coords_writemask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_1 | VKD3DSP_WRITEMASK_3;
+    }
+
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, coords, coords_writemask);
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+            &ins->src[1], resource, ins->dst[0].write_mask, &instr->loc))
+        return false;
+
+    if (multisampled)
+    {
+        if (sample_index->type == HLSL_IR_CONSTANT)
+            vsir_src_from_hlsl_constant_value(&ins->src[2], ctx,
+                    &hlsl_ir_constant(sample_index)->value, VKD3D_DATA_INT, 1, 0);
+        else if (version->major == 4 && version->minor == 0)
+            hlsl_error(ctx, &sample_index->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Expected literal sample index.");
+        else
+            vsir_src_from_hlsl_node(&ins->src[2], ctx, sample_index, VKD3DSP_WRITEMASK_ALL);
+    }
+    return true;
+}
+
+static bool sm4_generate_vsir_instr_sample(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_resource_load *load)
+{
+    const struct hlsl_ir_node *texel_offset = load->texel_offset.node;
+    const struct hlsl_ir_node *coords = load->coords.node;
+    const struct hlsl_deref *resource = &load->resource;
+    const struct hlsl_deref *sampler = &load->sampler;
+    const struct hlsl_ir_node *instr = &load->node;
+    struct vkd3d_shader_instruction *ins;
+    enum vkd3d_shader_opcode opcode;
+    unsigned int src_count;
+
+    switch (load->load_type)
+    {
+        case HLSL_RESOURCE_SAMPLE:
+            opcode = VKD3DSIH_SAMPLE;
+            src_count = 3;
+            break;
+
+        case HLSL_RESOURCE_SAMPLE_CMP:
+            opcode = VKD3DSIH_SAMPLE_C;
+            src_count = 4;
+            break;
+
+        case HLSL_RESOURCE_SAMPLE_CMP_LZ:
+            opcode = VKD3DSIH_SAMPLE_C_LZ;
+            src_count = 4;
+            break;
+
+        case HLSL_RESOURCE_SAMPLE_LOD:
+            opcode = VKD3DSIH_SAMPLE_LOD;
+            src_count = 4;
+            break;
+
+        case HLSL_RESOURCE_SAMPLE_LOD_BIAS:
+            opcode = VKD3DSIH_SAMPLE_B;
+            src_count = 4;
+            break;
+
+        case HLSL_RESOURCE_SAMPLE_GRAD:
+            opcode = VKD3DSIH_SAMPLE_GRAD;
+            src_count = 5;
+            break;
+
+        default:
+            vkd3d_unreachable();
+    }
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, opcode, 1, src_count)))
+        return false;
+
+    if (texel_offset && !sm4_generate_vsir_validate_texel_offset_aoffimmi(texel_offset))
+    {
+        hlsl_error(ctx, &texel_offset->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TEXEL_OFFSET,
+                "Offset must resolve to integer literal in the range -8 to 7.");
+        return false;
+    }
+    sm4_generate_vsir_encode_texel_offset_as_aoffimmi(ins, texel_offset);
+
+    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, coords, VKD3DSP_WRITEMASK_ALL);
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program, &ins->src[1],
+            resource, ins->dst[0].write_mask, &instr->loc))
+        return false;
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program, &ins->src[2],
+            sampler, VKD3DSP_WRITEMASK_ALL, &instr->loc))
+        return false;
+
+    if (opcode == VKD3DSIH_SAMPLE_LOD || opcode == VKD3DSIH_SAMPLE_B)
+    {
+        vsir_src_from_hlsl_node(&ins->src[3], ctx, load->lod.node, VKD3DSP_WRITEMASK_ALL);
+    }
+    else if (opcode == VKD3DSIH_SAMPLE_C || opcode == VKD3DSIH_SAMPLE_C_LZ)
+    {
+        vsir_src_from_hlsl_node(&ins->src[3], ctx, load->cmp.node, VKD3DSP_WRITEMASK_ALL);
+    }
+    else if (opcode == VKD3DSIH_SAMPLE_GRAD)
+    {
+        vsir_src_from_hlsl_node(&ins->src[3], ctx, load->ddx.node, VKD3DSP_WRITEMASK_ALL);
+        vsir_src_from_hlsl_node(&ins->src[4], ctx, load->ddy.node, VKD3DSP_WRITEMASK_ALL);
+    }
+    return true;
+}
+
+static bool sm4_generate_vsir_instr_gather(struct hlsl_ctx *ctx, struct vsir_program *program,
+        const struct hlsl_ir_resource_load *load, uint32_t swizzle, bool compare)
+{
+    const struct vkd3d_shader_version *version = &program->shader_version;
+    const struct hlsl_ir_node *texel_offset = load->texel_offset.node;
+    const struct hlsl_ir_node *coords = load->coords.node;
+    const struct hlsl_deref *resource = &load->resource;
+    enum vkd3d_shader_opcode opcode = VKD3DSIH_GATHER4;
+    const struct hlsl_deref *sampler = &load->sampler;
+    const struct hlsl_ir_node *instr = &load->node;
+    unsigned int src_count = 3, current_arg = 0;
+    struct vkd3d_shader_instruction *ins;
+
+    if (texel_offset && !sm4_generate_vsir_validate_texel_offset_aoffimmi(texel_offset))
+    {
+        if (!vkd3d_shader_ver_ge(version, 5, 0))
+        {
+            hlsl_error(ctx, &texel_offset->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TEXEL_OFFSET,
+                "Offset must resolve to integer literal in the range -8 to 7 for profiles < 5.");
+            return false;
+        }
+        opcode = VKD3DSIH_GATHER4_PO;
+        ++src_count;
+    }
+
+    if (compare)
+    {
+        opcode = opcode == VKD3DSIH_GATHER4 ? VKD3DSIH_GATHER4_C : VKD3DSIH_GATHER4_PO_C;
+        ++src_count;
+    }
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, opcode, 1, src_count)))
+        return false;
+
+    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+    vsir_src_from_hlsl_node(&ins->src[current_arg++], ctx, coords, VKD3DSP_WRITEMASK_ALL);
+
+    if (opcode == VKD3DSIH_GATHER4_PO || opcode == VKD3DSIH_GATHER4_PO_C)
+        vsir_src_from_hlsl_node(&ins->src[current_arg++], ctx, texel_offset, VKD3DSP_WRITEMASK_ALL);
+    else
+        sm4_generate_vsir_encode_texel_offset_as_aoffimmi(ins, texel_offset);
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+            &ins->src[current_arg++], resource, ins->dst[0].write_mask, &instr->loc))
+        return false;
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+            &ins->src[current_arg], sampler, VKD3DSP_WRITEMASK_ALL, &instr->loc))
+        return false;
+    ins->src[current_arg].reg.dimension = VSIR_DIMENSION_VEC4;
+    ins->src[current_arg].swizzle = swizzle;
+    current_arg++;
+
+    if (compare)
+        vsir_src_from_hlsl_node(&ins->src[current_arg++], ctx, load->cmp.node, VKD3DSP_WRITEMASK_0);
+
+    return true;
+}
+
+static bool sm4_generate_vsir_instr_sample_info(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_resource_load *load)
+{
+    const struct hlsl_deref *resource = &load->resource;
+    const struct hlsl_ir_node *instr = &load->node;
+    struct hlsl_type *type = instr->data_type;
+    struct vkd3d_shader_instruction *ins;
+
+    VKD3D_ASSERT(type->e.numeric.type == HLSL_TYPE_UINT || type->e.numeric.type == HLSL_TYPE_FLOAT);
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_SAMPLE_INFO, 1, 1)))
+        return false;
+
+    if (type->e.numeric.type == HLSL_TYPE_UINT)
+        ins->flags = VKD3DSI_SAMPLE_INFO_UINT;
+
+    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+            &ins->src[0], resource, ins->dst[0].write_mask, &instr->loc))
+        return false;
+
+    return true;
+}
+
+static bool sm4_generate_vsir_instr_resinfo(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_resource_load *load)
+{
+    const struct hlsl_deref *resource = &load->resource;
+    const struct hlsl_ir_node *instr = &load->node;
+    struct hlsl_type *type = instr->data_type;
+    struct vkd3d_shader_instruction *ins;
+
+    if (resource->data_type->sampler_dim == HLSL_SAMPLER_DIM_BUFFER
+            || resource->data_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
+    {
+        hlsl_fixme(ctx, &load->node.loc, "resinfo for buffers.");
+        return false;
+    }
+
+    VKD3D_ASSERT(type->e.numeric.type == HLSL_TYPE_UINT || type->e.numeric.type == HLSL_TYPE_FLOAT);
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_RESINFO, 1, 2)))
+        return false;
+
+    if (type->e.numeric.type == HLSL_TYPE_UINT)
+        ins->flags = VKD3DSI_RESINFO_UINT;
+
+    vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, load->lod.node, VKD3DSP_WRITEMASK_ALL);
+
+    if (!sm4_generate_vsir_init_src_param_from_deref(ctx, program,
+            &ins->src[1], resource, ins->dst[0].write_mask, &instr->loc))
+        return false;
+
+    return true;
+}
+
+static uint32_t get_gather_swizzle(enum hlsl_resource_load_type type)
+{
+    switch (type)
+    {
+        case HLSL_RESOURCE_GATHER_RED:
+        case HLSL_RESOURCE_GATHER_CMP_RED:
+            return VKD3D_SHADER_SWIZZLE(X, X, X, X);
+
+        case HLSL_RESOURCE_GATHER_GREEN:
+        case HLSL_RESOURCE_GATHER_CMP_GREEN:
+            return VKD3D_SHADER_SWIZZLE(Y, Y, Y, Y);
+
+        case HLSL_RESOURCE_GATHER_BLUE:
+        case HLSL_RESOURCE_GATHER_CMP_BLUE:
+            return VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z);
+
+        case HLSL_RESOURCE_GATHER_ALPHA:
+        case HLSL_RESOURCE_GATHER_CMP_ALPHA:
+            return VKD3D_SHADER_SWIZZLE(W, W, W, W);
+        default:
+            return 0;
+    }
+
+    return 0;
+}
+
+static bool sm4_generate_vsir_instr_resource_load(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_resource_load *load)
+{
+    if (load->sampler.var && !load->sampler.var->is_uniform)
+    {
+        hlsl_fixme(ctx, &load->node.loc, "Sample using non-uniform sampler variable.");
+        return false;
+    }
+
+    if (!load->resource.var->is_uniform)
+    {
+        hlsl_fixme(ctx, &load->node.loc, "Load from non-uniform resource variable.");
+        return false;
+    }
+
+    switch (load->load_type)
+    {
+        case HLSL_RESOURCE_LOAD:
+            return sm4_generate_vsir_instr_ld(ctx, program, load);
+
+        case HLSL_RESOURCE_SAMPLE:
+        case HLSL_RESOURCE_SAMPLE_CMP:
+        case HLSL_RESOURCE_SAMPLE_CMP_LZ:
+        case HLSL_RESOURCE_SAMPLE_LOD:
+        case HLSL_RESOURCE_SAMPLE_LOD_BIAS:
+        case HLSL_RESOURCE_SAMPLE_GRAD:
+            /* Combined sample expressions were lowered. */
+            VKD3D_ASSERT(load->sampler.var);
+            return sm4_generate_vsir_instr_sample(ctx, program, load);
+
+        case HLSL_RESOURCE_GATHER_RED:
+        case HLSL_RESOURCE_GATHER_GREEN:
+        case HLSL_RESOURCE_GATHER_BLUE:
+        case HLSL_RESOURCE_GATHER_ALPHA:
+            return sm4_generate_vsir_instr_gather(ctx, program, load, get_gather_swizzle(load->load_type), false);
+
+        case HLSL_RESOURCE_GATHER_CMP_RED:
+        case HLSL_RESOURCE_GATHER_CMP_GREEN:
+        case HLSL_RESOURCE_GATHER_CMP_BLUE:
+        case HLSL_RESOURCE_GATHER_CMP_ALPHA:
+            return sm4_generate_vsir_instr_gather(ctx, program, load, get_gather_swizzle(load->load_type), true);
+
+        case HLSL_RESOURCE_SAMPLE_INFO:
+            return sm4_generate_vsir_instr_sample_info(ctx, program, load);
+
+        case HLSL_RESOURCE_RESINFO:
+            return sm4_generate_vsir_instr_resinfo(ctx, program, load);
+
+        case HLSL_RESOURCE_SAMPLE_PROJ:
+            vkd3d_unreachable();
+
+        default:
+            return false;
+    }
+}
+
+static bool sm4_generate_vsir_instr_jump(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_jump *jump)
+{
+    const struct hlsl_ir_node *instr = &jump->node;
+    struct vkd3d_shader_instruction *ins;
+
+    switch (jump->type)
+    {
+        case HLSL_IR_JUMP_BREAK:
+            return generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_BREAK, 0, 0);
+
+        case HLSL_IR_JUMP_CONTINUE:
+            return generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_CONTINUE, 0, 0);
+
+        case HLSL_IR_JUMP_DISCARD_NZ:
+            if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_DISCARD, 0, 1)))
+                return false;
+            ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
+
+            vsir_src_from_hlsl_node(&ins->src[0], ctx, jump->condition.node, VKD3DSP_WRITEMASK_ALL);
+            return true;
+
+        case HLSL_IR_JUMP_RETURN:
+            vkd3d_unreachable();
+
+        default:
+            hlsl_fixme(ctx, &jump->node.loc, "Jump type %s.", hlsl_jump_type_to_string(jump->type));
+            return false;
+    }
+}
+
+static void sm4_generate_vsir_block(struct hlsl_ctx *ctx, struct hlsl_block *block, struct vsir_program *program);
+
+static void sm4_generate_vsir_instr_if(struct hlsl_ctx *ctx, struct vsir_program *program, struct hlsl_ir_if *iff)
+{
+    struct hlsl_ir_node *instr = &iff->node;
+    struct vkd3d_shader_instruction *ins;
+
+    VKD3D_ASSERT(iff->condition.node->data_type->e.numeric.dimx == 1);
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_IF, 0, 1)))
+        return;
+    ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
+
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, iff->condition.node, VKD3DSP_WRITEMASK_ALL);
+
+    sm4_generate_vsir_block(ctx, &iff->then_block, program);
+
+    if (!list_empty(&iff->else_block.instrs))
+    {
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_ELSE, 0, 0)))
+            return;
+        sm4_generate_vsir_block(ctx, &iff->else_block, program);
+    }
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_ENDIF, 0, 0)))
+        return;
+}
+
+static void sm4_generate_vsir_instr_loop(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_loop *loop)
+{
+    struct hlsl_ir_node *instr = &loop->node;
+    struct vkd3d_shader_instruction *ins;
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_LOOP, 0, 0)))
+        return;
+
+    sm4_generate_vsir_block(ctx, &loop->body, program);
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_ENDLOOP, 0, 0)))
+        return;
+}
+
+static void sm4_generate_vsir_instr_switch(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_switch *swi)
+{
+    const struct hlsl_ir_node *selector = swi->selector.node;
+    struct hlsl_ir_node *instr = &swi->node;
+    struct vkd3d_shader_instruction *ins;
+    struct hlsl_ir_switch_case *cas;
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_SWITCH, 0, 1)))
+        return;
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, selector, VKD3DSP_WRITEMASK_ALL);
+
+    LIST_FOR_EACH_ENTRY(cas, &swi->cases, struct hlsl_ir_switch_case, entry)
+    {
+        if (cas->is_default)
+        {
+            if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_DEFAULT, 0, 0)))
+                return;
+        }
+        else
+        {
+            struct hlsl_constant_value value = {.u[0].u = cas->value};
+
+            if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_CASE, 0, 1)))
+                return;
+            vsir_src_from_hlsl_constant_value(&ins->src[0], ctx, &value, VKD3D_DATA_UINT, 1, VKD3DSP_WRITEMASK_ALL);
+        }
+
+        sm4_generate_vsir_block(ctx, &cas->body, program);
+    }
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, VKD3DSIH_ENDSWITCH, 0, 0)))
+        return;
+}
+
+static void sm4_generate_vsir_block(struct hlsl_ctx *ctx, struct hlsl_block *block, struct vsir_program *program)
+{
+    struct vkd3d_string_buffer *dst_type_string;
+    struct hlsl_ir_node *instr, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(instr, next, &block->instrs, struct hlsl_ir_node, entry)
+    {
+        if (instr->data_type)
+        {
+            if (instr->data_type->class != HLSL_CLASS_SCALAR && instr->data_type->class != HLSL_CLASS_VECTOR)
+            {
+                hlsl_fixme(ctx, &instr->loc, "Class %#x should have been lowered or removed.", instr->data_type->class);
+                break;
+            }
+        }
+
+        switch (instr->type)
+        {
+            case HLSL_IR_CALL:
+                vkd3d_unreachable();
+
+            case HLSL_IR_CONSTANT:
+                /* In SM4 all constants are inlined. */
+                break;
+
+            case HLSL_IR_EXPR:
+                if (!(dst_type_string = hlsl_type_to_string(ctx, instr->data_type)))
+                    break;
+                sm4_generate_vsir_instr_expr(ctx, program, hlsl_ir_expr(instr), dst_type_string->buffer);
+                hlsl_release_string_buffer(ctx, dst_type_string);
+                break;
+
+            case HLSL_IR_IF:
+                sm4_generate_vsir_instr_if(ctx, program, hlsl_ir_if(instr));
+                break;
+
+            case HLSL_IR_LOAD:
+                sm4_generate_vsir_instr_load(ctx, program, hlsl_ir_load(instr));
+                break;
+
+            case HLSL_IR_LOOP:
+                sm4_generate_vsir_instr_loop(ctx, program, hlsl_ir_loop(instr));
+                break;
+
+            case HLSL_IR_RESOURCE_LOAD:
+                sm4_generate_vsir_instr_resource_load(ctx, program, hlsl_ir_resource_load(instr));
+                break;
+
+            case HLSL_IR_RESOURCE_STORE:
+                sm4_generate_vsir_instr_resource_store(ctx, program, hlsl_ir_resource_store(instr));
+                break;
+
+            case HLSL_IR_JUMP:
+                sm4_generate_vsir_instr_jump(ctx, program, hlsl_ir_jump(instr));
+                break;
+
+            case HLSL_IR_STORE:
+                sm4_generate_vsir_instr_store(ctx, program, hlsl_ir_store(instr));
+                break;
+
+            case HLSL_IR_SWITCH:
+                sm4_generate_vsir_instr_switch(ctx, program, hlsl_ir_switch(instr));
+                break;
+
+            case HLSL_IR_SWIZZLE:
+                generate_vsir_instr_swizzle(ctx, program, hlsl_ir_swizzle(instr));
+                break;
+
+            default:
+                break;
+        }
+    }
+}
+
+static void sm4_generate_vsir_add_function(struct hlsl_ctx *ctx,
+        struct hlsl_ir_function_decl *func, uint64_t config_flags, struct vsir_program *program)
+{
+    bool is_patch_constant_func = func == ctx->patch_constant_func;
+    struct hlsl_block block = {0};
+    struct hlsl_scope *scope;
+    struct hlsl_ir_var *var;
+    uint32_t temp_count;
+
+    compute_liveness(ctx, func);
+    mark_indexable_vars(ctx, func);
+    temp_count = allocate_temp_registers(ctx, func);
+    if (ctx->result)
+        return;
+    program->temp_count = max(program->temp_count, temp_count);
+
+    hlsl_block_init(&block);
+
+    LIST_FOR_EACH_ENTRY(var, &func->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        if ((var->is_input_semantic && var->last_read)
+                || (var->is_output_semantic && var->first_write))
+            sm4_generate_vsir_instr_dcl_semantic(ctx, program, var, is_patch_constant_func, &block, &var->loc);
+    }
+
+    if (temp_count)
+        sm4_generate_vsir_instr_dcl_temps(ctx, program, temp_count, &block, &func->loc);
+
+    LIST_FOR_EACH_ENTRY(scope, &ctx->scopes, struct hlsl_scope, entry)
+    {
+        LIST_FOR_EACH_ENTRY(var, &scope->vars, struct hlsl_ir_var, scope_entry)
+        {
+            if (var->is_uniform || var->is_input_semantic || var->is_output_semantic)
+                continue;
+            if (!var->regs[HLSL_REGSET_NUMERIC].allocated)
+                continue;
+
+            if (var->indexable)
+            {
+                unsigned int id = var->regs[HLSL_REGSET_NUMERIC].id;
+                unsigned int size = align(var->data_type->reg_size[HLSL_REGSET_NUMERIC], 4) / 4;
+
+                sm4_generate_vsir_instr_dcl_indexable_temp(ctx, program, &block, id, size, 4, &var->loc);
+            }
+        }
+    }
+
+    list_move_head(&func->body.instrs, &block.instrs);
+
+    hlsl_block_cleanup(&block);
+
+    sm4_generate_vsir_block(ctx, &func->body, program);
+
+    generate_vsir_add_program_instruction(ctx, program, &func->loc, VKD3DSIH_RET, 0, 0);
+}
+
+static int sm4_compare_extern_resources(const void *a, const void *b)
+{
+    const struct extern_resource *aa = a;
+    const struct extern_resource *bb = b;
+    int r;
+
+    if ((r = vkd3d_u32_compare(aa->regset, bb->regset)))
+        return r;
+
+    if ((r = vkd3d_u32_compare(aa->space, bb->space)))
+        return r;
+
+    return vkd3d_u32_compare(aa->index, bb->index);
+}
+
+static const char *string_skip_tag(const char *string)
+{
+    if (!strncmp(string, "<resource>", strlen("<resource>")))
+        return string + strlen("<resource>");
+    return string;
+}
+
+static void sm4_free_extern_resources(struct extern_resource *extern_resources, unsigned int count)
+{
+    unsigned int i;
+
+    for (i = 0; i < count; ++i)
+    {
+        vkd3d_free(extern_resources[i].name);
+    }
+    vkd3d_free(extern_resources);
+}
+
+static struct extern_resource *sm4_get_extern_resources(struct hlsl_ctx *ctx, unsigned int *count)
+{
+    bool separate_components = ctx->profile->major_version == 5 && ctx->profile->minor_version == 0;
+    struct extern_resource *extern_resources = NULL;
+    const struct hlsl_ir_var *var;
+    struct hlsl_buffer *buffer;
+    enum hlsl_regset regset;
+    size_t capacity = 0;
+    char *name;
+
+    *count = 0;
+
+    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+    {
+        if (separate_components)
+        {
+            unsigned int component_count = hlsl_type_component_count(var->data_type);
+            unsigned int k, regset_offset;
+
+            for (k = 0; k < component_count; ++k)
+            {
+                struct hlsl_type *component_type = hlsl_type_get_component_type(ctx, var->data_type, k);
+                struct vkd3d_string_buffer *name_buffer;
+
+                if (!hlsl_type_is_resource(component_type))
+                    continue;
+
+                regset_offset = hlsl_type_get_component_offset(ctx, var->data_type, k, &regset);
+                if (regset_offset > var->regs[regset].allocation_size)
+                    continue;
+
+                if (!var->objects_usage[regset][regset_offset].used)
+                    continue;
+
+                if (!(hlsl_array_reserve(ctx, (void **)&extern_resources,
+                        &capacity, *count + 1, sizeof(*extern_resources))))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    return NULL;
+                }
+
+                if (!(name_buffer = hlsl_component_to_string(ctx, var, k)))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    return NULL;
+                }
+                if (!(name = hlsl_strdup(ctx, string_skip_tag(name_buffer->buffer))))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    hlsl_release_string_buffer(ctx, name_buffer);
+                    return NULL;
+                }
+                hlsl_release_string_buffer(ctx, name_buffer);
+
+                extern_resources[*count].var = NULL;
+                extern_resources[*count].buffer = NULL;
+
+                extern_resources[*count].name = name;
+                extern_resources[*count].is_user_packed = !!var->reg_reservation.reg_type;
+
+                extern_resources[*count].component_type = component_type;
+
+                extern_resources[*count].regset = regset;
+                extern_resources[*count].id = var->regs[regset].id;
+                extern_resources[*count].space = var->regs[regset].space;
+                extern_resources[*count].index = var->regs[regset].index + regset_offset;
+                extern_resources[*count].bind_count = 1;
+                extern_resources[*count].loc = var->loc;
+
+                ++*count;
+            }
+        }
+        else
+        {
+            unsigned int r;
+
+            if (!hlsl_type_is_resource(var->data_type))
+                continue;
+
+            for (r = 0; r <= HLSL_REGSET_LAST; ++r)
+            {
+                if (!var->regs[r].allocated)
+                    continue;
+
+                if (!(hlsl_array_reserve(ctx, (void **)&extern_resources,
+                        &capacity, *count + 1, sizeof(*extern_resources))))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    return NULL;
+                }
+
+                if (!(name = hlsl_strdup(ctx, string_skip_tag(var->name))))
+                {
+                    sm4_free_extern_resources(extern_resources, *count);
+                    *count = 0;
+                    return NULL;
+                }
+
+                extern_resources[*count].var = var;
+                extern_resources[*count].buffer = NULL;
+
+                extern_resources[*count].name = name;
+                /* For some reason 5.1 resources aren't marked as
+                 * user-packed, but cbuffers still are. */
+                extern_resources[*count].is_user_packed = hlsl_version_lt(ctx, 5, 1)
+                        && !!var->reg_reservation.reg_type;
+
+                extern_resources[*count].component_type = hlsl_type_get_component_type(ctx, var->data_type, 0);
+
+                extern_resources[*count].regset = r;
+                extern_resources[*count].id = var->regs[r].id;
+                extern_resources[*count].space = var->regs[r].space;
+                extern_resources[*count].index = var->regs[r].index;
+                extern_resources[*count].bind_count = var->bind_count[r];
+                extern_resources[*count].loc = var->loc;
+
+                ++*count;
+            }
+        }
+    }
+
+    LIST_FOR_EACH_ENTRY(buffer, &ctx->buffers, struct hlsl_buffer, entry)
+    {
+        if (!buffer->reg.allocated)
+            continue;
+
+        if (!(hlsl_array_reserve(ctx, (void **)&extern_resources,
+                &capacity, *count + 1, sizeof(*extern_resources))))
+        {
+            sm4_free_extern_resources(extern_resources, *count);
+            *count = 0;
+            return NULL;
+        }
+
+        if (!(name = hlsl_strdup(ctx, buffer->name)))
+        {
+            sm4_free_extern_resources(extern_resources, *count);
+            *count = 0;
+            return NULL;
+        }
+
+        extern_resources[*count].var = NULL;
+        extern_resources[*count].buffer = buffer;
+
+        extern_resources[*count].name = name;
+        extern_resources[*count].is_user_packed = !!buffer->reservation.reg_type;
+
+        extern_resources[*count].component_type = NULL;
+
+        extern_resources[*count].regset = HLSL_REGSET_NUMERIC;
+        extern_resources[*count].id = buffer->reg.id;
+        extern_resources[*count].space = buffer->reg.space;
+        extern_resources[*count].index = buffer->reg.index;
+        extern_resources[*count].bind_count = 1;
+        extern_resources[*count].loc = buffer->loc;
+
+        ++*count;
+    }
+
+    if (extern_resources)
+        qsort(extern_resources, *count, sizeof(*extern_resources), sm4_compare_extern_resources);
+
+    return extern_resources;
+}
+
+static void generate_vsir_scan_required_features(struct hlsl_ctx *ctx, struct vsir_program *program)
+{
+    struct extern_resource *extern_resources;
+    unsigned int extern_resources_count;
+
+    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
+    for (unsigned int i = 0; i < extern_resources_count; ++i)
+    {
+        if (extern_resources[i].component_type && extern_resources[i].component_type->e.resource.rasteriser_ordered)
+            program->features.rovs = true;
+    }
+    sm4_free_extern_resources(extern_resources, extern_resources_count);
+
+    /* FIXME: We also emit code that should require UAVS_AT_EVERY_STAGE,
+     * STENCIL_REF, and TYPED_UAV_LOAD_ADDITIONAL_FORMATS. */
+}
+
+static void generate_vsir_scan_global_flags(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_ir_function_decl *entry_func)
+{
+    const struct vkd3d_shader_version *version = &program->shader_version;
+    struct extern_resource *extern_resources;
+    unsigned int extern_resources_count, i;
+
+    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
+
+    if (version->major == 4)
+    {
+        for (i = 0; i < extern_resources_count; ++i)
+        {
+            const struct extern_resource *resource = &extern_resources[i];
+            const struct hlsl_type *type = resource->component_type;
+
+            if (type && type->class == HLSL_CLASS_TEXTURE && type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
+            {
+                program->global_flags |= VKD3DSGF_ENABLE_RAW_AND_STRUCTURED_BUFFERS;
+                break;
+            }
+        }
+    }
+
+    sm4_free_extern_resources(extern_resources, extern_resources_count);
+
+    if (entry_func->early_depth_test && vkd3d_shader_ver_ge(version, 5, 0))
+        program->global_flags |= VKD3DSGF_FORCE_EARLY_DEPTH_STENCIL;
+}
+
+static void sm4_generate_vsir_add_dcl_constant_buffer(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct hlsl_buffer *cbuffer)
+{
+    unsigned int array_first = cbuffer->reg.index;
+    unsigned int array_last = cbuffer->reg.index; /* FIXME: array end. */
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_instruction *ins;
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &cbuffer->loc, VKD3DSIH_DCL_CONSTANT_BUFFER, 0, 0)))
+    {
+        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
+        return;
+    }
+
+    ins->declaration.cb.size = cbuffer->size;
+
+    src_param = &ins->declaration.cb.src;
+    vsir_src_param_init(src_param, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 0);
+    src_param->reg.dimension = VSIR_DIMENSION_VEC4;
+    src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
+
+    ins->declaration.cb.range.space = cbuffer->reg.space;
+    ins->declaration.cb.range.first = array_first;
+    ins->declaration.cb.range.last = array_last;
+
+    src_param->reg.idx[0].offset = cbuffer->reg.id;
+    src_param->reg.idx[1].offset = array_first;
+    src_param->reg.idx[2].offset = array_last;
+    src_param->reg.idx_count = 3;
+}
+
+static void sm4_generate_vsir_add_dcl_sampler(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct extern_resource *resource)
+{
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_instruction *ins;
+    unsigned int i;
+
+    VKD3D_ASSERT(resource->regset == HLSL_REGSET_SAMPLERS);
+    VKD3D_ASSERT(hlsl_version_lt(ctx, 5, 1) || resource->bind_count == 1);
+
+    for (i = 0; i < resource->bind_count; ++i)
+    {
+        unsigned int array_first = resource->index + i;
+        unsigned int array_last = resource->index + i; /* FIXME: array end. */
+
+        if (resource->var && !resource->var->objects_usage[HLSL_REGSET_SAMPLERS][i].used)
+            continue;
+
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &resource->loc, VKD3DSIH_DCL_SAMPLER, 0, 0)))
+        {
+            ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
+            return;
+        }
+
+        if (resource->component_type->sampler_dim == HLSL_SAMPLER_DIM_COMPARISON)
+            ins->flags |= VKD3DSI_SAMPLER_COMPARISON_MODE;
+
+        src_param = &ins->declaration.sampler.src;
+        vsir_src_param_init(src_param, VKD3DSPR_SAMPLER, VKD3D_DATA_UNUSED, 0);
+
+        ins->declaration.sampler.range.first = array_first;
+        ins->declaration.sampler.range.last = array_last;
+        ins->declaration.sampler.range.space = resource->space;
+
+        src_param->reg.idx[0].offset = resource->id;
+        src_param->reg.idx[1].offset = array_first;
+        src_param->reg.idx[2].offset = array_last;
+        src_param->reg.idx_count = 3;
+    }
+}
+
+static enum vkd3d_shader_resource_type sm4_generate_vsir_get_resource_type(const struct hlsl_type *type)
+{
+    switch (type->sampler_dim)
+    {
+        case HLSL_SAMPLER_DIM_1D:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_1D;
+        case HLSL_SAMPLER_DIM_2D:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_2D;
+        case HLSL_SAMPLER_DIM_3D:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_3D;
+        case HLSL_SAMPLER_DIM_CUBE:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_CUBE;
+        case HLSL_SAMPLER_DIM_1DARRAY:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_1DARRAY;
+        case HLSL_SAMPLER_DIM_2DARRAY:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_2DARRAY;
+        case HLSL_SAMPLER_DIM_2DMS:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_2DMS;
+        case HLSL_SAMPLER_DIM_2DMSARRAY:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_2DMSARRAY;
+        case HLSL_SAMPLER_DIM_CUBEARRAY:
+            return VKD3D_SHADER_RESOURCE_TEXTURE_CUBEARRAY;
+        case HLSL_SAMPLER_DIM_BUFFER:
+        case HLSL_SAMPLER_DIM_RAW_BUFFER:
+        case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
+            return VKD3D_SHADER_RESOURCE_BUFFER;
+        default:
+            vkd3d_unreachable();
+    }
+}
+
+static enum vkd3d_data_type sm4_generate_vsir_get_format_type(const struct hlsl_type *type)
+{
+    const struct hlsl_type *format = type->e.resource.format;
+
+    switch (format->e.numeric.type)
+    {
+        case HLSL_TYPE_DOUBLE:
+            return VKD3D_DATA_DOUBLE;
+
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+            if (format->modifiers & HLSL_MODIFIER_UNORM)
+                return VKD3D_DATA_UNORM;
+            if (format->modifiers & HLSL_MODIFIER_SNORM)
+                return VKD3D_DATA_SNORM;
+            return VKD3D_DATA_FLOAT;
+
+        case HLSL_TYPE_INT:
+            return VKD3D_DATA_INT;
+
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_UINT:
+            return VKD3D_DATA_UINT;
+    }
+
+    vkd3d_unreachable();
+}
+
+static void sm4_generate_vsir_add_dcl_texture(struct hlsl_ctx *ctx,
+        struct vsir_program *program, const struct extern_resource *resource,
+        bool uav)
+{
+    enum hlsl_regset regset = uav ? HLSL_REGSET_UAVS : HLSL_REGSET_TEXTURES;
+    struct vkd3d_shader_structured_resource *structured_resource;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct vkd3d_shader_semantic *semantic;
+    struct vkd3d_shader_instruction *ins;
+    struct hlsl_type *component_type;
+    enum vkd3d_shader_opcode opcode;
+    bool multisampled;
+    unsigned int i, j;
+
+    VKD3D_ASSERT(resource->regset == regset);
+    VKD3D_ASSERT(hlsl_version_lt(ctx, 5, 1) || resource->bind_count == 1);
+
+    component_type = resource->component_type;
+
+    for (i = 0; i < resource->bind_count; ++i)
+    {
+        unsigned int array_first = resource->index + i;
+        unsigned int array_last = resource->index + i; /* FIXME: array end. */
+
+        if (resource->var && !resource->var->objects_usage[regset][i].used)
+            continue;
+
+        if (uav)
+        {
+            switch (component_type->sampler_dim)
+            {
+                case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
+                    opcode = VKD3DSIH_DCL_UAV_STRUCTURED;
+                    break;
+                case HLSL_SAMPLER_DIM_RAW_BUFFER:
+                    opcode = VKD3DSIH_DCL_UAV_RAW;
+                    break;
+                default:
+                    opcode = VKD3DSIH_DCL_UAV_TYPED;
+                    break;
+            }
+        }
+        else
+        {
+            switch (component_type->sampler_dim)
+            {
+                case HLSL_SAMPLER_DIM_RAW_BUFFER:
+                    opcode = VKD3DSIH_DCL_RESOURCE_RAW;
+                    break;
+                default:
+                    opcode = VKD3DSIH_DCL;
+                    break;
+            }
+        }
+
+        if (!(ins = generate_vsir_add_program_instruction(ctx, program, &resource->loc, opcode, 0, 0)))
+        {
+            ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
+            return;
+        }
+        semantic = &ins->declaration.semantic;
+        structured_resource = &ins->declaration.structured_resource;
+        dst_param = &semantic->resource.reg;
+        vsir_dst_param_init(dst_param, uav ? VKD3DSPR_UAV : VKD3DSPR_RESOURCE, VKD3D_DATA_UNUSED, 0);
+
+        if (uav && component_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
+            structured_resource->byte_stride = 4 * component_type->e.resource.format->reg_size[HLSL_REGSET_NUMERIC];
+        if (uav && component_type->e.resource.rasteriser_ordered)
+            ins->flags = VKD3DSUF_RASTERISER_ORDERED_VIEW;
+
+        multisampled = component_type->sampler_dim == HLSL_SAMPLER_DIM_2DMS
+                || component_type->sampler_dim == HLSL_SAMPLER_DIM_2DMSARRAY;
+
+        if (!hlsl_version_ge(ctx, 4, 1) && multisampled && !component_type->sample_count)
+        {
+            hlsl_error(ctx, &resource->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "Multisampled texture object declaration needs sample count for profile %u.%u.",
+                    ctx->profile->major_version, ctx->profile->minor_version);
+        }
+
+        for (j = 0; j < 4; ++j)
+            semantic->resource_data_type[j] = sm4_generate_vsir_get_format_type(component_type);
+
+        semantic->resource.range.first = array_first;
+        semantic->resource.range.last = array_last;
+        semantic->resource.range.space = resource->space;
+
+        dst_param->reg.idx[0].offset = resource->id;
+        dst_param->reg.idx[1].offset = array_first;
+        dst_param->reg.idx[2].offset = array_last;
+        dst_param->reg.idx_count = 3;
+
+        ins->resource_type = sm4_generate_vsir_get_resource_type(resource->component_type);
+        if (resource->component_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
+            ins->raw = true;
+        if (resource->component_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
+        {
+            ins->structured = true;
+            ins->resource_stride = 4 * component_type->e.resource.format->reg_size[HLSL_REGSET_NUMERIC];
+        }
+
+        if (multisampled)
+            semantic->sample_count = component_type->sample_count;
     }
 }
 
-static void sm4_generate_vsir_add_function(struct hlsl_ctx *ctx,
-        struct hlsl_ir_function_decl *func, uint64_t config_flags, struct vsir_program *program)
+/* OBJECTIVE: Translate all the information from ctx and entry_func to the
+ * vsir_program, so it can be used as input to tpf_compile() without relying
+ * on ctx and entry_func. */
+static void sm4_generate_vsir(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func,
+        uint64_t config_flags, struct vsir_program *program)
 {
-    bool is_patch_constant_func = func == ctx->patch_constant_func;
-    struct hlsl_block block = {0};
-    struct hlsl_scope *scope;
-    struct hlsl_ir_var *var;
-    uint32_t temp_count;
+    struct vkd3d_shader_version version = {0};
+    struct extern_resource *extern_resources;
+    unsigned int extern_resources_count;
+    const struct hlsl_buffer *cbuffer;
 
-    compute_liveness(ctx, func);
-    mark_indexable_vars(ctx, func);
-    temp_count = allocate_temp_registers(ctx, func);
-    if (ctx->result)
+    version.major = ctx->profile->major_version;
+    version.minor = ctx->profile->minor_version;
+    version.type = ctx->profile->type;
+
+    if (!vsir_program_init(program, NULL, &version, 0, VSIR_CF_STRUCTURED, VSIR_NORMALISED_SM4))
+    {
+        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
         return;
-    program->temp_count = max(program->temp_count, temp_count);
+    }
+
+    generate_vsir_signature(ctx, program, func);
+    if (version.type == VKD3D_SHADER_TYPE_HULL)
+        generate_vsir_signature(ctx, program, ctx->patch_constant_func);
+
+    if (version.type == VKD3D_SHADER_TYPE_COMPUTE)
+    {
+        program->thread_group_size.x = ctx->thread_count[0];
+        program->thread_group_size.y = ctx->thread_count[1];
+        program->thread_group_size.z = ctx->thread_count[2];
+    }
+    else if (version.type == VKD3D_SHADER_TYPE_HULL)
+    {
+        program->input_control_point_count = 1; /* TODO: Obtain from InputPatch */
+        program->output_control_point_count = ctx->output_control_point_count;
+        program->tess_domain = ctx->domain;
+        program->tess_partitioning = ctx->partitioning;
+        program->tess_output_primitive = ctx->output_primitive;
+    }
+    else if (version.type == VKD3D_SHADER_TYPE_DOMAIN)
+    {
+        program->input_control_point_count = 0; /* TODO: Obtain from OutputPatch */
+        program->tess_domain = ctx->domain;
+    }
+
+    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
+    {
+        if (cbuffer->reg.allocated)
+            sm4_generate_vsir_add_dcl_constant_buffer(ctx, program, cbuffer);
+    }
+
+    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
+    for (unsigned int i = 0; i < extern_resources_count; ++i)
+    {
+        const struct extern_resource *resource = &extern_resources[i];
+
+        if (resource->regset == HLSL_REGSET_SAMPLERS)
+            sm4_generate_vsir_add_dcl_sampler(ctx, program, resource);
+        else if (resource->regset == HLSL_REGSET_TEXTURES)
+            sm4_generate_vsir_add_dcl_texture(ctx, program, resource, false);
+        else if (resource->regset == HLSL_REGSET_UAVS)
+            sm4_generate_vsir_add_dcl_texture(ctx, program, resource, true);
+    }
+    sm4_free_extern_resources(extern_resources, extern_resources_count);
+
+    if (version.type == VKD3D_SHADER_TYPE_HULL)
+        generate_vsir_add_program_instruction(ctx, program,
+                &ctx->patch_constant_func->loc, VKD3DSIH_HS_CONTROL_POINT_PHASE, 0, 0);
+    sm4_generate_vsir_add_function(ctx, func, config_flags, program);
+    if (version.type == VKD3D_SHADER_TYPE_HULL)
+    {
+        generate_vsir_add_program_instruction(ctx, program,
+                &ctx->patch_constant_func->loc, VKD3DSIH_HS_FORK_PHASE, 0, 0);
+        sm4_generate_vsir_add_function(ctx, ctx->patch_constant_func, config_flags, program);
+    }
+
+    generate_vsir_scan_required_features(ctx, program);
+    generate_vsir_scan_global_flags(ctx, program, func);
+}
+
+/* For some reason, for matrices, values from default value initializers end
+ * up in different components than from regular initializers. Default value
+ * initializers fill the matrix in vertical reading order
+ * (left-to-right top-to-bottom) instead of regular reading order
+ * (top-to-bottom left-to-right), so they have to be adjusted. An exception is
+ * that the order of matrix initializers for function parameters are row-major
+ * (top-to-bottom left-to-right). */
+static unsigned int get_component_index_from_default_initializer_index(struct hlsl_type *type, unsigned int index)
+{
+    unsigned int element_comp_count, element, x, y, i;
+    unsigned int base = 0;
+
+    switch (type->class)
+    {
+        case HLSL_CLASS_MATRIX:
+            x = index / type->e.numeric.dimy;
+            y = index % type->e.numeric.dimy;
+            return y * type->e.numeric.dimx + x;
+
+        case HLSL_CLASS_ARRAY:
+            element_comp_count = hlsl_type_component_count(type->e.array.type);
+            element = index / element_comp_count;
+            base = element * element_comp_count;
+            return base + get_component_index_from_default_initializer_index(type->e.array.type, index - base);
+
+        case HLSL_CLASS_STRUCT:
+            for (i = 0; i < type->e.record.field_count; ++i)
+            {
+                struct hlsl_type *field_type = type->e.record.fields[i].type;
+
+                element_comp_count = hlsl_type_component_count(field_type);
+                if (index - base < element_comp_count)
+                    return base + get_component_index_from_default_initializer_index(field_type, index - base);
+                base += element_comp_count;
+            }
+            break;
+
+        default:
+            return index;
+    }
+
+    vkd3d_unreachable();
+}
+
+static D3D_SRV_DIMENSION sm4_rdef_resource_dimension(const struct hlsl_type *type)
+{
+    switch (type->sampler_dim)
+    {
+        case HLSL_SAMPLER_DIM_1D:
+            return D3D_SRV_DIMENSION_TEXTURE1D;
+        case HLSL_SAMPLER_DIM_2D:
+            return D3D_SRV_DIMENSION_TEXTURE2D;
+        case HLSL_SAMPLER_DIM_3D:
+            return D3D_SRV_DIMENSION_TEXTURE3D;
+        case HLSL_SAMPLER_DIM_CUBE:
+            return D3D_SRV_DIMENSION_TEXTURECUBE;
+        case HLSL_SAMPLER_DIM_1DARRAY:
+            return D3D_SRV_DIMENSION_TEXTURE1DARRAY;
+        case HLSL_SAMPLER_DIM_2DARRAY:
+            return D3D_SRV_DIMENSION_TEXTURE2DARRAY;
+        case HLSL_SAMPLER_DIM_2DMS:
+            return D3D_SRV_DIMENSION_TEXTURE2DMS;
+        case HLSL_SAMPLER_DIM_2DMSARRAY:
+            return D3D_SRV_DIMENSION_TEXTURE2DMSARRAY;
+        case HLSL_SAMPLER_DIM_CUBEARRAY:
+            return D3D_SRV_DIMENSION_TEXTURECUBEARRAY;
+        case HLSL_SAMPLER_DIM_BUFFER:
+        case HLSL_SAMPLER_DIM_RAW_BUFFER:
+        case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
+            return D3D_SRV_DIMENSION_BUFFER;
+        default:
+            break;
+    }
+
+    vkd3d_unreachable();
+}
+
+static enum D3D_RESOURCE_RETURN_TYPE sm4_data_type(const struct hlsl_type *type)
+{
+    const struct hlsl_type *format = type->e.resource.format;
+
+    switch (format->e.numeric.type)
+    {
+        case HLSL_TYPE_DOUBLE:
+            return D3D_RETURN_TYPE_DOUBLE;
+
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+            if (format->modifiers & HLSL_MODIFIER_UNORM)
+                return D3D_RETURN_TYPE_UNORM;
+            if (format->modifiers & HLSL_MODIFIER_SNORM)
+                return D3D_RETURN_TYPE_SNORM;
+            return D3D_RETURN_TYPE_FLOAT;
+
+        case HLSL_TYPE_INT:
+            return D3D_RETURN_TYPE_SINT;
+            break;
+
+        case HLSL_TYPE_BOOL:
+        case HLSL_TYPE_UINT:
+            return D3D_RETURN_TYPE_UINT;
+    }
+
+    vkd3d_unreachable();
+}
+
+static D3D_SHADER_INPUT_TYPE sm4_resource_type(const struct hlsl_type *type)
+{
+    switch (type->class)
+    {
+        case HLSL_CLASS_SAMPLER:
+            return D3D_SIT_SAMPLER;
+        case HLSL_CLASS_TEXTURE:
+            return D3D_SIT_TEXTURE;
+        case HLSL_CLASS_UAV:
+            return D3D_SIT_UAV_RWTYPED;
+        default:
+            break;
+    }
+
+    vkd3d_unreachable();
+}
+
+static D3D_SHADER_VARIABLE_CLASS sm4_class(const struct hlsl_type *type)
+{
+    switch (type->class)
+    {
+        case HLSL_CLASS_MATRIX:
+            VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
+            if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
+                return D3D_SVC_MATRIX_COLUMNS;
+            else
+                return D3D_SVC_MATRIX_ROWS;
+        case HLSL_CLASS_SCALAR:
+            return D3D_SVC_SCALAR;
+        case HLSL_CLASS_VECTOR:
+            return D3D_SVC_VECTOR;
+
+        case HLSL_CLASS_ARRAY:
+        case HLSL_CLASS_DEPTH_STENCIL_STATE:
+        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
+        case HLSL_CLASS_EFFECT_GROUP:
+        case HLSL_CLASS_ERROR:
+        case HLSL_CLASS_STRUCT:
+        case HLSL_CLASS_PASS:
+        case HLSL_CLASS_PIXEL_SHADER:
+        case HLSL_CLASS_RASTERIZER_STATE:
+        case HLSL_CLASS_RENDER_TARGET_VIEW:
+        case HLSL_CLASS_SAMPLER:
+        case HLSL_CLASS_STRING:
+        case HLSL_CLASS_TECHNIQUE:
+        case HLSL_CLASS_TEXTURE:
+        case HLSL_CLASS_UAV:
+        case HLSL_CLASS_VERTEX_SHADER:
+        case HLSL_CLASS_VOID:
+        case HLSL_CLASS_CONSTANT_BUFFER:
+        case HLSL_CLASS_COMPUTE_SHADER:
+        case HLSL_CLASS_DOMAIN_SHADER:
+        case HLSL_CLASS_HULL_SHADER:
+        case HLSL_CLASS_GEOMETRY_SHADER:
+        case HLSL_CLASS_BLEND_STATE:
+        case HLSL_CLASS_STREAM_OUTPUT:
+        case HLSL_CLASS_NULL:
+            break;
+    }
+
+    vkd3d_unreachable();
+}
+
+static D3D_SHADER_VARIABLE_TYPE sm4_base_type(const struct hlsl_type *type)
+{
+    switch (type->e.numeric.type)
+    {
+        case HLSL_TYPE_BOOL:
+            return D3D_SVT_BOOL;
+        case HLSL_TYPE_DOUBLE:
+            return D3D_SVT_DOUBLE;
+        case HLSL_TYPE_FLOAT:
+        case HLSL_TYPE_HALF:
+            return D3D_SVT_FLOAT;
+        case HLSL_TYPE_INT:
+            return D3D_SVT_INT;
+        case HLSL_TYPE_UINT:
+            return D3D_SVT_UINT;
+    }
+
+    vkd3d_unreachable();
+}
+
+static void write_sm4_type(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer, struct hlsl_type *type)
+{
+    const struct hlsl_type *array_type = hlsl_get_multiarray_element_type(type);
+    const char *name = array_type->name ? array_type->name : "<unnamed>";
+    const struct hlsl_profile_info *profile = ctx->profile;
+    unsigned int array_size = 0;
+    size_t name_offset = 0;
+    size_t i;
+
+    if (type->bytecode_offset)
+        return;
+
+    if (profile->major_version >= 5)
+        name_offset = put_string(buffer, name);
+
+    if (type->class == HLSL_CLASS_ARRAY)
+        array_size = hlsl_get_multiarray_size(type);
+
+    if (array_type->class == HLSL_CLASS_STRUCT)
+    {
+        unsigned int field_count = 0;
+        size_t fields_offset = 0;
+
+        for (i = 0; i < array_type->e.record.field_count; ++i)
+        {
+            struct hlsl_struct_field *field = &array_type->e.record.fields[i];
+
+            if (!field->type->reg_size[HLSL_REGSET_NUMERIC])
+                continue;
+
+            field->name_bytecode_offset = put_string(buffer, field->name);
+            write_sm4_type(ctx, buffer, field->type);
+            ++field_count;
+        }
+
+        fields_offset = bytecode_align(buffer);
+
+        for (i = 0; i < array_type->e.record.field_count; ++i)
+        {
+            struct hlsl_struct_field *field = &array_type->e.record.fields[i];
+
+            if (!field->type->reg_size[HLSL_REGSET_NUMERIC])
+                continue;
+
+            put_u32(buffer, field->name_bytecode_offset);
+            put_u32(buffer, field->type->bytecode_offset);
+            put_u32(buffer, field->reg_offset[HLSL_REGSET_NUMERIC] * sizeof(float));
+        }
+        type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(D3D_SVC_STRUCT, D3D_SVT_VOID));
+        put_u32(buffer, vkd3d_make_u32(1, hlsl_type_component_count(array_type)));
+        put_u32(buffer, vkd3d_make_u32(array_size, field_count));
+        put_u32(buffer, fields_offset);
+    }
+    else
+    {
+        VKD3D_ASSERT(array_type->class <= HLSL_CLASS_LAST_NUMERIC);
+        type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(sm4_class(array_type), sm4_base_type(array_type)));
+        put_u32(buffer, vkd3d_make_u32(array_type->e.numeric.dimy, array_type->e.numeric.dimx));
+        put_u32(buffer, vkd3d_make_u32(array_size, 0));
+        put_u32(buffer, 1);
+    }
+
+    if (profile->major_version >= 5)
+    {
+        put_u32(buffer, 0); /* FIXME: unknown */
+        put_u32(buffer, 0); /* FIXME: unknown */
+        put_u32(buffer, 0); /* FIXME: unknown */
+        put_u32(buffer, 0); /* FIXME: unknown */
+        put_u32(buffer, name_offset);
+    }
+}
+
+static void sm4_generate_rdef(struct hlsl_ctx *ctx, struct vkd3d_shader_code *rdef)
+{
+    uint32_t binding_desc_size = (hlsl_version_ge(ctx, 5, 1) ? 10 : 8) * sizeof(uint32_t);
+    size_t cbuffers_offset, resources_offset, creator_offset, string_offset;
+    unsigned int cbuffer_count = 0, extern_resources_count, i, j;
+    size_t cbuffer_position, resource_position, creator_position;
+    const struct hlsl_profile_info *profile = ctx->profile;
+    struct vkd3d_bytecode_buffer buffer = {0};
+    struct extern_resource *extern_resources;
+    const struct hlsl_buffer *cbuffer;
+    const struct hlsl_ir_var *var;
+
+    static const uint16_t target_types[] =
+    {
+        0xffff, /* PIXEL */
+        0xfffe, /* VERTEX */
+        0x4753, /* GEOMETRY */
+        0x4853, /* HULL */
+        0x4453, /* DOMAIN */
+        0x4353, /* COMPUTE */
+    };
+
+    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
+
+    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
+    {
+        if (cbuffer->reg.allocated)
+            ++cbuffer_count;
+    }
+
+    put_u32(&buffer, cbuffer_count);
+    cbuffer_position = put_u32(&buffer, 0);
+    put_u32(&buffer, extern_resources_count);
+    resource_position = put_u32(&buffer, 0);
+    put_u32(&buffer, vkd3d_make_u32(vkd3d_make_u16(profile->minor_version, profile->major_version),
+            target_types[profile->type]));
+    put_u32(&buffer, 0); /* FIXME: compilation flags */
+    creator_position = put_u32(&buffer, 0);
+
+    if (profile->major_version >= 5)
+    {
+        put_u32(&buffer, hlsl_version_ge(ctx, 5, 1) ? TAG_RD11_REVERSE : TAG_RD11);
+        put_u32(&buffer, 15 * sizeof(uint32_t)); /* size of RDEF header including this header */
+        put_u32(&buffer, 6 * sizeof(uint32_t)); /* size of buffer desc */
+        put_u32(&buffer, binding_desc_size); /* size of binding desc */
+        put_u32(&buffer, 10 * sizeof(uint32_t)); /* size of variable desc */
+        put_u32(&buffer, 9 * sizeof(uint32_t)); /* size of type desc */
+        put_u32(&buffer, 3 * sizeof(uint32_t)); /* size of member desc */
+        put_u32(&buffer, 0); /* unknown; possibly a null terminator */
+    }
+
+    /* Bound resources. */
+
+    resources_offset = bytecode_align(&buffer);
+    set_u32(&buffer, resource_position, resources_offset);
+
+    for (i = 0; i < extern_resources_count; ++i)
+    {
+        const struct extern_resource *resource = &extern_resources[i];
+        uint32_t flags = 0;
+
+        if (resource->is_user_packed)
+            flags |= D3D_SIF_USERPACKED;
+
+        put_u32(&buffer, 0); /* name */
+        if (resource->buffer)
+            put_u32(&buffer, resource->buffer->type == HLSL_BUFFER_CONSTANT ? D3D_SIT_CBUFFER : D3D_SIT_TBUFFER);
+        else
+            put_u32(&buffer, sm4_resource_type(resource->component_type));
+        if (resource->regset == HLSL_REGSET_TEXTURES || resource->regset == HLSL_REGSET_UAVS)
+        {
+            unsigned int dimx = resource->component_type->e.resource.format->e.numeric.dimx;
+
+            put_u32(&buffer, sm4_data_type(resource->component_type));
+            put_u32(&buffer, sm4_rdef_resource_dimension(resource->component_type));
+            put_u32(&buffer, ~0u); /* FIXME: multisample count */
+            flags |= (dimx - 1) << VKD3D_SM4_SIF_TEXTURE_COMPONENTS_SHIFT;
+        }
+        else
+        {
+            put_u32(&buffer, 0);
+            put_u32(&buffer, 0);
+            put_u32(&buffer, 0);
+        }
+        put_u32(&buffer, resource->index);
+        put_u32(&buffer, resource->bind_count);
+        put_u32(&buffer, flags);
+
+        if (hlsl_version_ge(ctx, 5, 1))
+        {
+            put_u32(&buffer, resource->space);
+            put_u32(&buffer, resource->id);
+        }
+    }
+
+    for (i = 0; i < extern_resources_count; ++i)
+    {
+        const struct extern_resource *resource = &extern_resources[i];
+
+        string_offset = put_string(&buffer, resource->name);
+        set_u32(&buffer, resources_offset + i * binding_desc_size, string_offset);
+    }
+
+    /* Buffers. */
+
+    cbuffers_offset = bytecode_align(&buffer);
+    set_u32(&buffer, cbuffer_position, cbuffers_offset);
+    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
+    {
+        unsigned int var_count = 0;
+
+        if (!cbuffer->reg.allocated)
+            continue;
 
-    hlsl_block_init(&block);
+        LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+        {
+            if (var->is_uniform && var->buffer == cbuffer && var->data_type->reg_size[HLSL_REGSET_NUMERIC])
+                ++var_count;
+        }
 
-    LIST_FOR_EACH_ENTRY(var, &func->extern_vars, struct hlsl_ir_var, extern_entry)
-    {
-        if ((var->is_input_semantic && var->last_read)
-                || (var->is_output_semantic && var->first_write))
-            sm4_generate_vsir_instr_dcl_semantic(ctx, program, var, is_patch_constant_func, &block, &var->loc);
+        put_u32(&buffer, 0); /* name */
+        put_u32(&buffer, var_count);
+        put_u32(&buffer, 0); /* variable offset */
+        put_u32(&buffer, align(cbuffer->size, 4) * sizeof(float));
+        put_u32(&buffer, 0); /* FIXME: flags */
+        put_u32(&buffer, cbuffer->type == HLSL_BUFFER_CONSTANT ? D3D_CT_CBUFFER : D3D_CT_TBUFFER);
     }
 
-    if (temp_count)
-        sm4_generate_vsir_instr_dcl_temps(ctx, program, temp_count, &block, &func->loc);
+    i = 0;
+    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
+    {
+        if (!cbuffer->reg.allocated)
+            continue;
 
-    LIST_FOR_EACH_ENTRY(scope, &ctx->scopes, struct hlsl_scope, entry)
+        string_offset = put_string(&buffer, cbuffer->name);
+        set_u32(&buffer, cbuffers_offset + i++ * 6 * sizeof(uint32_t), string_offset);
+    }
+
+    i = 0;
+    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
     {
-        LIST_FOR_EACH_ENTRY(var, &scope->vars, struct hlsl_ir_var, scope_entry)
+        size_t vars_start = bytecode_align(&buffer);
+
+        if (!cbuffer->reg.allocated)
+            continue;
+
+        set_u32(&buffer, cbuffers_offset + (i++ * 6 + 2) * sizeof(uint32_t), vars_start);
+
+        LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
         {
-            if (var->is_uniform || var->is_input_semantic || var->is_output_semantic)
+            uint32_t flags = 0;
+
+            if (!var->is_uniform || var->buffer != cbuffer || !var->data_type->reg_size[HLSL_REGSET_NUMERIC])
                 continue;
-            if (!var->regs[HLSL_REGSET_NUMERIC].allocated)
+
+            if (var->is_read)
+                flags |= D3D_SVF_USED;
+
+            put_u32(&buffer, 0); /* name */
+            put_u32(&buffer, var->buffer_offset * sizeof(float));
+            put_u32(&buffer, var->data_type->reg_size[HLSL_REGSET_NUMERIC] * sizeof(float));
+            put_u32(&buffer, flags);
+            put_u32(&buffer, 0); /* type */
+            put_u32(&buffer, 0); /* default value */
+
+            if (profile->major_version >= 5)
+            {
+                put_u32(&buffer, 0); /* texture start */
+                put_u32(&buffer, 0); /* texture count */
+                put_u32(&buffer, 0); /* sampler start */
+                put_u32(&buffer, 0); /* sampler count */
+            }
+        }
+
+        j = 0;
+        LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
+        {
+            const unsigned int var_size = (profile->major_version >= 5 ? 10 : 6);
+            size_t var_offset = vars_start + j * var_size * sizeof(uint32_t);
+
+            if (!var->is_uniform || var->buffer != cbuffer || !var->data_type->reg_size[HLSL_REGSET_NUMERIC])
                 continue;
 
-            if (var->indexable)
+            string_offset = put_string(&buffer, var->name);
+            set_u32(&buffer, var_offset, string_offset);
+            write_sm4_type(ctx, &buffer, var->data_type);
+            set_u32(&buffer, var_offset + 4 * sizeof(uint32_t), var->data_type->bytecode_offset);
+
+            if (var->default_values)
             {
-                unsigned int id = var->regs[HLSL_REGSET_NUMERIC].id;
-                unsigned int size = align(var->data_type->reg_size[HLSL_REGSET_NUMERIC], 4) / 4;
+                unsigned int reg_size = var->data_type->reg_size[HLSL_REGSET_NUMERIC];
+                unsigned int comp_count = hlsl_type_component_count(var->data_type);
+                unsigned int default_value_offset;
+                unsigned int k;
 
-                sm4_generate_vsir_instr_dcl_indexable_temp(ctx, program, &block, id, size, 4, &var->loc);
+                default_value_offset = bytecode_reserve_bytes(&buffer, reg_size * sizeof(uint32_t));
+                set_u32(&buffer, var_offset + 5 * sizeof(uint32_t), default_value_offset);
+
+                for (k = 0; k < comp_count; ++k)
+                {
+                    struct hlsl_type *comp_type = hlsl_type_get_component_type(ctx, var->data_type, k);
+                    unsigned int comp_offset, comp_index;
+                    enum hlsl_regset regset;
+
+                    if (comp_type->class == HLSL_CLASS_STRING)
+                    {
+                        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                                "Cannot write string default value.");
+                        continue;
+                    }
+
+                    comp_index = get_component_index_from_default_initializer_index(var->data_type, k);
+                    comp_offset = hlsl_type_get_component_offset(ctx, var->data_type, comp_index, &regset);
+                    if (regset == HLSL_REGSET_NUMERIC)
+                    {
+                        if (comp_type->e.numeric.type == HLSL_TYPE_DOUBLE)
+                            hlsl_fixme(ctx, &var->loc, "Write double default values.");
+
+                        set_u32(&buffer, default_value_offset + comp_offset * sizeof(uint32_t),
+                                var->default_values[k].number.u);
+                    }
+                }
             }
+
+            ++j;
         }
     }
 
-    list_move_head(&func->body.instrs, &block.instrs);
+    creator_offset = put_string(&buffer, vkd3d_shader_get_version(NULL, NULL));
+    set_u32(&buffer, creator_position, creator_offset);
 
-    hlsl_block_cleanup(&block);
+    sm4_free_extern_resources(extern_resources, extern_resources_count);
 
-    sm4_generate_vsir_block(ctx, &func->body, program);
+    if (buffer.status)
+    {
+        vkd3d_free(buffer.data);
+        ctx->result = buffer.status;
+        return;
+    }
+    rdef->code = buffer.data;
+    rdef->size = buffer.size;
 }
 
-/* OBJECTIVE: Translate all the information from ctx and entry_func to the
- * vsir_program, so it can be used as input to tpf_compile() without relying
- * on ctx and entry_func. */
-static void sm4_generate_vsir(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *func,
-        uint64_t config_flags, struct vsir_program *program)
+static bool loop_unrolling_generate_const_bool_store(struct hlsl_ctx *ctx, struct hlsl_ir_var *var,
+        bool val, struct hlsl_block *block, struct vkd3d_shader_location *loc)
 {
-    struct vkd3d_shader_version version = {0};
+    struct hlsl_ir_node *const_node, *store;
 
-    version.major = ctx->profile->major_version;
-    version.minor = ctx->profile->minor_version;
-    version.type = ctx->profile->type;
+    if (!(const_node = hlsl_new_bool_constant(ctx, val, loc)))
+        return false;
+    hlsl_block_add_instr(block, const_node);
+
+    if (!(store = hlsl_new_simple_store(ctx, var, const_node)))
+        return false;
+    hlsl_block_add_instr(block, store);
+
+    return true;
+}
+
+static bool loop_unrolling_remove_jumps_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *loop_broken, struct hlsl_ir_var *loop_continued);
+
+static bool loop_unrolling_remove_jumps_visit(struct hlsl_ctx *ctx, struct hlsl_ir_node *node,
+        struct hlsl_ir_var *loop_broken, struct hlsl_ir_var *loop_continued)
+{
+    struct hlsl_ir_jump *jump;
+    struct hlsl_ir_var *var;
+    struct hlsl_block draft;
+    struct hlsl_ir_if *iff;
 
-    if (!vsir_program_init(program, NULL, &version, 0, VSIR_CF_STRUCTURED, VSIR_NOT_NORMALISED))
+    if (node->type == HLSL_IR_IF)
     {
-        ctx->result = VKD3D_ERROR_OUT_OF_MEMORY;
-        return;
+        iff = hlsl_ir_if(node);
+        if (loop_unrolling_remove_jumps_recurse(ctx, &iff->then_block, loop_broken, loop_continued))
+            return true;
+        if (loop_unrolling_remove_jumps_recurse(ctx, &iff->else_block, loop_broken, loop_continued))
+            return true;
+        return false;
     }
 
-    generate_vsir_signature(ctx, program, func);
-    if (version.type == VKD3D_SHADER_TYPE_HULL)
-        generate_vsir_signature(ctx, program, ctx->patch_constant_func);
-
-    if (version.type == VKD3D_SHADER_TYPE_COMPUTE)
+    if (node->type == HLSL_IR_JUMP)
     {
-        program->thread_group_size.x = ctx->thread_count[0];
-        program->thread_group_size.y = ctx->thread_count[1];
-        program->thread_group_size.z = ctx->thread_count[2];
+        jump = hlsl_ir_jump(node);
+        if (jump->type != HLSL_IR_JUMP_UNRESOLVED_CONTINUE && jump->type != HLSL_IR_JUMP_BREAK)
+            return false;
+
+        hlsl_block_init(&draft);
+
+        if (jump->type == HLSL_IR_JUMP_UNRESOLVED_CONTINUE)
+            var = loop_continued;
+        else
+            var = loop_broken;
+
+        if (!loop_unrolling_generate_const_bool_store(ctx, var, true, &draft, &jump->node.loc))
+            return false;
+
+        list_move_before(&jump->node.entry, &draft.instrs);
+        list_remove(&jump->node.entry);
+        hlsl_free_instr(&jump->node);
+
+        return true;
     }
 
-    sm4_generate_vsir_add_function(ctx, func, config_flags, program);
-    if (version.type == VKD3D_SHADER_TYPE_HULL)
-        sm4_generate_vsir_add_function(ctx, ctx->patch_constant_func, config_flags, program);
+    return false;
 }
 
-static struct hlsl_ir_jump *loop_unrolling_find_jump(struct hlsl_block *block, struct hlsl_ir_node *stop_point,
-        struct hlsl_block **found_block)
+static struct hlsl_ir_if *loop_unrolling_generate_var_check(struct hlsl_ctx *ctx,
+        struct hlsl_block *dst, struct hlsl_ir_var *var, struct vkd3d_shader_location *loc)
 {
-    struct hlsl_ir_node *node;
+    struct hlsl_ir_node *cond, *iff;
+    struct hlsl_block then_block;
+    struct hlsl_ir_load *load;
 
-    LIST_FOR_EACH_ENTRY(node, &block->instrs, struct hlsl_ir_node, entry)
+    hlsl_block_init(&then_block);
+
+    if (!(load = hlsl_new_var_load(ctx, var, loc)))
+        return NULL;
+    hlsl_block_add_instr(dst, &load->node);
+
+    if (!(cond = hlsl_new_unary_expr(ctx, HLSL_OP1_LOGIC_NOT, &load->node, loc)))
+        return NULL;
+    hlsl_block_add_instr(dst, cond);
+
+    if (!(iff = hlsl_new_if(ctx, cond, &then_block, NULL, loc)))
+        return NULL;
+    hlsl_block_add_instr(dst, iff);
+
+    return hlsl_ir_if(iff);
+}
+
+static bool loop_unrolling_remove_jumps_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *loop_broken, struct hlsl_ir_var *loop_continued)
+{
+    struct hlsl_ir_node *node, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE(node, next, &block->instrs, struct hlsl_ir_node, entry)
     {
-        if (node == stop_point)
-            return NULL;
+        struct hlsl_ir_if *broken_check, *continued_check;
+        struct hlsl_block draft;
 
-        if (node->type == HLSL_IR_IF)
-        {
-            struct hlsl_ir_if *iff = hlsl_ir_if(node);
-            struct hlsl_ir_jump *jump = NULL;
+        if (!loop_unrolling_remove_jumps_visit(ctx, node, loop_broken, loop_continued))
+            continue;
 
-            if ((jump = loop_unrolling_find_jump(&iff->then_block, stop_point, found_block)))
-                return jump;
-            if ((jump = loop_unrolling_find_jump(&iff->else_block, stop_point, found_block)))
-                return jump;
-        }
-        else if (node->type == HLSL_IR_JUMP)
-        {
-            struct hlsl_ir_jump *jump = hlsl_ir_jump(node);
+        if (&next->entry == &block->instrs)
+            return true;
 
-            if (jump->type == HLSL_IR_JUMP_BREAK || jump->type == HLSL_IR_JUMP_CONTINUE)
-            {
-                *found_block = block;
-                return jump;
-            }
-        }
+        hlsl_block_init(&draft);
+
+        broken_check = loop_unrolling_generate_var_check(ctx, &draft, loop_broken, &next->loc);
+        continued_check = loop_unrolling_generate_var_check(ctx,
+                &broken_check->then_block, loop_continued, &next->loc);
+
+        list_move_before(&next->entry, &draft.instrs);
+
+        list_move_slice_tail(&continued_check->then_block.instrs, &next->entry, list_tail(&block->instrs));
+
+        return true;
     }
 
-    return NULL;
+    return false;
+}
+
+static void loop_unrolling_remove_jumps(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_var *loop_broken, struct hlsl_ir_var *loop_continued)
+{
+    while (loop_unrolling_remove_jumps_recurse(ctx, block, loop_broken, loop_continued));
 }
 
 static unsigned int loop_unrolling_get_max_iterations(struct hlsl_ctx *ctx, struct hlsl_ir_loop *loop)
@@ -8696,7 +11290,7 @@ static unsigned int loop_unrolling_get_max_iterations(struct hlsl_ctx *ctx, stru
         return loop->unroll_limit;
 
     /* All SMs will default to 1024 if [unroll] has been specified without an explicit limit. */
-    if (loop->unroll_type == HLSL_IR_LOOP_FORCE_UNROLL)
+    if (loop->unroll_type == HLSL_LOOP_FORCE_UNROLL)
         return 1024;
 
     /* SM4 limits implicit unrolling to 254 iterations. */
@@ -8707,167 +11301,279 @@ static unsigned int loop_unrolling_get_max_iterations(struct hlsl_ctx *ctx, stru
     return 1024;
 }
 
-static bool loop_unrolling_unroll_loop(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        struct hlsl_block *loop_parent, struct hlsl_ir_loop *loop)
+static void loop_unrolling_simplify(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct copy_propagation_state *state, unsigned int *index)
+{
+    size_t scopes_depth = state->scope_count - 1;
+    unsigned int current_index;
+    bool progress;
+
+    do
+    {
+        state->stopped = false;
+        for (size_t i = state->scope_count; scopes_depth < i; --i)
+            copy_propagation_pop_scope(state);
+        copy_propagation_push_scope(state, ctx);
+
+        progress = hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, block, NULL);
+        progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_identities, block, NULL);
+        progress |= hlsl_transform_ir(ctx, hlsl_fold_constant_swizzles, block, NULL);
+
+        current_index = index_instructions(block, *index);
+        progress |= copy_propagation_transform_block(ctx, block, state);
+
+        progress |= hlsl_transform_ir(ctx, fold_swizzle_chains, block, NULL);
+        progress |= hlsl_transform_ir(ctx, remove_trivial_swizzles, block, NULL);
+        progress |= hlsl_transform_ir(ctx, remove_trivial_conditional_branches, block, NULL);
+    } while (progress);
+
+    *index = current_index;
+}
+
+static bool loop_unrolling_check_val(struct copy_propagation_state *state, struct hlsl_ir_var *var)
+{
+    struct copy_propagation_value *v;
+
+    if (!(v = copy_propagation_get_value(state, var, 0, UINT_MAX))
+            || v->node->type != HLSL_IR_CONSTANT)
+        return false;
+
+    return hlsl_ir_constant(v->node)->value.u[0].u;
+}
+
+static bool loop_unrolling_unroll_loop(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_loop *loop)
 {
-    unsigned int max_iterations, i;
+    struct hlsl_block draft, tmp_dst, loop_body;
+    struct hlsl_ir_var *broken, *continued;
+    unsigned int max_iterations, i, index;
+    struct copy_propagation_state state;
+    struct hlsl_ir_if *target_if;
+
+    if (!(broken = hlsl_new_synthetic_var(ctx, "broken",
+            hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL), &loop->node.loc)))
+        goto fail;
+
+    if (!(continued = hlsl_new_synthetic_var(ctx, "continued",
+            hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL), &loop->node.loc)))
+        goto fail;
+
+    hlsl_block_init(&draft);
+    hlsl_block_init(&tmp_dst);
 
     max_iterations = loop_unrolling_get_max_iterations(ctx, loop);
+    copy_propagation_state_init(&state, ctx);
+    index = 2;
+    state.stop = &loop->node;
+    loop_unrolling_simplify(ctx, block, &state, &index);
+    state.stopped = false;
+    index = loop->node.index;
+
+    if (!loop_unrolling_generate_const_bool_store(ctx, broken, false, &tmp_dst, &loop->node.loc))
+        goto fail;
+    hlsl_block_add_block(&draft, &tmp_dst);
+
+    if (!loop_unrolling_generate_const_bool_store(ctx, continued, false, &tmp_dst, &loop->node.loc))
+        goto fail;
+    hlsl_block_add_block(&draft, &tmp_dst);
+
+    if (!(target_if = loop_unrolling_generate_var_check(ctx, &tmp_dst, broken, &loop->node.loc)))
+        goto fail;
+    state.stop = LIST_ENTRY(list_head(&tmp_dst.instrs), struct hlsl_ir_node, entry);
+    hlsl_block_add_block(&draft, &tmp_dst);
+
+    copy_propagation_push_scope(&state, ctx);
+    loop_unrolling_simplify(ctx, &draft, &state, &index);
+
+    /* As an optimization, we only remove jumps from the loop's body once. */
+    if (!hlsl_clone_block(ctx, &loop_body, &loop->body))
+        goto fail;
+    loop_unrolling_remove_jumps(ctx, &loop_body, broken, continued);
 
     for (i = 0; i < max_iterations; ++i)
     {
-        struct hlsl_block tmp_dst, *jump_block;
-        struct hlsl_ir_jump *jump = NULL;
+        copy_propagation_push_scope(&state, ctx);
 
-        if (!hlsl_clone_block(ctx, &tmp_dst, &loop->body))
-            return false;
-        list_move_before(&loop->node.entry, &tmp_dst.instrs);
-        hlsl_block_cleanup(&tmp_dst);
+        if (!loop_unrolling_generate_const_bool_store(ctx, continued, false, &tmp_dst, &loop->node.loc))
+            goto fail;
+        hlsl_block_add_block(&target_if->then_block, &tmp_dst);
 
-        hlsl_run_const_passes(ctx, block);
+        if (!hlsl_clone_block(ctx, &tmp_dst, &loop_body))
+            goto fail;
+        hlsl_block_add_block(&target_if->then_block, &tmp_dst);
 
-        if ((jump = loop_unrolling_find_jump(loop_parent, &loop->node, &jump_block)))
-        {
-            enum hlsl_ir_jump_type type = jump->type;
+        loop_unrolling_simplify(ctx, &target_if->then_block, &state, &index);
 
-            if (jump_block != loop_parent)
-            {
-                if (loop->unroll_type == HLSL_IR_LOOP_FORCE_UNROLL)
-                    hlsl_error(ctx, &jump->node.loc, VKD3D_SHADER_ERROR_HLSL_FAILED_FORCED_UNROLL,
-                        "Unable to unroll loop, unrolling loops with conditional jumps is currently not supported.");
-                return false;
-            }
+        if (loop_unrolling_check_val(&state, broken))
+            break;
 
-            list_move_slice_tail(&tmp_dst.instrs, &jump->node.entry, list_prev(&loop_parent->instrs, &loop->node.entry));
-            hlsl_block_cleanup(&tmp_dst);
+        if (!(target_if = loop_unrolling_generate_var_check(ctx, &tmp_dst, broken, &loop->node.loc)))
+            goto fail;
+        hlsl_block_add_block(&draft, &tmp_dst);
 
-            if (type == HLSL_IR_JUMP_BREAK)
-                break;
-        }
-    }
+        if (!hlsl_clone_block(ctx, &tmp_dst, &loop->iter))
+            goto fail;
+        hlsl_block_add_block(&target_if->then_block, &tmp_dst);
+   }
 
     /* Native will not emit an error if max_iterations has been reached with an
      * explicit limit. It also will not insert a loop if there are iterations left
      * i.e [unroll(4)] for (i = 0; i < 8; ++i)) */
     if (!loop->unroll_limit && i == max_iterations)
     {
-        if (loop->unroll_type == HLSL_IR_LOOP_FORCE_UNROLL)
+        if (loop->unroll_type == HLSL_LOOP_FORCE_UNROLL)
             hlsl_error(ctx, &loop->node.loc, VKD3D_SHADER_ERROR_HLSL_FAILED_FORCED_UNROLL,
                 "Unable to unroll loop, maximum iterations reached (%u).", max_iterations);
-        return false;
+        goto fail;
     }
 
+    hlsl_block_cleanup(&loop_body);
+    copy_propagation_state_destroy(&state);
+
+    list_move_before(&loop->node.entry, &draft.instrs);
+    hlsl_block_cleanup(&draft);
     list_remove(&loop->node.entry);
     hlsl_free_instr(&loop->node);
 
     return true;
+
+fail:
+    hlsl_block_cleanup(&loop_body);
+    copy_propagation_state_destroy(&state);
+    hlsl_block_cleanup(&draft);
+
+    return false;
 }
 
-/*
- * loop_unrolling_find_unrollable_loop() is not the normal way to do things;
- * normal passes simply iterate over the whole block and apply a transformation
- * to every relevant instruction. However, loop unrolling can fail, and we want
- * to leave the loop in its previous state in that case. That isn't a problem by
- * itself, except that loop unrolling needs copy-prop in order to work properly,
- * and copy-prop state at the time of the loop depends on the rest of the program
- * up to that point. This means we need to clone the whole program, and at that
- * point we have to search it again anyway to find the clone of the loop we were
- * going to unroll.
- *
- * FIXME: Ideally we wouldn't clone the whole program; instead we would run copyprop
- * up until the loop instruction, clone just that loop, then use copyprop again
- * with the saved state after unrolling. However, copyprop currently isn't built
- * for that yet [notably, it still relies on indices]. Note also this still doesn't
- * really let us use transform_ir() anyway [since we don't have a good way to say
- * "copyprop from the beginning of the program up to the instruction we're
- * currently processing" from the callback]; we'd have to use a dedicated
- * recursive function instead. */
-static struct hlsl_ir_loop *loop_unrolling_find_unrollable_loop(struct hlsl_ctx *ctx, struct hlsl_block *block,
-        struct hlsl_block **containing_block)
+static bool unroll_loops(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, void *context)
 {
-    struct hlsl_ir_node *instr;
+    struct hlsl_block *program = context;
+    struct hlsl_ir_loop *loop;
 
-    LIST_FOR_EACH_ENTRY(instr, &block->instrs, struct hlsl_ir_node, entry)
+    if (node->type != HLSL_IR_LOOP)
+        return true;
+
+    loop = hlsl_ir_loop(node);
+
+    if (loop->unroll_type != HLSL_LOOP_UNROLL && loop->unroll_type != HLSL_LOOP_FORCE_UNROLL)
+        return true;
+
+    if (!loop_unrolling_unroll_loop(ctx, program, loop))
+        loop->unroll_type = HLSL_LOOP_FORCE_LOOP;
+
+    return true;
+}
+
+/* We could handle this at parse time. However, loop unrolling often needs to
+ * know the value of variables modified in the "iter" block. It is possible to
+ * detect that all exit paths of a loop body modify such variables in the same
+ * way, but difficult, and d3dcompiler does not attempt to do so.
+ * In fact, d3dcompiler is capable of unrolling the following loop:
+ * for (int i = 0; i < 10; ++i)
+ * {
+ *     if (some_uniform > 4)
+ *         continue;
+ * }
+ * but cannot unroll the same loop with "++i" moved to each exit path:
+ * for (int i = 0; i < 10;)
+ * {
+ *     if (some_uniform > 4)
+ *     {
+ *         ++i;
+ *         continue;
+ *     }
+ *     ++i;
+ * }
+ */
+static bool resolve_loops(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, void *context)
+{
+    struct hlsl_ir_loop *loop;
+
+    if (node->type != HLSL_IR_LOOP)
+        return true;
+
+    loop = hlsl_ir_loop(node);
+
+    hlsl_block_add_block(&loop->body, &loop->iter);
+    return true;
+}
+
+static void resolve_continues(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_loop *last_loop)
+{
+    struct hlsl_ir_node *node;
+
+    LIST_FOR_EACH_ENTRY(node, &block->instrs, struct hlsl_ir_node, entry)
     {
-        switch (instr->type)
+        switch (node->type)
         {
             case HLSL_IR_LOOP:
             {
-                struct hlsl_ir_loop *nested_loop;
-                struct hlsl_ir_loop *loop = hlsl_ir_loop(instr);
-
-                if ((nested_loop = loop_unrolling_find_unrollable_loop(ctx, &loop->body, containing_block)))
-                    return nested_loop;
-
-                if (loop->unroll_type == HLSL_IR_LOOP_UNROLL || loop->unroll_type == HLSL_IR_LOOP_FORCE_UNROLL)
-                {
-                    *containing_block = block;
-                    return loop;
-                }
+                struct hlsl_ir_loop *loop = hlsl_ir_loop(node);
 
+                resolve_continues(ctx, &loop->body, loop);
                 break;
             }
             case HLSL_IR_IF:
             {
-                struct hlsl_ir_loop *loop;
-                struct hlsl_ir_if *iff = hlsl_ir_if(instr);
-
-                if ((loop = loop_unrolling_find_unrollable_loop(ctx, &iff->then_block, containing_block)))
-                    return loop;
-                if ((loop = loop_unrolling_find_unrollable_loop(ctx, &iff->else_block, containing_block)))
-                    return loop;
-
+                struct hlsl_ir_if *iff = hlsl_ir_if(node);
+                resolve_continues(ctx, &iff->then_block, last_loop);
+                resolve_continues(ctx, &iff->else_block, last_loop);
                 break;
             }
             case HLSL_IR_SWITCH:
             {
-                struct hlsl_ir_switch *s = hlsl_ir_switch(instr);
+                struct hlsl_ir_switch *s = hlsl_ir_switch(node);
                 struct hlsl_ir_switch_case *c;
-                struct hlsl_ir_loop *loop;
 
                 LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
                 {
-                    if ((loop = loop_unrolling_find_unrollable_loop(ctx, &c->body, containing_block)))
-                        return loop;
+                    resolve_continues(ctx, &c->body, last_loop);
+                }
+
+                break;
+            }
+            case HLSL_IR_JUMP:
+            {
+                struct hlsl_ir_jump *jump = hlsl_ir_jump(node);
+
+                if (jump->type != HLSL_IR_JUMP_UNRESOLVED_CONTINUE)
+                    break;
+
+                if (last_loop->type == HLSL_LOOP_FOR)
+                {
+                    struct hlsl_block draft;
+
+                    if (!hlsl_clone_block(ctx, &draft, &last_loop->iter))
+                        return;
+
+                    list_move_before(&node->entry, &draft.instrs);
+                    hlsl_block_cleanup(&draft);
                 }
 
+                jump->type = HLSL_IR_JUMP_CONTINUE;
                 break;
             }
             default:
                 break;
         }
     }
-
-    return NULL;
 }
 
-static void transform_unroll_loops(struct hlsl_ctx *ctx, struct hlsl_block *block)
+static void loop_unrolling_execute(struct hlsl_ctx *ctx, struct hlsl_block *block)
 {
-    while (true)
-    {
-        struct hlsl_block clone, *containing_block;
-        struct hlsl_ir_loop *loop, *cloned_loop;
-
-        if (!(loop = loop_unrolling_find_unrollable_loop(ctx, block, &containing_block)))
-            return;
-
-        if (!hlsl_clone_block(ctx, &clone, block))
-            return;
-
-        cloned_loop = loop_unrolling_find_unrollable_loop(ctx, &clone, &containing_block);
-        VKD3D_ASSERT(cloned_loop);
+    bool progress;
 
-        if (!loop_unrolling_unroll_loop(ctx, &clone, containing_block, cloned_loop))
-        {
-            hlsl_block_cleanup(&clone);
-            loop->unroll_type = HLSL_IR_LOOP_FORCE_LOOP;
-            continue;
-        }
+    /* These are required by copy propagation, which in turn is required for
+     * unrolling. */
+    do
+    {
+        progress = hlsl_transform_ir(ctx, split_array_copies, block, NULL);
+        progress |= hlsl_transform_ir(ctx, split_struct_copies, block, NULL);
+    } while (progress);
+    hlsl_transform_ir(ctx, split_matrix_copies, block, NULL);
 
-        hlsl_block_cleanup(block);
-        hlsl_block_init(block);
-        hlsl_block_add_block(block, &clone);
-    }
+    hlsl_transform_ir(ctx, unroll_loops, block, block);
+    resolve_continues(ctx, block, NULL);
+    hlsl_transform_ir(ctx, resolve_loops, block, NULL);
 }
 
 static bool lower_f16tof32(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_block *block)
@@ -9107,16 +11813,17 @@ static void process_entry_function(struct hlsl_ctx *ctx,
         append_output_var_copy(ctx, entry_func, entry_func->return_var);
     }
 
-    if (profile->major_version >= 4)
+    if (hlsl_version_ge(ctx, 4, 0))
     {
         hlsl_transform_ir(ctx, lower_discard_neg, body, NULL);
     }
     else
     {
         hlsl_transform_ir(ctx, lower_discard_nz, body, NULL);
+        hlsl_transform_ir(ctx, lower_resource_load_bias, body, NULL);
     }
 
-    transform_unroll_loops(ctx, body);
+    loop_unrolling_execute(ctx, body);
     hlsl_run_const_passes(ctx, body);
 
     remove_unreachable_code(ctx, body);
@@ -9126,9 +11833,13 @@ static void process_entry_function(struct hlsl_ctx *ctx,
     lower_ir(ctx, lower_casts_to_bool, body);
     lower_ir(ctx, lower_int_dot, body);
 
+    if (hlsl_version_lt(ctx, 4, 0))
+        hlsl_transform_ir(ctx, lower_separate_samples, body, NULL);
+
     hlsl_transform_ir(ctx, validate_dereferences, body, NULL);
     hlsl_transform_ir(ctx, track_object_components_sampler_dim, body, NULL);
-    if (profile->major_version >= 4)
+
+    if (hlsl_version_ge(ctx, 4, 0))
         hlsl_transform_ir(ctx, lower_combined_samples, body, NULL);
 
     do
@@ -9136,7 +11847,10 @@ static void process_entry_function(struct hlsl_ctx *ctx,
     while (hlsl_transform_ir(ctx, dce, body, NULL));
 
     hlsl_transform_ir(ctx, track_components_usage, body, NULL);
-    sort_synthetic_separated_samplers_first(ctx);
+    if (hlsl_version_lt(ctx, 4, 0))
+        sort_synthetic_combined_samplers_first(ctx);
+    else
+        sort_synthetic_separated_samplers_first(ctx);
 
     if (profile->major_version < 4)
     {
@@ -9241,14 +11955,16 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
         mark_indexable_vars(ctx, entry_func);
         allocate_temp_registers(ctx, entry_func);
         allocate_const_registers(ctx, entry_func);
+        sort_uniforms_by_bind_count(ctx, HLSL_REGSET_SAMPLERS);
+        allocate_objects(ctx, entry_func, HLSL_REGSET_SAMPLERS);
     }
     else
     {
         allocate_buffers(ctx);
         allocate_objects(ctx, entry_func, HLSL_REGSET_TEXTURES);
         allocate_objects(ctx, entry_func, HLSL_REGSET_UAVS);
+        allocate_objects(ctx, entry_func, HLSL_REGSET_SAMPLERS);
     }
-    allocate_objects(ctx, entry_func, HLSL_REGSET_SAMPLERS);
 
     if (TRACE_ON())
         rb_for_each_entry(&ctx->functions, dump_function, ctx);
@@ -9265,7 +11981,11 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
             struct vsir_program program;
             int result;
 
-            sm1_generate_vsir(ctx, entry_func, config_flags, &program, &ctab);
+            sm1_generate_ctab(ctx, &ctab);
+            if (ctx->result)
+                return ctx->result;
+
+            sm1_generate_vsir(ctx, entry_func, config_flags, &program);
             if (ctx->result)
             {
                 vsir_program_cleanup(&program);
@@ -9282,18 +12002,25 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
         case VKD3D_SHADER_TARGET_DXBC_TPF:
         {
             uint32_t config_flags = vkd3d_shader_init_config_flags();
+            struct vkd3d_shader_code rdef = {0};
             struct vsir_program program;
             int result;
 
+            sm4_generate_rdef(ctx, &rdef);
+            if (ctx->result)
+                return ctx->result;
+
             sm4_generate_vsir(ctx, entry_func, config_flags, &program);
             if (ctx->result)
             {
                 vsir_program_cleanup(&program);
+                vkd3d_shader_free_shader_code(&rdef);
                 return ctx->result;
             }
 
-            result = tpf_compile(&program, config_flags, out, ctx->message_context, ctx, entry_func);
+            result = tpf_compile(&program, config_flags, &rdef, out, ctx->message_context);
             vsir_program_cleanup(&program);
+            vkd3d_shader_free_shader_code(&rdef);
             return result;
         }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
index 716adb15f08..e8dd4d62ae2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_constant_ops.c
@@ -30,7 +30,7 @@ static bool fold_abs(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -121,7 +121,7 @@ static bool fold_bit_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -143,20 +143,20 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
         const struct hlsl_type *dst_type, const struct hlsl_ir_constant *src)
 {
     unsigned int k;
-    uint32_t u;
-    int32_t i;
-    double d;
-    float f;
+    uint32_t u = 0;
+    double d = 0.0;
+    float f = 0.0f;
+    int32_t i = 0;
 
-    if (dst_type->dimx != src->node.data_type->dimx
-            || dst_type->dimy != src->node.data_type->dimy)
+    if (dst_type->e.numeric.dimx != src->node.data_type->e.numeric.dimx
+            || dst_type->e.numeric.dimy != src->node.data_type->e.numeric.dimy)
     {
         FIXME("Cast from %s to %s.\n", debug_hlsl_type(ctx, src->node.data_type),
                 debug_hlsl_type(ctx, dst_type));
         return false;
     }
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (src->node.data_type->e.numeric.type)
         {
@@ -195,9 +195,6 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                 f = !!src->value.u[k].u;
                 d = !!src->value.u[k].u;
                 break;
-
-            default:
-                vkd3d_unreachable();
         }
 
         switch (dst_type->e.numeric.type)
@@ -220,9 +217,8 @@ static bool fold_cast(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
                 break;
 
             case HLSL_TYPE_BOOL:
-                /* Casts to bool should have already been lowered. */
-            default:
-                vkd3d_unreachable();
+                dst->u[k].u = u ? ~0u : 0u;
+                break;
         }
     }
     return true;
@@ -236,7 +232,7 @@ static bool fold_ceil(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -262,7 +258,7 @@ static bool fold_exp2(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -288,7 +284,7 @@ static bool fold_floor(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -315,7 +311,7 @@ static bool fold_fract(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -341,7 +337,7 @@ static bool fold_log2(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -386,7 +382,7 @@ static bool fold_neg(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -420,7 +416,7 @@ static bool fold_not(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -444,7 +440,7 @@ static bool fold_rcp(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -489,7 +485,7 @@ static bool fold_rsq(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -529,7 +525,7 @@ static bool fold_sat(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -555,7 +551,7 @@ static bool fold_sqrt(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
 
     VKD3D_ASSERT(type == src->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -601,7 +597,7 @@ static bool fold_add(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -638,7 +634,7 @@ static bool fold_and(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -665,7 +661,7 @@ static bool fold_or(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, const
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -692,7 +688,7 @@ static bool fold_bit_xor(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -717,10 +713,10 @@ static bool fold_dot(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
 
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
-    VKD3D_ASSERT(src1->node.data_type->dimx == src2->node.data_type->dimx);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.dimx == src2->node.data_type->e.numeric.dimx);
 
     dst->u[0].f = 0.0f;
-    for (k = 0; k < src1->node.data_type->dimx; ++k)
+    for (k = 0; k < src1->node.data_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -746,11 +742,11 @@ static bool fold_dp2add(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src3->node.data_type->e.numeric.type);
-    VKD3D_ASSERT(src1->node.data_type->dimx == src2->node.data_type->dimx);
-    VKD3D_ASSERT(src3->node.data_type->dimx == 1);
+    VKD3D_ASSERT(src1->node.data_type->e.numeric.dimx == src2->node.data_type->e.numeric.dimx);
+    VKD3D_ASSERT(src3->node.data_type->e.numeric.dimx == 1);
 
     dst->u[0].f = src3->value.u[0].f;
-    for (k = 0; k < src1->node.data_type->dimx; ++k)
+    for (k = 0; k < src1->node.data_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -777,7 +773,7 @@ static bool fold_div(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -844,7 +840,7 @@ static bool fold_equal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, co
     VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
     VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (src1->node.data_type->e.numeric.type)
         {
@@ -862,9 +858,6 @@ static bool fold_equal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, co
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = src1->value.u[k].u == src2->value.u[k].u;
                 break;
-
-            default:
-                vkd3d_unreachable();
         }
 
         dst->u[k].u *= ~0u;
@@ -880,7 +873,7 @@ static bool fold_gequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
     VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (src1->node.data_type->e.numeric.type)
         {
@@ -901,9 +894,6 @@ static bool fold_gequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = src1->value.u[k].u >= src2->value.u[k].u;
                 break;
-
-            default:
-                vkd3d_unreachable();
         }
 
         dst->u[k].u *= ~0u;
@@ -919,7 +909,7 @@ static bool fold_less(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
     VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
     VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (src1->node.data_type->e.numeric.type)
         {
@@ -940,9 +930,6 @@ static bool fold_less(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, con
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = src1->value.u[k].u < src2->value.u[k].u;
                 break;
-
-            default:
-                vkd3d_unreachable();
         }
 
         dst->u[k].u *= ~0u;
@@ -958,16 +945,13 @@ static bool fold_lshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     VKD3D_ASSERT(dst_type->e.numeric.type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(src2->node.data_type->e.numeric.type == HLSL_TYPE_INT);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         unsigned int shift = src2->value.u[k].u % 32;
 
         switch (src1->node.data_type->e.numeric.type)
         {
             case HLSL_TYPE_INT:
-                dst->u[k].i = src1->value.u[k].i << shift;
-                break;
-
             case HLSL_TYPE_UINT:
                 dst->u[k].u = src1->value.u[k].u << shift;
                 break;
@@ -989,7 +973,7 @@ static bool fold_max(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -1027,7 +1011,7 @@ static bool fold_min(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -1066,7 +1050,7 @@ static bool fold_mod(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -1108,7 +1092,7 @@ static bool fold_mul(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, cons
     VKD3D_ASSERT(type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (type)
         {
@@ -1142,7 +1126,7 @@ static bool fold_nequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     VKD3D_ASSERT(dst_type->e.numeric.type == HLSL_TYPE_BOOL);
     VKD3D_ASSERT(src1->node.data_type->e.numeric.type == src2->node.data_type->e.numeric.type);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         switch (src1->node.data_type->e.numeric.type)
         {
@@ -1160,9 +1144,6 @@ static bool fold_nequal(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
             case HLSL_TYPE_BOOL:
                 dst->u[k].u = src1->value.u[k].u != src2->value.u[k].u;
                 break;
-
-            default:
-                vkd3d_unreachable();
         }
 
         dst->u[k].u *= ~0u;
@@ -1179,7 +1160,7 @@ static bool fold_ternary(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst,
     VKD3D_ASSERT(dst_type->e.numeric.type == src3->node.data_type->e.numeric.type);
     VKD3D_ASSERT(src1->node.data_type->e.numeric.type == HLSL_TYPE_BOOL);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
         dst->u[k] = src1->value.u[k].u ? src2->value.u[k] : src3->value.u[k];
 
     return true;
@@ -1193,7 +1174,7 @@ static bool fold_rshift(struct hlsl_ctx *ctx, struct hlsl_constant_value *dst, c
     VKD3D_ASSERT(dst_type->e.numeric.type == src1->node.data_type->e.numeric.type);
     VKD3D_ASSERT(src2->node.data_type->e.numeric.type == HLSL_TYPE_INT);
 
-    for (k = 0; k < dst_type->dimx; ++k)
+    for (k = 0; k < dst_type->e.numeric.dimx; ++k)
     {
         unsigned int shift = src2->value.u[k].u % 32;
 
@@ -1401,7 +1382,7 @@ static bool constant_is_zero(struct hlsl_ir_constant *const_arg)
     struct hlsl_type *data_type = const_arg->node.data_type;
     unsigned int k;
 
-    for (k = 0; k < data_type->dimx; ++k)
+    for (k = 0; k < data_type->e.numeric.dimx; ++k)
     {
         switch (data_type->e.numeric.type)
         {
@@ -1422,9 +1403,6 @@ static bool constant_is_zero(struct hlsl_ir_constant *const_arg)
                 if (const_arg->value.u[k].u != 0)
                     return false;
                 break;
-
-            default:
-                return false;
         }
     }
     return true;
@@ -1435,7 +1413,7 @@ static bool constant_is_one(struct hlsl_ir_constant *const_arg)
     struct hlsl_type *data_type = const_arg->node.data_type;
     unsigned int k;
 
-    for (k = 0; k < data_type->dimx; ++k)
+    for (k = 0; k < data_type->e.numeric.dimx; ++k)
     {
         switch (data_type->e.numeric.type)
         {
@@ -1460,9 +1438,6 @@ static bool constant_is_one(struct hlsl_ir_constant *const_arg)
                 if (const_arg->value.u[k].u != ~0)
                     return false;
                 break;
-
-            default:
-                return false;
         }
     }
     return true;
@@ -1544,6 +1519,250 @@ bool hlsl_fold_constant_identities(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
     return false;
 }
 
+static bool is_op_associative(enum hlsl_ir_expr_op op, enum hlsl_base_type type)
+{
+    switch (op)
+    {
+        case HLSL_OP2_ADD:
+        case HLSL_OP2_MUL:
+            return type == HLSL_TYPE_INT || type == HLSL_TYPE_UINT;
+
+        case HLSL_OP2_BIT_AND:
+        case HLSL_OP2_BIT_OR:
+        case HLSL_OP2_BIT_XOR:
+        case HLSL_OP2_LOGIC_AND:
+        case HLSL_OP2_LOGIC_OR:
+        case HLSL_OP2_MAX:
+        case HLSL_OP2_MIN:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+static bool is_op_commutative(enum hlsl_ir_expr_op op)
+{
+    switch (op)
+    {
+        case HLSL_OP2_ADD:
+        case HLSL_OP2_BIT_AND:
+        case HLSL_OP2_BIT_OR:
+        case HLSL_OP2_BIT_XOR:
+        case HLSL_OP2_DOT:
+        case HLSL_OP2_LOGIC_AND:
+        case HLSL_OP2_LOGIC_OR:
+        case HLSL_OP2_MAX:
+        case HLSL_OP2_MIN:
+        case HLSL_OP2_MUL:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+/* Returns true iff x OPL (y OPR z) = (x OPL y) OPR (x OPL z). */
+static bool is_op_left_distributive(enum hlsl_ir_expr_op opl, enum hlsl_ir_expr_op opr, enum hlsl_base_type type)
+{
+    switch (opl)
+    {
+        case HLSL_OP2_BIT_AND:
+            return opr == HLSL_OP2_BIT_OR || opr == HLSL_OP2_BIT_XOR;
+
+        case HLSL_OP2_BIT_OR:
+            return opr == HLSL_OP2_BIT_AND;
+
+        case HLSL_OP2_DOT:
+        case HLSL_OP2_MUL:
+            return opr == HLSL_OP2_ADD && (type == HLSL_TYPE_INT || type == HLSL_TYPE_UINT);
+
+        case HLSL_OP2_MAX:
+            return opr == HLSL_OP2_MIN;
+
+        case HLSL_OP2_MIN:
+            return opr == HLSL_OP2_MAX;
+
+        default:
+            return false;
+    }
+}
+
+/* Attempt to collect together the expression (x OPL a) OPR (x OPL b) -> x OPL (a OPR b). */
+static struct hlsl_ir_node *collect_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
+        enum hlsl_ir_expr_op opr, struct hlsl_ir_node *node1, struct hlsl_ir_node *node2)
+{
+    enum hlsl_base_type type = instr->data_type->e.numeric.type;
+    struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {0};
+    struct hlsl_ir_node *ab, *res;
+    struct hlsl_ir_expr *e1, *e2;
+    enum hlsl_ir_expr_op opl;
+
+    if (!node1 || !node2 || node1->type != HLSL_IR_EXPR || node2->type != HLSL_IR_EXPR)
+        return NULL;
+    e1 = hlsl_ir_expr(node1);
+    e2 = hlsl_ir_expr(node2);
+    opl = e1->op;
+
+    if (e2->op != opl || !is_op_left_distributive(opl, opr, type))
+        return NULL;
+    if (e1->operands[0].node != e2->operands[0].node)
+        return NULL;
+    if (e1->operands[1].node->type != HLSL_IR_CONSTANT || e2->operands[1].node->type != HLSL_IR_CONSTANT)
+        return NULL;
+
+    if (!(ab = hlsl_new_binary_expr(ctx, opr, e1->operands[1].node, e2->operands[1].node)))
+        return NULL;
+    list_add_before(&instr->entry, &ab->entry);
+
+    operands[0] = e1->operands[0].node;
+    operands[1] = ab;
+
+    if (!(res = hlsl_new_expr(ctx, opl, operands, instr->data_type, &instr->loc)))
+        return NULL;
+    list_add_before(&instr->entry, &res->entry);
+    return res;
+}
+
+bool hlsl_normalize_binary_exprs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
+{
+    struct hlsl_ir_node *arg1, *arg2, *tmp;
+    struct hlsl_ir_expr *expr;
+    enum hlsl_base_type type;
+    enum hlsl_ir_expr_op op;
+    bool progress = false;
+
+    if (instr->type != HLSL_IR_EXPR)
+        return false;
+    expr = hlsl_ir_expr(instr);
+
+    if (instr->data_type->class > HLSL_CLASS_VECTOR)
+        return false;
+
+    arg1 = expr->operands[0].node;
+    arg2 = expr->operands[1].node;
+    type = instr->data_type->e.numeric.type;
+    op = expr->op;
+
+    if (!arg1 || !arg2)
+        return false;
+
+    if ((tmp = collect_exprs(ctx, instr, op, arg1, arg2)))
+    {
+        /* (x OPL a) OPR (x OPL b) -> x OPL (a OPR b) */
+        hlsl_replace_node(instr, tmp);
+        return true;
+    }
+
+    if (is_op_commutative(op) && arg1->type == HLSL_IR_CONSTANT && arg2->type != HLSL_IR_CONSTANT)
+    {
+        /* a OP x -> x OP a */
+        tmp = arg1;
+        arg1 = arg2;
+        arg2 = tmp;
+        progress = true;
+    }
+
+    if (is_op_associative(op, type))
+    {
+        struct hlsl_ir_expr *e1 = arg1->type == HLSL_IR_EXPR ? hlsl_ir_expr(arg1) : NULL;
+        struct hlsl_ir_expr *e2 = arg2->type == HLSL_IR_EXPR ? hlsl_ir_expr(arg2) : NULL;
+
+        if (e1 && e1->op == op && e1->operands[0].node->type != HLSL_IR_CONSTANT
+                && e1->operands[1].node->type == HLSL_IR_CONSTANT)
+        {
+            if (arg2->type == HLSL_IR_CONSTANT)
+            {
+                /* (x OP a) OP b -> x OP (a OP b) */
+                struct hlsl_ir_node *ab;
+
+                if (!(ab = hlsl_new_binary_expr(ctx, op, e1->operands[1].node, arg2)))
+                    return false;
+                list_add_before(&instr->entry, &ab->entry);
+
+                arg1 = e1->operands[0].node;
+                arg2 = ab;
+                progress = true;
+            }
+            else if (is_op_commutative(op))
+            {
+                /* (x OP a) OP y -> (x OP y) OP a */
+                struct hlsl_ir_node *xy;
+
+                if (!(xy = hlsl_new_binary_expr(ctx, op, e1->operands[0].node, arg2)))
+                    return false;
+                list_add_before(&instr->entry, &xy->entry);
+
+                arg1 = xy;
+                arg2 = e1->operands[1].node;
+                progress = true;
+            }
+        }
+
+        if (!progress && arg1->type != HLSL_IR_CONSTANT && e2 && e2->op == op
+                && e2->operands[0].node->type != HLSL_IR_CONSTANT && e2->operands[1].node->type == HLSL_IR_CONSTANT)
+        {
+            /* x OP (y OP a) -> (x OP y) OP a */
+            struct hlsl_ir_node *xy;
+
+            if (!(xy = hlsl_new_binary_expr(ctx, op, arg1, e2->operands[0].node)))
+                return false;
+            list_add_before(&instr->entry, &xy->entry);
+
+            arg1 = xy;
+            arg2 = e2->operands[1].node;
+            progress = true;
+        }
+
+        if (!progress && e1 && (tmp = collect_exprs(ctx, instr, op, e1->operands[1].node, arg2)))
+        {
+            /* (y OPR (x OPL a)) OPR (x OPL b) -> y OPR (x OPL (a OPR b)) */
+            arg1 = e1->operands[0].node;
+            arg2 = tmp;
+            progress = true;
+        }
+
+        if (!progress && is_op_commutative(op) && e1
+                && (tmp = collect_exprs(ctx, instr, op, e1->operands[0].node, arg2)))
+        {
+            /* ((x OPL a) OPR y) OPR (x OPL b) -> (x OPL (a OPR b)) OPR y */
+            arg1 = tmp;
+            arg2 = e1->operands[1].node;
+            progress = true;
+        }
+
+        if (!progress && e2 && (tmp = collect_exprs(ctx, instr, op, arg1, e2->operands[0].node)))
+        {
+            /* (x OPL a) OPR ((x OPL b) OPR y) -> (x OPL (a OPR b)) OPR y */
+            arg1 = tmp;
+            arg2 = e2->operands[1].node;
+            progress = true;
+        }
+
+        if (!progress && is_op_commutative(op) && e2
+                && (tmp = collect_exprs(ctx, instr, op, arg1, e2->operands[1].node)))
+        {
+            /* (x OPL a) OPR (y OPR (x OPL b)) -> (x OPL (a OPR b)) OPR y */
+            arg1 = tmp;
+            arg2 = e2->operands[0].node;
+            progress = true;
+        }
+    }
+
+    if (progress)
+    {
+        struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = {arg1, arg2};
+        struct hlsl_ir_node *res;
+
+        if (!(res = hlsl_new_expr(ctx, op, operands, instr->data_type, &instr->loc)))
+            return false;
+        list_add_before(&instr->entry, &res->entry);
+        hlsl_replace_node(instr, res);
+    }
+
+    return progress;
+}
+
 bool hlsl_fold_constant_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
 {
     struct hlsl_constant_value value;
@@ -1559,8 +1778,8 @@ bool hlsl_fold_constant_swizzles(struct hlsl_ctx *ctx, struct hlsl_ir_node *inst
         return false;
     src = hlsl_ir_constant(swizzle->val.node);
 
-    for (i = 0; i < swizzle->node.data_type->dimx; ++i)
-        value.u[i] = src->value.u[hlsl_swizzle_get_component(swizzle->swizzle, i)];
+    for (i = 0; i < swizzle->node.data_type->e.numeric.dimx; ++i)
+        value.u[i] = src->value.u[hlsl_swizzle_get_component(swizzle->u.vector, i)];
 
     if (!(dst = hlsl_new_constant(ctx, instr->data_type, &value, &instr->loc)))
         return false;
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index b0e89bededb..3678ad0bacf 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2023 Conor McCarthy for CodeWeavers
+ * Copyright 2023-2024 Elizabeth Figura for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -201,6 +202,14 @@ static void src_param_init_const_uint(struct vkd3d_shader_src_param *src, uint32
     src->reg.u.immconst_u32[0] = value;
 }
 
+static void vsir_src_param_init_io(struct vkd3d_shader_src_param *src,
+        enum vkd3d_shader_register_type reg_type, const struct signature_element *e, unsigned int idx_count)
+{
+    vsir_src_param_init(src, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
+    src->reg.dimension = VSIR_DIMENSION_VEC4;
+    src->swizzle = vsir_swizzle_from_writemask(e->mask);
+}
+
 void vsir_src_param_init_label(struct vkd3d_shader_src_param *param, unsigned int label_id)
 {
     vsir_src_param_init(param, VKD3DSPR_LABEL, VKD3D_DATA_UNUSED, 1);
@@ -214,6 +223,14 @@ static void src_param_init_parameter(struct vkd3d_shader_src_param *src, uint32_
     src->reg.idx[0].offset = idx;
 }
 
+static void src_param_init_parameter_vec4(struct vkd3d_shader_src_param *src, uint32_t idx, enum vkd3d_data_type type)
+{
+    vsir_src_param_init(src, VKD3DSPR_PARAMETER, type, 1);
+    src->reg.idx[0].offset = idx;
+    src->reg.dimension = VSIR_DIMENSION_VEC4;
+    src->swizzle = VKD3D_SHADER_NO_SWIZZLE;
+}
+
 static void vsir_src_param_init_resource(struct vkd3d_shader_src_param *src, unsigned int id, unsigned int idx)
 {
     vsir_src_param_init(src, VKD3DSPR_RESOURCE, VKD3D_DATA_UNUSED, 2);
@@ -243,6 +260,14 @@ static void src_param_init_ssa_float(struct vkd3d_shader_src_param *src, unsigne
     src->reg.idx[0].offset = idx;
 }
 
+static void src_param_init_ssa_float4(struct vkd3d_shader_src_param *src, unsigned int idx)
+{
+    vsir_src_param_init(src, VKD3DSPR_SSA, VKD3D_DATA_FLOAT, 1);
+    src->reg.idx[0].offset = idx;
+    src->reg.dimension = VSIR_DIMENSION_VEC4;
+    src->swizzle = VKD3D_SHADER_NO_SWIZZLE;
+}
+
 static void src_param_init_temp_bool(struct vkd3d_shader_src_param *src, unsigned int idx)
 {
     vsir_src_param_init(src, VKD3DSPR_TEMP, VKD3D_DATA_BOOL, 1);
@@ -278,6 +303,14 @@ void vsir_dst_param_init(struct vkd3d_shader_dst_param *param, enum vkd3d_shader
     param->shift = 0;
 }
 
+static void vsir_dst_param_init_io(struct vkd3d_shader_dst_param *dst, enum vkd3d_shader_register_type reg_type,
+        const struct signature_element *e, unsigned int idx_count)
+{
+    vsir_dst_param_init(dst, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
+    dst->reg.dimension = VSIR_DIMENSION_VEC4;
+    dst->write_mask = e->mask;
+}
+
 static void dst_param_init_ssa_bool(struct vkd3d_shader_dst_param *dst, unsigned int idx)
 {
     vsir_dst_param_init(dst, VKD3DSPR_SSA, VKD3D_DATA_BOOL, 1);
@@ -290,6 +323,14 @@ static void dst_param_init_ssa_float(struct vkd3d_shader_dst_param *dst, unsigne
     dst->reg.idx[0].offset = idx;
 }
 
+static void dst_param_init_ssa_float4(struct vkd3d_shader_dst_param *dst, unsigned int idx)
+{
+    vsir_dst_param_init(dst, VKD3DSPR_SSA, VKD3D_DATA_FLOAT, 1);
+    dst->reg.idx[0].offset = idx;
+    dst->reg.dimension = VSIR_DIMENSION_VEC4;
+    dst->write_mask = VKD3DSP_WRITEMASK_ALL;
+}
+
 static void dst_param_init_temp_bool(struct vkd3d_shader_dst_param *dst, unsigned int idx)
 {
     vsir_dst_param_init(dst, VKD3DSPR_TEMP, VKD3D_DATA_BOOL, 1);
@@ -662,7 +703,56 @@ static enum vkd3d_result vsir_program_lower_sm1_sincos(struct vsir_program *prog
     return VKD3D_OK;
 }
 
-static enum vkd3d_result vsir_program_lower_tex(struct vsir_program *program, struct vkd3d_shader_instruction *tex)
+static enum vkd3d_result vsir_program_lower_texldp(struct vsir_program *program,
+        struct vkd3d_shader_instruction *tex, unsigned int *tmp_idx)
+{
+    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
+    struct vkd3d_shader_location *location = &tex->location;
+    struct vkd3d_shader_instruction *div_ins, *tex_ins;
+    size_t pos = tex - instructions->elements;
+    unsigned int w_comp;
+
+    w_comp = vsir_swizzle_get_component(tex->src[0].swizzle, 3);
+
+    if (!shader_instruction_array_insert_at(instructions, pos + 1, 2))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    if (*tmp_idx == ~0u)
+        *tmp_idx = program->temp_count++;
+
+    div_ins = &instructions->elements[pos + 1];
+    tex_ins = &instructions->elements[pos + 2];
+
+    if (!vsir_instruction_init_with_params(program, div_ins, location, VKD3DSIH_DIV, 1, 2))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    vsir_dst_param_init(&div_ins->dst[0], VKD3DSPR_TEMP, VKD3D_DATA_FLOAT, 1);
+    div_ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
+    div_ins->dst[0].reg.idx[0].offset = *tmp_idx;
+    div_ins->dst[0].write_mask = VKD3DSP_WRITEMASK_ALL;
+
+    div_ins->src[0] = tex->src[0];
+
+    div_ins->src[1] = tex->src[0];
+    div_ins->src[1].swizzle = vkd3d_shader_create_swizzle(w_comp, w_comp, w_comp, w_comp);
+
+    if (!vsir_instruction_init_with_params(program, tex_ins, location, VKD3DSIH_TEX, 1, 2))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    tex_ins->dst[0] = tex->dst[0];
+
+    tex_ins->src[0].reg = div_ins->dst[0].reg;
+    tex_ins->src[0].swizzle = VKD3D_SHADER_NO_SWIZZLE;
+
+    tex_ins->src[1] = tex->src[1];
+
+    vkd3d_shader_instruction_make_nop(tex);
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result vsir_program_lower_tex(struct vsir_program *program,
+        struct vkd3d_shader_instruction *tex, struct vkd3d_shader_message_context *message_context)
 {
     unsigned int idx = tex->src[1].reg.idx[0].offset;
     struct vkd3d_shader_src_param *srcs;
@@ -670,16 +760,34 @@ static enum vkd3d_result vsir_program_lower_tex(struct vsir_program *program, st
     VKD3D_ASSERT(tex->src[1].reg.idx_count == 1);
     VKD3D_ASSERT(!tex->src[1].reg.idx[0].rel_addr);
 
-    if (!(srcs = shader_src_param_allocator_get(&program->instructions.src_params, 3)))
+    if (!(srcs = shader_src_param_allocator_get(&program->instructions.src_params, 4)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
     srcs[0] = tex->src[0];
     vsir_src_param_init_resource(&srcs[1], idx, idx);
     vsir_src_param_init_sampler(&srcs[2], idx, idx);
 
-    tex->opcode = VKD3DSIH_SAMPLE;
-    tex->src = srcs;
-    tex->src_count = 3;
+    if (!tex->flags)
+    {
+        tex->opcode = VKD3DSIH_SAMPLE;
+        tex->src = srcs;
+        tex->src_count = 3;
+    }
+    else if (tex->flags == VKD3DSI_TEXLD_BIAS)
+    {
+        tex->opcode = VKD3DSIH_SAMPLE_B;
+        tex->src = srcs;
+        tex->src_count = 4;
+
+        srcs[3] = tex->src[0];
+        srcs[3].swizzle = VKD3D_SHADER_SWIZZLE(W, W, W, W);
+    }
+    else
+    {
+        vkd3d_shader_error(message_context, &tex->location,
+                VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED, "Unhandled tex flags %#x.", tex->flags);
+        return VKD3D_ERROR_NOT_IMPLEMENTED;
+    }
 
     return VKD3D_OK;
 }
@@ -709,6 +817,76 @@ static enum vkd3d_result vsir_program_lower_texldd(struct vsir_program *program,
     return VKD3D_OK;
 }
 
+static enum vkd3d_result vsir_program_lower_dcl_input(struct vsir_program *program,
+        struct vkd3d_shader_instruction *ins, struct vsir_transformation_context *ctx)
+{
+    switch (ins->declaration.dst.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+        case VKD3DSPR_OUTPUT:
+        case VKD3DSPR_PATCHCONST:
+        case VKD3DSPR_INCONTROLPOINT:
+        case VKD3DSPR_OUTCONTROLPOINT:
+            break;
+
+        case VKD3DSPR_PRIMID:
+        case VKD3DSPR_FORKINSTID:
+        case VKD3DSPR_JOININSTID:
+        case VKD3DSPR_THREADID:
+        case VKD3DSPR_THREADGROUPID:
+        case VKD3DSPR_LOCALTHREADID:
+        case VKD3DSPR_LOCALTHREADINDEX:
+        case VKD3DSPR_COVERAGE:
+        case VKD3DSPR_TESSCOORD:
+        case VKD3DSPR_OUTPOINTID:
+        case VKD3DSPR_GSINSTID:
+        case VKD3DSPR_WAVELANECOUNT:
+        case VKD3DSPR_WAVELANEINDEX:
+            bitmap_set(program->io_dcls, ins->declaration.dst.reg.type);
+            break;
+
+        default:
+            vkd3d_shader_error(ctx->message_context, &ins->location,
+                    VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Internal compiler error: invalid register type %#x for DCL_INPUT.",
+                    ins->declaration.dst.reg.type);
+            return VKD3D_ERROR;
+    }
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result vsir_program_lower_dcl_output(struct vsir_program *program,
+        struct vkd3d_shader_instruction *ins, struct vsir_transformation_context *ctx)
+{
+    switch (ins->declaration.dst.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+        case VKD3DSPR_OUTPUT:
+        case VKD3DSPR_PATCHCONST:
+        case VKD3DSPR_INCONTROLPOINT:
+        case VKD3DSPR_OUTCONTROLPOINT:
+            break;
+
+        case VKD3DSPR_DEPTHOUT:
+        case VKD3DSPR_SAMPLEMASK:
+        case VKD3DSPR_DEPTHOUTGE:
+        case VKD3DSPR_DEPTHOUTLE:
+        case VKD3DSPR_OUTSTENCILREF:
+            bitmap_set(program->io_dcls, ins->declaration.dst.reg.type);
+            break;
+
+        default:
+            vkd3d_shader_error(ctx->message_context, &ins->location,
+                    VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Internal compiler error: invalid register type %#x for DCL_OUTPUT.",
+                    ins->declaration.dst.reg.type);
+            return VKD3D_ERROR;
+    }
+
+    return VKD3D_OK;
+}
+
 static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
@@ -743,19 +921,47 @@ static enum vkd3d_result vsir_program_lower_instructions(struct vsir_program *pr
             case VKD3DSIH_DCL_GLOBAL_FLAGS:
             case VKD3DSIH_DCL_SAMPLER:
             case VKD3DSIH_DCL_TEMPS:
+            case VKD3DSIH_DCL_TESSELLATOR_DOMAIN:
             case VKD3DSIH_DCL_THREAD_GROUP:
             case VKD3DSIH_DCL_UAV_TYPED:
                 vkd3d_shader_instruction_make_nop(ins);
                 break;
 
+            case VKD3DSIH_DCL_INPUT:
+                vsir_program_lower_dcl_input(program, ins, ctx);
+                vkd3d_shader_instruction_make_nop(ins);
+                break;
+
+            case VKD3DSIH_DCL_OUTPUT:
+                vsir_program_lower_dcl_output(program, ins, ctx);
+                vkd3d_shader_instruction_make_nop(ins);
+                break;
+
+            case VKD3DSIH_DCL_INPUT_SGV:
+            case VKD3DSIH_DCL_INPUT_SIV:
+            case VKD3DSIH_DCL_INPUT_PS:
+            case VKD3DSIH_DCL_INPUT_PS_SGV:
+            case VKD3DSIH_DCL_INPUT_PS_SIV:
+            case VKD3DSIH_DCL_OUTPUT_SIV:
+                vkd3d_shader_instruction_make_nop(ins);
+                break;
+
             case VKD3DSIH_SINCOS:
                 if ((ret = vsir_program_lower_sm1_sincos(program, ins)) < 0)
                     return ret;
                 break;
 
             case VKD3DSIH_TEX:
-                if ((ret = vsir_program_lower_tex(program, ins)) < 0)
-                    return ret;
+                if (ins->flags == VKD3DSI_TEXLD_PROJECT)
+                {
+                    if ((ret = vsir_program_lower_texldp(program, ins, &tmp_idx)) < 0)
+                        return ret;
+                }
+                else
+                {
+                    if ((ret = vsir_program_lower_tex(program, ins, message_context)) < 0)
+                        return ret;
+                }
                 break;
 
             case VKD3DSIH_TEXLDD:
@@ -847,11 +1053,36 @@ static enum vkd3d_result vsir_program_ensure_ret(struct vsir_program *program,
     return VKD3D_OK;
 }
 
+static bool add_signature_element(struct shader_signature *signature, const char *semantic_name,
+        uint32_t semantic_index, uint32_t mask, uint32_t register_index,
+        enum vkd3d_shader_interpolation_mode interpolation_mode)
+{
+    struct signature_element *new_elements, *e;
+
+    if (!(new_elements = vkd3d_realloc(signature->elements,
+            (signature->element_count + 1) * sizeof(*signature->elements))))
+        return false;
+    signature->elements = new_elements;
+    e = &signature->elements[signature->element_count++];
+    memset(e, 0, sizeof(*e));
+    e->semantic_name = vkd3d_strdup(semantic_name);
+    e->semantic_index = semantic_index;
+    e->sysval_semantic = VKD3D_SHADER_SV_NONE;
+    e->component_type = VKD3D_SHADER_COMPONENT_FLOAT;
+    e->register_count = 1;
+    e->mask = mask;
+    e->used_mask = mask;
+    e->register_index = register_index;
+    e->target_location = register_index;
+    e->interpolation_mode = interpolation_mode;
+    return true;
+}
+
 static enum vkd3d_result vsir_program_add_diffuse_output(struct vsir_program *program,
         struct vsir_transformation_context *ctx)
 {
     struct shader_signature *signature = &program->output_signature;
-    struct signature_element *new_elements, *e;
+    struct signature_element *e;
 
     if (program->shader_version.type != VKD3D_SHADER_TYPE_VERTEX)
         return VKD3D_OK;
@@ -864,22 +1095,8 @@ static enum vkd3d_result vsir_program_add_diffuse_output(struct vsir_program *pr
         return VKD3D_OK;
     }
 
-    if (!(new_elements = vkd3d_realloc(signature->elements,
-            (signature->element_count + 1) * sizeof(*signature->elements))))
+    if (!add_signature_element(signature, "COLOR", 0, VKD3DSP_WRITEMASK_ALL, SM1_COLOR_REGISTER_OFFSET, VKD3DSIM_NONE))
         return VKD3D_ERROR_OUT_OF_MEMORY;
-    signature->elements = new_elements;
-    e = &signature->elements[signature->element_count++];
-    memset(e, 0, sizeof(*e));
-    e->semantic_name = vkd3d_strdup("COLOR");
-    e->sysval_semantic = VKD3D_SHADER_SV_NONE;
-    e->component_type = VKD3D_SHADER_COMPONENT_FLOAT;
-    e->register_count = 1;
-    e->mask = VKD3DSP_WRITEMASK_ALL;
-    e->used_mask = VKD3DSP_WRITEMASK_ALL;
-    e->register_index = SM1_COLOR_REGISTER_OFFSET;
-    e->target_location = SM1_COLOR_REGISTER_OFFSET;
-    e->interpolation_mode = VKD3DSIM_NONE;
-
     return VKD3D_OK;
 }
 
@@ -975,6 +1192,7 @@ static void remove_unread_output_components(const struct shader_signature *signa
     switch (dst->reg.type)
     {
         case VKD3DSPR_OUTPUT:
+        case VKD3DSPR_TEXCRDOUT:
             e = vsir_signature_find_element_for_reg(signature, dst->reg.idx[0].offset, 0);
             break;
 
@@ -1034,6 +1252,9 @@ static enum vkd3d_result vsir_program_remap_output_signature(struct vsir_program
 
             e->target_location = map->input_register_index;
 
+            TRACE("Mapping signature index %u (mask %#x) to target location %u (mask %#x).\n",
+                    i, e->mask, map->input_register_index, map->input_mask);
+
             if ((input_mask & e->mask) == input_mask)
             {
                 ++subset_varying_count;
@@ -1054,6 +1275,8 @@ static enum vkd3d_result vsir_program_remap_output_signature(struct vsir_program
         }
         else
         {
+            TRACE("Marking signature index %u (mask %#x) as unused.\n", i, e->mask);
+
             e->target_location = SIGNATURE_TARGET_LOCATION_UNUSED;
         }
 
@@ -1213,12 +1436,6 @@ static void flattener_eliminate_phase_related_dcls(struct hull_flattener *normal
         vkd3d_shader_instruction_make_nop(ins);
         return;
     }
-    else if (ins->opcode == VKD3DSIH_DCL_INPUT && shader_register_is_phase_instance_id(
-            &ins->declaration.dst.reg))
-    {
-        vkd3d_shader_instruction_make_nop(ins);
-        return;
-    }
 
     if (normaliser->phase == VKD3DSIH_INVALID || vsir_instruction_is_dcl(ins))
         return;
@@ -1369,25 +1586,15 @@ static void shader_dst_param_normalise_outpointid(struct vkd3d_shader_dst_param
     }
 }
 
-static void shader_dst_param_io_init(struct vkd3d_shader_dst_param *param, const struct signature_element *e,
-        enum vkd3d_shader_register_type reg_type, unsigned int idx_count)
-{
-    param->write_mask = e->mask;
-    param->modifiers = 0;
-    param->shift = 0;
-    vsir_register_init(&param->reg, reg_type, vkd3d_data_type_from_component_type(e->component_type), idx_count);
-}
-
 static enum vkd3d_result control_point_normaliser_emit_hs_input(struct control_point_normaliser *normaliser,
         const struct shader_signature *s, unsigned int input_control_point_count, unsigned int dst,
         const struct vkd3d_shader_location *location)
 {
     struct vkd3d_shader_instruction *ins;
-    struct vkd3d_shader_dst_param *param;
     const struct signature_element *e;
-    unsigned int i, count;
+    unsigned int i, count = 2;
 
-    for (i = 0, count = 1; i < s->element_count; ++i)
+    for (i = 0; i < s->element_count; ++i)
         count += !!s->elements[i].used_mask;
 
     if (!shader_instruction_array_reserve(&normaliser->instructions, normaliser->instructions.count + count))
@@ -1399,7 +1606,7 @@ static enum vkd3d_result control_point_normaliser_emit_hs_input(struct control_p
 
     ins = &normaliser->instructions.elements[dst];
     vsir_instruction_init(ins, location, VKD3DSIH_HS_CONTROL_POINT_PHASE);
-    ins->flags = 1;
+
     ++ins;
 
     for (i = 0; i < s->element_count; ++i)
@@ -1408,26 +1615,35 @@ static enum vkd3d_result control_point_normaliser_emit_hs_input(struct control_p
         if (!e->used_mask)
             continue;
 
-        if (e->sysval_semantic != VKD3D_SHADER_SV_NONE)
-        {
-            vsir_instruction_init(ins, location, VKD3DSIH_DCL_INPUT_SIV);
-            param = &ins->declaration.register_semantic.reg;
-            ins->declaration.register_semantic.sysval_semantic = vkd3d_siv_from_sysval(e->sysval_semantic);
-        }
-        else
+        vsir_instruction_init(ins, location, VKD3DSIH_MOV);
+        ins->dst = shader_dst_param_allocator_get(&normaliser->instructions.dst_params, 1);
+        ins->dst_count = 1;
+        ins->src = shader_src_param_allocator_get(&normaliser->instructions.src_params, 1);
+        ins->src_count = 1;
+
+        if (!ins->dst || ! ins->src)
         {
-            vsir_instruction_init(ins, location, VKD3DSIH_DCL_INPUT);
-            param = &ins->declaration.dst;
+            WARN("Failed to allocate dst/src param.\n");
+            return VKD3D_ERROR_OUT_OF_MEMORY;
         }
 
-        shader_dst_param_io_init(param, e, VKD3DSPR_INPUT, 2);
-        param->reg.idx[0].offset = input_control_point_count;
-        param->reg.idx[1].offset = e->register_index;
-        param->write_mask = e->mask;
+        vsir_dst_param_init_io(&ins->dst[0], VKD3DSPR_OUTPUT, e, 2);
+        ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
+        ins->dst[0].reg.idx[0].offset = 0;
+        ins->dst[0].reg.idx[0].rel_addr = normaliser->outpointid_param;
+        ins->dst[0].reg.idx[1].offset = e->register_index;
+
+        vsir_src_param_init_io(&ins->src[0], VKD3DSPR_INPUT, e, 2);
+        ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
+        ins->src[0].reg.idx[0].offset = 0;
+        ins->src[0].reg.idx[0].rel_addr = normaliser->outpointid_param;
+        ins->src[0].reg.idx[1].offset = e->register_index;
 
         ++ins;
     }
 
+    vsir_instruction_init(ins, location, VKD3DSIH_RET);
+
     return VKD3D_OK;
 }
 
@@ -1442,7 +1658,7 @@ static enum vkd3d_result instruction_array_normalise_hull_shader_control_point_i
     enum vkd3d_result ret;
     unsigned int i, j;
 
-    VKD3D_ASSERT(program->normalisation_level == VSIR_NOT_NORMALISED);
+    VKD3D_ASSERT(program->normalisation_level == VSIR_NORMALISED_SM4);
 
     if (program->shader_version.type != VKD3D_SHADER_TYPE_HULL)
     {
@@ -1545,11 +1761,6 @@ static bool io_normaliser_is_in_fork_or_join_phase(const struct io_normaliser *n
     return normaliser->phase == VKD3DSIH_HS_FORK_PHASE || normaliser->phase == VKD3DSIH_HS_JOIN_PHASE;
 }
 
-static bool io_normaliser_is_in_control_point_phase(const struct io_normaliser *normaliser)
-{
-    return normaliser->phase == VKD3DSIH_HS_CONTROL_POINT_PHASE;
-}
-
 static bool shader_signature_find_element_for_reg(const struct shader_signature *signature,
         unsigned int reg_idx, unsigned int write_mask, unsigned int *element_idx)
 {
@@ -1820,7 +2031,8 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
     element_count = s->element_count;
     if (!(elements = vkd3d_malloc(element_count * sizeof(*elements))))
         return false;
-    memcpy(elements, s->elements, element_count * sizeof(*elements));
+    if (element_count)
+        memcpy(elements, s->elements, element_count * sizeof(*elements));
 
     for (i = 0; i < element_count; ++i)
         elements[i].sort_index = i;
@@ -1920,41 +2132,26 @@ static unsigned int shader_register_normalise_arrayed_addressing(struct vkd3d_sh
 {
     VKD3D_ASSERT(id_idx < ARRAY_SIZE(reg->idx) - 1);
 
-    /* For a relative-addressed register index, move the id up a slot to separate it from the address,
-     * because rel_addr can be replaced with a constant offset in some cases. */
-    if (reg->idx[id_idx].rel_addr)
-    {
-        reg->idx[id_idx + 1].rel_addr = NULL;
-        reg->idx[id_idx + 1].offset = reg->idx[id_idx].offset;
-        reg->idx[id_idx].offset -= register_index;
-        if (id_idx)
-        {
-            /* idx[id_idx] now contains the array index, which must be moved below the control point id. */
-            struct vkd3d_shader_register_index tmp = reg->idx[id_idx];
-            reg->idx[id_idx] = reg->idx[id_idx - 1];
-            reg->idx[id_idx - 1] = tmp;
-        }
-        ++id_idx;
-    }
-    /* Otherwise we have no address for the arrayed register, so insert one. This happens e.g. where
-     * tessellation level registers are merged into an array because they're an array in SPIR-V. */
-    else
-    {
-        ++id_idx;
-        memmove(&reg->idx[1], &reg->idx[0], id_idx * sizeof(reg->idx[0]));
-        reg->idx[0].rel_addr = NULL;
-        reg->idx[0].offset = reg->idx[id_idx].offset - register_index;
-    }
+    /* Make room for the array index at the front of the array. */
+    ++id_idx;
+    memmove(&reg->idx[1], &reg->idx[0], id_idx * sizeof(reg->idx[0]));
+
+    /* The array index inherits the register relative address, but is offsetted
+     * by the signature element register index. */
+    reg->idx[0].rel_addr = reg->idx[id_idx].rel_addr;
+    reg->idx[0].offset = reg->idx[id_idx].offset - register_index;
+    reg->idx[id_idx].rel_addr = NULL;
+
+    /* The signature index offset will be fixed in the caller. */
 
     return id_idx;
 }
 
-static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_param, bool is_io_dcl,
+static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_param,
          struct io_normaliser *normaliser)
  {
     unsigned int id_idx, reg_idx, write_mask, element_idx;
     struct vkd3d_shader_register *reg = &dst_param->reg;
-    struct vkd3d_shader_dst_param **dcl_params;
     const struct shader_signature *signature;
     const struct signature_element *e;
 
@@ -1970,26 +2167,23 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
                 /* Convert patch constant outputs to the patch constant register type to avoid the need
                  * to convert compiler symbols when accessed as inputs in a later stage. */
                 reg->type = VKD3DSPR_PATCHCONST;
-                dcl_params = normaliser->pc_dcl_params;
             }
             else
             {
                 signature = normaliser->output_signature;
-                dcl_params = normaliser->output_dcl_params;
             }
             break;
 
         case VKD3DSPR_PATCHCONST:
             reg_idx = reg->idx[reg->idx_count - 1].offset;
             signature = normaliser->patch_constant_signature;
-            dcl_params = normaliser->pc_dcl_params;
             break;
 
+        case VKD3DSPR_TEXCRDOUT:
         case VKD3DSPR_COLOROUT:
             reg_idx = reg->idx[0].offset;
             signature = normaliser->output_signature;
             reg->type = VKD3DSPR_OUTPUT;
-            dcl_params = normaliser->output_dcl_params;
             break;
 
         case VKD3DSPR_INCONTROLPOINT:
@@ -1997,14 +2191,12 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
             reg_idx = reg->idx[reg->idx_count - 1].offset;
             signature = normaliser->input_signature;
             reg->type = VKD3DSPR_INPUT;
-            dcl_params = normaliser->input_dcl_params;
             break;
 
         case VKD3DSPR_ATTROUT:
             reg_idx = SM1_COLOR_REGISTER_OFFSET + reg->idx[0].offset;
             signature = normaliser->output_signature;
             reg->type = VKD3DSPR_OUTPUT;
-            dcl_params = normaliser->output_dcl_params;
             break;
 
         case VKD3DSPR_RASTOUT:
@@ -2014,7 +2206,6 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
             reg_idx = SM1_RASTOUT_REGISTER_OFFSET + reg->idx[0].offset;
             signature = normaliser->output_signature;
             reg->type = VKD3DSPR_OUTPUT;
-            dcl_params = normaliser->output_dcl_params;
             /* Fog and point size are scalar, but fxc/d3dcompiler emits a full
              * write mask when writing to them. */
             if (reg->idx[0].offset > 0)
@@ -2030,54 +2221,8 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
         vkd3d_unreachable();
     e = &signature->elements[element_idx];
 
-    if (is_io_dcl)
-    {
-        /* Validated in the TPF reader. */
-        VKD3D_ASSERT(element_idx < ARRAY_SIZE(normaliser->input_dcl_params));
-
-        if (dcl_params[element_idx])
-        {
-            /* Merge split declarations into a single one. */
-            dcl_params[element_idx]->write_mask |= dst_param->write_mask;
-            /* Turn this into a nop. */
-            return false;
-        }
-        else
-        {
-            dcl_params[element_idx] = dst_param;
-        }
-    }
-
-    if (io_normaliser_is_in_control_point_phase(normaliser) && reg->type == VKD3DSPR_OUTPUT)
-    {
-        if (is_io_dcl)
-        {
-            /* Emit an array size for the control points for consistency with inputs. */
-            reg->idx[0].offset = normaliser->output_control_point_count;
-        }
-        else
-        {
-            /* The control point id param. */
-            VKD3D_ASSERT(reg->idx[0].rel_addr);
-        }
-        id_idx = 1;
-    }
-
     if ((e->register_count > 1 || vsir_sysval_semantic_is_tess_factor(e->sysval_semantic)))
-    {
-        if (is_io_dcl)
-        {
-            /* For control point I/O, idx 0 contains the control point count.
-             * Ensure it is moved up to the next slot. */
-            reg->idx[id_idx].offset = reg->idx[0].offset;
-            reg->idx[0].offset = e->register_count;
-            ++id_idx;
-        }
-        else
-        {
-            id_idx = shader_register_normalise_arrayed_addressing(reg, id_idx, e->register_index);
-        }
-    }
+        id_idx = shader_register_normalise_arrayed_addressing(reg, id_idx, e->register_index);
 
     /* Replace the register index with the signature element index */
     reg->idx[id_idx].offset = element_idx;
@@ -2129,6 +2274,8 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
 
         case VKD3DSPR_OUTCONTROLPOINT:
             reg->type = VKD3DSPR_OUTPUT;
+            if (io_normaliser_is_in_fork_or_join_phase(normaliser))
+                normaliser->use_vocp = true;
             /* fall through */
         case VKD3DSPR_OUTPUT:
             reg_idx = reg->idx[reg->idx_count - 1].offset;
@@ -2136,8 +2283,6 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
             break;
 
         case VKD3DSPR_TEXTURE:
-            if (normaliser->shader_type != VKD3D_SHADER_TYPE_PIXEL)
-                return;
             reg->type = VKD3DSPR_INPUT;
             reg_idx = reg->idx[0].offset;
             signature = normaliser->input_signature;
@@ -2169,40 +2314,10 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
 static void shader_instruction_normalise_io_params(struct vkd3d_shader_instruction *ins,
         struct io_normaliser *normaliser)
 {
-    struct vkd3d_shader_register *reg;
     unsigned int i;
 
     switch (ins->opcode)
     {
-        case VKD3DSIH_DCL_INPUT:
-            if (normaliser->shader_type == VKD3D_SHADER_TYPE_HULL)
-            {
-                reg = &ins->declaration.dst.reg;
-
-                if (reg->type == VKD3DSPR_OUTCONTROLPOINT)
-                    normaliser->use_vocp = true;
-
-                /* We don't need to keep OUTCONTROLPOINT or PATCHCONST input declarations since their
-                * equivalents were declared earlier, but INCONTROLPOINT may be the first occurrence. */
-                if (reg->type == VKD3DSPR_OUTCONTROLPOINT || reg->type == VKD3DSPR_PATCHCONST)
-                    vkd3d_shader_instruction_make_nop(ins);
-                else if (reg->type == VKD3DSPR_INCONTROLPOINT)
-                    reg->type = VKD3DSPR_INPUT;
-            }
-            /* fall through */
-        case VKD3DSIH_DCL_INPUT_PS:
-        case VKD3DSIH_DCL_OUTPUT:
-            if (!shader_dst_param_io_normalise(&ins->declaration.dst, true, normaliser))
-                vkd3d_shader_instruction_make_nop(ins);
-            break;
-        case VKD3DSIH_DCL_INPUT_SGV:
-        case VKD3DSIH_DCL_INPUT_SIV:
-        case VKD3DSIH_DCL_INPUT_PS_SGV:
-        case VKD3DSIH_DCL_INPUT_PS_SIV:
-        case VKD3DSIH_DCL_OUTPUT_SIV:
-            if (!shader_dst_param_io_normalise(&ins->declaration.register_semantic.reg, true, normaliser))
-                vkd3d_shader_instruction_make_nop(ins);
-            break;
         case VKD3DSIH_HS_CONTROL_POINT_PHASE:
         case VKD3DSIH_HS_FORK_PHASE:
         case VKD3DSIH_HS_JOIN_PHASE:
@@ -2215,7 +2330,7 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
             if (vsir_instruction_is_dcl(ins))
                 break;
             for (i = 0; i < ins->dst_count; ++i)
-                shader_dst_param_io_normalise(&ins->dst[i], false, normaliser);
+                shader_dst_param_io_normalise(&ins->dst[i], normaliser);
             for (i = 0; i < ins->src_count; ++i)
                 shader_src_param_io_normalise(&ins->src[i], normaliser);
             break;
@@ -2275,7 +2390,7 @@ static enum vkd3d_result vsir_program_normalise_io_registers(struct vsir_program
 
     program->instructions = normaliser.instructions;
     program->use_vocp = normaliser.use_vocp;
-    program->normalisation_level = VSIR_FULLY_NORMALISED_IO;
+    program->normalisation_level = VSIR_NORMALISED_SM6;
     return VKD3D_OK;
 }
 
@@ -2299,16 +2414,12 @@ static bool get_flat_constant_register_type(const struct vkd3d_shader_register *
     {
         enum vkd3d_shader_register_type type;
         enum vkd3d_shader_d3dbc_constant_register set;
-        uint32_t offset;
     }
     regs[] =
     {
-        {VKD3DSPR_CONST, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 0},
-        {VKD3DSPR_CONST2, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 2048},
-        {VKD3DSPR_CONST3, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 4096},
-        {VKD3DSPR_CONST4, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER, 6144},
-        {VKD3DSPR_CONSTINT, VKD3D_SHADER_D3DBC_INT_CONSTANT_REGISTER, 0},
-        {VKD3DSPR_CONSTBOOL, VKD3D_SHADER_D3DBC_BOOL_CONSTANT_REGISTER, 0},
+        {VKD3DSPR_CONST, VKD3D_SHADER_D3DBC_FLOAT_CONSTANT_REGISTER},
+        {VKD3DSPR_CONSTINT, VKD3D_SHADER_D3DBC_INT_CONSTANT_REGISTER},
+        {VKD3DSPR_CONSTBOOL, VKD3D_SHADER_D3DBC_BOOL_CONSTANT_REGISTER},
     };
 
     unsigned int i;
@@ -2324,7 +2435,7 @@ static bool get_flat_constant_register_type(const struct vkd3d_shader_register *
             }
 
             *set = regs[i].set;
-            *index = regs[i].offset + reg->idx[0].offset;
+            *index = reg->idx[0].offset;
             return true;
         }
     }
@@ -3726,7 +3837,8 @@ static enum vkd3d_result vsir_cfg_structure_list_append_from_region(struct vsir_
             sizeof(*list->structures)))
         return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    memcpy(&list->structures[list->count], begin, size * sizeof(*begin));
+    if (size)
+        memcpy(&list->structures[list->count], begin, size * sizeof(*begin));
 
     list->count += size;
 
@@ -4663,7 +4775,8 @@ static enum vkd3d_result vsir_cfg_generate_synthetic_loop_intervals(struct vsir_
         }
     }
 
-    qsort(cfg->loop_intervals, cfg->loop_interval_count, sizeof(*cfg->loop_intervals), compare_loop_intervals);
+    if (cfg->loop_intervals)
+        qsort(cfg->loop_intervals, cfg->loop_interval_count, sizeof(*cfg->loop_intervals), compare_loop_intervals);
 
     if (TRACE_ON())
         for (i = 0; i < cfg->loop_interval_count; ++i)
@@ -6634,52 +6747,486 @@ static enum vkd3d_result vsir_program_insert_point_coord(struct vsir_program *pr
     return VKD3D_OK;
 }
 
-struct validation_context
+static enum vkd3d_result vsir_program_add_fog_input(struct vsir_program *program,
+        struct vsir_transformation_context *ctx)
 {
-    struct vkd3d_shader_message_context *message_context;
-    const struct vsir_program *program;
-    size_t instruction_idx;
-    struct vkd3d_shader_location null_location;
-    bool invalid_instruction_idx;
-    enum vkd3d_result status;
-    bool dcl_temps_found;
-    enum vkd3d_shader_opcode phase;
-    bool inside_block;
-
-    struct validation_context_temp_data
-    {
-        enum vsir_dimension dimension;
-        size_t first_seen;
-    } *temps;
+    struct shader_signature *signature = &program->input_signature;
+    uint32_t register_idx = 0;
 
-    struct validation_context_ssa_data
-    {
-        enum vsir_dimension dimension;
-        enum vkd3d_data_type data_type;
-        size_t first_seen;
-        uint32_t write_mask;
-        uint32_t read_mask;
-        size_t first_assigned;
-    } *ssas;
+    if (program->shader_version.type != VKD3D_SHADER_TYPE_PIXEL)
+        return VKD3D_OK;
 
-    enum vkd3d_shader_opcode *blocks;
-    size_t depth;
-    size_t blocks_capacity;
-};
+    if (!vsir_program_get_parameter(program, VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE))
+        return VKD3D_OK;
 
-static void VKD3D_PRINTF_FUNC(3, 4) validator_error(struct validation_context *ctx,
-        enum vkd3d_shader_error error, const char *format, ...)
-{
-    struct vkd3d_string_buffer buf;
-    va_list args;
+    /* We could check the value and skip this if NONE, but chances are if a
+     * user specifies the fog fragment mode as a parameter, they'll want to
+     * enable it dynamically. Always specifying it (and hence always outputting
+     * it from the VS) avoids an extra VS variant. */
 
-    vkd3d_string_buffer_init(&buf);
+    if (vsir_signature_find_element_by_name(signature, "FOG", 0))
+        return VKD3D_OK;
 
-    va_start(args, format);
-    vkd3d_string_buffer_vprintf(&buf, format, args);
-    va_end(args);
+    for (unsigned int i = 0; i < signature->element_count; ++i)
+        register_idx = max(register_idx, signature->elements[i].register_index + 1);
 
-    if (ctx->invalid_instruction_idx)
+    if (!add_signature_element(signature, "FOG", 0, VKD3DSP_WRITEMASK_0, register_idx, VKD3DSIM_LINEAR))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result insert_fragment_fog_before_ret(struct vsir_program *program,
+        const struct vkd3d_shader_instruction *ret, enum vkd3d_shader_fog_fragment_mode mode,
+        uint32_t fog_signature_idx, uint32_t colour_signature_idx, uint32_t colour_temp,
+        size_t *ret_pos, struct vkd3d_shader_message_context *message_context)
+{
+    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
+    struct vkd3d_shader_location loc = ret->location;
+    uint32_t ssa_factor = program->ssa_count++;
+    size_t pos = ret - instructions->elements;
+    struct vkd3d_shader_instruction *ins;
+    uint32_t ssa_temp, ssa_temp2;
+
+    switch (mode)
+    {
+        case VKD3D_SHADER_FOG_FRAGMENT_LINEAR:
+            /* We generate the following code:
+             *
+             * add sr0, FOG_END, -vFOG.x
+             * mul_sat srFACTOR, sr0, FOG_SCALE
+             */
+            if (!shader_instruction_array_insert_at(&program->instructions, pos, 4))
+                return VKD3D_ERROR_OUT_OF_MEMORY;
+            *ret_pos = pos + 4;
+
+            ssa_temp = program->ssa_count++;
+
+            ins = &program->instructions.elements[pos];
+
+            vsir_instruction_init_with_params(program, ins, &loc, VKD3DSIH_ADD, 1, 2);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_temp);
+            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_END, VKD3D_DATA_FLOAT);
+            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 1);
+            ins->src[1].reg.idx[0].offset = fog_signature_idx;
+            ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
+            ins->src[1].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+            ins->src[1].modifiers = VKD3DSPSM_NEG;
+
+            vsir_instruction_init_with_params(program, ++ins, &loc, VKD3DSIH_MUL, 1, 2);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_factor);
+            ins->dst[0].modifiers = VKD3DSPDM_SATURATE;
+            src_param_init_ssa_float(&ins->src[0], ssa_temp);
+            src_param_init_parameter(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VKD3D_DATA_FLOAT);
+            break;
+
+        case VKD3D_SHADER_FOG_FRAGMENT_EXP:
+            /* We generate the following code:
+             *
+             * mul sr0, FOG_SCALE, vFOG.x
+             * exp_sat srFACTOR, -sr0
+             */
+            if (!shader_instruction_array_insert_at(&program->instructions, pos, 4))
+                return VKD3D_ERROR_OUT_OF_MEMORY;
+            *ret_pos = pos + 4;
+
+            ssa_temp = program->ssa_count++;
+
+            ins = &program->instructions.elements[pos];
+
+            vsir_instruction_init_with_params(program, ins, &loc, VKD3DSIH_MUL, 1, 2);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_temp);
+            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VKD3D_DATA_FLOAT);
+            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 1);
+            ins->src[1].reg.idx[0].offset = fog_signature_idx;
+            ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
+            ins->src[1].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+
+            vsir_instruction_init_with_params(program, ++ins, &loc, VKD3DSIH_EXP, 1, 1);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_factor);
+            ins->dst[0].modifiers = VKD3DSPDM_SATURATE;
+            src_param_init_ssa_float(&ins->src[0], ssa_temp);
+            ins->src[0].modifiers = VKD3DSPSM_NEG;
+            break;
+
+        case VKD3D_SHADER_FOG_FRAGMENT_EXP2:
+            /* We generate the following code:
+             *
+             * mul sr0, FOG_SCALE, vFOG.x
+             * mul sr1, sr0, sr0
+             * exp_sat srFACTOR, -sr1
+             */
+            if (!shader_instruction_array_insert_at(&program->instructions, pos, 5))
+                return VKD3D_ERROR_OUT_OF_MEMORY;
+            *ret_pos = pos + 5;
+
+            ssa_temp = program->ssa_count++;
+            ssa_temp2 = program->ssa_count++;
+
+            ins = &program->instructions.elements[pos];
+
+            vsir_instruction_init_with_params(program, ins, &loc, VKD3DSIH_MUL, 1, 2);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_temp);
+            src_param_init_parameter(&ins->src[0], VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, VKD3D_DATA_FLOAT);
+            vsir_src_param_init(&ins->src[1], VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 1);
+            ins->src[1].reg.idx[0].offset = fog_signature_idx;
+            ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
+            ins->src[1].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+
+            vsir_instruction_init_with_params(program, ++ins, &loc, VKD3DSIH_MUL, 1, 2);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_temp2);
+            src_param_init_ssa_float(&ins->src[0], ssa_temp);
+            src_param_init_ssa_float(&ins->src[1], ssa_temp);
+
+            vsir_instruction_init_with_params(program, ++ins, &loc, VKD3DSIH_EXP, 1, 1);
+            dst_param_init_ssa_float(&ins->dst[0], ssa_factor);
+            ins->dst[0].modifiers = VKD3DSPDM_SATURATE;
+            src_param_init_ssa_float(&ins->src[0], ssa_temp2);
+            ins->src[0].modifiers = VKD3DSPSM_NEG;
+            break;
+
+        default:
+            vkd3d_unreachable();
+    }
+
+    /* We generate the following code:
+     *
+     * add sr0, FRAG_COLOUR, -FOG_COLOUR
+     * mad oC0, sr0, srFACTOR, FOG_COLOUR
+     */
+
+    vsir_instruction_init_with_params(program, ++ins, &loc, VKD3DSIH_ADD, 1, 2);
+    dst_param_init_ssa_float4(&ins->dst[0], program->ssa_count++);
+    src_param_init_temp_float4(&ins->src[0], colour_temp);
+    src_param_init_parameter_vec4(&ins->src[1], VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR, VKD3D_DATA_FLOAT);
+    ins->src[1].modifiers = VKD3DSPSM_NEG;
+
+    vsir_instruction_init_with_params(program, ++ins, &loc, VKD3DSIH_MAD, 1, 3);
+    dst_param_init_output(&ins->dst[0], VKD3D_DATA_FLOAT, colour_signature_idx,
+            program->output_signature.elements[colour_signature_idx].mask);
+    src_param_init_ssa_float4(&ins->src[0], program->ssa_count - 1);
+    src_param_init_ssa_float(&ins->src[1], ssa_factor);
+    src_param_init_parameter_vec4(&ins->src[2], VKD3D_SHADER_PARAMETER_NAME_FOG_COLOUR, VKD3D_DATA_FLOAT);
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result vsir_program_insert_fragment_fog(struct vsir_program *program,
+        struct vsir_transformation_context *ctx)
+{
+    struct vkd3d_shader_message_context *message_context = ctx->message_context;
+    uint32_t colour_signature_idx, fog_signature_idx, colour_temp;
+    const struct vkd3d_shader_parameter1 *mode_parameter = NULL;
+    static const struct vkd3d_shader_location no_loc;
+    const struct signature_element *fog_element;
+    enum vkd3d_shader_fog_fragment_mode mode;
+    struct vkd3d_shader_instruction *ins;
+    size_t new_pos;
+    int ret;
+
+    if (program->shader_version.type != VKD3D_SHADER_TYPE_PIXEL)
+        return VKD3D_OK;
+
+    if (!vsir_signature_find_sysval(&program->output_signature, VKD3D_SHADER_SV_TARGET, 0, &colour_signature_idx))
+        return VKD3D_OK;
+
+    if (!(mode_parameter = vsir_program_get_parameter(program, VKD3D_SHADER_PARAMETER_NAME_FOG_FRAGMENT_MODE)))
+        return VKD3D_OK;
+
+    if (mode_parameter->type != VKD3D_SHADER_PARAMETER_TYPE_IMMEDIATE_CONSTANT)
+    {
+        vkd3d_shader_error(message_context, &no_loc, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                "Unsupported fog fragment mode parameter type %#x.", mode_parameter->type);
+        return VKD3D_ERROR_NOT_IMPLEMENTED;
+    }
+    if (mode_parameter->data_type != VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32)
+    {
+        vkd3d_shader_error(message_context, &no_loc, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
+                "Invalid fog fragment mode parameter data type %#x.", mode_parameter->data_type);
+        return VKD3D_ERROR_INVALID_ARGUMENT;
+    }
+    mode = mode_parameter->u.immediate_constant.u.u32;
+
+    if (mode == VKD3D_SHADER_FOG_FRAGMENT_NONE)
+        return VKD3D_OK;
+
+    /* Should have been added by vsir_program_add_fog_input(). */
+    if (!(fog_element = vsir_signature_find_element_by_name(&program->input_signature, "FOG", 0)))
+    {
+        ERR("Fog input not found.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    fog_signature_idx = fog_element - program->input_signature.elements;
+
+    /* We're going to be reading from the output, so we need to go
+     * through the whole shader and convert it to a temp. */
+    colour_temp = program->temp_count++;
+
+    for (size_t i = 0; i < program->instructions.count; ++i)
+    {
+        ins = &program->instructions.elements[i];
+
+        if (vsir_instruction_is_dcl(ins))
+            continue;
+
+        if (ins->opcode == VKD3DSIH_RET)
+        {
+            if ((ret = insert_fragment_fog_before_ret(program, ins, mode, fog_signature_idx,
+                    colour_signature_idx, colour_temp, &new_pos, message_context)) < 0)
+                return ret;
+            i = new_pos;
+            continue;
+        }
+
+        for (size_t j = 0; j < ins->dst_count; ++j)
+        {
+            struct vkd3d_shader_dst_param *dst = &ins->dst[j];
+
+            /* Note we run after I/O normalization. */
+            if (dst->reg.type == VKD3DSPR_OUTPUT && dst->reg.idx[0].offset == colour_signature_idx)
+            {
+                dst->reg.type = VKD3DSPR_TEMP;
+                dst->reg.idx[0].offset = colour_temp;
+            }
+        }
+    }
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result vsir_program_add_fog_output(struct vsir_program *program,
+        struct vsir_transformation_context *ctx)
+{
+    struct shader_signature *signature = &program->output_signature;
+    const struct vkd3d_shader_parameter1 *source_parameter;
+    uint32_t register_idx = 0;
+
+    if (!is_pre_rasterization_shader(program->shader_version.type))
+        return VKD3D_OK;
+
+    if (!(source_parameter = vsir_program_get_parameter(program, VKD3D_SHADER_PARAMETER_NAME_FOG_SOURCE)))
+        return VKD3D_OK;
+
+    if (source_parameter->type == VKD3D_SHADER_PARAMETER_TYPE_IMMEDIATE_CONSTANT)
+    {
+        enum vkd3d_shader_fog_source source = source_parameter->u.immediate_constant.u.u32;
+
+        if (source == VKD3D_SHADER_FOG_SOURCE_FOG)
+            return VKD3D_OK;
+
+        if (source == VKD3D_SHADER_FOG_SOURCE_FOG_OR_SPECULAR_W
+                && !vsir_signature_find_element_by_name(signature, "COLOR", 1))
+            return VKD3D_OK;
+    }
+
+    if (vsir_signature_find_element_by_name(signature, "FOG", 0))
+        return VKD3D_OK;
+
+    for (unsigned int i = 0; i < signature->element_count; ++i)
+        register_idx = max(register_idx, signature->elements[i].register_index + 1);
+
+    if (!add_signature_element(signature, "FOG", 0, VKD3DSP_WRITEMASK_0, register_idx, VKD3DSIM_LINEAR))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result insert_vertex_fog_before_ret(struct vsir_program *program,
+        const struct vkd3d_shader_instruction *ret, enum vkd3d_shader_fog_source source, uint32_t temp,
+        uint32_t fog_signature_idx, uint32_t source_signature_idx, size_t *ret_pos)
+{
+    const struct signature_element *e = &program->output_signature.elements[source_signature_idx];
+    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
+    size_t pos = ret - instructions->elements;
+    struct vkd3d_shader_instruction *ins;
+
+    if (!shader_instruction_array_insert_at(&program->instructions, pos, 2))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    ins = &program->instructions.elements[pos];
+
+    /* Write the fog output. */
+    vsir_instruction_init_with_params(program, ins, &ret->location, VKD3DSIH_MOV, 1, 1);
+    dst_param_init_output(&ins->dst[0], VKD3D_DATA_FLOAT, fog_signature_idx, 0x1);
+    src_param_init_temp_float4(&ins->src[0], temp);
+    if (source == VKD3D_SHADER_FOG_SOURCE_Z)
+        ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z);
+    else /* Position or specular W. */
+        ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(W, W, W, W);
+    ++ins;
+
+    /* Write the position or specular output. */
+    vsir_instruction_init_with_params(program, ins, &ret->location, VKD3DSIH_MOV, 1, 1);
+    dst_param_init_output(&ins->dst[0], vkd3d_data_type_from_component_type(e->component_type),
+            source_signature_idx, e->mask);
+    src_param_init_temp_float4(&ins->src[0], temp);
+    ++ins;
+
+    *ret_pos = pos + 2;
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result vsir_program_insert_vertex_fog(struct vsir_program *program,
+        struct vsir_transformation_context *ctx)
+{
+    struct vkd3d_shader_message_context *message_context = ctx->message_context;
+    const struct vkd3d_shader_parameter1 *source_parameter = NULL;
+    uint32_t fog_signature_idx, source_signature_idx, temp;
+    static const struct vkd3d_shader_location no_loc;
+    enum vkd3d_shader_fog_source source;
+    const struct signature_element *e;
+
+    if (!is_pre_rasterization_shader(program->shader_version.type))
+        return VKD3D_OK;
+
+    if (!(source_parameter = vsir_program_get_parameter(program, VKD3D_SHADER_PARAMETER_NAME_FOG_SOURCE)))
+        return VKD3D_OK;
+
+    if (source_parameter->type != VKD3D_SHADER_PARAMETER_TYPE_IMMEDIATE_CONSTANT)
+    {
+        vkd3d_shader_error(message_context, &no_loc, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                "Unsupported fog source parameter type %#x.", source_parameter->type);
+        return VKD3D_ERROR_NOT_IMPLEMENTED;
+    }
+    if (source_parameter->data_type != VKD3D_SHADER_PARAMETER_DATA_TYPE_UINT32)
+    {
+        vkd3d_shader_error(message_context, &no_loc, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE,
+                "Invalid fog source parameter data type %#x.", source_parameter->data_type);
+        return VKD3D_ERROR_INVALID_ARGUMENT;
+    }
+    source = source_parameter->u.immediate_constant.u.u32;
+
+    TRACE("Fog source %#x.\n", source);
+
+    if (source == VKD3D_SHADER_FOG_SOURCE_FOG)
+        return VKD3D_OK;
+
+    if (source == VKD3D_SHADER_FOG_SOURCE_FOG_OR_SPECULAR_W)
+    {
+        if (program->has_fog || !(e = vsir_signature_find_element_by_name(&program->output_signature, "COLOR", 1)))
+            return VKD3D_OK;
+        source_signature_idx = e - program->output_signature.elements;
+    }
+    else
+    {
+        if (!vsir_signature_find_sysval(&program->output_signature,
+                VKD3D_SHADER_SV_POSITION, 0, &source_signature_idx))
+        {
+            vkd3d_shader_error(ctx->message_context, &no_loc,
+                    VKD3D_SHADER_ERROR_VSIR_MISSING_SEMANTIC, "Shader does not write position.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+    }
+
+    if (!(e = vsir_signature_find_element_by_name(&program->output_signature, "FOG", 0)))
+    {
+        ERR("Fog output not found.\n");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    fog_signature_idx = e - program->output_signature.elements;
+
+    temp = program->temp_count++;
+
+    /* Insert a fog write before each ret, and convert either specular or
+     * position output to a temp. */
+    for (size_t i = 0; i < program->instructions.count; ++i)
+    {
+        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
+
+        if (vsir_instruction_is_dcl(ins))
+            continue;
+
+        if (ins->opcode == VKD3DSIH_RET)
+        {
+            size_t new_pos;
+            int ret;
+
+            if ((ret = insert_vertex_fog_before_ret(program, ins, source, temp,
+                    fog_signature_idx, source_signature_idx, &new_pos)) < 0)
+                return ret;
+            i = new_pos;
+            continue;
+        }
+
+        for (size_t j = 0; j < ins->dst_count; ++j)
+        {
+            struct vkd3d_shader_dst_param *dst = &ins->dst[j];
+
+            /* Note we run after I/O normalization. */
+            if (dst->reg.type == VKD3DSPR_OUTPUT && dst->reg.idx[0].offset == source_signature_idx)
+            {
+                dst->reg.type = VKD3DSPR_TEMP;
+                dst->reg.idx[0].offset = temp;
+            }
+        }
+    }
+
+    program->has_fog = true;
+
+    return VKD3D_OK;
+}
+
+struct validation_context
+{
+    struct vkd3d_shader_message_context *message_context;
+    const struct vsir_program *program;
+    size_t instruction_idx;
+    struct vkd3d_shader_location null_location;
+    bool invalid_instruction_idx;
+    enum vkd3d_result status;
+    bool dcl_temps_found;
+    enum vkd3d_shader_opcode phase;
+    bool inside_block;
+
+    struct validation_context_temp_data
+    {
+        enum vsir_dimension dimension;
+        size_t first_seen;
+    } *temps;
+
+    struct validation_context_ssa_data
+    {
+        enum vsir_dimension dimension;
+        enum vkd3d_data_type data_type;
+        size_t first_seen;
+        uint32_t write_mask;
+        uint32_t read_mask;
+        size_t first_assigned;
+    } *ssas;
+
+    enum vkd3d_shader_opcode *blocks;
+    size_t depth;
+    size_t blocks_capacity;
+
+    unsigned int outer_tess_idxs[4];
+    unsigned int inner_tess_idxs[2];
+
+    struct validation_context_signature_data
+    {
+        struct validation_context_signature_stream_data
+        {
+            struct validation_context_signature_register_data
+            {
+                struct validation_context_signature_component_data
+                {
+                    const struct signature_element *element;
+                } components[VKD3D_VEC4_SIZE];
+            } registers[MAX_REG_OUTPUT];
+        } streams[VKD3D_MAX_STREAM_COUNT];
+    } input_signature_data, output_signature_data, patch_constant_signature_data;
+};
+
+static void VKD3D_PRINTF_FUNC(3, 4) validator_error(struct validation_context *ctx,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    struct vkd3d_string_buffer buf;
+    va_list args;
+
+    vkd3d_string_buffer_init(&buf);
+
+    va_start(args, format);
+    vkd3d_string_buffer_vprintf(&buf, format, args);
+    va_end(args);
+
+    if (ctx->invalid_instruction_idx)
     {
         vkd3d_shader_error(ctx->message_context, &ctx->null_location, error, "%s", buf.buffer);
         WARN("VSIR validation error: %s\n", buf.buffer);
@@ -6707,76 +7254,240 @@ static void vsir_validate_register_without_indices(struct validation_context *ct
                 reg->idx_count, reg->type);
 }
 
-static void vsir_validate_io_register(struct validation_context *ctx,
-        const struct vkd3d_shader_register *reg)
+enum vsir_signature_type
+{
+    SIGNATURE_TYPE_INPUT,
+    SIGNATURE_TYPE_OUTPUT,
+    SIGNATURE_TYPE_PATCH_CONSTANT,
+};
+
+enum vsir_io_reg_type
 {
+    REG_V,
+    REG_O,
+    REG_VPC,
+    REG_VICP,
+    REG_VOCP,
+    REG_COUNT,
+};
+
+enum vsir_phase
+{
+    PHASE_NONE,
+    PHASE_CONTROL_POINT,
+    PHASE_FORK,
+    PHASE_JOIN,
+    PHASE_COUNT,
+};
+
+struct vsir_io_register_data
+{
+    unsigned int flags;
+    enum vsir_signature_type signature_type;
     const struct shader_signature *signature;
-    bool has_control_point = false;
+    unsigned int control_point_count;
+};
 
-    switch (reg->type)
+enum
+{
+    INPUT_BIT = (1u << 0),
+    OUTPUT_BIT = (1u << 1),
+    CONTROL_POINT_BIT = (1u << 2),
+};
+
+static const struct vsir_io_register_data vsir_sm4_io_register_data
+        [VKD3D_SHADER_TYPE_GRAPHICS_COUNT][PHASE_COUNT][REG_COUNT] =
+{
+    [VKD3D_SHADER_TYPE_PIXEL][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_VERTEX][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_GEOMETRY][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_HULL][PHASE_CONTROL_POINT] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_HULL][PHASE_FORK] =
+    {
+        [REG_VICP] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_VOCP] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_OUTPUT},
+        /* According to MSDN, vpc is not allowed in fork phases. However we
+         * don't really distinguish between fork and join phases, so we
+         * allow it. */
+        [REG_VPC] = {INPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+    },
+    [VKD3D_SHADER_TYPE_HULL][PHASE_JOIN] =
+    {
+        [REG_VICP] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_VOCP] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_OUTPUT},
+        [REG_VPC] = {INPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+    },
+    [VKD3D_SHADER_TYPE_DOMAIN][PHASE_NONE] =
+    {
+        [REG_VICP] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_VPC] = {INPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+};
+
+static const struct vsir_io_register_data vsir_sm6_io_register_data
+        [VKD3D_SHADER_TYPE_GRAPHICS_COUNT][PHASE_COUNT][REG_COUNT] =
+{
+    [VKD3D_SHADER_TYPE_PIXEL][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_VERTEX][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_GEOMETRY][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_HULL][PHASE_CONTROL_POINT] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {OUTPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+    [VKD3D_SHADER_TYPE_HULL][PHASE_FORK] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_OUTPUT},
+        [REG_VPC] = {INPUT_BIT | OUTPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+    },
+    [VKD3D_SHADER_TYPE_HULL][PHASE_JOIN] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_O] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_OUTPUT},
+        [REG_VPC] = {INPUT_BIT | OUTPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+    },
+    [VKD3D_SHADER_TYPE_DOMAIN][PHASE_NONE] =
+    {
+        [REG_V] = {INPUT_BIT | CONTROL_POINT_BIT, SIGNATURE_TYPE_INPUT},
+        [REG_VPC] = {INPUT_BIT, SIGNATURE_TYPE_PATCH_CONSTANT},
+        [REG_O] = {OUTPUT_BIT, SIGNATURE_TYPE_OUTPUT},
+    },
+};
+
+static const bool vsir_get_io_register_data(struct validation_context *ctx,
+        enum vkd3d_shader_register_type register_type, struct vsir_io_register_data *data)
+{
+    const struct vsir_io_register_data (*signature_register_data)
+            [VKD3D_SHADER_TYPE_GRAPHICS_COUNT][PHASE_COUNT][REG_COUNT];
+    enum vsir_io_reg_type io_reg_type;
+    enum vsir_phase phase;
+
+    if (ctx->program->shader_version.type >= ARRAY_SIZE(*signature_register_data))
+        return NULL;
+
+    if (ctx->program->normalisation_level >= VSIR_NORMALISED_SM6)
+        signature_register_data = &vsir_sm6_io_register_data;
+    else
+        signature_register_data = &vsir_sm4_io_register_data;
+
+    switch (register_type)
     {
-        case VKD3DSPR_INPUT:
-            signature = &ctx->program->input_signature;
+        case VKD3DSPR_INPUT:           io_reg_type = REG_V; break;
+        case VKD3DSPR_OUTPUT:          io_reg_type = REG_O; break;
+        case VKD3DSPR_INCONTROLPOINT:  io_reg_type = REG_VICP; break;
+        case VKD3DSPR_OUTCONTROLPOINT: io_reg_type = REG_VOCP; break;
+        case VKD3DSPR_PATCHCONST:      io_reg_type = REG_VPC; break;
 
-            switch (ctx->program->shader_version.type)
-            {
-                case VKD3D_SHADER_TYPE_GEOMETRY:
-                case VKD3D_SHADER_TYPE_HULL:
-                case VKD3D_SHADER_TYPE_DOMAIN:
-                    has_control_point = true;
-                    break;
+        default:
+            return NULL;
+    }
 
-                default:
-                    break;
-            }
-            break;
+    switch (ctx->phase)
+    {
+        case VKD3DSIH_HS_CONTROL_POINT_PHASE: phase = PHASE_CONTROL_POINT; break;
+        case VKD3DSIH_HS_FORK_PHASE:          phase = PHASE_FORK; break;
+        case VKD3DSIH_HS_JOIN_PHASE:          phase = PHASE_JOIN; break;
+        case VKD3DSIH_INVALID:                phase = PHASE_NONE; break;
 
-        case VKD3DSPR_OUTPUT:
-            switch (ctx->program->shader_version.type)
-            {
-                case VKD3D_SHADER_TYPE_HULL:
-                    if (ctx->phase == VKD3DSIH_HS_CONTROL_POINT_PHASE
-                            || ctx->program->normalisation_level >= VSIR_FULLY_NORMALISED_IO)
-                    {
-                        signature = &ctx->program->output_signature;
-                        has_control_point = ctx->program->normalisation_level >= VSIR_NORMALISED_HULL_CONTROL_POINT_IO;
-                    }
-                    else
-                    {
-                        signature = &ctx->program->patch_constant_signature;
-                    }
-                    break;
+        default:
+            vkd3d_unreachable();
+    }
 
-                default:
-                    signature = &ctx->program->output_signature;
-                    break;
-            }
-            break;
+    *data = (*signature_register_data)[ctx->program->shader_version.type][phase][io_reg_type];
 
-        case VKD3DSPR_INCONTROLPOINT:
-            signature = &ctx->program->input_signature;
-            has_control_point = true;
-            break;
+    if (!(data->flags & (INPUT_BIT | OUTPUT_BIT)))
+        return false;
 
-        case VKD3DSPR_OUTCONTROLPOINT:
-            signature = &ctx->program->output_signature;
-            has_control_point = true;
-            break;
+    /* VSIR_NORMALISED_HULL_CONTROL_POINT_IO differs from VSIR_NORMALISED_SM4
+     * for just a single flag. So we don't keep a whole copy of it, but just
+     * patch SM4 when needed. */
+    if (ctx->program->normalisation_level == VSIR_NORMALISED_HULL_CONTROL_POINT_IO
+            && ctx->program->shader_version.type == VKD3D_SHADER_TYPE_HULL
+            && phase == PHASE_CONTROL_POINT && io_reg_type == REG_O)
+    {
+        VKD3D_ASSERT(!(data->flags & CONTROL_POINT_BIT));
+        data->flags |= CONTROL_POINT_BIT;
+    }
 
-        case VKD3DSPR_PATCHCONST:
-            signature = &ctx->program->patch_constant_signature;
-            break;
+    switch (data->signature_type)
+    {
+        case SIGNATURE_TYPE_INPUT:
+            data->signature = &ctx->program->input_signature;
+            data->control_point_count = ctx->program->input_control_point_count;
+            return true;
+
+        case SIGNATURE_TYPE_OUTPUT:
+            data->signature = &ctx->program->output_signature;
+            data->control_point_count = ctx->program->output_control_point_count;
+            return true;
+
+        case SIGNATURE_TYPE_PATCH_CONSTANT:
+            data->signature = &ctx->program->patch_constant_signature;
+            return true;
 
         default:
             vkd3d_unreachable();
     }
+}
 
-    if (ctx->program->normalisation_level < VSIR_FULLY_NORMALISED_IO)
+static void vsir_validate_io_register(struct validation_context *ctx, const struct vkd3d_shader_register *reg)
+{
+    unsigned int control_point_index, control_point_count;
+    const struct shader_signature *signature;
+    struct vsir_io_register_data io_reg_data;
+    bool has_control_point;
+
+    if (!vsir_get_io_register_data(ctx, reg->type, &io_reg_data))
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                "Invalid usage of register type %#x.", reg->type);
+        return;
+    }
+
+    signature = io_reg_data.signature;
+    has_control_point = io_reg_data.flags & CONTROL_POINT_BIT;
+    control_point_count = io_reg_data.control_point_count;
+
+    if (ctx->program->normalisation_level < VSIR_NORMALISED_SM6)
     {
         /* Indices are [register] or [control point, register]. Both are
          * allowed to have a relative address. */
         unsigned int expected_idx_count = 1 + !!has_control_point;
 
+        control_point_index = 0;
+
         if (reg->idx_count != expected_idx_count)
         {
             validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT,
@@ -6795,7 +7506,7 @@ static void vsir_validate_io_register(struct validation_context *ctx,
         /* If the signature element is not an array, indices are
          * [signature] or [control point, signature]. If the signature
          * element is an array, indices are [array, signature] or
-         * [control point, array, signature]. In any case `signature' is
+         * [array, control point, signature]. In any case `signature' is
          * not allowed to have a relative address, while the others are.
          */
         if (reg->idx_count < 1)
@@ -6829,6 +7540,7 @@ static void vsir_validate_io_register(struct validation_context *ctx,
             is_array = true;
 
         expected_idx_count = 1 + !!has_control_point + !!is_array;
+        control_point_index = !!is_array;
 
         if (reg->idx_count != expected_idx_count)
         {
@@ -6837,7 +7549,18 @@ static void vsir_validate_io_register(struct validation_context *ctx,
                     reg->idx_count, reg->type);
             return;
         }
+
+        if (is_array && !reg->idx[0].rel_addr && reg->idx[0].offset >= element->register_count)
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                    "Array index %u exceeds the signature element register count %u in a register of type %#x.",
+                    reg->idx[0].offset, element->register_count, reg->type);
     }
+
+    if (has_control_point && !reg->idx[control_point_index].rel_addr
+            && reg->idx[control_point_index].offset >= control_point_count)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                "Control point index %u exceeds the control point count %u in a register of type %#x.",
+                reg->idx[control_point_index].offset, control_point_count, reg->type);
 }
 
 static void vsir_validate_temp_register(struct validation_context *ctx,
@@ -7143,8 +7866,26 @@ static void vsir_validate_register(struct validation_context *ctx,
     for (i = 0; i < min(reg->idx_count, ARRAY_SIZE(reg->idx)); ++i)
     {
         const struct vkd3d_shader_src_param *param = reg->idx[i].rel_addr;
-        if (reg->idx[i].rel_addr)
+        if (param)
+        {
             vsir_validate_src_param(ctx, param);
+
+            switch (param->reg.type)
+            {
+                case VKD3DSPR_TEMP:
+                case VKD3DSPR_SSA:
+                case VKD3DSPR_ADDR:
+                case VKD3DSPR_LOOP:
+                case VKD3DSPR_OUTPOINTID:
+                    break;
+
+                default:
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                            "Invalid register type %#x for a relative address parameter.",
+                            param->reg.type);
+                    break;
+            }
+        }
     }
 
     switch (reg->type)
@@ -7185,6 +7926,10 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_register_without_indices(ctx, reg);
             break;
 
+        case VKD3DSPR_PRIMID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
         case VKD3DSPR_NULL:
             vsir_validate_register_without_indices(ctx, reg);
             break;
@@ -7201,6 +7946,18 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_uav_register(ctx, reg);
             break;
 
+        case VKD3DSPR_OUTPOINTID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_FORKINSTID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_JOININSTID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
         case VKD3DSPR_INCONTROLPOINT:
             vsir_validate_io_register(ctx, reg);
             break;
@@ -7213,6 +7970,38 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_io_register(ctx, reg);
             break;
 
+        case VKD3DSPR_TESSCOORD:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_THREADID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_THREADGROUPID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_LOCALTHREADID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_LOCALTHREADINDEX:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_COVERAGE:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_SAMPLEMASK:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_GSINSTID:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
         case VKD3DSPR_DEPTHOUTGE:
             vsir_validate_register_without_indices(ctx, reg);
             break;
@@ -7221,15 +8010,37 @@ static void vsir_validate_register(struct validation_context *ctx,
             vsir_validate_register_without_indices(ctx, reg);
             break;
 
+        case VKD3DSPR_OUTSTENCILREF:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
         case VKD3DSPR_SSA:
             vsir_validate_ssa_register(ctx, reg);
             break;
 
+        case VKD3DSPR_WAVELANECOUNT:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
+        case VKD3DSPR_WAVELANEINDEX:
+            vsir_validate_register_without_indices(ctx, reg);
+            break;
+
         default:
             break;
     }
 }
 
+static void vsir_validate_io_dst_param(struct validation_context *ctx,
+        const struct vkd3d_shader_dst_param *dst)
+{
+    struct vsir_io_register_data io_reg_data;
+
+    if (!vsir_get_io_register_data(ctx, dst->reg.type, &io_reg_data) || !(io_reg_data.flags & OUTPUT_BIT))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                "Invalid register type %#x used as destination parameter.", dst->reg.type);
+}
+
 static void vsir_validate_dst_param(struct validation_context *ctx,
         const struct vkd3d_shader_dst_param *dst)
 {
@@ -7304,15 +8115,28 @@ static void vsir_validate_dst_param(struct validation_context *ctx,
         case VKD3DSPR_IMMCONST64:
         case VKD3DSPR_SAMPLER:
         case VKD3DSPR_RESOURCE:
-        case VKD3DSPR_INPUT:
             validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
                     "Invalid %#x register used as destination parameter.", dst->reg.type);
             break;
 
+        case VKD3DSPR_INPUT:
+            vsir_validate_io_dst_param(ctx, dst);
+            break;
+
+        case VKD3DSPR_OUTPUT:
+            vsir_validate_io_dst_param(ctx, dst);
+            break;
+
+        case VKD3DSPR_INCONTROLPOINT:
+            vsir_validate_io_dst_param(ctx, dst);
+            break;
+
+        case VKD3DSPR_OUTCONTROLPOINT:
+            vsir_validate_io_dst_param(ctx, dst);
+            break;
+
         case VKD3DSPR_PATCHCONST:
-            if (ctx->program->shader_version.type != VKD3D_SHADER_TYPE_HULL)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
-                        "PATCHCONST register used as destination parameters are only allowed in Hull Shaders.");
+            vsir_validate_io_dst_param(ctx, dst);
             break;
 
         default:
@@ -7320,6 +8144,16 @@ static void vsir_validate_dst_param(struct validation_context *ctx,
     }
 }
 
+static void vsir_validate_io_src_param(struct validation_context *ctx,
+        const struct vkd3d_shader_src_param *src)
+{
+    struct vsir_io_register_data io_reg_data;
+
+    if (!vsir_get_io_register_data(ctx, src->reg.type, &io_reg_data) || !(io_reg_data.flags & INPUT_BIT))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                "Invalid register type %#x used as source parameter.", src->reg.type);
+}
+
 static void vsir_validate_src_param(struct validation_context *ctx,
         const struct vkd3d_shader_src_param *src)
 {
@@ -7355,18 +8189,24 @@ static void vsir_validate_src_param(struct validation_context *ctx,
                     "Invalid NULL register used as source parameter.");
             break;
 
+        case VKD3DSPR_INPUT:
+            vsir_validate_io_src_param(ctx, src);
+            break;
+
         case VKD3DSPR_OUTPUT:
-            if (ctx->program->shader_version.type != VKD3D_SHADER_TYPE_HULL
-                    || (ctx->phase != VKD3DSIH_HS_FORK_PHASE && ctx->phase != VKD3DSIH_HS_JOIN_PHASE))
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
-                        "Invalid OUTPUT register used as source parameter.");
+            vsir_validate_io_src_param(ctx, src);
+            break;
+
+        case VKD3DSPR_INCONTROLPOINT:
+            vsir_validate_io_src_param(ctx, src);
+            break;
+
+        case VKD3DSPR_OUTCONTROLPOINT:
+            vsir_validate_io_src_param(ctx, src);
             break;
 
         case VKD3DSPR_PATCHCONST:
-            if (ctx->program->shader_version.type != VKD3D_SHADER_TYPE_DOMAIN
-                    && ctx->program->shader_version.type != VKD3D_SHADER_TYPE_HULL)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
-                        "PATCHCONST register used as source parameters are only allowed in Hull and Domain Shaders.");
+            vsir_validate_io_src_param(ctx, src);
             break;
 
         default:
@@ -7420,13 +8260,6 @@ static bool vsir_validate_src_max_count(struct validation_context *ctx,
     return true;
 }
 
-enum vsir_signature_type
-{
-    SIGNATURE_TYPE_INPUT,
-    SIGNATURE_TYPE_OUTPUT,
-    SIGNATURE_TYPE_PATCH_CONSTANT,
-};
-
 static const char * const signature_type_names[] =
 {
     [SIGNATURE_TYPE_INPUT] = "input",
@@ -7466,17 +8299,37 @@ sysval_validation_data[] =
 };
 
 static void vsir_validate_signature_element(struct validation_context *ctx,
-        const struct shader_signature *signature, enum vsir_signature_type signature_type,
-        unsigned int idx)
+        const struct shader_signature *signature, struct validation_context_signature_data *signature_data,
+        enum vsir_signature_type signature_type, unsigned int idx)
 {
+    enum vkd3d_tessellator_domain expected_tess_domain = VKD3D_TESSELLATOR_DOMAIN_INVALID;
+    bool integer_type = false, is_outer = false, is_gs_output, require_index = true;
     const char *signature_type_name = signature_type_names[signature_type];
     const struct signature_element *element = &signature->elements[idx];
-    bool integer_type = false;
+    unsigned int semantic_index_max = 0, i, j;
 
     if (element->register_count == 0)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
                 "element %u of %s signature: Invalid zero register count.", idx, signature_type_name);
 
+    if (ctx->program->normalisation_level < VSIR_NORMALISED_SM6 && element->register_count != 1)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                "element %u of %s signature: Invalid register count %u.", idx, signature_type_name,
+                element->register_count);
+
+    if (element->register_index != UINT_MAX && (element->register_index >= MAX_REG_OUTPUT
+            || MAX_REG_OUTPUT - element->register_index < element->register_count))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                "element %u of %s signature: Invalid register index %u and count %u.",
+                idx, signature_type_name, element->register_index, element->register_count);
+
+    is_gs_output = ctx->program->shader_version.type == VKD3D_SHADER_TYPE_GEOMETRY
+            && signature_type == SIGNATURE_TYPE_OUTPUT;
+    if (element->stream_index >= VKD3D_MAX_STREAM_COUNT || (element->stream_index != 0 && !is_gs_output))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                "element %u of %s signature: Invalid stream index %u.",
+                idx, signature_type_name, element->stream_index);
+
     if (element->mask == 0 || (element->mask & ~0xf))
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
                 "element %u of %s signature: Invalid mask %#x.", idx, signature_type_name, element->mask);
@@ -7486,33 +8339,27 @@ static void vsir_validate_signature_element(struct validation_context *ctx,
                 "element %u of %s signature: Non-contiguous mask %#x.",
                 idx, signature_type_name, element->mask);
 
-    /* Here we'd likely want to validate that the usage mask is a subset of the
-     * signature mask. Unfortunately the D3DBC parser sometimes violates this.
-     * For example I've seen a shader like this:
-     *   ps_3_0
-     *   [...]
-     *   dcl_texcoord0 v0
-     *   [...]
-     *   texld r2.xyzw, v0.xyzw, s1.xyzw
-     *   [...]
-     *
-     * The dcl_textcoord0 instruction secretly has a .xy mask, which is used to
-     * compute the signature mask, but the texld instruction apparently uses all
-     * the components. Of course the last two components are ignored, but
-     * formally they seem to be used. So we end up with a signature element with
-     * mask .xy and usage mask .xyzw.
-     *
-     * The correct fix would probably be to make the D3DBC parser aware of which
-     * components are really used for each instruction, but that would take some
-     * time. */
-    if (element->used_mask & ~0xf)
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
-                "element %u of %s signature: Invalid usage mask %#x.",
-                idx, signature_type_name, element->used_mask);
+    if (ctx->program->normalisation_level >= VSIR_NORMALISED_SM4)
+    {
+        if ((element->used_mask & element->mask) != element->used_mask)
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                    "element %u of %s signature: Invalid usage mask %#x with mask %#x.",
+                    idx, signature_type_name, element->used_mask, element->mask);
+    }
+    else
+    {
+        if (element->used_mask & ~0xf)
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                    "element %u of %s signature: Invalid usage mask %#x.",
+                    idx, signature_type_name, element->used_mask);
+    }
 
     switch (element->sysval_semantic)
     {
         case VKD3D_SHADER_SV_NONE:
+        case VKD3D_SHADER_SV_TARGET:
+            break;
+
         case VKD3D_SHADER_SV_POSITION:
         case VKD3D_SHADER_SV_CLIP_DISTANCE:
         case VKD3D_SHADER_SV_CULL_DISTANCE:
@@ -7523,18 +8370,43 @@ static void vsir_validate_signature_element(struct validation_context *ctx,
         case VKD3D_SHADER_SV_INSTANCE_ID:
         case VKD3D_SHADER_SV_IS_FRONT_FACE:
         case VKD3D_SHADER_SV_SAMPLE_INDEX:
+        case VKD3D_SHADER_SV_DEPTH:
+        case VKD3D_SHADER_SV_COVERAGE:
+        case VKD3D_SHADER_SV_DEPTH_GREATER_EQUAL:
+        case VKD3D_SHADER_SV_DEPTH_LESS_EQUAL:
+        case VKD3D_SHADER_SV_STENCIL_REF:
+            require_index = false;
+            break;
+
         case VKD3D_SHADER_SV_TESS_FACTOR_QUADEDGE:
+            expected_tess_domain = VKD3D_TESSELLATOR_DOMAIN_QUAD;
+            semantic_index_max = 4;
+            is_outer = true;
+            break;
+
         case VKD3D_SHADER_SV_TESS_FACTOR_QUADINT:
+            expected_tess_domain = VKD3D_TESSELLATOR_DOMAIN_QUAD;
+            semantic_index_max = 2;
+            is_outer = false;
+            break;
+
         case VKD3D_SHADER_SV_TESS_FACTOR_TRIEDGE:
+            expected_tess_domain = VKD3D_TESSELLATOR_DOMAIN_TRIANGLE;
+            semantic_index_max = 3;
+            is_outer = true;
+            break;
+
         case VKD3D_SHADER_SV_TESS_FACTOR_TRIINT:
+            expected_tess_domain = VKD3D_TESSELLATOR_DOMAIN_TRIANGLE;
+            semantic_index_max = 1;
+            is_outer = false;
+            break;
+
         case VKD3D_SHADER_SV_TESS_FACTOR_LINEDET:
         case VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN:
-        case VKD3D_SHADER_SV_TARGET:
-        case VKD3D_SHADER_SV_DEPTH:
-        case VKD3D_SHADER_SV_COVERAGE:
-        case VKD3D_SHADER_SV_DEPTH_GREATER_EQUAL:
-        case VKD3D_SHADER_SV_DEPTH_LESS_EQUAL:
-        case VKD3D_SHADER_SV_STENCIL_REF:
+            expected_tess_domain = VKD3D_TESSELLATOR_DOMAIN_LINE;
+            semantic_index_max = 2;
+            is_outer = true;
             break;
 
         default:
@@ -7544,6 +8416,43 @@ static void vsir_validate_signature_element(struct validation_context *ctx,
             break;
     }
 
+    if (require_index && element->register_index == UINT_MAX)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                "element %u of %s signature: System value semantic %#x requires a register index.",
+                idx, signature_type_name, element->sysval_semantic);
+
+    if (expected_tess_domain != VKD3D_TESSELLATOR_DOMAIN_INVALID)
+    {
+        if (signature_type != SIGNATURE_TYPE_PATCH_CONSTANT)
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                    "element %u of %s signature: System value semantic %#x is only valid "
+                    "in the patch constant signature.",
+                    idx, signature_type_name, element->sysval_semantic);
+
+        if (ctx->program->tess_domain != expected_tess_domain)
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                    "element %u of %s signature: Invalid system value semantic %#x for tessellator domain %#x.",
+                    idx, signature_type_name, element->sysval_semantic, ctx->program->tess_domain);
+
+        if (element->semantic_index >= semantic_index_max)
+        {
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                    "element %u of %s signature: Invalid semantic index %u for system value semantic %#x.",
+                    idx, signature_type_name, element->semantic_index, element->sysval_semantic);
+        }
+        else
+        {
+            unsigned int *idx_pos = &(is_outer ? ctx->outer_tess_idxs : ctx->inner_tess_idxs)[element->semantic_index];
+
+            if (*idx_pos != ~0u)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "element %u of %s signature: Duplicate semantic index %u for system value semantic %#x.",
+                        idx, signature_type_name, element->semantic_index, element->sysval_semantic);
+            else
+                *idx_pos = idx;
+        }
+    }
+
     if (element->sysval_semantic < ARRAY_SIZE(sysval_validation_data))
     {
         const struct sysval_validation_data_element *data = &sysval_validation_data[element->sysval_semantic];
@@ -7622,6 +8531,31 @@ static void vsir_validate_signature_element(struct validation_context *ctx,
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
                 "element %u of %s signature: Invalid interpolation mode %#x for integer component type.",
                 idx, signature_type_name, element->interpolation_mode);
+
+    if (element->stream_index >= VKD3D_MAX_STREAM_COUNT || !require_index)
+        return;
+
+    for (i = element->register_index; i < MAX_REG_OUTPUT
+            && i - element->register_index < element->register_count; ++i)
+    {
+        struct validation_context_signature_stream_data *stream_data = &signature_data->streams[element->stream_index];
+        struct validation_context_signature_register_data *register_data = &stream_data->registers[i];
+
+        for (j = 0; j < VKD3D_VEC4_SIZE; ++j)
+        {
+            struct validation_context_signature_component_data *component_data = &register_data->components[j];
+
+            if (!(element->mask & (1u << j)))
+                continue;
+
+            if (!component_data->element)
+                component_data->element = element;
+            else
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "element %u of %s signature: Conflict with element %zu.",
+                        idx, signature_type_name, component_data->element - signature->elements);
+        }
+    }
 }
 
 static const unsigned int allowed_signature_phases[] =
@@ -7631,8 +8565,8 @@ static const unsigned int allowed_signature_phases[] =
     [SIGNATURE_TYPE_PATCH_CONSTANT] = HS_BIT | DS_BIT,
 };
 
-static void vsir_validate_signature(struct validation_context *ctx,
-        const struct shader_signature *signature, enum vsir_signature_type signature_type)
+static void vsir_validate_signature(struct validation_context *ctx, const struct shader_signature *signature,
+        struct validation_context_signature_data *signature_data, enum vsir_signature_type signature_type)
 {
     unsigned int i;
 
@@ -7642,7 +8576,110 @@ static void vsir_validate_signature(struct validation_context *ctx,
                 "Unexpected %s signature.", signature_type_names[signature_type]);
 
     for (i = 0; i < signature->element_count; ++i)
-        vsir_validate_signature_element(ctx, signature, signature_type, i);
+        vsir_validate_signature_element(ctx, signature, signature_data, signature_type, i);
+
+    if (signature_type == SIGNATURE_TYPE_PATCH_CONSTANT)
+    {
+        const struct signature_element *first_element, *element;
+        unsigned int expected_outer_count = 0;
+        unsigned int expected_inner_count = 0;
+
+        switch (ctx->program->tess_domain)
+        {
+            case VKD3D_TESSELLATOR_DOMAIN_QUAD:
+                expected_outer_count = 4;
+                expected_inner_count = 2;
+                break;
+
+            case VKD3D_TESSELLATOR_DOMAIN_TRIANGLE:
+                expected_outer_count = 3;
+                expected_inner_count = 1;
+                break;
+
+            case VKD3D_TESSELLATOR_DOMAIN_LINE:
+                expected_outer_count = 2;
+                expected_inner_count = 0;
+                break;
+
+            default:
+                break;
+        }
+
+        /* After I/O normalisation tessellation factors are merged in a single array. */
+        if (ctx->program->normalisation_level >= VSIR_NORMALISED_SM6)
+        {
+            expected_outer_count = min(1, expected_outer_count);
+            expected_inner_count = min(1, expected_inner_count);
+        }
+
+        first_element = NULL;
+        for (i = 0; i < expected_outer_count; ++i)
+        {
+            if (ctx->outer_tess_idxs[i] == ~0u)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "Missing outer system value semantic %u.", i);
+            }
+            else
+            {
+                element = &signature->elements[ctx->outer_tess_idxs[i]];
+
+                if (!first_element)
+                {
+                    first_element = element;
+                    continue;
+                }
+
+                if (element->register_index != first_element->register_index + i)
+                {
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                            "Invalid register index %u for outer system value semantic %u, expected %u.",
+                            element->register_index, i, first_element->register_index + i);
+                }
+
+                if (element->mask != first_element->mask)
+                {
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                            "Invalid mask %#x for outer system value semantic %u, expected %#x.",
+                            element->mask, i, first_element->mask);
+                }
+            }
+        }
+
+        first_element = NULL;
+        for (i = 0; i < expected_inner_count; ++i)
+        {
+            if (ctx->inner_tess_idxs[i] == ~0u)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "Missing inner system value semantic %u.", i);
+            }
+            else
+            {
+                element = &signature->elements[ctx->inner_tess_idxs[i]];
+
+                if (!first_element)
+                {
+                    first_element = element;
+                    continue;
+                }
+
+                if (element->register_index != first_element->register_index + i)
+                {
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                            "Invalid register index %u for inner system value semantic %u, expected %u.",
+                            element->register_index, i, first_element->register_index + i);
+                }
+
+                if (element->mask != first_element->mask)
+                {
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                            "Invalid mask %#x for inner system value semantic %u, expected %#x.",
+                            element->mask, i, first_element->mask);
+                }
+            }
+        }
+    }
 }
 
 static const char *name_from_cf_type(enum vsir_control_flow_type type)
@@ -7754,6 +8791,206 @@ static void vsir_validate_dcl_hs_max_tessfactor(struct validation_context *ctx,
                 instruction->declaration.max_tessellation_factor);
 }
 
+static void vsir_validate_dcl_index_range(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    unsigned int i, j, base_register_idx, effective_write_mask = 0, control_point_count, first_component = UINT_MAX;
+    const struct vkd3d_shader_index_range *range = &instruction->declaration.index_range;
+    enum vkd3d_shader_sysval_semantic sysval = ~0u;
+    const struct shader_signature *signature;
+    struct vsir_io_register_data io_reg_data;
+    bool has_control_point;
+
+    if (ctx->program->normalisation_level >= VSIR_NORMALISED_SM6)
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER,
+                "DCL_INDEX_RANGE is not allowed with fully normalised input/output.");
+        return;
+    }
+
+    if (range->dst.modifiers != VKD3DSPDM_NONE)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS,
+                "Invalid modifier %#x on a DCL_INDEX_RANGE destination parameter.", range->dst.modifiers);
+
+    if (range->dst.shift != 0)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SHIFT,
+                "Invalid shift %u on a DCL_INDEX_RANGE destination parameter.", range->dst.shift);
+
+    if (!vsir_get_io_register_data(ctx, range->dst.reg.type, &io_reg_data))
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                "Invalid register type %#x in DCL_INDEX_RANGE instruction.",
+                range->dst.reg.type);
+        return;
+    }
+
+    signature = io_reg_data.signature;
+    has_control_point = io_reg_data.flags & CONTROL_POINT_BIT;
+    control_point_count = io_reg_data.control_point_count;
+
+    if (range->dst.reg.idx_count != 1 + !!has_control_point)
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT,
+                "Invalid index count %u in DCL_INDEX_RANGE instruction.",
+                range->dst.reg.idx_count);
+        return;
+    }
+
+    if (range->dst.reg.idx[0].rel_addr || (has_control_point && range->dst.reg.idx[1].rel_addr))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                "Invalid relative address in DCL_INDEX_RANGE instruction.");
+
+    if (has_control_point)
+    {
+        if (range->dst.reg.idx[0].offset != control_point_count)
+        {
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                    "Invalid control point index %u in DCL_INDEX_RANGE instruction, expected %u.",
+                    range->dst.reg.idx[0].offset, control_point_count);
+        }
+
+        base_register_idx = range->dst.reg.idx[1].offset;
+    }
+    else
+    {
+        base_register_idx = range->dst.reg.idx[0].offset;
+    }
+
+    if (range->register_count < 2)
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_RANGE,
+                "Invalid register count %u in DCL_INDEX_RANGE instruction, expected at least 2.",
+                range->register_count);
+        return;
+    }
+
+    /* Check that for each register in the range the write mask intersects at
+     * most one (and possibly zero) signature elements. Keep track of the union
+     * of all signature element masks. */
+    for (i = 0; i < range->register_count; ++i)
+    {
+        bool found = false;
+
+        for (j = 0; j < signature->element_count; ++j)
+        {
+            const struct signature_element *element = &signature->elements[j];
+
+            if (base_register_idx + i != element->register_index || !(range->dst.write_mask & element->mask))
+                continue;
+
+            if (found)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                        "Invalid write mask %#x on a DCL_INDEX_RANGE destination parameter.",
+                        range->dst.write_mask);
+
+            found = true;
+
+            if (first_component == UINT_MAX)
+                first_component = vsir_write_mask_get_component_idx(element->mask);
+            else if (first_component != vsir_write_mask_get_component_idx(element->mask))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                        "Signature masks are not left-aligned within a DCL_INDEX_RANGE.");
+
+            effective_write_mask |= element->mask;
+        }
+    }
+
+    /* Check again to have at most one intersection for each register, but this
+     * time using the effective write mask. Also check that we have stabilized,
+     * i.e., the effective write mask now contains all the signature element
+     * masks. This important for being able to merge all the signature elements
+     * in a single one without conflicts (there is no hard reason why we
+     * couldn't support an effective write mask that stabilizes after more
+     * iterations, but the code would be more complicated, and we avoid that if
+     * we can). */
+    for (i = 0; i < range->register_count; ++i)
+    {
+        bool found = false;
+
+        for (j = 0; j < signature->element_count; ++j)
+        {
+            const struct signature_element *element = &signature->elements[j];
+
+            if (base_register_idx + i != element->register_index || !(effective_write_mask & element->mask))
+                continue;
+
+            if (element->sysval_semantic != VKD3D_SHADER_SV_NONE
+                    && !vsir_sysval_semantic_is_tess_factor(element->sysval_semantic))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "Invalid sysval semantic %#x on a signature element touched by DCL_INDEX_RANGE.",
+                        element->sysval_semantic);
+
+            if (sysval == ~0u)
+            {
+                sysval = element->sysval_semantic;
+                /* Line density and line detail can be arrayed together. */
+                if (sysval == VKD3D_SHADER_SV_TESS_FACTOR_LINEDEN)
+                    sysval = VKD3D_SHADER_SV_TESS_FACTOR_LINEDET;
+            }
+            else
+            {
+                if (sysval != element->sysval_semantic)
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                            "Inconsistent sysval semantic %#x on a signature element touched by DCL_INDEX_RANGE, "
+                            "%#x was already seen.",
+                            element->sysval_semantic, sysval);
+            }
+
+            if (found)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                        "Invalid write mask %#x on a DCL_INDEX_RANGE destination parameter.",
+                        range->dst.write_mask);
+
+            found = true;
+
+            if (~effective_write_mask & element->mask)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                        "Invalid write mask %#x on a signature element touched by a "
+                        "DCL_INDEX_RANGE instruction with effective write mask %#x.",
+                        element->mask, effective_write_mask);
+
+            if (first_component != vsir_write_mask_get_component_idx(element->mask))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK,
+                        "Signature element masks are not left-aligned within a DCL_INDEX_RANGE.");
+        }
+    }
+
+    VKD3D_ASSERT(sysval != ~0u);
+}
+
+static void vsir_validate_dcl_input(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.dst.reg.type)
+    {
+        /* Signature input registers. */
+        case VKD3DSPR_INPUT:
+        case VKD3DSPR_INCONTROLPOINT:
+        case VKD3DSPR_OUTCONTROLPOINT:
+        case VKD3DSPR_PATCHCONST:
+        /* Non-signature input registers. */
+        case VKD3DSPR_PRIMID:
+        case VKD3DSPR_FORKINSTID:
+        case VKD3DSPR_JOININSTID:
+        case VKD3DSPR_THREADID:
+        case VKD3DSPR_THREADGROUPID:
+        case VKD3DSPR_LOCALTHREADID:
+        case VKD3DSPR_LOCALTHREADINDEX:
+        case VKD3DSPR_COVERAGE:
+        case VKD3DSPR_TESSCOORD:
+        case VKD3DSPR_OUTPOINTID:
+        case VKD3DSPR_GSINSTID:
+        case VKD3DSPR_WAVELANECOUNT:
+        case VKD3DSPR_WAVELANEINDEX:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_INPUT.",
+                    instruction->declaration.dst.reg.type);
+    }
+}
+
 static void vsir_validate_dcl_input_primitive(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -7763,6 +9000,105 @@ static void vsir_validate_dcl_input_primitive(struct validation_context *ctx,
                 instruction->declaration.primitive_type.type);
 }
 
+static void vsir_validate_dcl_input_ps(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.dst.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_INPUT_PS.",
+                    instruction->declaration.dst.reg.type);
+    }
+}
+
+static void vsir_validate_dcl_input_ps_sgv(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.register_semantic.reg.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_INPUT_PS_SGV.",
+                    instruction->declaration.register_semantic.reg.reg.type);
+    }
+}
+
+static void vsir_validate_dcl_input_ps_siv(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.register_semantic.reg.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_INPUT_PS_SIV.",
+                    instruction->declaration.register_semantic.reg.reg.type);
+    }
+}
+
+static void vsir_validate_dcl_input_sgv(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.register_semantic.reg.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_INPUT_SGV.",
+                    instruction->declaration.register_semantic.reg.reg.type);
+    }
+}
+
+static void vsir_validate_dcl_input_siv(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.register_semantic.reg.reg.type)
+    {
+        case VKD3DSPR_INPUT:
+        case VKD3DSPR_PATCHCONST:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_INPUT_SIV.",
+                    instruction->declaration.register_semantic.reg.reg.type);
+    }
+}
+
+static void vsir_validate_dcl_output(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.dst.reg.type)
+    {
+        /* Signature output registers. */
+        case VKD3DSPR_OUTPUT:
+        case VKD3DSPR_PATCHCONST:
+        /* Non-signature output registers. */
+        case VKD3DSPR_DEPTHOUT:
+        case VKD3DSPR_SAMPLEMASK:
+        case VKD3DSPR_DEPTHOUTGE:
+        case VKD3DSPR_DEPTHOUTLE:
+        case VKD3DSPR_OUTSTENCILREF:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_OUTPUT.",
+                    instruction->declaration.dst.reg.type);
+    }
+}
+
 static void vsir_validate_dcl_output_control_point_count(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -7772,6 +9108,22 @@ static void vsir_validate_dcl_output_control_point_count(struct validation_conte
                 instruction->declaration.count);
 }
 
+static void vsir_validate_dcl_output_siv(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    switch (instruction->declaration.register_semantic.reg.reg.type)
+    {
+        case VKD3DSPR_OUTPUT:
+        case VKD3DSPR_PATCHCONST:
+            break;
+
+        default:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid register type %#x in instruction DCL_OUTPUT_SIV.",
+                    instruction->declaration.register_semantic.reg.reg.type);
+    }
+}
+
 static void vsir_validate_dcl_output_topology(struct validation_context *ctx,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -7801,6 +9153,11 @@ static void vsir_validate_dcl_tessellator_domain(struct validation_context *ctx,
             || instruction->declaration.tessellator_domain >= VKD3D_TESSELLATOR_DOMAIN_COUNT)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_TESSELLATION,
                 "Tessellator domain %#x is invalid.", instruction->declaration.tessellator_domain);
+
+    if (instruction->declaration.tessellator_domain != ctx->program->tess_domain)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_TESSELLATION,
+                "DCL_TESSELLATOR_DOMAIN argument %#x doesn't match the shader tessellator domain %#x.",
+                instruction->declaration.tessellator_domain, ctx->program->tess_domain);
 }
 
 static void vsir_validate_dcl_tessellator_output_primitive(struct validation_context *ctx,
@@ -8063,8 +9420,17 @@ static const struct vsir_validator_instruction_desc vsir_validator_instructions[
     [VKD3DSIH_HS_JOIN_PHASE] =                    {0,   0, vsir_validate_hull_shader_phase},
     [VKD3DSIH_DCL_GS_INSTANCES] =                 {0,   0, vsir_validate_dcl_gs_instances},
     [VKD3DSIH_DCL_HS_MAX_TESSFACTOR] =            {0,   0, vsir_validate_dcl_hs_max_tessfactor},
+    [VKD3DSIH_DCL_INDEX_RANGE] =                  {0,   0, vsir_validate_dcl_index_range},
+    [VKD3DSIH_DCL_INPUT] =                        {0,   0, vsir_validate_dcl_input},
     [VKD3DSIH_DCL_INPUT_PRIMITIVE] =              {0,   0, vsir_validate_dcl_input_primitive},
+    [VKD3DSIH_DCL_INPUT_PS] =                     {0,   0, vsir_validate_dcl_input_ps},
+    [VKD3DSIH_DCL_INPUT_PS_SGV] =                 {0,   0, vsir_validate_dcl_input_ps_sgv},
+    [VKD3DSIH_DCL_INPUT_PS_SIV] =                 {0,   0, vsir_validate_dcl_input_ps_siv},
+    [VKD3DSIH_DCL_INPUT_SGV] =                    {0,   0, vsir_validate_dcl_input_sgv},
+    [VKD3DSIH_DCL_INPUT_SIV] =                    {0,   0, vsir_validate_dcl_input_siv},
+    [VKD3DSIH_DCL_OUTPUT] =                       {0,   0, vsir_validate_dcl_output},
     [VKD3DSIH_DCL_OUTPUT_CONTROL_POINT_COUNT] =   {0,   0, vsir_validate_dcl_output_control_point_count},
+    [VKD3DSIH_DCL_OUTPUT_SIV] =                   {0,   0, vsir_validate_dcl_output_siv},
     [VKD3DSIH_DCL_OUTPUT_TOPOLOGY] =              {0,   0, vsir_validate_dcl_output_topology},
     [VKD3DSIH_DCL_TEMPS] =                        {0,   0, vsir_validate_dcl_temps},
     [VKD3DSIH_DCL_TESSELLATOR_DOMAIN] =           {0,   0, vsir_validate_dcl_tessellator_domain},
@@ -8177,6 +9543,12 @@ enum vkd3d_result vsir_program_validate(struct vsir_program *program, uint64_t c
         .status = VKD3D_OK,
         .phase = VKD3DSIH_INVALID,
         .invalid_instruction_idx = true,
+        .outer_tess_idxs[0] = ~0u,
+        .outer_tess_idxs[1] = ~0u,
+        .outer_tess_idxs[2] = ~0u,
+        .outer_tess_idxs[3] = ~0u,
+        .inner_tess_idxs[0] = ~0u,
+        .inner_tess_idxs[1] = ~0u,
     };
     unsigned int i;
 
@@ -8187,12 +9559,20 @@ enum vkd3d_result vsir_program_validate(struct vsir_program *program, uint64_t c
     {
         case VKD3D_SHADER_TYPE_HULL:
         case VKD3D_SHADER_TYPE_DOMAIN:
+            if (program->tess_domain == VKD3D_TESSELLATOR_DOMAIN_INVALID
+                    || program->tess_domain >= VKD3D_TESSELLATOR_DOMAIN_COUNT)
+                validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_TESSELLATION,
+                        "Invalid tessellation domain %#x.", program->tess_domain);
             break;
 
         default:
             if (program->patch_constant_signature.element_count != 0)
                 validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
                         "Patch constant signature is only valid for hull and domain shaders.");
+
+            if (program->tess_domain != VKD3D_TESSELLATOR_DOMAIN_INVALID)
+                validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_TESSELLATION,
+                        "Invalid tessellation domain %#x.", program->tess_domain);
     }
 
     switch (program->shader_version.type)
@@ -8226,9 +9606,47 @@ enum vkd3d_result vsir_program_validate(struct vsir_program *program, uint64_t c
                         program->output_control_point_count);
     }
 
-    vsir_validate_signature(&ctx, &program->input_signature, SIGNATURE_TYPE_INPUT);
-    vsir_validate_signature(&ctx, &program->output_signature, SIGNATURE_TYPE_OUTPUT);
-    vsir_validate_signature(&ctx, &program->patch_constant_signature, SIGNATURE_TYPE_PATCH_CONSTANT);
+    vsir_validate_signature(&ctx, &program->input_signature,
+            &ctx.input_signature_data, SIGNATURE_TYPE_INPUT);
+    vsir_validate_signature(&ctx, &program->output_signature,
+            &ctx.output_signature_data, SIGNATURE_TYPE_OUTPUT);
+    vsir_validate_signature(&ctx, &program->patch_constant_signature,
+            &ctx.patch_constant_signature_data, SIGNATURE_TYPE_PATCH_CONSTANT);
+
+    for (i = 0; i < sizeof(program->io_dcls) * CHAR_BIT; ++i)
+    {
+        if (!bitmap_is_set(program->io_dcls, i))
+            continue;
+
+        switch (i)
+        {
+            /* Input registers */
+            case VKD3DSPR_PRIMID:
+            case VKD3DSPR_FORKINSTID:
+            case VKD3DSPR_JOININSTID:
+            case VKD3DSPR_THREADID:
+            case VKD3DSPR_THREADGROUPID:
+            case VKD3DSPR_LOCALTHREADID:
+            case VKD3DSPR_LOCALTHREADINDEX:
+            case VKD3DSPR_COVERAGE:
+            case VKD3DSPR_TESSCOORD:
+            case VKD3DSPR_OUTPOINTID:
+            case VKD3DSPR_GSINSTID:
+            case VKD3DSPR_WAVELANECOUNT:
+            case VKD3DSPR_WAVELANEINDEX:
+            /* Output registers */
+            case VKD3DSPR_DEPTHOUT:
+            case VKD3DSPR_SAMPLEMASK:
+            case VKD3DSPR_DEPTHOUTGE:
+            case VKD3DSPR_DEPTHOUTLE:
+            case VKD3DSPR_OUTSTENCILREF:
+                break;
+
+            default:
+                validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE,
+                        "Invalid input/output declaration %u.", i);
+        }
+    }
 
     if (!(ctx.temps = vkd3d_calloc(ctx.program->temp_count, sizeof(*ctx.temps))))
         goto fail;
@@ -8318,6 +9736,12 @@ enum vkd3d_result vsir_program_transform_early(struct vsir_program *program, uin
     if (program->shader_version.major <= 2)
         vsir_transform(&ctx, vsir_program_add_diffuse_output);
 
+    /* For vsir_program_insert_fragment_fog(). */
+    vsir_transform(&ctx, vsir_program_add_fog_input);
+
+    /* For vsir_program_insert_vertex_fog(). */
+    vsir_transform(&ctx, vsir_program_add_fog_output);
+
     return ctx.result;
 }
 
@@ -8372,6 +9796,8 @@ enum vkd3d_result vsir_program_transform(struct vsir_program *program, uint64_t
     vsir_transform(&ctx, vsir_program_insert_point_size);
     vsir_transform(&ctx, vsir_program_insert_point_size_clamp);
     vsir_transform(&ctx, vsir_program_insert_point_coord);
+    vsir_transform(&ctx, vsir_program_insert_fragment_fog);
+    vsir_transform(&ctx, vsir_program_insert_vertex_fog);
 
     if (TRACE_ON())
         vsir_program_trace(program);
diff --git a/libs/vkd3d/libs/vkd3d-shader/msl.c b/libs/vkd3d/libs/vkd3d-shader/msl.c
index df3edeaa4e6..bb85e62e94c 100644
--- a/libs/vkd3d/libs/vkd3d-shader/msl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/msl.c
@@ -41,6 +41,8 @@ struct msl_generator
     const char *prefix;
     bool failed;
 
+    bool write_depth;
+
     const struct vkd3d_shader_interface_info *interface_info;
     const struct vkd3d_shader_scan_descriptor_info1 *descriptor_info;
 };
@@ -153,6 +155,72 @@ static void msl_print_register_name(struct vkd3d_string_buffer *buffer,
             msl_print_register_datatype(buffer, gen, reg->data_type);
             break;
 
+        case VKD3DSPR_DEPTHOUT:
+            if (gen->program->shader_version.type != VKD3D_SHADER_TYPE_PIXEL)
+                msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                        "Internal compiler error: Unhandled depth output in shader type #%x.",
+                        gen->program->shader_version.type);
+            vkd3d_string_buffer_printf(buffer, "o_depth");
+            break;
+
+        case VKD3DSPR_IMMCONST:
+            switch (reg->dimension)
+            {
+                case VSIR_DIMENSION_SCALAR:
+                    switch (reg->data_type)
+                    {
+                        case VKD3D_DATA_INT:
+                            vkd3d_string_buffer_printf(buffer, "as_type<int>(%#xu)", reg->u.immconst_u32[0]);
+                            break;
+                        case VKD3D_DATA_UINT:
+                            vkd3d_string_buffer_printf(buffer, "%#xu", reg->u.immconst_u32[0]);
+                            break;
+                        case VKD3D_DATA_FLOAT:
+                            vkd3d_string_buffer_printf(buffer, "as_type<float>(%#xu)", reg->u.immconst_u32[0]);
+                            break;
+                        default:
+                            msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                                    "Internal compiler error: Unhandled immconst datatype %#x.", reg->data_type);
+                            vkd3d_string_buffer_printf(buffer, "<unrecognised immconst datatype %#x>", reg->data_type);
+                            break;
+                    }
+                    break;
+
+                case VSIR_DIMENSION_VEC4:
+                    switch (reg->data_type)
+                    {
+                        case VKD3D_DATA_INT:
+                            vkd3d_string_buffer_printf(buffer, "as_type<int4>(uint4(%#xu, %#xu, %#xu, %#xu))",
+                                    reg->u.immconst_u32[0], reg->u.immconst_u32[1],
+                                    reg->u.immconst_u32[2], reg->u.immconst_u32[3]);
+                            break;
+                        case VKD3D_DATA_UINT:
+                            vkd3d_string_buffer_printf(buffer, "uint4(%#xu, %#xu, %#xu, %#xu)",
+                                    reg->u.immconst_u32[0], reg->u.immconst_u32[1],
+                                    reg->u.immconst_u32[2], reg->u.immconst_u32[3]);
+                            vkd3d_string_buffer_printf(buffer, "%#xu", reg->u.immconst_u32[0]);
+                            break;
+                        case VKD3D_DATA_FLOAT:
+                            vkd3d_string_buffer_printf(buffer, "as_type<float4>(uint4(%#xu, %#xu, %#xu, %#xu))",
+                                    reg->u.immconst_u32[0], reg->u.immconst_u32[1],
+                                    reg->u.immconst_u32[2], reg->u.immconst_u32[3]);
+                            break;
+                        default:
+                            msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                                    "Internal compiler error: Unhandled immconst datatype %#x.", reg->data_type);
+                            vkd3d_string_buffer_printf(buffer, "<unrecognised immconst datatype %#x>", reg->data_type);
+                            break;
+                    }
+                    break;
+
+                default:
+                    vkd3d_string_buffer_printf(buffer, "<unhandled_dimension %#x>", reg->dimension);
+                    msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                            "Internal compiler error: Unhandled dimension %#x.", reg->dimension);
+                    break;
+            }
+            break;
+
         case VKD3DSPR_CONSTBUFFER:
             if (reg->idx_count != 3)
             {
@@ -215,19 +283,43 @@ static void msl_src_init(struct msl_src *msl_src, struct msl_generator *gen,
         const struct vkd3d_shader_src_param *vsir_src, uint32_t mask)
 {
     const struct vkd3d_shader_register *reg = &vsir_src->reg;
+    struct vkd3d_string_buffer *str;
 
     msl_src->str = vkd3d_string_buffer_get(&gen->string_buffers);
 
     if (reg->non_uniform)
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
                 "Internal compiler error: Unhandled 'non-uniform' modifier.");
-    if (vsir_src->modifiers)
-        msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
-                "Internal compiler error: Unhandled source modifier(s) %#x.", vsir_src->modifiers);
 
-    msl_print_register_name(msl_src->str, gen, reg);
+    if (!vsir_src->modifiers)
+        str = msl_src->str;
+    else
+        str = vkd3d_string_buffer_get(&gen->string_buffers);
+
+    msl_print_register_name(str, gen, reg);
     if (reg->dimension == VSIR_DIMENSION_VEC4)
-        msl_print_swizzle(msl_src->str, vsir_src->swizzle, mask);
+        msl_print_swizzle(str, vsir_src->swizzle, mask);
+
+    switch (vsir_src->modifiers)
+    {
+        case VKD3DSPSM_NONE:
+            break;
+        case VKD3DSPSM_NEG:
+            vkd3d_string_buffer_printf(msl_src->str, "-%s", str->buffer);
+            break;
+        case VKD3DSPSM_ABS:
+            vkd3d_string_buffer_printf(msl_src->str, "abs(%s)", str->buffer);
+            break;
+        default:
+            vkd3d_string_buffer_printf(msl_src->str, "<unhandled modifier %#x>(%s)",
+                    vsir_src->modifiers, str->buffer);
+            msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                    "Internal compiler error: Unhandled source modifier(s) %#x.", vsir_src->modifiers);
+            break;
+    }
+
+    if (str != msl_src->str)
+        vkd3d_string_buffer_release(&gen->string_buffers, str);
 }
 
 static void msl_dst_cleanup(struct msl_dst *dst, struct vkd3d_string_buffer_cache *cache)
@@ -253,7 +345,8 @@ static uint32_t msl_dst_init(struct msl_dst *msl_dst, struct msl_generator *gen,
     msl_dst->mask = vkd3d_string_buffer_get(&gen->string_buffers);
 
     msl_print_register_name(msl_dst->register_name, gen, &vsir_dst->reg);
-    msl_print_write_mask(msl_dst->mask, write_mask);
+    if (vsir_dst->reg.dimension == VSIR_DIMENSION_VEC4)
+        msl_print_write_mask(msl_dst->mask, write_mask);
 
     return write_mask;
 }
@@ -261,22 +354,29 @@ static uint32_t msl_dst_init(struct msl_dst *msl_dst, struct msl_generator *gen,
 static void VKD3D_PRINTF_FUNC(3, 4) msl_print_assignment(
         struct msl_generator *gen, struct msl_dst *dst, const char *format, ...)
 {
+    uint32_t modifiers = dst->vsir->modifiers;
     va_list args;
 
     if (dst->vsir->shift)
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
                 "Internal compiler error: Unhandled destination shift %#x.", dst->vsir->shift);
-    if (dst->vsir->modifiers)
+    if (modifiers & ~VKD3DSPDM_SATURATE)
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
-                "Internal compiler error: Unhandled destination modifier(s) %#x.", dst->vsir->modifiers);
+                "Internal compiler error: Unhandled destination modifier(s) %#x.", modifiers);
 
     msl_print_indent(gen->buffer, gen->indent);
     vkd3d_string_buffer_printf(gen->buffer, "%s%s = ", dst->register_name->buffer, dst->mask->buffer);
 
+    if (modifiers & VKD3DSPDM_SATURATE)
+        vkd3d_string_buffer_printf(gen->buffer, "saturate(");
+
     va_start(args, format);
     vkd3d_string_buffer_vprintf(gen->buffer, format, args);
     va_end(args);
 
+    if (modifiers & VKD3DSPDM_SATURATE)
+        vkd3d_string_buffer_printf(gen->buffer, ")");
+
     vkd3d_string_buffer_printf(gen->buffer, ";\n");
 }
 
@@ -288,6 +388,164 @@ static void msl_unhandled(struct msl_generator *gen, const struct vkd3d_shader_i
             "Internal compiler error: Unhandled instruction %#x.", ins->opcode);
 }
 
+static void msl_binop(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins, const char *op)
+{
+    struct msl_src src[2];
+    struct msl_dst dst;
+    uint32_t mask;
+
+    mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    msl_src_init(&src[0], gen, &ins->src[0], mask);
+    msl_src_init(&src[1], gen, &ins->src[1], mask);
+
+    msl_print_assignment(gen, &dst, "%s %s %s", src[0].str->buffer, op, src[1].str->buffer);
+
+    msl_src_cleanup(&src[1], &gen->string_buffers);
+    msl_src_cleanup(&src[0], &gen->string_buffers);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
+static void msl_dot(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins, uint32_t src_mask)
+{
+    unsigned int component_count;
+    struct msl_src src[2];
+    struct msl_dst dst;
+    uint32_t dst_mask;
+
+    dst_mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    msl_src_init(&src[0], gen, &ins->src[0], src_mask);
+    msl_src_init(&src[1], gen, &ins->src[1], src_mask);
+
+    if ((component_count = vsir_write_mask_component_count(dst_mask)) > 1)
+        msl_print_assignment(gen, &dst, "float%u(dot(%s, %s))",
+                component_count, src[0].str->buffer, src[1].str->buffer);
+    else
+        msl_print_assignment(gen, &dst, "dot(%s, %s)", src[0].str->buffer, src[1].str->buffer);
+
+    msl_src_cleanup(&src[1], &gen->string_buffers);
+    msl_src_cleanup(&src[0], &gen->string_buffers);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
+static void msl_intrinsic(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins, const char *op)
+{
+    struct vkd3d_string_buffer *args;
+    struct msl_src src;
+    struct msl_dst dst;
+    unsigned int i;
+    uint32_t mask;
+
+    mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    args = vkd3d_string_buffer_get(&gen->string_buffers);
+
+    for (i = 0; i < ins->src_count; ++i)
+    {
+        msl_src_init(&src, gen, &ins->src[i], mask);
+        vkd3d_string_buffer_printf(args, "%s%s", i ? ", " : "", src.str->buffer);
+        msl_src_cleanup(&src, &gen->string_buffers);
+    }
+
+    msl_print_assignment(gen, &dst, "%s(%s)", op, args->buffer);
+
+    vkd3d_string_buffer_release(&gen->string_buffers, args);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
+static void msl_relop(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins, const char *op)
+{
+    unsigned int mask_size;
+    struct msl_src src[2];
+    struct msl_dst dst;
+    uint32_t mask;
+
+    mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    msl_src_init(&src[0], gen, &ins->src[0], mask);
+    msl_src_init(&src[1], gen, &ins->src[1], mask);
+
+    if ((mask_size = vsir_write_mask_component_count(mask)) > 1)
+        msl_print_assignment(gen, &dst, "select(uint%u(0u), uint%u(0xffffffffu), bool%u(%s %s %s))",
+                mask_size, mask_size, mask_size, src[0].str->buffer, op, src[1].str->buffer);
+    else
+        msl_print_assignment(gen, &dst, "%s %s %s ? 0xffffffffu : 0u",
+                src[0].str->buffer, op, src[1].str->buffer);
+
+    msl_src_cleanup(&src[1], &gen->string_buffers);
+    msl_src_cleanup(&src[0], &gen->string_buffers);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
+static void msl_cast(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins, const char *constructor)
+{
+    unsigned int component_count;
+    struct msl_src src;
+    struct msl_dst dst;
+    uint32_t mask;
+
+    mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    msl_src_init(&src, gen, &ins->src[0], mask);
+
+    if ((component_count = vsir_write_mask_component_count(mask)) > 1)
+        msl_print_assignment(gen, &dst, "%s%u(%s)", constructor, component_count, src.str->buffer);
+    else
+        msl_print_assignment(gen, &dst, "%s(%s)", constructor, src.str->buffer);
+
+    msl_src_cleanup(&src, &gen->string_buffers);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
+static void msl_end_block(struct msl_generator *gen)
+{
+    --gen->indent;
+    msl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "}\n");
+}
+
+static void msl_begin_block(struct msl_generator *gen)
+{
+    msl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "{\n");
+    ++gen->indent;
+}
+
+static void msl_if(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins)
+{
+    const char *condition;
+    struct msl_src src;
+
+    msl_src_init(&src, gen, &ins->src[0], VKD3DSP_WRITEMASK_0);
+
+    msl_print_indent(gen->buffer, gen->indent);
+    condition = ins->flags == VKD3D_SHADER_CONDITIONAL_OP_NZ ? "bool" : "!bool";
+    vkd3d_string_buffer_printf(gen->buffer, "if (%s(%s))\n", condition, src.str->buffer);
+
+    msl_src_cleanup(&src, &gen->string_buffers);
+
+    msl_begin_block(gen);
+}
+
+static void msl_else(struct msl_generator *gen)
+{
+    msl_end_block(gen);
+    msl_print_indent(gen->buffer, gen->indent);
+    vkd3d_string_buffer_printf(gen->buffer, "else\n");
+    msl_begin_block(gen);
+}
+
+static void msl_unary_op(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins, const char *op)
+{
+    struct msl_src src;
+    struct msl_dst dst;
+    uint32_t mask;
+
+    mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    msl_src_init(&src, gen, &ins->src[0], mask);
+
+    msl_print_assignment(gen, &dst, "%s%s", op, src.str->buffer);
+
+    msl_src_cleanup(&src, &gen->string_buffers);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
 static void msl_mov(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins)
 {
     struct msl_src src;
@@ -303,6 +561,31 @@ static void msl_mov(struct msl_generator *gen, const struct vkd3d_shader_instruc
     msl_dst_cleanup(&dst, &gen->string_buffers);
 }
 
+static void msl_movc(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins)
+{
+    unsigned int component_count;
+    struct msl_src src[3];
+    struct msl_dst dst;
+    uint32_t mask;
+
+    mask = msl_dst_init(&dst, gen, ins, &ins->dst[0]);
+    msl_src_init(&src[0], gen, &ins->src[0], mask);
+    msl_src_init(&src[1], gen, &ins->src[1], mask);
+    msl_src_init(&src[2], gen, &ins->src[2], mask);
+
+    if ((component_count = vsir_write_mask_component_count(mask)) > 1)
+        msl_print_assignment(gen, &dst, "select(%s, %s, bool%u(%s))",
+                src[2].str->buffer, src[1].str->buffer, component_count, src[0].str->buffer);
+    else
+        msl_print_assignment(gen, &dst, "select(%s, %s, bool(%s))",
+                src[2].str->buffer, src[1].str->buffer, src[0].str->buffer);
+
+    msl_src_cleanup(&src[2], &gen->string_buffers);
+    msl_src_cleanup(&src[1], &gen->string_buffers);
+    msl_src_cleanup(&src[0], &gen->string_buffers);
+    msl_dst_cleanup(&dst, &gen->string_buffers);
+}
+
 static void msl_ret(struct msl_generator *gen, const struct vkd3d_shader_instruction *ins)
 {
     msl_print_indent(gen->buffer, gen->indent);
@@ -315,17 +598,119 @@ static void msl_handle_instruction(struct msl_generator *gen, const struct vkd3d
 
     switch (ins->opcode)
     {
-        case VKD3DSIH_DCL_INPUT:
-        case VKD3DSIH_DCL_OUTPUT:
-        case VKD3DSIH_DCL_OUTPUT_SIV:
+        case VKD3DSIH_ADD:
+            msl_binop(gen, ins, "+");
+            break;
+        case VKD3DSIH_AND:
+            msl_binop(gen, ins, "&");
+            break;
         case VKD3DSIH_NOP:
             break;
+        case VKD3DSIH_DIV:
+            msl_binop(gen, ins, "/");
+            break;
+        case VKD3DSIH_DP2:
+            msl_dot(gen, ins, vkd3d_write_mask_from_component_count(2));
+            break;
+        case VKD3DSIH_DP3:
+            msl_dot(gen, ins, vkd3d_write_mask_from_component_count(3));
+            break;
+        case VKD3DSIH_DP4:
+            msl_dot(gen, ins, VKD3DSP_WRITEMASK_ALL);
+            break;
+        case VKD3DSIH_ELSE:
+            msl_else(gen);
+            break;
+        case VKD3DSIH_ENDIF:
+            msl_end_block(gen);
+            break;
+        case VKD3DSIH_IEQ:
+            msl_relop(gen, ins, "==");
+            break;
+        case VKD3DSIH_EXP:
+            msl_intrinsic(gen, ins, "exp2");
+            break;
+        case VKD3DSIH_FRC:
+            msl_intrinsic(gen, ins, "fract");
+            break;
+        case VKD3DSIH_FTOI:
+            msl_cast(gen, ins, "int");
+            break;
+        case VKD3DSIH_FTOU:
+            msl_cast(gen, ins, "uint");
+            break;
+        case VKD3DSIH_GEO:
+            msl_relop(gen, ins, ">=");
+            break;
+        case VKD3DSIH_IF:
+            msl_if(gen, ins);
+            break;
+        case VKD3DSIH_ISHL:
+            msl_binop(gen, ins, "<<");
+            break;
+        case VKD3DSIH_ISHR:
+        case VKD3DSIH_USHR:
+            msl_binop(gen, ins, ">>");
+            break;
+        case VKD3DSIH_LTO:
+            msl_relop(gen, ins, "<");
+            break;
+        case VKD3DSIH_MAD:
+            msl_intrinsic(gen, ins, "fma");
+            break;
+        case VKD3DSIH_MAX:
+            msl_intrinsic(gen, ins, "max");
+            break;
+        case VKD3DSIH_MIN:
+            msl_intrinsic(gen, ins, "min");
+            break;
+        case VKD3DSIH_INE:
+        case VKD3DSIH_NEU:
+            msl_relop(gen, ins, "!=");
+            break;
+        case VKD3DSIH_ITOF:
+        case VKD3DSIH_UTOF:
+            msl_cast(gen, ins, "float");
+            break;
+        case VKD3DSIH_LOG:
+            msl_intrinsic(gen, ins, "log2");
+            break;
         case VKD3DSIH_MOV:
             msl_mov(gen, ins);
             break;
+        case VKD3DSIH_MOVC:
+            msl_movc(gen, ins);
+            break;
+        case VKD3DSIH_MUL:
+            msl_binop(gen, ins, "*");
+            break;
+        case VKD3DSIH_NOT:
+            msl_unary_op(gen, ins, "~");
+            break;
+        case VKD3DSIH_OR:
+            msl_binop(gen, ins, "|");
+            break;
         case VKD3DSIH_RET:
             msl_ret(gen, ins);
             break;
+        case VKD3DSIH_ROUND_NE:
+            msl_intrinsic(gen, ins, "rint");
+            break;
+        case VKD3DSIH_ROUND_NI:
+            msl_intrinsic(gen, ins, "floor");
+            break;
+        case VKD3DSIH_ROUND_PI:
+            msl_intrinsic(gen, ins, "ceil");
+            break;
+        case VKD3DSIH_ROUND_Z:
+            msl_intrinsic(gen, ins, "trunc");
+            break;
+        case VKD3DSIH_RSQ:
+            msl_intrinsic(gen, ins, "rsqrt");
+            break;
+        case VKD3DSIH_SQRT:
+            msl_intrinsic(gen, ins, "sqrt");
+            break;
         default:
             msl_unhandled(gen, ins);
             break;
@@ -489,6 +874,16 @@ static void msl_generate_input_struct_declarations(struct msl_generator *gen)
 
         if (e->sysval_semantic)
         {
+            if (e->sysval_semantic == VKD3D_SHADER_SV_IS_FRONT_FACE)
+            {
+                if (type != VKD3D_SHADER_TYPE_PIXEL)
+                    msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                            "Internal compiler error: Unhandled SV_IS_FRONT_FACE in shader type #%x.", type);
+
+                msl_print_indent(gen->buffer, 1);
+                vkd3d_string_buffer_printf(buffer, "bool is_front_face [[front_facing]];\n");
+                continue;
+            }
             msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
                     "Internal compiler error: Unhandled system value %#x.", e->sysval_semantic);
             continue;
@@ -501,13 +896,6 @@ static void msl_generate_input_struct_declarations(struct msl_generator *gen)
             continue;
         }
 
-        if (e->interpolation_mode != VKD3DSIM_NONE)
-        {
-            msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
-                    "Internal compiler error: Unhandled interpolation mode %#x.", e->interpolation_mode);
-            continue;
-        }
-
         if(e->register_count > 1)
         {
             msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
@@ -551,6 +939,18 @@ static void msl_generate_input_struct_declarations(struct msl_generator *gen)
                 break;
         }
 
+        switch (e->interpolation_mode)
+        {
+            /* The default interpolation attribute. */
+            case VKD3DSIM_LINEAR:
+            case VKD3DSIM_NONE:
+                break;
+            default:
+                msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
+                        "Internal compiler error: Unhandled interpolation mode %#x.", e->interpolation_mode);
+                break;
+        }
+
         vkd3d_string_buffer_printf(buffer, ";\n");
     }
 
@@ -602,6 +1002,14 @@ static void msl_generate_output_struct_declarations(struct msl_generator *gen)
     {
         e = &signature->elements[i];
 
+        if (e->sysval_semantic == VKD3D_SHADER_SV_DEPTH)
+        {
+            gen->write_depth = true;
+            msl_print_indent(gen->buffer, 1);
+            vkd3d_string_buffer_printf(buffer, "float shader_out_depth [[depth(any)]];\n");
+            continue;
+        }
+
         if (e->target_location == SIGNATURE_TARGET_LOCATION_UNUSED)
             continue;
 
@@ -690,6 +1098,10 @@ static void msl_generate_entrypoint_prologue(struct msl_generator *gen)
             vkd3d_string_buffer_printf(buffer, " = input.shader_in_%u", i);
             msl_print_write_mask(buffer, e->mask);
         }
+        else if (e->sysval_semantic == VKD3D_SHADER_SV_IS_FRONT_FACE)
+        {
+            vkd3d_string_buffer_printf(buffer, ".u = uint4(input.is_front_face ? 0xffffffffu : 0u, 0, 0, 0)");
+        }
         else
         {
             vkd3d_string_buffer_printf(buffer, " = <unhandled sysval %#x>", e->sysval_semantic);
@@ -711,6 +1123,12 @@ static void msl_generate_entrypoint_epilogue(struct msl_generator *gen)
     {
         e = &signature->elements[i];
 
+        if (e->sysval_semantic == VKD3D_SHADER_SV_DEPTH)
+        {
+            vkd3d_string_buffer_printf(buffer, "    output.shader_out_depth = shader_out_depth;\n");
+            continue;
+        }
+
         if (e->target_location == SIGNATURE_TARGET_LOCATION_UNUSED)
             continue;
 
@@ -770,9 +1188,14 @@ static void msl_generate_entrypoint(struct msl_generator *gen)
     vkd3d_string_buffer_printf(gen->buffer, "    vkd3d_vec4 %s_out[%u];\n", gen->prefix, 32);
     vkd3d_string_buffer_printf(gen->buffer, "    vkd3d_%s_out output;\n", gen->prefix);
 
+    if (gen->write_depth)
+        vkd3d_string_buffer_printf(gen->buffer, "    float shader_out_depth;\n");
+
     msl_generate_entrypoint_prologue(gen);
 
     vkd3d_string_buffer_printf(gen->buffer, "    %s_main(%s_in, %s_out", gen->prefix, gen->prefix, gen->prefix);
+    if (gen->write_depth)
+        vkd3d_string_buffer_printf(gen->buffer, ", shader_out_depth");
     if (gen->descriptor_info->descriptor_count)
         vkd3d_string_buffer_printf(gen->buffer, ", descriptors");
     vkd3d_string_buffer_printf(gen->buffer, ");\n");
@@ -790,6 +1213,8 @@ static int msl_generator_generate(struct msl_generator *gen, struct vkd3d_shader
     MESSAGE("Generating a MSL shader. This is unsupported; you get to keep all the pieces if it breaks.\n");
 
     vkd3d_string_buffer_printf(gen->buffer, "/* Generated by %s. */\n\n", vkd3d_shader_get_version(NULL, NULL));
+    vkd3d_string_buffer_printf(gen->buffer, "#include <metal_common>\n\n");
+    vkd3d_string_buffer_printf(gen->buffer, "using namespace metal;\n\n");
 
     if (gen->program->global_flags)
         msl_compiler_error(gen, VKD3D_SHADER_ERROR_MSL_INTERNAL,
@@ -808,6 +1233,8 @@ static int msl_generator_generate(struct msl_generator *gen, struct vkd3d_shader
             "void %s_main(thread vkd3d_vec4 *v, "
             "thread vkd3d_vec4 *o",
             gen->prefix);
+    if (gen->write_depth)
+        vkd3d_string_buffer_printf(gen->buffer, ", thread float& o_depth");
     if (gen->descriptor_info->descriptor_count)
         vkd3d_string_buffer_printf(gen->buffer, ", constant vkd3d_%s_descriptors& descriptors", gen->prefix);
     vkd3d_string_buffer_printf(gen->buffer, ")\n{\n");
@@ -887,7 +1314,7 @@ int msl_compile(struct vsir_program *program, uint64_t config_flags,
     if ((ret = vsir_program_transform(program, config_flags, compile_info, message_context)) < 0)
         return ret;
 
-    VKD3D_ASSERT(program->normalisation_level == VSIR_FULLY_NORMALISED_IO);
+    VKD3D_ASSERT(program->normalisation_level == VSIR_NORMALISED_SM6);
 
     if ((ret = msl_generator_init(&generator, program, compile_info, descriptor_info, message_context)) < 0)
         return ret;
diff --git a/libs/vkd3d/libs/vkd3d-shader/preproc.l b/libs/vkd3d/libs/vkd3d-shader/preproc.l
index 4a8d0fddae1..d167415c356 100644
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.l
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.l
@@ -20,6 +20,7 @@
 
 %{
 
+#include "preproc.h"
 #include "preproc.tab.h"
 
 #undef ERROR  /* defined in wingdi.h */
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index bdfd632ad12..efa76983546 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -34,6 +34,32 @@
 # include "vulkan/GLSL.std.450.h"
 #endif  /* HAVE_SPIRV_UNIFIED1_GLSL_STD_450_H */
 
+#define VKD3D_SPIRV_VERSION_1_0 0x00010000
+#define VKD3D_SPIRV_VERSION_1_3 0x00010300
+#define VKD3D_SPIRV_GENERATOR_ID 18
+#define VKD3D_SPIRV_GENERATOR_VERSION 14
+#define VKD3D_SPIRV_GENERATOR_MAGIC vkd3d_make_u32(VKD3D_SPIRV_GENERATOR_VERSION, VKD3D_SPIRV_GENERATOR_ID)
+#ifndef VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER
+# define VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER 0
+#endif
+
+#define VKD3D_SPIRV_HEADER_SIZE 5
+
+#define VKD3D_SPIRV_VERSION_MAJOR_SHIFT             16u
+#define VKD3D_SPIRV_VERSION_MAJOR_MASK              (0xffu << VKD3D_SPIRV_VERSION_MAJOR_SHIFT)
+#define VKD3D_SPIRV_VERSION_MINOR_SHIFT             8u
+#define VKD3D_SPIRV_VERSION_MINOR_MASK              (0xffu << VKD3D_SPIRV_VERSION_MINOR_SHIFT)
+
+#define VKD3D_SPIRV_GENERATOR_ID_SHIFT              16u
+#define VKD3D_SPIRV_GENERATOR_ID_MASK               (0xffffu << VKD3D_SPIRV_GENERATOR_ID_SHIFT)
+#define VKD3D_SPIRV_GENERATOR_VERSION_SHIFT         0u
+#define VKD3D_SPIRV_GENERATOR_VERSION_MASK          (0xffffu << VKD3D_SPIRV_GENERATOR_VERSION_SHIFT)
+
+#define VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_SHIFT    16u
+#define VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_MASK     (0xffffu << VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_SHIFT)
+#define VKD3D_SPIRV_INSTRUCTION_OP_SHIFT            0u
+#define VKD3D_SPIRV_INSTRUCTION_OP_MASK             (0xffffu << VKD3D_SPIRV_INSTRUCTION_OP_SHIFT)
+
 #ifdef HAVE_SPIRV_TOOLS
 # include "spirv-tools/libspirv.h"
 
@@ -82,7 +108,7 @@ static uint32_t get_binary_to_text_options(enum vkd3d_shader_compile_option_form
     return out;
 }
 
-static enum vkd3d_result vkd3d_spirv_binary_to_text(const struct vkd3d_shader_code *spirv,
+static enum vkd3d_result spirv_tools_binary_to_text(const struct vkd3d_shader_code *spirv,
         enum vkd3d_shader_spirv_environment environment,
         enum vkd3d_shader_compile_option_formatting_flags formatting, struct vkd3d_shader_code *out)
 {
@@ -143,20 +169,6 @@ static enum vkd3d_result vkd3d_spirv_binary_to_text(const struct vkd3d_shader_co
     return result;
 }
 
-static void vkd3d_spirv_dump(const struct vkd3d_shader_code *spirv,
-        enum vkd3d_shader_spirv_environment environment)
-{
-    static const enum vkd3d_shader_compile_option_formatting_flags formatting
-            = VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT | VKD3D_SHADER_COMPILE_OPTION_FORMATTING_HEADER;
-    struct vkd3d_shader_code text;
-
-    if (!vkd3d_spirv_binary_to_text(spirv, environment, formatting, &text))
-    {
-        vkd3d_shader_trace_text(text.code, text.size);
-        vkd3d_shader_free_shader_code(&text);
-    }
-}
-
 static bool vkd3d_spirv_validate(struct vkd3d_string_buffer *buffer, const struct vkd3d_shader_code *spirv,
         enum vkd3d_shader_spirv_environment environment)
 {
@@ -180,14 +192,13 @@ static bool vkd3d_spirv_validate(struct vkd3d_string_buffer *buffer, const struc
 
 #else
 
-static enum vkd3d_result vkd3d_spirv_binary_to_text(const struct vkd3d_shader_code *spirv,
+static enum vkd3d_result spirv_tools_binary_to_text(const struct vkd3d_shader_code *spirv,
         enum vkd3d_shader_spirv_environment environment,
         enum vkd3d_shader_compile_option_formatting_flags formatting, struct vkd3d_shader_code *out)
 {
     return VKD3D_ERROR;
 }
-static void vkd3d_spirv_dump(const struct vkd3d_shader_code *spirv,
-        enum vkd3d_shader_spirv_environment environment) {}
+
 static bool vkd3d_spirv_validate(struct vkd3d_string_buffer *buffer, const struct vkd3d_shader_code *spirv,
         enum vkd3d_shader_spirv_environment environment)
 {
@@ -196,6 +207,312 @@ static bool vkd3d_spirv_validate(struct vkd3d_string_buffer *buffer, const struc
 
 #endif  /* HAVE_SPIRV_TOOLS */
 
+struct spirv_colours
+{
+    const char *reset;
+    const char *comment;
+};
+
+struct spirv_parser
+{
+    struct vkd3d_string_buffer_cache string_buffers;
+    struct vkd3d_shader_location location;
+    struct vkd3d_shader_message_context *message_context;
+    enum vkd3d_shader_compile_option_formatting_flags formatting;
+    struct spirv_colours colours;
+    bool failed;
+
+    const uint32_t *code;
+    size_t pos;
+    size_t size;
+
+    struct vkd3d_string_buffer *text;
+};
+
+static void VKD3D_PRINTF_FUNC(3, 4) spirv_parser_error(struct spirv_parser *parser,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    va_list args;
+
+    va_start(args, format);
+    vkd3d_shader_verror(parser->message_context, &parser->location, error, format, args);
+    va_end(args);
+    parser->failed = true;
+}
+
+static uint32_t spirv_parser_read_u32(struct spirv_parser *parser)
+{
+    if (parser->pos >= parser->size)
+    {
+        parser->failed = true;
+        return 0;
+    }
+
+    return parser->code[parser->pos++];
+}
+
+static void VKD3D_PRINTF_FUNC(2, 3) spirv_parser_print_comment(struct spirv_parser *parser, const char *format, ...)
+{
+    va_list args;
+
+    if (!parser->text)
+        return;
+
+    va_start(args, format);
+    vkd3d_string_buffer_printf(parser->text, "%s; ", parser->colours.comment);
+    vkd3d_string_buffer_vprintf(parser->text, format, args);
+    vkd3d_string_buffer_printf(parser->text, "%s\n", parser->colours.reset);
+    va_end(args);
+}
+
+static void spirv_parser_print_generator(struct spirv_parser *parser, uint32_t magic)
+{
+    unsigned int id, version;
+    const char *name;
+
+    id = (magic & VKD3D_SPIRV_GENERATOR_ID_MASK) >> VKD3D_SPIRV_GENERATOR_ID_SHIFT;
+    version = (magic & VKD3D_SPIRV_GENERATOR_VERSION_MASK) >> VKD3D_SPIRV_GENERATOR_VERSION_SHIFT;
+
+    switch (id)
+    {
+        case VKD3D_SPIRV_GENERATOR_ID:
+            name = "Wine VKD3D Shader Compiler";
+            break;
+
+        default:
+            name = NULL;
+            break;
+    }
+
+    if (name)
+        spirv_parser_print_comment(parser, "Generator: %s; %u", name, version);
+    else
+        spirv_parser_print_comment(parser, "Generator: Unknown (%#x); %u", id, version);
+}
+
+static enum vkd3d_result spirv_parser_read_header(struct spirv_parser *parser)
+{
+    uint32_t magic, version, generator, bound, schema;
+    unsigned int major, minor;
+
+    if (parser->pos > parser->size || parser->size - parser->pos < VKD3D_SPIRV_HEADER_SIZE)
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                "Unexpected end while reading the SPIR-V header.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    magic = spirv_parser_read_u32(parser);
+    version = spirv_parser_read_u32(parser);
+    generator = spirv_parser_read_u32(parser);
+    bound = spirv_parser_read_u32(parser);
+    schema = spirv_parser_read_u32(parser);
+
+    if (magic != SpvMagicNumber)
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                "Invalid magic number %#08x.", magic);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    if (version & ~(VKD3D_SPIRV_VERSION_MAJOR_MASK | VKD3D_SPIRV_VERSION_MINOR_MASK))
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                "Invalid version token %#08x.", version);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    major = (version & VKD3D_SPIRV_VERSION_MAJOR_MASK) >> VKD3D_SPIRV_VERSION_MAJOR_SHIFT;
+    minor = (version & VKD3D_SPIRV_VERSION_MINOR_MASK) >> VKD3D_SPIRV_VERSION_MINOR_SHIFT;
+    if (major != 1 || minor > 0)
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "Unable to parse SPIR-V version %u.%u.", major, minor);
+        return VKD3D_ERROR_NOT_IMPLEMENTED;
+    }
+
+    if (!bound)
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                "Invalid zero id bound.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    if (schema)
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+                "Unable to handle instruction schema %#08x.", schema);
+        return VKD3D_ERROR_NOT_IMPLEMENTED;
+    }
+
+    if (parser->formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_HEADER)
+    {
+        spirv_parser_print_comment(parser, "SPIR-V");
+        spirv_parser_print_comment(parser, "Version: %u.%u", major, minor);
+        spirv_parser_print_generator(parser, generator);
+        spirv_parser_print_comment(parser, "Bound: %u", bound);
+        spirv_parser_print_comment(parser, "Schema: %u", schema);
+    }
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result spirv_parser_parse_instruction(struct spirv_parser *parser)
+{
+    struct vkd3d_string_buffer *buffer;
+    uint16_t op, count;
+    unsigned int i;
+    uint32_t word;
+
+    word = spirv_parser_read_u32(parser);
+    count = (word & VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_MASK) >> VKD3D_SPIRV_INSTRUCTION_WORD_COUNT_SHIFT;
+    op = (word & VKD3D_SPIRV_INSTRUCTION_OP_MASK) >> VKD3D_SPIRV_INSTRUCTION_OP_SHIFT;
+
+    if (!count)
+    {
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                "Invalid word count %u.", count);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    --count;
+    buffer = vkd3d_string_buffer_get(&parser->string_buffers);
+    for (i = 0; i < count; ++i)
+    {
+        word = spirv_parser_read_u32(parser);
+        vkd3d_string_buffer_printf(buffer, " 0x%08x", word);
+    }
+    spirv_parser_print_comment(parser, "<unrecognised instruction %#x>%s", op, buffer->buffer);
+    vkd3d_string_buffer_release(&parser->string_buffers, buffer);
+
+    spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
+            "Unrecognised instruction %#x.", op);
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result spirv_parser_parse(struct spirv_parser *parser, struct vkd3d_shader_code *text)
+{
+    enum vkd3d_result ret;
+
+    if (text)
+        parser->text = vkd3d_string_buffer_get(&parser->string_buffers);
+
+    if ((ret = spirv_parser_read_header(parser)) < 0)
+        goto fail;
+    while (parser->pos < parser->size)
+    {
+        ++parser->location.line;
+        if ((ret = spirv_parser_parse_instruction(parser)) < 0)
+            goto fail;
+    }
+
+    if (parser->failed)
+    {
+        ret = VKD3D_ERROR_INVALID_SHADER;
+        goto fail;
+    }
+
+    if (text)
+        vkd3d_shader_code_from_string_buffer(text, parser->text);
+
+    return VKD3D_OK;
+
+fail:
+    if (parser->text)
+    {
+        if (TRACE_ON())
+            vkd3d_string_buffer_trace(parser->text);
+        vkd3d_string_buffer_release(&parser->string_buffers, parser->text);
+    }
+    return ret;
+}
+
+static void spirv_parser_cleanup(struct spirv_parser *parser)
+{
+    vkd3d_string_buffer_cache_cleanup(&parser->string_buffers);
+}
+
+static enum vkd3d_result spirv_parser_init(struct spirv_parser *parser, const struct vkd3d_shader_code *source,
+        const char *source_name, enum vkd3d_shader_compile_option_formatting_flags formatting,
+        struct vkd3d_shader_message_context *message_context)
+{
+    static const struct spirv_colours no_colours =
+    {
+        .reset = "",
+        .comment = "",
+    };
+    static const struct spirv_colours colours =
+    {
+        .reset = "\x1b[m",
+        .comment = "\x1b[36m",
+    };
+
+    memset(parser, 0, sizeof(*parser));
+    parser->location.source_name = source_name;
+    parser->message_context = message_context;
+    vkd3d_string_buffer_cache_init(&parser->string_buffers);
+
+    if (source->size % 4)
+    {
+        vkd3d_string_buffer_cache_cleanup(&parser->string_buffers);
+        spirv_parser_error(parser, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                "Shader size %zu is not a multiple of four.", source->size);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    parser->formatting = formatting;
+    if (formatting & VKD3D_SHADER_COMPILE_OPTION_FORMATTING_COLOUR)
+        parser->colours = colours;
+    else
+        parser->colours = no_colours;
+    parser->code = source->code;
+    parser->size = source->size / 4;
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result vkd3d_spirv_binary_to_text(const struct vkd3d_shader_code *spirv,
+        const char *source_name, enum vkd3d_shader_spirv_environment environment,
+        enum vkd3d_shader_compile_option_formatting_flags formatting,
+        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context)
+{
+    struct spirv_parser parser;
+    enum vkd3d_result ret;
+
+    if (!VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER)
+        return spirv_tools_binary_to_text(spirv, environment, formatting, out);
+
+    MESSAGE("Creating a SPIR-V parser. This is unsupported; you get to keep all the pieces if it breaks.\n");
+
+    if ((ret = spirv_parser_init(&parser, spirv, source_name, formatting, message_context)) < 0)
+        return ret;
+
+    ret = spirv_parser_parse(&parser, out);
+
+    spirv_parser_cleanup(&parser);
+
+    return ret;
+}
+
+static void vkd3d_spirv_dump(const struct vkd3d_shader_code *spirv, enum vkd3d_shader_spirv_environment environment)
+{
+    static const enum vkd3d_shader_compile_option_formatting_flags formatting
+            = VKD3D_SHADER_COMPILE_OPTION_FORMATTING_INDENT | VKD3D_SHADER_COMPILE_OPTION_FORMATTING_HEADER;
+    struct vkd3d_shader_message_context message_context;
+    struct vkd3d_shader_code text;
+
+    vkd3d_shader_message_context_init(&message_context, VKD3D_SHADER_LOG_INFO);
+
+    if (!vkd3d_spirv_binary_to_text(spirv, NULL, environment, formatting, &text, &message_context))
+    {
+        vkd3d_shader_trace_text(text.code, text.size);
+        vkd3d_shader_free_shader_code(&text);
+    }
+
+    vkd3d_shader_message_context_cleanup(&message_context);
+}
+
 enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d_shader_sysval_semantic sysval,
         unsigned int index)
 {
@@ -247,12 +564,6 @@ enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval_indexed(enum vkd3d
     }
 }
 
-#define VKD3D_SPIRV_VERSION_1_0 0x00010000
-#define VKD3D_SPIRV_VERSION_1_3 0x00010300
-#define VKD3D_SPIRV_GENERATOR_ID 18
-#define VKD3D_SPIRV_GENERATOR_VERSION 14
-#define VKD3D_SPIRV_GENERATOR_MAGIC vkd3d_make_u32(VKD3D_SPIRV_GENERATOR_VERSION, VKD3D_SPIRV_GENERATOR_ID)
-
 struct vkd3d_spirv_stream
 {
     uint32_t *words;
@@ -2406,6 +2717,7 @@ struct vkd3d_hull_shader_variables
 struct ssa_register_info
 {
     enum vkd3d_data_type data_type;
+    uint8_t write_mask;
     uint32_t id;
 };
 
@@ -2471,7 +2783,6 @@ struct spirv_compiler
     bool emit_point_size;
 
     enum vkd3d_shader_opcode phase;
-    bool emit_default_control_point_phase;
     struct vkd3d_shader_phase control_point_phase;
     struct vkd3d_shader_phase patch_constant_phase;
 
@@ -3316,13 +3627,19 @@ static uint32_t spirv_compiler_emit_variable(struct spirv_compiler *compiler,
 static const struct vkd3d_spec_constant_info
 {
     enum vkd3d_shader_parameter_name name;
-    uint32_t default_value;
+    union
+    {
+        uint32_t u;
+        float f;
+    } default_value;
     const char *debug_name;
 }
 vkd3d_shader_parameters[] =
 {
-    {VKD3D_SHADER_PARAMETER_NAME_RASTERIZER_SAMPLE_COUNT, 1, "sample_count"},
-    {VKD3D_SHADER_PARAMETER_NAME_ALPHA_TEST_REF, 0, "alpha_test_ref"},
+    {VKD3D_SHADER_PARAMETER_NAME_RASTERIZER_SAMPLE_COUNT, {.u = 1}, "sample_count"},
+    {VKD3D_SHADER_PARAMETER_NAME_ALPHA_TEST_REF, {.f = 0.0f}, "alpha_test_ref"},
+    {VKD3D_SHADER_PARAMETER_NAME_FOG_END, {.f = 1.0f}, "fog_end"},
+    {VKD3D_SHADER_PARAMETER_NAME_FOG_SCALE, {.f = 1.0f}, "fog_scale"},
 };
 
 static const struct vkd3d_spec_constant_info *get_spec_constant_info(enum vkd3d_shader_parameter_name name)
@@ -3383,7 +3700,7 @@ static uint32_t spirv_compiler_emit_spec_constant(struct spirv_compiler *compile
     const struct vkd3d_spec_constant_info *info;
 
     info = get_spec_constant_info(name);
-    default_value = info ? info->default_value : 0;
+    default_value = info ? info->default_value.u : 0;
 
     scalar_type_id = vkd3d_spirv_get_type_id(builder, vkd3d_component_type_from_data_type(type), 1);
     vector_type_id = vkd3d_spirv_get_type_id(builder, vkd3d_component_type_from_data_type(type), component_count);
@@ -3574,6 +3891,24 @@ static bool spirv_compiler_get_register_info(struct spirv_compiler *compiler,
         register_info->is_aggregate = false;
         return true;
     }
+    else if (reg->type == VKD3DSPR_SSA)
+    {
+        const struct ssa_register_info *ssa = &compiler->ssa_register_info[reg->idx[0].offset];
+
+        if (!ssa->id)
+        {
+            /* Should only be from a missing instruction implementation. */
+            VKD3D_ASSERT(compiler->failed);
+            return 0;
+        }
+
+        memset(register_info, 0, sizeof(*register_info));
+        register_info->id = ssa->id;
+        register_info->storage_class = SpvStorageClassMax;
+        register_info->component_type = vkd3d_component_type_from_data_type(ssa->data_type);
+        register_info->write_mask = ssa->write_mask;
+        return true;
+    }
 
     vkd3d_symbol_make_register(&reg_symbol, reg);
     if (!(entry = rb_get(&compiler->symbol_table, &reg_symbol)))
@@ -4181,67 +4516,14 @@ static uint32_t spirv_compiler_emit_constant_array(struct spirv_compiler *compil
     return const_id;
 }
 
-static const struct ssa_register_info *spirv_compiler_get_ssa_register_info(const struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg)
-{
-    VKD3D_ASSERT(reg->idx[0].offset < compiler->ssa_register_count);
-    VKD3D_ASSERT(reg->idx_count == 1);
-    return &compiler->ssa_register_info[reg->idx[0].offset];
-}
-
 static void spirv_compiler_set_ssa_register_info(const struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, uint32_t val_id)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask, uint32_t val_id)
 {
     unsigned int i = reg->idx[0].offset;
     VKD3D_ASSERT(i < compiler->ssa_register_count);
     compiler->ssa_register_info[i].data_type = reg->data_type;
     compiler->ssa_register_info[i].id = val_id;
-}
-
-static uint32_t spirv_compiler_emit_load_ssa_reg(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, enum vkd3d_shader_component_type component_type,
-        uint32_t swizzle)
-{
-    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    enum vkd3d_shader_component_type reg_component_type;
-    const struct ssa_register_info *ssa;
-    unsigned int component_idx;
-    uint32_t type_id, val_id;
-
-    ssa = spirv_compiler_get_ssa_register_info(compiler, reg);
-    val_id = ssa->id;
-    if (!val_id)
-    {
-        /* Should only be from a missing instruction implementation. */
-        VKD3D_ASSERT(compiler->failed);
-        return 0;
-    }
-    VKD3D_ASSERT(vkd3d_swizzle_is_scalar(swizzle, reg));
-
-    reg_component_type = vkd3d_component_type_from_data_type(ssa->data_type);
-
-    if (reg->dimension == VSIR_DIMENSION_SCALAR)
-    {
-        if (component_type != reg_component_type)
-        {
-            type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
-            val_id = vkd3d_spirv_build_op_bitcast(builder, type_id, val_id);
-        }
-
-        return val_id;
-    }
-
-    if (component_type != reg_component_type)
-    {
-        /* Required for resource loads with sampled type int, because DXIL has no signedness.
-         * Only 128-bit vector sizes are used. */
-        type_id = vkd3d_spirv_get_type_id(builder, component_type, VKD3D_VEC4_SIZE);
-        val_id = vkd3d_spirv_build_op_bitcast(builder, type_id, val_id);
-    }
-
-    type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
-    component_idx = vsir_swizzle_get_component(swizzle, 0);
-    return vkd3d_spirv_build_op_composite_extract1(builder, type_id, val_id, component_idx);
+    compiler->ssa_register_info[i].write_mask = write_mask;
 }
 
 static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
@@ -4267,9 +4549,6 @@ static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
     component_count = vsir_write_mask_component_count(write_mask);
     component_type = vkd3d_component_type_from_data_type(reg->data_type);
 
-    if (reg->type == VKD3DSPR_SSA)
-        return spirv_compiler_emit_load_ssa_reg(compiler, reg, component_type, swizzle);
-
     if (!spirv_compiler_get_register_info(compiler, reg, &reg_info))
     {
         type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
@@ -4294,9 +4573,9 @@ static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
         type_id = vkd3d_spirv_get_type_id(builder,
                 reg_info.component_type, vsir_write_mask_component_count(reg_info.write_mask));
         val_id = vkd3d_spirv_build_op_load(builder, type_id, reg_info.id, SpvMemoryAccessMaskNone);
+        swizzle = data_type_is_64_bit(reg->data_type) ? vsir_swizzle_32_from_64(swizzle) : swizzle;
     }
 
-    swizzle = data_type_is_64_bit(reg->data_type) ? vsir_swizzle_32_from_64(swizzle) : swizzle;
     val_id = spirv_compiler_emit_swizzle(compiler,
             val_id, reg_info.write_mask, reg_info.component_type, swizzle, val_write_mask);
 
@@ -4497,7 +4776,7 @@ static void spirv_compiler_emit_store_reg(struct spirv_compiler *compiler,
 
     if (reg->type == VKD3DSPR_SSA)
     {
-        spirv_compiler_set_ssa_register_info(compiler, reg, val_id);
+        spirv_compiler_set_ssa_register_info(compiler, reg, write_mask, val_id);
         return;
     }
 
@@ -4883,35 +5162,36 @@ static const struct vkd3d_spirv_builtin vkd3d_output_point_size_builtin =
 static const struct
 {
     enum vkd3d_shader_register_type reg_type;
+    SpvStorageClass storage_class;
     struct vkd3d_spirv_builtin builtin;
 }
 vkd3d_register_builtins[] =
 {
-    {VKD3DSPR_THREADID,         {VKD3D_SHADER_COMPONENT_INT, 3, SpvBuiltInGlobalInvocationId}},
-    {VKD3DSPR_LOCALTHREADID,    {VKD3D_SHADER_COMPONENT_INT, 3, SpvBuiltInLocalInvocationId}},
-    {VKD3DSPR_LOCALTHREADINDEX, {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInLocalInvocationIndex}},
-    {VKD3DSPR_THREADGROUPID,    {VKD3D_SHADER_COMPONENT_INT, 3, SpvBuiltInWorkgroupId}},
+    {VKD3DSPR_THREADID,         SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 3, SpvBuiltInGlobalInvocationId}},
+    {VKD3DSPR_LOCALTHREADID,    SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 3, SpvBuiltInLocalInvocationId}},
+    {VKD3DSPR_LOCALTHREADINDEX, SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInLocalInvocationIndex}},
+    {VKD3DSPR_THREADGROUPID,    SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 3, SpvBuiltInWorkgroupId}},
 
-    {VKD3DSPR_GSINSTID,         {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInvocationId}},
-    {VKD3DSPR_OUTPOINTID,       {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInvocationId}},
+    {VKD3DSPR_GSINSTID,         SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInvocationId}},
+    {VKD3DSPR_OUTPOINTID,       SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInInvocationId}},
 
-    {VKD3DSPR_PRIMID,           {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInPrimitiveId}},
+    {VKD3DSPR_PRIMID,           SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_INT, 1, SpvBuiltInPrimitiveId}},
 
-    {VKD3DSPR_TESSCOORD,        {VKD3D_SHADER_COMPONENT_FLOAT, 3, SpvBuiltInTessCoord}},
+    {VKD3DSPR_TESSCOORD,        SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_FLOAT, 3, SpvBuiltInTessCoord}},
 
-    {VKD3DSPR_POINT_COORD,      {VKD3D_SHADER_COMPONENT_FLOAT, 2, SpvBuiltInPointCoord}},
+    {VKD3DSPR_POINT_COORD,      SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_FLOAT, 2, SpvBuiltInPointCoord}},
 
-    {VKD3DSPR_COVERAGE,         {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSampleMask, NULL, 1}},
-    {VKD3DSPR_SAMPLEMASK,       {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSampleMask, NULL, 1}},
+    {VKD3DSPR_COVERAGE,         SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSampleMask, NULL, 1}},
+    {VKD3DSPR_SAMPLEMASK,       SpvStorageClassOutput, {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSampleMask, NULL, 1}},
 
-    {VKD3DSPR_DEPTHOUT,         {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInFragDepth}},
-    {VKD3DSPR_DEPTHOUTGE,       {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInFragDepth}},
-    {VKD3DSPR_DEPTHOUTLE,       {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInFragDepth}},
+    {VKD3DSPR_DEPTHOUT,         SpvStorageClassOutput, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInFragDepth}},
+    {VKD3DSPR_DEPTHOUTGE,       SpvStorageClassOutput, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInFragDepth}},
+    {VKD3DSPR_DEPTHOUTLE,       SpvStorageClassOutput, {VKD3D_SHADER_COMPONENT_FLOAT, 1, SpvBuiltInFragDepth}},
 
-    {VKD3DSPR_OUTSTENCILREF,    {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInFragStencilRefEXT}},
+    {VKD3DSPR_OUTSTENCILREF,    SpvStorageClassOutput, {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInFragStencilRefEXT}},
 
-    {VKD3DSPR_WAVELANECOUNT,    {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSubgroupSize}},
-    {VKD3DSPR_WAVELANEINDEX,    {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSubgroupLocalInvocationId}},
+    {VKD3DSPR_WAVELANECOUNT,    SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSubgroupSize}},
+    {VKD3DSPR_WAVELANEINDEX,    SpvStorageClassInput,  {VKD3D_SHADER_COMPONENT_UINT, 1, SpvBuiltInSubgroupLocalInvocationId}},
 };
 
 static void spirv_compiler_emit_register_execution_mode(struct spirv_compiler *compiler,
@@ -4970,14 +5250,18 @@ static const struct vkd3d_spirv_builtin *get_spirv_builtin_for_sysval(
 }
 
 static const struct vkd3d_spirv_builtin *get_spirv_builtin_for_register(
-        enum vkd3d_shader_register_type reg_type)
+        enum vkd3d_shader_register_type reg_type, SpvStorageClass *storage_class)
 {
     unsigned int i;
 
     for (i = 0; i < ARRAY_SIZE(vkd3d_register_builtins); ++i)
     {
         if (vkd3d_register_builtins[i].reg_type == reg_type)
+        {
+            if (storage_class)
+                *storage_class = vkd3d_register_builtins[i].storage_class;
             return &vkd3d_register_builtins[i].builtin;
+        }
     }
 
     return NULL;
@@ -4990,7 +5274,7 @@ static const struct vkd3d_spirv_builtin *vkd3d_get_spirv_builtin(const struct sp
 
     if ((builtin = get_spirv_builtin_for_sysval(compiler, sysval)))
         return builtin;
-    if ((builtin = get_spirv_builtin_for_register(reg_type)))
+    if ((builtin = get_spirv_builtin_for_register(reg_type, NULL)))
         return builtin;
 
     if ((sysval != VKD3D_SHADER_SV_NONE && sysval != VKD3D_SHADER_SV_TARGET)
@@ -5322,21 +5606,26 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     return input_id;
 }
 
-static void spirv_compiler_emit_input_register(struct spirv_compiler *compiler,
+static void spirv_compiler_emit_io_register(struct spirv_compiler *compiler,
         const struct vkd3d_shader_dst_param *dst)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_register *reg = &dst->reg;
     const struct vkd3d_spirv_builtin *builtin;
     struct vkd3d_symbol reg_symbol;
+    SpvStorageClass storage_class;
+    uint32_t write_mask, id;
     struct rb_entry *entry;
-    uint32_t write_mask;
-    uint32_t input_id;
 
     VKD3D_ASSERT(!reg->idx_count || !reg->idx[0].rel_addr);
     VKD3D_ASSERT(reg->idx_count < 2);
 
-    if (!(builtin = get_spirv_builtin_for_register(reg->type)))
+    if (reg->type == VKD3DSPR_RASTOUT && reg->idx[0].offset == VSIR_RASTOUT_POINT_SIZE)
+    {
+        builtin = &vkd3d_output_point_size_builtin;
+        storage_class = SpvStorageClassOutput;
+    }
+    else if (!(builtin = get_spirv_builtin_for_register(reg->type, &storage_class)))
     {
         FIXME("Unhandled register %#x.\n", reg->type);
         return;
@@ -5347,14 +5636,15 @@ static void spirv_compiler_emit_input_register(struct spirv_compiler *compiler,
     if ((entry = rb_get(&compiler->symbol_table, &reg_symbol)))
         return;
 
-    input_id = spirv_compiler_emit_builtin_variable(compiler, builtin, SpvStorageClassInput, 0);
+    id = spirv_compiler_emit_builtin_variable(compiler, builtin, storage_class, 0);
 
     write_mask = vkd3d_write_mask_from_component_count(builtin->component_count);
-    vkd3d_symbol_set_register_info(&reg_symbol, input_id,
-            SpvStorageClassInput, builtin->component_type, write_mask);
+    vkd3d_symbol_set_register_info(&reg_symbol, id,
+            storage_class, builtin->component_type, write_mask);
     reg_symbol.info.reg.is_aggregate = builtin->spirv_array_size;
     spirv_compiler_put_symbol(compiler, &reg_symbol);
-    spirv_compiler_emit_register_debug_name(builder, input_id, reg);
+    spirv_compiler_emit_register_execution_mode(compiler, reg->type);
+    spirv_compiler_emit_register_debug_name(builder, id, reg);
 }
 
 static unsigned int get_shader_output_swizzle(const struct spirv_compiler *compiler,
@@ -5458,41 +5748,6 @@ static void spirv_compiler_emit_shader_signature_outputs(struct spirv_compiler *
     }
 }
 
-static void spirv_compiler_emit_output_register(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_dst_param *dst)
-{
-    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    const struct vkd3d_shader_register *reg = &dst->reg;
-    const struct vkd3d_spirv_builtin *builtin;
-    struct vkd3d_symbol reg_symbol;
-    uint32_t write_mask;
-    uint32_t output_id;
-
-    VKD3D_ASSERT(!reg->idx_count || !reg->idx[0].rel_addr);
-    VKD3D_ASSERT(reg->idx_count < 2);
-
-    if (reg->type == VKD3DSPR_RASTOUT && reg->idx[0].offset == VSIR_RASTOUT_POINT_SIZE)
-    {
-        builtin = &vkd3d_output_point_size_builtin;
-    }
-    else if (!(builtin = get_spirv_builtin_for_register(reg->type)))
-    {
-        FIXME("Unhandled register %#x.\n", reg->type);
-        return;
-    }
-
-    output_id = spirv_compiler_emit_builtin_variable(compiler, builtin, SpvStorageClassOutput, 0);
-
-    vkd3d_symbol_make_register(&reg_symbol, reg);
-    write_mask = vkd3d_write_mask_from_component_count(builtin->component_count);
-    vkd3d_symbol_set_register_info(&reg_symbol, output_id,
-            SpvStorageClassOutput, builtin->component_type, write_mask);
-    reg_symbol.info.reg.is_aggregate = builtin->spirv_array_size;
-    spirv_compiler_put_symbol(compiler, &reg_symbol);
-    spirv_compiler_emit_register_execution_mode(compiler, reg->type);
-    spirv_compiler_emit_register_debug_name(builder, output_id, reg);
-}
-
 static uint32_t spirv_compiler_emit_shader_phase_builtin_variable(struct spirv_compiler *compiler,
         const struct vkd3d_spirv_builtin *builtin, const unsigned int *array_sizes, unsigned int size_count)
 {
@@ -5857,16 +6112,6 @@ static void spirv_compiler_emit_shader_epilogue_function(struct spirv_compiler *
     compiler->epilogue_function_id = 0;
 }
 
-static void spirv_compiler_emit_hull_shader_builtins(struct spirv_compiler *compiler)
-{
-    struct vkd3d_shader_dst_param dst;
-
-    memset(&dst, 0, sizeof(dst));
-    vsir_register_init(&dst.reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_FLOAT, 0);
-    dst.write_mask = VKD3DSP_WRITEMASK_0;
-    spirv_compiler_emit_input_register(compiler, &dst);
-}
-
 static void spirv_compiler_emit_initial_declarations(struct spirv_compiler *compiler)
 {
     const struct vkd3d_shader_transform_feedback_info *xfb_info = compiler->xfb_info;
@@ -5879,7 +6124,6 @@ static void spirv_compiler_emit_initial_declarations(struct spirv_compiler *comp
             break;
         case VKD3D_SHADER_TYPE_HULL:
             vkd3d_spirv_set_execution_model(builder, SpvExecutionModelTessellationControl);
-            spirv_compiler_emit_hull_shader_builtins(compiler);
             break;
         case VKD3D_SHADER_TYPE_DOMAIN:
             vkd3d_spirv_set_execution_model(builder, SpvExecutionModelTessellationEvaluation);
@@ -6699,27 +6943,6 @@ static void spirv_compiler_emit_dcl_tgsm_structured(struct spirv_compiler *compi
             tgsm_structured->structure_count * stride, stride, tgsm_structured->zero_init);
 }
 
-static void spirv_compiler_emit_dcl_input(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    const struct vkd3d_shader_dst_param *dst = &instruction->declaration.dst;
-
-    /* INPUT and PATCHCONST are handled in spirv_compiler_emit_io_declarations().
-     * OUTPOINTID is handled in spirv_compiler_emit_hull_shader_builtins(). */
-    if (dst->reg.type != VKD3DSPR_INPUT && dst->reg.type != VKD3DSPR_PATCHCONST
-            && dst->reg.type != VKD3DSPR_OUTPOINTID)
-        spirv_compiler_emit_input_register(compiler, dst);
-}
-
-static void spirv_compiler_emit_dcl_output(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    const struct vkd3d_shader_dst_param *dst = &instruction->declaration.dst;
-
-    if (dst->reg.type != VKD3DSPR_OUTPUT && dst->reg.type != VKD3DSPR_PATCHCONST)
-        spirv_compiler_emit_output_register(compiler, dst);
-}
-
 static void spirv_compiler_emit_dcl_stream(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -6822,15 +7045,11 @@ static void spirv_compiler_emit_dcl_gs_instances(struct spirv_compiler *compiler
     compiler->spirv_builder.invocation_count = instruction->declaration.count;
 }
 
-static void spirv_compiler_emit_dcl_tessellator_domain(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
+static void spirv_compiler_emit_tessellator_domain(struct spirv_compiler *compiler,
+        enum vkd3d_tessellator_domain domain)
 {
-    enum vkd3d_tessellator_domain domain = instruction->declaration.tessellator_domain;
     SpvExecutionMode mode;
 
-    if (compiler->shader_type == VKD3D_SHADER_TYPE_HULL && spirv_compiler_is_opengl_target(compiler))
-        return;
-
     switch (domain)
     {
         case VKD3D_TESSELLATOR_DOMAIN_LINE:
@@ -6916,15 +7135,10 @@ static void spirv_compiler_emit_thread_group_size(struct spirv_compiler *compile
             SpvExecutionModeLocalSize, local_size, ARRAY_SIZE(local_size));
 }
 
-static void spirv_compiler_emit_default_control_point_phase(struct spirv_compiler *compiler);
-
 static void spirv_compiler_leave_shader_phase(struct spirv_compiler *compiler)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
 
-    if (is_in_control_point_phase(compiler) && compiler->emit_default_control_point_phase)
-        spirv_compiler_emit_default_control_point_phase(compiler);
-
     vkd3d_spirv_build_op_function_end(builder);
 
     if (is_in_control_point_phase(compiler))
@@ -6969,9 +7183,6 @@ static void spirv_compiler_enter_shader_phase(struct spirv_compiler *compiler,
     phase->function_id = function_id;
     /* The insertion location must be set after the label is emitted. */
     phase->function_location = 0;
-
-    if (instruction->opcode == VKD3DSIH_HS_CONTROL_POINT_PHASE)
-        compiler->emit_default_control_point_phase = instruction->flags;
 }
 
 static void spirv_compiler_initialise_block(struct spirv_compiler *compiler)
@@ -7000,63 +7211,6 @@ static void spirv_compiler_initialise_block(struct spirv_compiler *compiler)
     }
 }
 
-static void spirv_compiler_emit_default_control_point_phase(struct spirv_compiler *compiler)
-{
-    const struct shader_signature *output_signature = &compiler->output_signature;
-    const struct shader_signature *input_signature = &compiler->input_signature;
-    uint32_t type_id, output_ptr_type_id, input_id, dst_id, invocation_id;
-    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    enum vkd3d_shader_component_type component_type;
-    struct vkd3d_shader_src_param invocation;
-    struct vkd3d_shader_register input_reg;
-    unsigned int component_count;
-    unsigned int i;
-
-    vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
-    spirv_compiler_initialise_block(compiler);
-    invocation_id = spirv_compiler_emit_load_invocation_id(compiler);
-
-    memset(&invocation, 0, sizeof(invocation));
-    vsir_register_init(&invocation.reg, VKD3DSPR_OUTPOINTID, VKD3D_DATA_INT, 0);
-    invocation.swizzle = VKD3D_SHADER_NO_SWIZZLE;
-
-    vsir_register_init(&input_reg, VKD3DSPR_INPUT, VKD3D_DATA_FLOAT, 2);
-    input_reg.idx[0].offset = 0;
-    input_reg.idx[0].rel_addr = &invocation;
-    input_reg.idx[1].offset = 0;
-    input_id = spirv_compiler_get_register_id(compiler, &input_reg);
-
-    VKD3D_ASSERT(input_signature->element_count == output_signature->element_count);
-    for (i = 0; i < output_signature->element_count; ++i)
-    {
-        const struct signature_element *output = &output_signature->elements[i];
-        const struct signature_element *input = &input_signature->elements[i];
-        struct vkd3d_shader_register_info output_reg_info;
-        struct vkd3d_shader_register output_reg;
-
-        VKD3D_ASSERT(input->mask == output->mask);
-        VKD3D_ASSERT(input->component_type == output->component_type);
-
-        input_reg.idx[1].offset = i;
-        input_id = spirv_compiler_get_register_id(compiler, &input_reg);
-
-        vsir_register_init(&output_reg, VKD3DSPR_OUTPUT, VKD3D_DATA_FLOAT, 1);
-        output_reg.idx[0].offset = i;
-        spirv_compiler_get_register_info(compiler, &output_reg, &output_reg_info);
-
-        component_type = output->component_type;
-        component_count = vsir_write_mask_component_count(output->mask);
-        type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
-        output_ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassOutput, type_id);
-
-        dst_id = vkd3d_spirv_build_op_access_chain1(builder, output_ptr_type_id, output_reg_info.id, invocation_id);
-
-        vkd3d_spirv_build_op_copy_memory(builder, dst_id, input_id, SpvMemoryAccessMaskNone);
-    }
-
-    vkd3d_spirv_build_op_return(builder);
-}
-
 static void spirv_compiler_emit_barrier(struct spirv_compiler *compiler,
         SpvScope execution_scope, SpvScope memory_scope, SpvMemorySemanticsMask semantics)
 {
@@ -7105,12 +7259,13 @@ static void spirv_compiler_emit_shader_epilogue_invocation(struct spirv_compiler
 
 static void spirv_compiler_emit_hull_shader_main(struct spirv_compiler *compiler)
 {
+    size_t table_count = compiler->offset_info.descriptor_table_count;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t void_id;
 
     /* If a patch constant function used descriptor indexing the offsets must be reloaded. */
-    memset(compiler->descriptor_offset_ids, 0, compiler->offset_info.descriptor_table_count
-            * sizeof(*compiler->descriptor_offset_ids));
+    if (table_count)
+        memset(compiler->descriptor_offset_ids, 0, table_count * sizeof(*compiler->descriptor_offset_ids));
     vkd3d_spirv_builder_begin_main_function(builder);
     vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
 
@@ -7147,7 +7302,6 @@ static SpvOp spirv_compiler_map_alu_instruction(const struct vkd3d_shader_instru
         {VKD3DSIH_DDIV,       SpvOpFDiv},
         {VKD3DSIH_DIV,        SpvOpFDiv},
         {VKD3DSIH_DMUL,       SpvOpFMul},
-        {VKD3DSIH_DTOF,       SpvOpFConvert},
         {VKD3DSIH_DTOI,       SpvOpConvertFToS},
         {VKD3DSIH_DTOU,       SpvOpConvertFToU},
         {VKD3DSIH_FREM,       SpvOpFRem},
@@ -7501,7 +7655,7 @@ static void spirv_compiler_emit_mov(struct spirv_compiler *compiler,
 
 general_implementation:
     write_mask = dst->write_mask;
-    if (src->reg.type == VKD3DSPR_IMMCONST64 && !data_type_is_64_bit(dst->reg.data_type))
+    if (data_type_is_64_bit(src->reg.data_type) && !data_type_is_64_bit(dst->reg.data_type))
         write_mask = vsir_write_mask_64_from_32(write_mask);
     else if (!data_type_is_64_bit(src->reg.data_type) && data_type_is_64_bit(dst->reg.data_type))
         write_mask = vsir_write_mask_32_from_64(write_mask);
@@ -7785,6 +7939,7 @@ static void spirv_compiler_emit_ftoi(struct spirv_compiler *compiler,
     uint32_t src_type_id, dst_type_id, condition_type_id;
     enum vkd3d_shader_component_type component_type;
     unsigned int component_count;
+    uint32_t write_mask;
 
     VKD3D_ASSERT(instruction->dst_count == 1);
     VKD3D_ASSERT(instruction->src_count == 1);
@@ -7794,21 +7949,23 @@ static void spirv_compiler_emit_ftoi(struct spirv_compiler *compiler,
      * and for NaN to yield zero. */
 
     component_count = vsir_write_mask_component_count(dst->write_mask);
-    src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, dst->write_mask);
-    dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
-    src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
 
     if (src->reg.data_type == VKD3D_DATA_DOUBLE)
     {
+        write_mask = vkd3d_write_mask_from_component_count(component_count);
         int_min_id = spirv_compiler_get_constant_double_vector(compiler, -2147483648.0, component_count);
         float_max_id = spirv_compiler_get_constant_double_vector(compiler, 2147483648.0, component_count);
     }
     else
     {
+        write_mask = dst->write_mask;
         int_min_id = spirv_compiler_get_constant_float_vector(compiler, -2147483648.0f, component_count);
         float_max_id = spirv_compiler_get_constant_float_vector(compiler, 2147483648.0f, component_count);
     }
 
+    src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, write_mask);
+    dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
+    src_id = spirv_compiler_emit_load_src(compiler, src, write_mask);
     val_id = vkd3d_spirv_build_op_glsl_std450_max(builder, src_type_id, src_id, int_min_id);
 
     /* VSIR allows the destination of a signed conversion to be unsigned. */
@@ -7838,6 +7995,7 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
     const struct vkd3d_shader_src_param *src = instruction->src;
     uint32_t src_type_id, dst_type_id, condition_type_id;
     unsigned int component_count;
+    uint32_t write_mask;
 
     VKD3D_ASSERT(instruction->dst_count == 1);
     VKD3D_ASSERT(instruction->src_count == 1);
@@ -7847,21 +8005,23 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
      * and for NaN to yield zero. */
 
     component_count = vsir_write_mask_component_count(dst->write_mask);
-    src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, dst->write_mask);
-    dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
-    src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
 
     if (src->reg.data_type == VKD3D_DATA_DOUBLE)
     {
+        write_mask = vkd3d_write_mask_from_component_count(component_count);
         zero_id = spirv_compiler_get_constant_double_vector(compiler, 0.0, component_count);
         float_max_id = spirv_compiler_get_constant_double_vector(compiler, 4294967296.0, component_count);
     }
     else
     {
+        write_mask = dst->write_mask;
         zero_id = spirv_compiler_get_constant_float_vector(compiler, 0.0f, component_count);
         float_max_id = spirv_compiler_get_constant_float_vector(compiler, 4294967296.0f, component_count);
     }
 
+    src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, write_mask);
+    dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
+    src_id = spirv_compiler_emit_load_src(compiler, src, write_mask);
     val_id = vkd3d_spirv_build_op_glsl_std450_max(builder, src_type_id, src_id, zero_id);
 
     uint_max_id = spirv_compiler_get_constant_uint_vector(compiler, UINT_MAX, component_count);
@@ -7875,6 +8035,29 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
 }
 
+static void spirv_compiler_emit_dtof(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_dst_param *dst = instruction->dst;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t type_id, val_id, src_id;
+    unsigned int component_count;
+    uint32_t write_mask;
+
+    component_count = vsir_write_mask_component_count(dst->write_mask);
+    write_mask = vkd3d_write_mask_from_component_count(component_count);
+
+    src_id = spirv_compiler_emit_load_src(compiler, src, write_mask);
+
+    type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, component_count);
+    val_id = vkd3d_spirv_build_op_tr1(builder, &builder->function_stream, SpvOpFConvert, type_id, src_id);
+    if (instruction->flags & VKD3DSI_PRECISE_XYZW)
+        vkd3d_spirv_build_op_decorate(builder, val_id, SpvDecorationNoContraction, NULL, 0);
+
+    spirv_compiler_emit_store_dst(compiler, dst, val_id);
+}
+
 static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -10214,13 +10397,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_TGSM_STRUCTURED:
             spirv_compiler_emit_dcl_tgsm_structured(compiler, instruction);
             break;
-        case VKD3DSIH_DCL_INPUT_PS:
-        case VKD3DSIH_DCL_INPUT:
-            spirv_compiler_emit_dcl_input(compiler, instruction);
-            break;
-        case VKD3DSIH_DCL_OUTPUT:
-            spirv_compiler_emit_dcl_output(compiler, instruction);
-            break;
         case VKD3DSIH_DCL_STREAM:
             spirv_compiler_emit_dcl_stream(compiler, instruction);
             break;
@@ -10239,9 +10415,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_OUTPUT_CONTROL_POINT_COUNT:
             spirv_compiler_emit_output_vertex_count(compiler, instruction);
             break;
-        case VKD3DSIH_DCL_TESSELLATOR_DOMAIN:
-            spirv_compiler_emit_dcl_tessellator_domain(compiler, instruction);
-            break;
         case VKD3DSIH_DCL_TESSELLATOR_OUTPUT_PRIMITIVE:
             spirv_compiler_emit_tessellator_output_primitive(compiler,
                     instruction->declaration.tessellator_output_primitive);
@@ -10275,7 +10448,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DDIV:
         case VKD3DSIH_DIV:
         case VKD3DSIH_DMUL:
-        case VKD3DSIH_DTOF:
         case VKD3DSIH_FREM:
         case VKD3DSIH_FTOD:
         case VKD3DSIH_IADD:
@@ -10363,6 +10535,9 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_FTOU:
             spirv_compiler_emit_ftou(compiler, instruction);
             break;
+        case VKD3DSIH_DTOF:
+            spirv_compiler_emit_dtof(compiler, instruction);
+            break;
         case VKD3DSIH_DEQO:
         case VKD3DSIH_DGEO:
         case VKD3DSIH_DLT:
@@ -10561,11 +10736,6 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
             break;
         case VKD3DSIH_DCL_HS_MAX_TESSFACTOR:
         case VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT:
-        case VKD3DSIH_DCL_INPUT_SGV:
-        case VKD3DSIH_DCL_INPUT_SIV:
-        case VKD3DSIH_DCL_INPUT_PS_SGV:
-        case VKD3DSIH_DCL_INPUT_PS_SIV:
-        case VKD3DSIH_DCL_OUTPUT_SIV:
         case VKD3DSIH_DCL_RESOURCE_RAW:
         case VKD3DSIH_DCL_RESOURCE_STRUCTURED:
         case VKD3DSIH_DCL_UAV_RAW:
@@ -10586,6 +10756,8 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
 
 static void spirv_compiler_emit_io_declarations(struct spirv_compiler *compiler)
 {
+    struct vkd3d_shader_dst_param dst;
+
     for (unsigned int i = 0; i < compiler->input_signature.element_count; ++i)
         spirv_compiler_emit_input(compiler, VKD3DSPR_INPUT, i);
 
@@ -10609,19 +10781,27 @@ static void spirv_compiler_emit_io_declarations(struct spirv_compiler *compiler)
 
     if (compiler->program->has_point_size)
     {
-        struct vkd3d_shader_dst_param dst;
-
         vsir_dst_param_init(&dst, VKD3DSPR_RASTOUT, VKD3D_DATA_FLOAT, 1);
         dst.reg.idx[0].offset = VSIR_RASTOUT_POINT_SIZE;
-        spirv_compiler_emit_output_register(compiler, &dst);
+        spirv_compiler_emit_io_register(compiler, &dst);
     }
 
     if (compiler->program->has_point_coord)
     {
-        struct vkd3d_shader_dst_param dst;
-
         vsir_dst_param_init(&dst, VKD3DSPR_POINT_COORD, VKD3D_DATA_FLOAT, 0);
-        spirv_compiler_emit_input_register(compiler, &dst);
+        spirv_compiler_emit_io_register(compiler, &dst);
+    }
+
+    for (unsigned int i = 0; i < sizeof(compiler->program->io_dcls) * CHAR_BIT; ++i)
+    {
+        /* For hull shaders we internally generate references to OUTPOINTID,
+         * so that must always be enabled. */
+        if (bitmap_is_set(compiler->program->io_dcls, i)
+                || (compiler->program->shader_version.type == VKD3D_SHADER_TYPE_HULL && i == VKD3DSPR_OUTPOINTID))
+        {
+            vsir_dst_param_init(&dst, i, VKD3D_DATA_FLOAT, 0);
+            spirv_compiler_emit_io_register(compiler, &dst);
+        }
     }
 }
 
@@ -10677,7 +10857,7 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler, struct
             compile_info, compiler->message_context)) < 0)
         return result;
 
-    VKD3D_ASSERT(program->normalisation_level == VSIR_FULLY_NORMALISED_IO);
+    VKD3D_ASSERT(program->normalisation_level == VSIR_NORMALISED_SM6);
 
     max_element_count = max(program->output_signature.element_count, program->patch_constant_signature.element_count);
     if (!(compiler->output_info = vkd3d_calloc(max_element_count, sizeof(*compiler->output_info))))
@@ -10743,6 +10923,9 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler, struct
     compiler->input_control_point_count = program->input_control_point_count;
     compiler->output_control_point_count = program->output_control_point_count;
 
+    if (program->shader_version.type == VKD3D_SHADER_TYPE_HULL && !spirv_compiler_is_opengl_target(compiler))
+        spirv_compiler_emit_tessellator_domain(compiler, program->tess_domain);
+
     if (compiler->shader_type != VKD3D_SHADER_TYPE_HULL)
         spirv_compiler_emit_shader_signature_outputs(compiler);
 
@@ -10823,7 +11006,8 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler, struct
     if (compile_info->target_type == VKD3D_SHADER_TARGET_SPIRV_TEXT)
     {
         struct vkd3d_shader_code text;
-        if (vkd3d_spirv_binary_to_text(spirv, environment, compiler->formatting, &text) != VKD3D_OK)
+        if (vkd3d_spirv_binary_to_text(spirv, compile_info->source_name, environment,
+                compiler->formatting, &text, compiler->message_context) != VKD3D_OK)
             return VKD3D_ERROR;
         vkd3d_shader_free_shader_code(spirv);
         *spirv = text;
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 9c41e2c2053..aa666086710 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -21,9 +21,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "hlsl.h"
 #include "vkd3d_shader_private.h"
-#include "d3dcommon.h"
 
 #define SM4_MAX_SRC_COUNT 6
 #define SM4_MAX_DST_COUNT 2
@@ -163,24 +161,6 @@ STATIC_ASSERT(SM4_MAX_SRC_COUNT <= SPIRV_MAX_SRC_COUNT);
 
 #define VKD3D_SM4_TYPE_COMPONENT(com, i)      (((com) >> (4 * (i))) & 0xfu)
 
-/* The shift that corresponds to the D3D_SIF_TEXTURE_COMPONENTS mask. */
-#define VKD3D_SM4_SIF_TEXTURE_COMPONENTS_SHIFT 2
-
-#define VKD3D_SM4_REQUIRES_DOUBLES                              0x00000001
-#define VKD3D_SM4_REQUIRES_EARLY_DEPTH_STENCIL                  0x00000002
-#define VKD3D_SM4_REQUIRES_UAVS_AT_EVERY_STAGE                  0x00000004
-#define VKD3D_SM4_REQUIRES_64_UAVS                              0x00000008
-#define VKD3D_SM4_REQUIRES_MINIMUM_PRECISION                    0x00000010
-#define VKD3D_SM4_REQUIRES_11_1_DOUBLE_EXTENSIONS               0x00000020
-#define VKD3D_SM4_REQUIRES_11_1_SHADER_EXTENSIONS               0x00000040
-#define VKD3D_SM4_REQUIRES_LEVEL_9_COMPARISON_FILTERING         0x00000080
-#define VKD3D_SM4_REQUIRES_TILED_RESOURCES                      0x00000100
-#define VKD3D_SM4_REQUIRES_STENCIL_REF                          0x00000200
-#define VKD3D_SM4_REQUIRES_INNER_COVERAGE                       0x00000400
-#define VKD3D_SM4_REQUIRES_TYPED_UAV_LOAD_ADDITIONAL_FORMATS    0x00000800
-#define VKD3D_SM4_REQUIRES_ROVS                                 0x00001000
-#define VKD3D_SM4_REQUIRES_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER 0x00002000
-
 enum vkd3d_sm4_opcode
 {
     VKD3D_SM4_OP_ADD                              = 0x00,
@@ -707,6 +687,7 @@ struct vkd3d_sm4_opcode_info
     char src_info[SM4_MAX_SRC_COUNT];
     void (*read_opcode_func)(struct vkd3d_shader_instruction *ins, uint32_t opcode, uint32_t opcode_token,
             const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv);
+    bool is_conditional_op;
 };
 
 static const enum vkd3d_primitive_type output_primitive_type_table[] =
@@ -1268,6 +1249,7 @@ static void shader_sm5_read_dcl_tessellator_domain(struct vkd3d_shader_instructi
 {
     ins->declaration.tessellator_domain = (opcode_token & VKD3D_SM5_TESSELLATOR_MASK)
             >> VKD3D_SM5_TESSELLATOR_SHIFT;
+    priv->p.program->tess_domain = ins->declaration.tessellator_domain;
 }
 
 static void shader_sm5_read_dcl_tessellator_partitioning(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1275,6 +1257,7 @@ static void shader_sm5_read_dcl_tessellator_partitioning(struct vkd3d_shader_ins
 {
     ins->declaration.tessellator_partitioning = (opcode_token & VKD3D_SM5_TESSELLATOR_MASK)
             >> VKD3D_SM5_TESSELLATOR_SHIFT;
+    priv->p.program->tess_partitioning = ins->declaration.tessellator_partitioning;
 }
 
 static void shader_sm5_read_dcl_tessellator_output_primitive(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1282,6 +1265,7 @@ static void shader_sm5_read_dcl_tessellator_output_primitive(struct vkd3d_shader
 {
     ins->declaration.tessellator_output_primitive = (opcode_token & VKD3D_SM5_TESSELLATOR_MASK)
             >> VKD3D_SM5_TESSELLATOR_SHIFT;
+    priv->p.program->tess_output_primitive = ins->declaration.tessellator_output_primitive;
 }
 
 static void shader_sm5_read_dcl_hs_max_tessfactor(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1407,8 +1391,6 @@ struct sm4_stat
 
 struct tpf_compiler
 {
-    /* OBJECTIVE: We want to get rid of this HLSL IR specific field. */
-    struct hlsl_ctx *ctx;
     struct vsir_program *program;
     struct vkd3d_sm4_lookup_tables lookup;
     struct sm4_stat *stat;
@@ -1439,18 +1421,18 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
         {VKD3D_SM4_OP_AND,                              VKD3DSIH_AND,                              "u",    "uu"},
         {VKD3D_SM4_OP_BREAK,                            VKD3DSIH_BREAK,                            "",     ""},
         {VKD3D_SM4_OP_BREAKC,                           VKD3DSIH_BREAKP,                           "",     "u",
-                shader_sm4_read_conditional_op},
+                shader_sm4_read_conditional_op, true},
         {VKD3D_SM4_OP_CASE,                             VKD3DSIH_CASE,                             "",     "u",
                 shader_sm4_read_case_condition},
         {VKD3D_SM4_OP_CONTINUE,                         VKD3DSIH_CONTINUE,                         "",     ""},
         {VKD3D_SM4_OP_CONTINUEC,                        VKD3DSIH_CONTINUEP,                        "",     "u",
-                shader_sm4_read_conditional_op},
+                shader_sm4_read_conditional_op, true},
         {VKD3D_SM4_OP_CUT,                              VKD3DSIH_CUT,                              "",     ""},
         {VKD3D_SM4_OP_DEFAULT,                          VKD3DSIH_DEFAULT,                          "",     ""},
         {VKD3D_SM4_OP_DERIV_RTX,                        VKD3DSIH_DSX,                              "f",    "f"},
         {VKD3D_SM4_OP_DERIV_RTY,                        VKD3DSIH_DSY,                              "f",    "f"},
         {VKD3D_SM4_OP_DISCARD,                          VKD3DSIH_DISCARD,                          "",     "u",
-                shader_sm4_read_conditional_op},
+                shader_sm4_read_conditional_op, true},
         {VKD3D_SM4_OP_DIV,                              VKD3DSIH_DIV,                              "f",    "ff"},
         {VKD3D_SM4_OP_DP2,                              VKD3DSIH_DP2,                              "f",    "ff"},
         {VKD3D_SM4_OP_DP3,                              VKD3DSIH_DP3,                              "f",    "ff"},
@@ -1468,7 +1450,7 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
         {VKD3D_SM4_OP_GE,                               VKD3DSIH_GEO,                              "u",    "ff"},
         {VKD3D_SM4_OP_IADD,                             VKD3DSIH_IADD,                             "i",    "ii"},
         {VKD3D_SM4_OP_IF,                               VKD3DSIH_IF,                               "",     "u",
-                shader_sm4_read_conditional_op},
+                shader_sm4_read_conditional_op, true},
         {VKD3D_SM4_OP_IEQ,                              VKD3DSIH_IEQ,                              "u",    "ii"},
         {VKD3D_SM4_OP_IGE,                              VKD3DSIH_IGE,                              "u",    "ii"},
         {VKD3D_SM4_OP_ILT,                              VKD3DSIH_ILT,                              "u",    "ii"},
@@ -1502,7 +1484,7 @@ static void init_sm4_lookup_tables(struct vkd3d_sm4_lookup_tables *lookup)
         {VKD3D_SM4_OP_RESINFO,                          VKD3DSIH_RESINFO,                          "f",    "i*"},
         {VKD3D_SM4_OP_RET,                              VKD3DSIH_RET,                              "",     ""},
         {VKD3D_SM4_OP_RETC,                             VKD3DSIH_RETP,                             "",     "u",
-                shader_sm4_read_conditional_op},
+                shader_sm4_read_conditional_op, true},
         {VKD3D_SM4_OP_ROUND_NE,                         VKD3DSIH_ROUND_NE,                         "f",    "f"},
         {VKD3D_SM4_OP_ROUND_NI,                         VKD3DSIH_ROUND_NI,                         "f",    "f"},
         {VKD3D_SM4_OP_ROUND_PI,                         VKD3DSIH_ROUND_PI,                         "f",    "f"},
@@ -1967,16 +1949,6 @@ static const struct vkd3d_sm4_register_type_info *get_info_from_vkd3d_register_t
     return lookup->register_type_info_from_vkd3d[vkd3d_type];
 }
 
-static enum vkd3d_sm4_swizzle_type vkd3d_sm4_get_default_swizzle_type(
-        const struct vkd3d_sm4_lookup_tables *lookup, enum vkd3d_shader_register_type vkd3d_type)
-{
-    const struct vkd3d_sm4_register_type_info *register_type_info =
-            get_info_from_vkd3d_register_type(lookup, vkd3d_type);
-
-    VKD3D_ASSERT(register_type_info);
-    return register_type_info->default_src_swizzle_type;
-}
-
 static enum vkd3d_sm4_stat_field get_stat_field_from_sm4_opcode(
         const struct vkd3d_sm4_lookup_tables *lookup, enum vkd3d_sm4_opcode sm4_opcode)
 {
@@ -2816,7 +2788,7 @@ static bool shader_sm4_init(struct vkd3d_shader_sm4_parser *sm4, struct vsir_pro
 
     /* Estimate instruction count to avoid reallocation in most shaders. */
     if (!vsir_program_init(program, compile_info,
-            &version, token_count / 7u + 20, VSIR_CF_STRUCTURED, VSIR_NOT_NORMALISED))
+            &version, token_count / 7u + 20, VSIR_CF_STRUCTURED, VSIR_NORMALISED_SM4))
         return false;
     vkd3d_shader_parser_init(&sm4->p, program, message_context, compile_info->source_name);
     sm4->ptr = sm4->start;
@@ -2925,6 +2897,7 @@ int tpf_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t con
     program->input_signature = dxbc_desc.input_signature;
     program->output_signature = dxbc_desc.output_signature;
     program->patch_constant_signature = dxbc_desc.patch_constant_signature;
+    program->features = dxbc_desc.features;
     memset(&dxbc_desc, 0, sizeof(dxbc_desc));
 
     /* DXBC stores used masks inverted for output signatures, for some reason.
@@ -2993,8 +2966,6 @@ int tpf_parse(const struct vkd3d_shader_compile_info *compile_info, uint64_t con
     return VKD3D_OK;
 }
 
-static void write_sm4_block(struct tpf_compiler *tpf, const struct hlsl_block *block);
-
 bool sm4_register_from_semantic_name(const struct vkd3d_shader_version *version,
         const char *semantic_name, bool output, enum vkd3d_shader_register_type *type, bool *has_idx)
 {
@@ -3217,18 +3188,17 @@ bool sm4_sysval_semantic_from_semantic_name(enum vkd3d_shader_sysval_semantic *s
     return true;
 }
 
-static void add_section(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc,
-        uint32_t tag, struct vkd3d_bytecode_buffer *buffer)
+static void add_section(struct tpf_compiler *tpf, uint32_t tag, struct vkd3d_bytecode_buffer *buffer)
 {
     /* Native D3DDisassemble() expects at least the sizes of the ISGN and OSGN
      * sections to be aligned. Without this, the sections themselves will be
      * aligned, but their reported sizes won't. */
     size_t size = bytecode_align(buffer);
 
-    dxbc_writer_add_section(dxbc, tag, buffer->data, size);
+    dxbc_writer_add_section(&tpf->dxbc, tag, buffer->data, size);
 
     if (buffer->status < 0)
-        ctx->result = buffer->status;
+        tpf->result = buffer->status;
 }
 
 static int signature_element_pointer_compare(const void *x, const void *y)
@@ -3289,747 +3259,33 @@ static void tpf_write_signature(struct tpf_compiler *tpf, const struct shader_si
         set_u32(&buffer, (2 + i * 6) * sizeof(uint32_t), string_offset);
     }
 
-    add_section(tpf->ctx, &tpf->dxbc, tag, &buffer);
+    add_section(tpf, tag, &buffer);
     vkd3d_free(sorted_elements);
 }
 
-static D3D_SHADER_VARIABLE_CLASS sm4_class(const struct hlsl_type *type)
-{
-    switch (type->class)
-    {
-        case HLSL_CLASS_MATRIX:
-            VKD3D_ASSERT(type->modifiers & HLSL_MODIFIERS_MAJORITY_MASK);
-            if (type->modifiers & HLSL_MODIFIER_COLUMN_MAJOR)
-                return D3D_SVC_MATRIX_COLUMNS;
-            else
-                return D3D_SVC_MATRIX_ROWS;
-        case HLSL_CLASS_SCALAR:
-            return D3D_SVC_SCALAR;
-        case HLSL_CLASS_VECTOR:
-            return D3D_SVC_VECTOR;
-
-        case HLSL_CLASS_ARRAY:
-        case HLSL_CLASS_DEPTH_STENCIL_STATE:
-        case HLSL_CLASS_DEPTH_STENCIL_VIEW:
-        case HLSL_CLASS_EFFECT_GROUP:
-        case HLSL_CLASS_ERROR:
-        case HLSL_CLASS_STRUCT:
-        case HLSL_CLASS_PASS:
-        case HLSL_CLASS_PIXEL_SHADER:
-        case HLSL_CLASS_RASTERIZER_STATE:
-        case HLSL_CLASS_RENDER_TARGET_VIEW:
-        case HLSL_CLASS_SAMPLER:
-        case HLSL_CLASS_STRING:
-        case HLSL_CLASS_TECHNIQUE:
-        case HLSL_CLASS_TEXTURE:
-        case HLSL_CLASS_UAV:
-        case HLSL_CLASS_VERTEX_SHADER:
-        case HLSL_CLASS_VOID:
-        case HLSL_CLASS_CONSTANT_BUFFER:
-        case HLSL_CLASS_COMPUTE_SHADER:
-        case HLSL_CLASS_DOMAIN_SHADER:
-        case HLSL_CLASS_HULL_SHADER:
-        case HLSL_CLASS_GEOMETRY_SHADER:
-        case HLSL_CLASS_BLEND_STATE:
-        case HLSL_CLASS_NULL:
-            break;
-    }
-    vkd3d_unreachable();
-}
-
-static D3D_SHADER_VARIABLE_TYPE sm4_base_type(const struct hlsl_type *type)
-{
-    switch (type->e.numeric.type)
-    {
-        case HLSL_TYPE_BOOL:
-            return D3D_SVT_BOOL;
-        case HLSL_TYPE_DOUBLE:
-            return D3D_SVT_DOUBLE;
-        case HLSL_TYPE_FLOAT:
-        case HLSL_TYPE_HALF:
-            return D3D_SVT_FLOAT;
-        case HLSL_TYPE_INT:
-            return D3D_SVT_INT;
-        case HLSL_TYPE_UINT:
-            return D3D_SVT_UINT;
-        default:
-            vkd3d_unreachable();
-    }
-}
-
-static void write_sm4_type(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *buffer, struct hlsl_type *type)
-{
-    const struct hlsl_type *array_type = hlsl_get_multiarray_element_type(type);
-    const char *name = array_type->name ? array_type->name : "<unnamed>";
-    const struct hlsl_profile_info *profile = ctx->profile;
-    unsigned int array_size = 0;
-    size_t name_offset = 0;
-    size_t i;
-
-    if (type->bytecode_offset)
-        return;
-
-    if (profile->major_version >= 5)
-        name_offset = put_string(buffer, name);
-
-    if (type->class == HLSL_CLASS_ARRAY)
-        array_size = hlsl_get_multiarray_size(type);
-
-    if (array_type->class == HLSL_CLASS_STRUCT)
-    {
-        unsigned int field_count = 0;
-        size_t fields_offset = 0;
-
-        for (i = 0; i < array_type->e.record.field_count; ++i)
-        {
-            struct hlsl_struct_field *field = &array_type->e.record.fields[i];
-
-            if (!field->type->reg_size[HLSL_REGSET_NUMERIC])
-                continue;
-
-            field->name_bytecode_offset = put_string(buffer, field->name);
-            write_sm4_type(ctx, buffer, field->type);
-            ++field_count;
-        }
-
-        fields_offset = bytecode_align(buffer);
-
-        for (i = 0; i < array_type->e.record.field_count; ++i)
-        {
-            struct hlsl_struct_field *field = &array_type->e.record.fields[i];
-
-            if (!field->type->reg_size[HLSL_REGSET_NUMERIC])
-                continue;
-
-            put_u32(buffer, field->name_bytecode_offset);
-            put_u32(buffer, field->type->bytecode_offset);
-            put_u32(buffer, field->reg_offset[HLSL_REGSET_NUMERIC] * sizeof(float));
-        }
-        type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(D3D_SVC_STRUCT, D3D_SVT_VOID));
-        put_u32(buffer, vkd3d_make_u32(1, hlsl_type_component_count(array_type)));
-        put_u32(buffer, vkd3d_make_u32(array_size, field_count));
-        put_u32(buffer, fields_offset);
-    }
-    else
-    {
-        VKD3D_ASSERT(array_type->class <= HLSL_CLASS_LAST_NUMERIC);
-        type->bytecode_offset = put_u32(buffer, vkd3d_make_u32(sm4_class(array_type), sm4_base_type(array_type)));
-        put_u32(buffer, vkd3d_make_u32(array_type->dimy, array_type->dimx));
-        put_u32(buffer, vkd3d_make_u32(array_size, 0));
-        put_u32(buffer, 1);
-    }
-
-    if (profile->major_version >= 5)
-    {
-        put_u32(buffer, 0); /* FIXME: unknown */
-        put_u32(buffer, 0); /* FIXME: unknown */
-        put_u32(buffer, 0); /* FIXME: unknown */
-        put_u32(buffer, 0); /* FIXME: unknown */
-        put_u32(buffer, name_offset);
-    }
-}
-
-static D3D_SHADER_INPUT_TYPE sm4_resource_type(const struct hlsl_type *type)
-{
-    switch (type->class)
-    {
-        case HLSL_CLASS_SAMPLER:
-            return D3D_SIT_SAMPLER;
-        case HLSL_CLASS_TEXTURE:
-            return D3D_SIT_TEXTURE;
-        case HLSL_CLASS_UAV:
-            return D3D_SIT_UAV_RWTYPED;
-        default:
-            break;
-    }
-
-    vkd3d_unreachable();
-}
-
-static enum vkd3d_sm4_data_type sm4_data_type(const struct hlsl_type *type)
-{
-    const struct hlsl_type *format = type->e.resource.format;
-
-    switch (format->e.numeric.type)
-    {
-        case HLSL_TYPE_DOUBLE:
-            return VKD3D_SM4_DATA_DOUBLE;
-
-        case HLSL_TYPE_FLOAT:
-        case HLSL_TYPE_HALF:
-            if (format->modifiers & HLSL_MODIFIER_UNORM)
-                return VKD3D_SM4_DATA_UNORM;
-            if (format->modifiers & HLSL_MODIFIER_SNORM)
-                return VKD3D_SM4_DATA_SNORM;
-            return VKD3D_SM4_DATA_FLOAT;
-
-        case HLSL_TYPE_INT:
-            return VKD3D_SM4_DATA_INT;
-            break;
-
-        case HLSL_TYPE_BOOL:
-        case HLSL_TYPE_UINT:
-            return VKD3D_SM4_DATA_UINT;
-
-        default:
-            vkd3d_unreachable();
-    }
-}
-
-static D3D_SRV_DIMENSION sm4_rdef_resource_dimension(const struct hlsl_type *type)
-{
-    switch (type->sampler_dim)
-    {
-        case HLSL_SAMPLER_DIM_1D:
-            return D3D_SRV_DIMENSION_TEXTURE1D;
-        case HLSL_SAMPLER_DIM_2D:
-            return D3D_SRV_DIMENSION_TEXTURE2D;
-        case HLSL_SAMPLER_DIM_3D:
-            return D3D_SRV_DIMENSION_TEXTURE3D;
-        case HLSL_SAMPLER_DIM_CUBE:
-            return D3D_SRV_DIMENSION_TEXTURECUBE;
-        case HLSL_SAMPLER_DIM_1DARRAY:
-            return D3D_SRV_DIMENSION_TEXTURE1DARRAY;
-        case HLSL_SAMPLER_DIM_2DARRAY:
-            return D3D_SRV_DIMENSION_TEXTURE2DARRAY;
-        case HLSL_SAMPLER_DIM_2DMS:
-            return D3D_SRV_DIMENSION_TEXTURE2DMS;
-        case HLSL_SAMPLER_DIM_2DMSARRAY:
-            return D3D_SRV_DIMENSION_TEXTURE2DMSARRAY;
-        case HLSL_SAMPLER_DIM_CUBEARRAY:
-            return D3D_SRV_DIMENSION_TEXTURECUBEARRAY;
-        case HLSL_SAMPLER_DIM_BUFFER:
-        case HLSL_SAMPLER_DIM_RAW_BUFFER:
-        case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
-            return D3D_SRV_DIMENSION_BUFFER;
-        default:
-            vkd3d_unreachable();
-    }
-}
-
-struct extern_resource
-{
-    /* var is only not NULL if this resource is a whole variable, so it may be responsible for more
-     * than one component. */
-    const struct hlsl_ir_var *var;
-    const struct hlsl_buffer *buffer;
-
-    char *name;
-    bool is_user_packed;
-
-    /* The data type of a single component of the resource.
-     * This might be different from the data type of the resource itself in 4.0
-     * profiles, where an array (or multi-dimensional array) is handled as a
-     * single resource, unlike in 5.0. */
-    struct hlsl_type *component_type;
-
-    enum hlsl_regset regset;
-    unsigned int id, space, index, bind_count;
-
-    struct vkd3d_shader_location loc;
-};
-
-static int sm4_compare_extern_resources(const void *a, const void *b)
-{
-    const struct extern_resource *aa = (const struct extern_resource *)a;
-    const struct extern_resource *bb = (const struct extern_resource *)b;
-    int r;
-
-    if ((r = vkd3d_u32_compare(aa->regset, bb->regset)))
-        return r;
-
-    if ((r = vkd3d_u32_compare(aa->space, bb->space)))
-        return r;
-
-    return vkd3d_u32_compare(aa->index, bb->index);
-}
-
-static void sm4_free_extern_resources(struct extern_resource *extern_resources, unsigned int count)
-{
-    unsigned int i;
-
-    for (i = 0; i < count; ++i)
-        vkd3d_free(extern_resources[i].name);
-    vkd3d_free(extern_resources);
-}
-
-static const char *string_skip_tag(const char *string)
-{
-    if (!strncmp(string, "<resource>", strlen("<resource>")))
-        return string + strlen("<resource>");
-    return string;
-}
-
-static struct extern_resource *sm4_get_extern_resources(struct hlsl_ctx *ctx, unsigned int *count)
-{
-    bool separate_components = ctx->profile->major_version == 5 && ctx->profile->minor_version == 0;
-    struct extern_resource *extern_resources = NULL;
-    const struct hlsl_ir_var *var;
-    struct hlsl_buffer *buffer;
-    enum hlsl_regset regset;
-    size_t capacity = 0;
-    char *name;
-
-    *count = 0;
-
-    LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
-    {
-        if (separate_components)
-        {
-            unsigned int component_count = hlsl_type_component_count(var->data_type);
-            unsigned int k, regset_offset;
-
-            for (k = 0; k < component_count; ++k)
-            {
-                struct hlsl_type *component_type = hlsl_type_get_component_type(ctx, var->data_type, k);
-                struct vkd3d_string_buffer *name_buffer;
-
-                if (!hlsl_type_is_resource(component_type))
-                    continue;
-
-                regset_offset = hlsl_type_get_component_offset(ctx, var->data_type, k, &regset);
-
-                if (regset_offset > var->regs[regset].allocation_size)
-                    continue;
-
-                if (var->objects_usage[regset][regset_offset].used)
-                {
-                    if (!(hlsl_array_reserve(ctx, (void **)&extern_resources, &capacity, *count + 1,
-                            sizeof(*extern_resources))))
-                    {
-                        sm4_free_extern_resources(extern_resources, *count);
-                        *count = 0;
-                        return NULL;
-                    }
-
-                    if (!(name_buffer = hlsl_component_to_string(ctx, var, k)))
-                    {
-                        sm4_free_extern_resources(extern_resources, *count);
-                        *count = 0;
-                        return NULL;
-                    }
-                    if (!(name = hlsl_strdup(ctx, string_skip_tag(name_buffer->buffer))))
-                    {
-                        sm4_free_extern_resources(extern_resources, *count);
-                        *count = 0;
-                        hlsl_release_string_buffer(ctx, name_buffer);
-                        return NULL;
-                    }
-                    hlsl_release_string_buffer(ctx, name_buffer);
-
-                    extern_resources[*count].var = NULL;
-                    extern_resources[*count].buffer = NULL;
-
-                    extern_resources[*count].name = name;
-                    extern_resources[*count].is_user_packed = !!var->reg_reservation.reg_type;
-
-                    extern_resources[*count].component_type = component_type;
-
-                    extern_resources[*count].regset = regset;
-                    extern_resources[*count].id = var->regs[regset].id;
-                    extern_resources[*count].space = var->regs[regset].space;
-                    extern_resources[*count].index = var->regs[regset].index + regset_offset;
-                    extern_resources[*count].bind_count = 1;
-                    extern_resources[*count].loc = var->loc;
-
-                    ++*count;
-                }
-            }
-        }
-        else
-        {
-            unsigned int r;
-
-            if (!hlsl_type_is_resource(var->data_type))
-                continue;
-
-            for (r = 0; r <= HLSL_REGSET_LAST; ++r)
-            {
-                if (!var->regs[r].allocated)
-                    continue;
-
-                if (!(hlsl_array_reserve(ctx, (void **)&extern_resources, &capacity, *count + 1,
-                        sizeof(*extern_resources))))
-                {
-                    sm4_free_extern_resources(extern_resources, *count);
-                    *count = 0;
-                    return NULL;
-                }
-
-                if (!(name = hlsl_strdup(ctx, string_skip_tag(var->name))))
-                {
-                    sm4_free_extern_resources(extern_resources, *count);
-                    *count = 0;
-                    return NULL;
-                }
-
-                extern_resources[*count].var = var;
-                extern_resources[*count].buffer = NULL;
-
-                extern_resources[*count].name = name;
-                /* For some reason 5.1 resources aren't marked as
-                 * user-packed, but cbuffers still are. */
-                extern_resources[*count].is_user_packed = hlsl_version_lt(ctx, 5, 1)
-                        && !!var->reg_reservation.reg_type;
-
-                extern_resources[*count].component_type = hlsl_type_get_component_type(ctx, var->data_type, 0);
-
-                extern_resources[*count].regset = r;
-                extern_resources[*count].id = var->regs[r].id;
-                extern_resources[*count].space = var->regs[r].space;
-                extern_resources[*count].index = var->regs[r].index;
-                extern_resources[*count].bind_count = var->bind_count[r];
-                extern_resources[*count].loc = var->loc;
-
-                ++*count;
-            }
-        }
-    }
-
-    LIST_FOR_EACH_ENTRY(buffer, &ctx->buffers, struct hlsl_buffer, entry)
-    {
-        if (!buffer->reg.allocated)
-            continue;
-
-        if (!(hlsl_array_reserve(ctx, (void **)&extern_resources, &capacity, *count + 1,
-                sizeof(*extern_resources))))
-        {
-            sm4_free_extern_resources(extern_resources, *count);
-            *count = 0;
-            return NULL;
-        }
-
-        if (!(name = hlsl_strdup(ctx, buffer->name)))
-        {
-            sm4_free_extern_resources(extern_resources, *count);
-            *count = 0;
-            return NULL;
-        }
-
-        extern_resources[*count].var = NULL;
-        extern_resources[*count].buffer = buffer;
-
-        extern_resources[*count].name = name;
-        extern_resources[*count].is_user_packed = !!buffer->reservation.reg_type;
-
-        extern_resources[*count].component_type = NULL;
-
-        extern_resources[*count].regset = HLSL_REGSET_NUMERIC;
-        extern_resources[*count].id = buffer->reg.id;
-        extern_resources[*count].space = buffer->reg.space;
-        extern_resources[*count].index = buffer->reg.index;
-        extern_resources[*count].bind_count = 1;
-        extern_resources[*count].loc = buffer->loc;
-
-        ++*count;
-    }
-
-    qsort(extern_resources, *count, sizeof(*extern_resources), sm4_compare_extern_resources);
-    return extern_resources;
-}
-
-/* For some reason, for matrices, values from default value initializers end up in different
- * components than from regular initializers. Default value initializers fill the matrix in
- * vertical reading order (left-to-right top-to-bottom) instead of regular reading order
- * (top-to-bottom left-to-right), so they have to be adjusted.
- * An exception is that the order of matrix initializers for function parameters are row-major
- * (top-to-bottom left-to-right). */
-static unsigned int get_component_index_from_default_initializer_index(struct hlsl_type *type, unsigned int index)
-{
-    unsigned int element_comp_count, element, x, y, i;
-    unsigned int base = 0;
-
-    switch (type->class)
-    {
-        case HLSL_CLASS_MATRIX:
-            x = index / type->dimy;
-            y = index % type->dimy;
-            return y * type->dimx + x;
-
-        case HLSL_CLASS_ARRAY:
-            element_comp_count = hlsl_type_component_count(type->e.array.type);
-            element = index / element_comp_count;
-            base = element * element_comp_count;
-            return base + get_component_index_from_default_initializer_index(type->e.array.type, index - base);
-
-        case HLSL_CLASS_STRUCT:
-            for (i = 0; i < type->e.record.field_count; ++i)
-            {
-                struct hlsl_type *field_type = type->e.record.fields[i].type;
-
-                element_comp_count = hlsl_type_component_count(field_type);
-                if (index - base < element_comp_count)
-                    return base + get_component_index_from_default_initializer_index(field_type, index - base);
-                base += element_comp_count;
-            }
-            break;
-
-        default:
-            return index;
-    }
-    vkd3d_unreachable();
-}
-
-static void write_sm4_rdef(struct hlsl_ctx *ctx, struct dxbc_writer *dxbc)
-{
-    uint32_t binding_desc_size = (hlsl_version_ge(ctx, 5, 1) ? 10 : 8) * sizeof(uint32_t);
-    size_t cbuffers_offset, resources_offset, creator_offset, string_offset;
-    unsigned int cbuffer_count = 0, extern_resources_count, i, j;
-    size_t cbuffer_position, resource_position, creator_position;
-    const struct hlsl_profile_info *profile = ctx->profile;
-    struct vkd3d_bytecode_buffer buffer = {0};
-    struct extern_resource *extern_resources;
-    const struct hlsl_buffer *cbuffer;
-    const struct hlsl_ir_var *var;
-
-    static const uint16_t target_types[] =
-    {
-        0xffff, /* PIXEL */
-        0xfffe, /* VERTEX */
-        0x4753, /* GEOMETRY */
-        0x4853, /* HULL */
-        0x4453, /* DOMAIN */
-        0x4353, /* COMPUTE */
-    };
-
-    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
-
-    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
-    {
-        if (cbuffer->reg.allocated)
-            ++cbuffer_count;
-    }
-
-    put_u32(&buffer, cbuffer_count);
-    cbuffer_position = put_u32(&buffer, 0);
-    put_u32(&buffer, extern_resources_count);
-    resource_position = put_u32(&buffer, 0);
-    put_u32(&buffer, vkd3d_make_u32(vkd3d_make_u16(profile->minor_version, profile->major_version),
-            target_types[profile->type]));
-    put_u32(&buffer, 0); /* FIXME: compilation flags */
-    creator_position = put_u32(&buffer, 0);
-
-    if (profile->major_version >= 5)
-    {
-        put_u32(&buffer, hlsl_version_ge(ctx, 5, 1) ? TAG_RD11_REVERSE : TAG_RD11);
-        put_u32(&buffer, 15 * sizeof(uint32_t)); /* size of RDEF header including this header */
-        put_u32(&buffer, 6 * sizeof(uint32_t)); /* size of buffer desc */
-        put_u32(&buffer, binding_desc_size); /* size of binding desc */
-        put_u32(&buffer, 10 * sizeof(uint32_t)); /* size of variable desc */
-        put_u32(&buffer, 9 * sizeof(uint32_t)); /* size of type desc */
-        put_u32(&buffer, 3 * sizeof(uint32_t)); /* size of member desc */
-        put_u32(&buffer, 0); /* unknown; possibly a null terminator */
-    }
-
-    /* Bound resources. */
-
-    resources_offset = bytecode_align(&buffer);
-    set_u32(&buffer, resource_position, resources_offset);
-
-    for (i = 0; i < extern_resources_count; ++i)
-    {
-        const struct extern_resource *resource = &extern_resources[i];
-        uint32_t flags = 0;
-
-        if (resource->is_user_packed)
-            flags |= D3D_SIF_USERPACKED;
-
-        put_u32(&buffer, 0); /* name */
-        if (resource->buffer)
-            put_u32(&buffer, resource->buffer->type == HLSL_BUFFER_CONSTANT ? D3D_SIT_CBUFFER : D3D_SIT_TBUFFER);
-        else
-            put_u32(&buffer, sm4_resource_type(resource->component_type));
-        if (resource->regset == HLSL_REGSET_TEXTURES || resource->regset == HLSL_REGSET_UAVS)
-        {
-            unsigned int dimx = resource->component_type->e.resource.format->dimx;
-
-            put_u32(&buffer, sm4_data_type(resource->component_type));
-            put_u32(&buffer, sm4_rdef_resource_dimension(resource->component_type));
-            put_u32(&buffer, ~0u); /* FIXME: multisample count */
-            flags |= (dimx - 1) << VKD3D_SM4_SIF_TEXTURE_COMPONENTS_SHIFT;
-        }
-        else
-        {
-            put_u32(&buffer, 0);
-            put_u32(&buffer, 0);
-            put_u32(&buffer, 0);
-        }
-        put_u32(&buffer, resource->index);
-        put_u32(&buffer, resource->bind_count);
-        put_u32(&buffer, flags);
-
-        if (hlsl_version_ge(ctx, 5, 1))
-        {
-            put_u32(&buffer, resource->space);
-            put_u32(&buffer, resource->id);
-        }
-    }
-
-    for (i = 0; i < extern_resources_count; ++i)
-    {
-        const struct extern_resource *resource = &extern_resources[i];
-
-        string_offset = put_string(&buffer, resource->name);
-        set_u32(&buffer, resources_offset + i * binding_desc_size, string_offset);
-    }
-
-    /* Buffers. */
-
-    cbuffers_offset = bytecode_align(&buffer);
-    set_u32(&buffer, cbuffer_position, cbuffers_offset);
-    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
-    {
-        unsigned int var_count = 0;
-
-        if (!cbuffer->reg.allocated)
-            continue;
-
-        LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
-        {
-            if (var->is_uniform && var->buffer == cbuffer && var->data_type->reg_size[HLSL_REGSET_NUMERIC])
-                ++var_count;
-        }
-
-        put_u32(&buffer, 0); /* name */
-        put_u32(&buffer, var_count);
-        put_u32(&buffer, 0); /* variable offset */
-        put_u32(&buffer, align(cbuffer->size, 4) * sizeof(float));
-        put_u32(&buffer, 0); /* FIXME: flags */
-        put_u32(&buffer, cbuffer->type == HLSL_BUFFER_CONSTANT ? D3D_CT_CBUFFER : D3D_CT_TBUFFER);
-    }
-
-    i = 0;
-    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
-    {
-        if (!cbuffer->reg.allocated)
-            continue;
-
-        string_offset = put_string(&buffer, cbuffer->name);
-        set_u32(&buffer, cbuffers_offset + i++ * 6 * sizeof(uint32_t), string_offset);
-    }
-
-    i = 0;
-    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
-    {
-        size_t vars_start = bytecode_align(&buffer);
-
-        if (!cbuffer->reg.allocated)
-            continue;
-
-        set_u32(&buffer, cbuffers_offset + (i++ * 6 + 2) * sizeof(uint32_t), vars_start);
-
-        LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
-        {
-            if (var->is_uniform && var->buffer == cbuffer && var->data_type->reg_size[HLSL_REGSET_NUMERIC])
-            {
-                uint32_t flags = 0;
-
-                if (var->is_read)
-                    flags |= D3D_SVF_USED;
-
-                put_u32(&buffer, 0); /* name */
-                put_u32(&buffer, var->buffer_offset * sizeof(float));
-                put_u32(&buffer, var->data_type->reg_size[HLSL_REGSET_NUMERIC] * sizeof(float));
-                put_u32(&buffer, flags);
-                put_u32(&buffer, 0); /* type */
-                put_u32(&buffer, 0); /* default value */
-
-                if (profile->major_version >= 5)
-                {
-                    put_u32(&buffer, 0); /* texture start */
-                    put_u32(&buffer, 0); /* texture count */
-                    put_u32(&buffer, 0); /* sampler start */
-                    put_u32(&buffer, 0); /* sampler count */
-                }
-            }
-        }
-
-        j = 0;
-        LIST_FOR_EACH_ENTRY(var, &ctx->extern_vars, struct hlsl_ir_var, extern_entry)
-        {
-            if (var->is_uniform && var->buffer == cbuffer && var->data_type->reg_size[HLSL_REGSET_NUMERIC])
-            {
-                const unsigned int var_size = (profile->major_version >= 5 ? 10 : 6);
-                size_t var_offset = vars_start + j * var_size * sizeof(uint32_t);
-
-                string_offset = put_string(&buffer, var->name);
-                set_u32(&buffer, var_offset, string_offset);
-                write_sm4_type(ctx, &buffer, var->data_type);
-                set_u32(&buffer, var_offset + 4 * sizeof(uint32_t), var->data_type->bytecode_offset);
-
-                if (var->default_values)
-                {
-                    unsigned int reg_size = var->data_type->reg_size[HLSL_REGSET_NUMERIC];
-                    unsigned int comp_count = hlsl_type_component_count(var->data_type);
-                    unsigned int default_value_offset;
-                    unsigned int k;
-
-                    default_value_offset = bytecode_reserve_bytes(&buffer, reg_size * sizeof(uint32_t));
-                    set_u32(&buffer, var_offset + 5 * sizeof(uint32_t), default_value_offset);
-
-                    for (k = 0; k < comp_count; ++k)
-                    {
-                        struct hlsl_type *comp_type = hlsl_type_get_component_type(ctx, var->data_type, k);
-                        unsigned int comp_offset, comp_index;
-                        enum hlsl_regset regset;
-
-                        if (comp_type->class == HLSL_CLASS_STRING)
-                        {
-                            hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                                    "Cannot write string default value.");
-                            continue;
-                        }
-
-                        comp_index = get_component_index_from_default_initializer_index(var->data_type, k);
-                        comp_offset = hlsl_type_get_component_offset(ctx, var->data_type, comp_index, &regset);
-                        if (regset == HLSL_REGSET_NUMERIC)
-                        {
-                            if (comp_type->e.numeric.type == HLSL_TYPE_DOUBLE)
-                                hlsl_fixme(ctx, &var->loc, "Write double default values.");
-
-                            set_u32(&buffer, default_value_offset + comp_offset * sizeof(uint32_t),
-                                    var->default_values[k].number.u);
-                        }
-                    }
-                }
-                ++j;
-            }
-        }
-    }
-
-    creator_offset = put_string(&buffer, vkd3d_shader_get_version(NULL, NULL));
-    set_u32(&buffer, creator_position, creator_offset);
-
-    add_section(ctx, dxbc, TAG_RDEF, &buffer);
-
-    sm4_free_extern_resources(extern_resources, extern_resources_count);
-}
-
-static enum vkd3d_sm4_resource_type sm4_resource_dimension(const struct hlsl_type *type)
+static enum vkd3d_sm4_resource_type sm4_resource_dimension(enum vkd3d_shader_resource_type resource_type)
 {
-    switch (type->sampler_dim)
+    switch (resource_type)
     {
-        case HLSL_SAMPLER_DIM_1D:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_1D:
             return VKD3D_SM4_RESOURCE_TEXTURE_1D;
-        case HLSL_SAMPLER_DIM_2D:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_2D:
             return VKD3D_SM4_RESOURCE_TEXTURE_2D;
-        case HLSL_SAMPLER_DIM_3D:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_3D:
             return VKD3D_SM4_RESOURCE_TEXTURE_3D;
-        case HLSL_SAMPLER_DIM_CUBE:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_CUBE:
             return VKD3D_SM4_RESOURCE_TEXTURE_CUBE;
-        case HLSL_SAMPLER_DIM_1DARRAY:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_1DARRAY:
             return VKD3D_SM4_RESOURCE_TEXTURE_1DARRAY;
-        case HLSL_SAMPLER_DIM_2DARRAY:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_2DARRAY:
             return VKD3D_SM4_RESOURCE_TEXTURE_2DARRAY;
-        case HLSL_SAMPLER_DIM_2DMS:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_2DMS:
             return VKD3D_SM4_RESOURCE_TEXTURE_2DMS;
-        case HLSL_SAMPLER_DIM_2DMSARRAY:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_2DMSARRAY:
             return VKD3D_SM4_RESOURCE_TEXTURE_2DMSARRAY;
-        case HLSL_SAMPLER_DIM_CUBEARRAY:
+        case VKD3D_SHADER_RESOURCE_TEXTURE_CUBEARRAY:
             return VKD3D_SM4_RESOURCE_TEXTURE_CUBEARRAY;
-        case HLSL_SAMPLER_DIM_BUFFER:
-        case HLSL_SAMPLER_DIM_RAW_BUFFER:
-        case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
+        case VKD3D_SHADER_RESOURCE_BUFFER:
             return VKD3D_SM4_RESOURCE_BUFFER;
         default:
             vkd3d_unreachable();
@@ -4096,297 +3352,6 @@ struct sm4_instruction
     unsigned int idx_src_count;
 };
 
-static void sm4_register_from_node(struct vkd3d_shader_register *reg, uint32_t *writemask,
-        const struct hlsl_ir_node *instr)
-{
-    VKD3D_ASSERT(instr->reg.allocated);
-    reg->type = VKD3DSPR_TEMP;
-    reg->dimension = VSIR_DIMENSION_VEC4;
-    reg->idx[0].offset = instr->reg.id;
-    reg->idx_count = 1;
-    *writemask = instr->reg.writemask;
-}
-
-static void sm4_numeric_register_from_deref(struct hlsl_ctx *ctx, struct vkd3d_shader_register *reg,
-        enum vkd3d_shader_register_type type, uint32_t *writemask, const struct hlsl_deref *deref,
-        struct sm4_instruction *sm4_instr)
-{
-    const struct hlsl_ir_var *var = deref->var;
-    unsigned int offset_const_deref;
-
-    reg->type = type;
-    reg->idx[0].offset = var->regs[HLSL_REGSET_NUMERIC].id;
-    reg->dimension = VSIR_DIMENSION_VEC4;
-
-    VKD3D_ASSERT(var->regs[HLSL_REGSET_NUMERIC].allocated);
-
-    if (!var->indexable)
-    {
-        offset_const_deref = hlsl_offset_from_deref_safe(ctx, deref);
-        reg->idx[0].offset += offset_const_deref / 4;
-        reg->idx_count = 1;
-    }
-    else
-    {
-        offset_const_deref = deref->const_offset;
-        reg->idx[1].offset = offset_const_deref / 4;
-        reg->idx_count = 2;
-
-        if (deref->rel_offset.node)
-        {
-            struct vkd3d_shader_src_param *idx_src;
-            unsigned int idx_writemask;
-
-            VKD3D_ASSERT(sm4_instr->idx_src_count < ARRAY_SIZE(sm4_instr->idx_srcs));
-            idx_src = &sm4_instr->idx_srcs[sm4_instr->idx_src_count++];
-            memset(idx_src, 0, sizeof(*idx_src));
-
-            reg->idx[1].rel_addr = idx_src;
-            sm4_register_from_node(&idx_src->reg, &idx_writemask, deref->rel_offset.node);
-            VKD3D_ASSERT(idx_writemask != 0);
-            idx_src->swizzle = swizzle_from_sm4(hlsl_swizzle_from_writemask(idx_writemask));
-        }
-    }
-
-    *writemask = 0xf & (0xf << (offset_const_deref % 4));
-    if (var->regs[HLSL_REGSET_NUMERIC].writemask)
-        *writemask = hlsl_combine_writemasks(var->regs[HLSL_REGSET_NUMERIC].writemask, *writemask);
-}
-
-static void sm4_register_from_deref(const struct tpf_compiler *tpf, struct vkd3d_shader_register *reg,
-        uint32_t *writemask, const struct hlsl_deref *deref, struct sm4_instruction *sm4_instr)
-{
-    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
-    const struct hlsl_type *data_type = hlsl_deref_get_type(tpf->ctx, deref);
-    const struct hlsl_ir_var *var = deref->var;
-    struct hlsl_ctx *ctx = tpf->ctx;
-
-    if (var->is_uniform)
-    {
-        enum hlsl_regset regset = hlsl_deref_get_regset(ctx, deref);
-
-        if (regset == HLSL_REGSET_TEXTURES)
-        {
-            reg->type = VKD3DSPR_RESOURCE;
-            reg->dimension = VSIR_DIMENSION_VEC4;
-            if (vkd3d_shader_ver_ge(version, 5, 1))
-            {
-                reg->idx[0].offset = var->regs[HLSL_REGSET_TEXTURES].id;
-                reg->idx[1].offset = var->regs[HLSL_REGSET_TEXTURES].index; /* FIXME: array index */
-                reg->idx_count = 2;
-            }
-            else
-            {
-                reg->idx[0].offset = var->regs[HLSL_REGSET_TEXTURES].index;
-                reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
-                reg->idx_count = 1;
-            }
-            VKD3D_ASSERT(regset == HLSL_REGSET_TEXTURES);
-            *writemask = VKD3DSP_WRITEMASK_ALL;
-        }
-        else if (regset == HLSL_REGSET_UAVS)
-        {
-            reg->type = VKD3DSPR_UAV;
-            reg->dimension = VSIR_DIMENSION_VEC4;
-            if (vkd3d_shader_ver_ge(version, 5, 1))
-            {
-                reg->idx[0].offset = var->regs[HLSL_REGSET_UAVS].id;
-                reg->idx[1].offset = var->regs[HLSL_REGSET_UAVS].index; /* FIXME: array index */
-                reg->idx_count = 2;
-            }
-            else
-            {
-                reg->idx[0].offset = var->regs[HLSL_REGSET_UAVS].index;
-                reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
-                reg->idx_count = 1;
-            }
-            VKD3D_ASSERT(regset == HLSL_REGSET_UAVS);
-            *writemask = VKD3DSP_WRITEMASK_ALL;
-        }
-        else if (regset == HLSL_REGSET_SAMPLERS)
-        {
-            reg->type = VKD3DSPR_SAMPLER;
-            reg->dimension = VSIR_DIMENSION_NONE;
-            if (vkd3d_shader_ver_ge(version, 5, 1))
-            {
-                reg->idx[0].offset = var->regs[HLSL_REGSET_SAMPLERS].id;
-                reg->idx[1].offset = var->regs[HLSL_REGSET_SAMPLERS].index; /* FIXME: array index */
-                reg->idx_count = 2;
-            }
-            else
-            {
-                reg->idx[0].offset = var->regs[HLSL_REGSET_SAMPLERS].index;
-                reg->idx[0].offset += hlsl_offset_from_deref_safe(ctx, deref);
-                reg->idx_count = 1;
-            }
-            VKD3D_ASSERT(regset == HLSL_REGSET_SAMPLERS);
-            *writemask = VKD3DSP_WRITEMASK_ALL;
-        }
-        else
-        {
-            unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref) + var->buffer_offset;
-
-            VKD3D_ASSERT(data_type->class <= HLSL_CLASS_VECTOR);
-            reg->type = VKD3DSPR_CONSTBUFFER;
-            reg->dimension = VSIR_DIMENSION_VEC4;
-            if (vkd3d_shader_ver_ge(version, 5, 1))
-            {
-                reg->idx[0].offset = var->buffer->reg.id;
-                reg->idx[1].offset = var->buffer->reg.index; /* FIXME: array index */
-                reg->idx[2].offset = offset / 4;
-                reg->idx_count = 3;
-            }
-            else
-            {
-                reg->idx[0].offset = var->buffer->reg.index;
-                reg->idx[1].offset = offset / 4;
-                reg->idx_count = 2;
-            }
-            *writemask = ((1u << data_type->dimx) - 1) << (offset & 3);
-        }
-    }
-    else if (var->is_input_semantic)
-    {
-        bool has_idx;
-
-        if (sm4_register_from_semantic_name(version, var->semantic.name, false, &reg->type, &has_idx))
-        {
-            unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
-
-            if (has_idx)
-            {
-                reg->idx[0].offset = var->semantic.index + offset / 4;
-                reg->idx_count = 1;
-            }
-
-            if (shader_sm4_is_scalar_register(reg))
-                reg->dimension = VSIR_DIMENSION_SCALAR;
-            else
-                reg->dimension = VSIR_DIMENSION_VEC4;
-            *writemask = ((1u << data_type->dimx) - 1) << (offset % 4);
-        }
-        else
-        {
-            struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
-
-            VKD3D_ASSERT(hlsl_reg.allocated);
-
-            if (version->type == VKD3D_SHADER_TYPE_DOMAIN)
-                reg->type = VKD3DSPR_PATCHCONST;
-            else
-                reg->type = VKD3DSPR_INPUT;
-            reg->dimension = VSIR_DIMENSION_VEC4;
-            reg->idx[0].offset = hlsl_reg.id;
-            reg->idx_count = 1;
-            *writemask = hlsl_reg.writemask;
-        }
-    }
-    else if (var->is_output_semantic)
-    {
-        bool has_idx;
-
-        if (sm4_register_from_semantic_name(version, var->semantic.name, true, &reg->type, &has_idx))
-        {
-            unsigned int offset = hlsl_offset_from_deref_safe(ctx, deref);
-
-            if (has_idx)
-            {
-                reg->idx[0].offset = var->semantic.index + offset / 4;
-                reg->idx_count = 1;
-            }
-
-            if (shader_sm4_is_scalar_register(reg))
-                reg->dimension = VSIR_DIMENSION_SCALAR;
-            else
-                reg->dimension = VSIR_DIMENSION_VEC4;
-            *writemask = ((1u << data_type->dimx) - 1) << (offset % 4);
-        }
-        else
-        {
-            struct hlsl_reg hlsl_reg = hlsl_reg_from_deref(ctx, deref);
-
-            VKD3D_ASSERT(hlsl_reg.allocated);
-            reg->type = VKD3DSPR_OUTPUT;
-            reg->dimension = VSIR_DIMENSION_VEC4;
-            reg->idx[0].offset = hlsl_reg.id;
-            reg->idx_count = 1;
-            *writemask = hlsl_reg.writemask;
-        }
-    }
-    else
-    {
-        enum vkd3d_shader_register_type type = deref->var->indexable ? VKD3DSPR_IDXTEMP : VKD3DSPR_TEMP;
-
-        sm4_numeric_register_from_deref(ctx, reg, type, writemask, deref, sm4_instr);
-    }
-}
-
-static void sm4_src_from_deref(const struct tpf_compiler *tpf, struct vkd3d_shader_src_param *src,
-        const struct hlsl_deref *deref, unsigned int map_writemask, struct sm4_instruction *sm4_instr)
-{
-    unsigned int hlsl_swizzle;
-    uint32_t writemask;
-
-    sm4_register_from_deref(tpf, &src->reg, &writemask, deref, sm4_instr);
-    if (vkd3d_sm4_get_default_swizzle_type(&tpf->lookup, src->reg.type) == VKD3D_SM4_SWIZZLE_VEC4)
-    {
-        hlsl_swizzle = hlsl_map_swizzle(hlsl_swizzle_from_writemask(writemask), map_writemask);
-        src->swizzle = swizzle_from_sm4(hlsl_swizzle);
-    }
-}
-
-static void sm4_dst_from_node(struct vkd3d_shader_dst_param *dst, const struct hlsl_ir_node *instr)
-{
-    sm4_register_from_node(&dst->reg, &dst->write_mask, instr);
-}
-
-static void sm4_src_from_constant_value(struct vkd3d_shader_src_param *src,
-        const struct hlsl_constant_value *value, unsigned int width, unsigned int map_writemask)
-{
-    src->swizzle = 0;
-    src->reg.type = VKD3DSPR_IMMCONST;
-    if (width == 1)
-    {
-        src->reg.dimension = VSIR_DIMENSION_SCALAR;
-        src->reg.u.immconst_u32[0] = value->u[0].u;
-    }
-    else
-    {
-        unsigned int i, j = 0;
-
-        src->reg.dimension = VSIR_DIMENSION_VEC4;
-        for (i = 0; i < 4; ++i)
-        {
-            if ((map_writemask & (1u << i)) && (j < width))
-                src->reg.u.immconst_u32[i] = value->u[j++].u;
-            else
-                src->reg.u.immconst_u32[i] = 0;
-        }
-    }
-}
-
-static void sm4_src_from_node(const struct tpf_compiler *tpf, struct vkd3d_shader_src_param *src,
-        const struct hlsl_ir_node *instr, uint32_t map_writemask)
-{
-    unsigned int hlsl_swizzle;
-    uint32_t writemask;
-
-    if (instr->type == HLSL_IR_CONSTANT)
-    {
-        struct hlsl_ir_constant *constant = hlsl_ir_constant(instr);
-
-        sm4_src_from_constant_value(src, &constant->value, instr->data_type->dimx, map_writemask);
-        return;
-    }
-
-    sm4_register_from_node(&src->reg, &writemask, instr);
-    if (vkd3d_sm4_get_default_swizzle_type(&tpf->lookup, src->reg.type) == VKD3D_SM4_SWIZZLE_VEC4)
-    {
-        hlsl_swizzle = hlsl_map_swizzle(hlsl_swizzle_from_writemask(writemask), map_writemask);
-        src->swizzle = swizzle_from_sm4(hlsl_swizzle);
-    }
-}
-
 static unsigned int sm4_get_index_addressing_from_reg(const struct vkd3d_shader_register *reg,
         unsigned int i)
 {
@@ -4650,204 +3615,41 @@ static void write_sm4_instruction(const struct tpf_compiler *tpf, const struct s
     sm4_update_stat_counters(tpf, instr);
 }
 
-static bool encode_texel_offset_as_aoffimmi(struct sm4_instruction *instr,
-        const struct hlsl_ir_node *texel_offset)
-{
-    struct sm4_instruction_modifier modif;
-    struct hlsl_ir_constant *offset;
-
-    if (!texel_offset || texel_offset->type != HLSL_IR_CONSTANT)
-        return false;
-    offset = hlsl_ir_constant(texel_offset);
-
-    modif.type = VKD3D_SM4_MODIFIER_AOFFIMMI;
-    modif.u.aoffimmi.u = offset->value.u[0].i;
-    modif.u.aoffimmi.v = 0;
-    modif.u.aoffimmi.w = 0;
-    if (offset->node.data_type->dimx > 1)
-        modif.u.aoffimmi.v = offset->value.u[1].i;
-    if (offset->node.data_type->dimx > 2)
-        modif.u.aoffimmi.w = offset->value.u[2].i;
-    if (modif.u.aoffimmi.u < -8 || modif.u.aoffimmi.u > 7
-            || modif.u.aoffimmi.v < -8 || modif.u.aoffimmi.v > 7
-            || modif.u.aoffimmi.w < -8 || modif.u.aoffimmi.w > 7)
-        return false;
-
-    instr->modifiers[instr->modifier_count++] = modif;
-    return true;
-}
-
-static void write_sm4_dcl_constant_buffer(const struct tpf_compiler *tpf, const struct hlsl_buffer *cbuffer)
+static void tpf_dcl_constant_buffer(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
-    size_t size = (cbuffer->used_size + 3) / 4;
+    const struct vkd3d_shader_constant_buffer *cb = &ins->declaration.cb;
+    size_t size = (cb->size + 3) / 4;
 
     struct sm4_instruction instr =
     {
         .opcode = VKD3D_SM4_OP_DCL_CONSTANT_BUFFER,
 
-        .srcs[0].reg.dimension = VSIR_DIMENSION_VEC4,
-        .srcs[0].reg.type = VKD3DSPR_CONSTBUFFER,
-        .srcs[0].swizzle = VKD3D_SHADER_NO_SWIZZLE,
+        .srcs[0] = cb->src,
         .src_count = 1,
     };
 
-    if (hlsl_version_ge(tpf->ctx, 5, 1))
+    if (vkd3d_shader_ver_ge(&tpf->program->shader_version, 5, 1))
     {
-        instr.srcs[0].reg.idx[0].offset = cbuffer->reg.id;
-        instr.srcs[0].reg.idx[1].offset = cbuffer->reg.index;
-        instr.srcs[0].reg.idx[2].offset = cbuffer->reg.index; /* FIXME: array end */
+        instr.srcs[0].reg.idx[0].offset = cb->src.reg.idx[0].offset;
+        instr.srcs[0].reg.idx[1].offset = cb->range.first;
+        instr.srcs[0].reg.idx[2].offset = cb->range.last;
         instr.srcs[0].reg.idx_count = 3;
 
         instr.idx[0] = size;
-        instr.idx[1] = cbuffer->reg.space;
+        instr.idx[1] = cb->range.space;
         instr.idx_count = 2;
     }
     else
     {
-        instr.srcs[0].reg.idx[0].offset = cbuffer->reg.index;
+        instr.srcs[0].reg.idx[0].offset = cb->range.first;
         instr.srcs[0].reg.idx[1].offset = size;
         instr.srcs[0].reg.idx_count = 2;
     }
 
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_dcl_samplers(const struct tpf_compiler *tpf, const struct extern_resource *resource)
-{
-    unsigned int i;
-    struct sm4_instruction instr =
-    {
-        .opcode = VKD3D_SM4_OP_DCL_SAMPLER,
-
-        .dsts[0].reg.type = VKD3DSPR_SAMPLER,
-        .dst_count = 1,
-    };
-
-    VKD3D_ASSERT(resource->regset == HLSL_REGSET_SAMPLERS);
-
-    if (resource->component_type->sampler_dim == HLSL_SAMPLER_DIM_COMPARISON)
-        instr.extra_bits |= VKD3D_SM4_SAMPLER_COMPARISON << VKD3D_SM4_SAMPLER_MODE_SHIFT;
-
-    for (i = 0; i < resource->bind_count; ++i)
-    {
-        if (resource->var && !resource->var->objects_usage[HLSL_REGSET_SAMPLERS][i].used)
-            continue;
-
-        if (hlsl_version_ge(tpf->ctx, 5, 1))
-        {
-            VKD3D_ASSERT(!i);
-            instr.dsts[0].reg.idx[0].offset = resource->id;
-            instr.dsts[0].reg.idx[1].offset = resource->index;
-            instr.dsts[0].reg.idx[2].offset = resource->index; /* FIXME: array end */
-            instr.dsts[0].reg.idx_count = 3;
-
-            instr.idx[0] = resource->space;
-            instr.idx_count = 1;
-        }
-        else
-        {
-            instr.dsts[0].reg.idx[0].offset = resource->index + i;
-            instr.dsts[0].reg.idx_count = 1;
-        }
-        write_sm4_instruction(tpf, &instr);
-    }
-}
-
-static void write_sm4_dcl_textures(const struct tpf_compiler *tpf, const struct extern_resource *resource,
-        bool uav)
-{
-    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
-    enum hlsl_regset regset = uav ? HLSL_REGSET_UAVS : HLSL_REGSET_TEXTURES;
-    struct hlsl_type *component_type;
-    struct sm4_instruction instr;
-    bool multisampled;
-    unsigned int i;
-
-    VKD3D_ASSERT(resource->regset == regset);
-
-    component_type = resource->component_type;
-
-    for (i = 0; i < resource->bind_count; ++i)
-    {
-        if (resource->var && !resource->var->objects_usage[regset][i].used)
-            continue;
-
-        instr = (struct sm4_instruction)
-        {
-            .dsts[0].reg.type = uav ? VKD3DSPR_UAV : VKD3DSPR_RESOURCE,
-            .dsts[0].reg.idx[0].offset = resource->id + i,
-            .dsts[0].reg.idx_count = 1,
-            .dst_count = 1,
-
-            .idx[0] = sm4_data_type(component_type) * 0x1111,
-            .idx_count = 1,
-        };
-
-        multisampled = component_type->sampler_dim == HLSL_SAMPLER_DIM_2DMS
-                || component_type->sampler_dim == HLSL_SAMPLER_DIM_2DMSARRAY;
-
-        if (!vkd3d_shader_ver_ge(version, 4, 1) && multisampled && !component_type->sample_count)
-        {
-            hlsl_error(tpf->ctx, &resource->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                    "Multisampled texture object declaration needs sample count for profile %u.%u.",
-                    version->major, version->minor);
-        }
-
-        if (vkd3d_shader_ver_ge(version, 5, 1))
-        {
-            VKD3D_ASSERT(!i);
-            instr.dsts[0].reg.idx[0].offset = resource->id;
-            instr.dsts[0].reg.idx[1].offset = resource->index;
-            instr.dsts[0].reg.idx[2].offset = resource->index; /* FIXME: array end */
-            instr.dsts[0].reg.idx_count = 3;
-
-            instr.idx[1] = resource->space;
-            instr.idx_count = 2;
-        }
-        else
-        {
-            instr.dsts[0].reg.idx[0].offset = resource->index + i;
-            instr.dsts[0].reg.idx_count = 1;
-        }
-
-        if (uav)
-        {
-            switch (component_type->sampler_dim)
-            {
-                case HLSL_SAMPLER_DIM_STRUCTURED_BUFFER:
-                    instr.opcode = VKD3D_SM5_OP_DCL_UAV_STRUCTURED;
-                    instr.byte_stride = component_type->e.resource.format->reg_size[HLSL_REGSET_NUMERIC] * 4;
-                    break;
-                case HLSL_SAMPLER_DIM_RAW_BUFFER:
-                    instr.opcode = VKD3D_SM5_OP_DCL_UAV_RAW;
-                    break;
-                default:
-                    instr.opcode = VKD3D_SM5_OP_DCL_UAV_TYPED;
-                    break;
-            }
-
-            if (component_type->e.resource.rasteriser_ordered)
-                instr.opcode |= VKD3DSUF_RASTERISER_ORDERED_VIEW << VKD3D_SM5_UAV_FLAGS_SHIFT;
-        }
-        else
-        {
-            switch (component_type->sampler_dim)
-            {
-                case HLSL_SAMPLER_DIM_RAW_BUFFER:
-                    instr.opcode = VKD3D_SM5_OP_DCL_RESOURCE_RAW;
-                    break;
-                default:
-                    instr.opcode = VKD3D_SM4_OP_DCL_RESOURCE;
-                    break;
-            }
-        }
-        instr.extra_bits |= (sm4_resource_dimension(component_type) << VKD3D_SM4_RESOURCE_TYPE_SHIFT);
-
-        if (multisampled)
-            instr.extra_bits |= component_type->sample_count << VKD3D_SM4_RESOURCE_SAMPLE_COUNT_SHIFT;
+    if (ins->flags & VKD3DSI_INDEXED_DYNAMIC)
+        instr.extra_bits |= VKD3D_SM4_INDEX_TYPE_MASK;
 
-        write_sm4_instruction(tpf, &instr);
-    }
+    write_sm4_instruction(tpf, &instr);
 }
 
 static void tpf_dcl_temps(const struct tpf_compiler *tpf, unsigned int count)
@@ -4924,42 +3726,116 @@ static void tpf_dcl_thread_group(const struct tpf_compiler *tpf, const struct vs
     write_sm4_instruction(tpf, &instr);
 }
 
-static void write_sm4_dcl_global_flags(const struct tpf_compiler *tpf, uint32_t flags)
+static void tpf_dcl_sampler(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
+    const struct vkd3d_shader_sampler *sampler = &ins->declaration.sampler;
     struct sm4_instruction instr =
     {
-        .opcode = VKD3D_SM4_OP_DCL_GLOBAL_FLAGS,
-        .extra_bits = flags << VKD3D_SM4_GLOBAL_FLAGS_SHIFT,
+        .opcode = VKD3D_SM4_OP_DCL_SAMPLER,
+        .extra_bits = ins->flags << VKD3D_SM4_SAMPLER_MODE_SHIFT,
+
+        .dsts[0].reg.type = VKD3DSPR_SAMPLER,
+        .dst_count = 1,
     };
 
+    if (vkd3d_shader_ver_ge(&tpf->program->shader_version, 5, 1))
+    {
+        instr.dsts[0].reg.idx[0].offset = sampler->src.reg.idx[0].offset;
+        instr.dsts[0].reg.idx[1].offset = sampler->range.first;
+        instr.dsts[0].reg.idx[2].offset = sampler->range.last;
+        instr.dsts[0].reg.idx_count = 3;
+
+        instr.idx[0] = ins->declaration.sampler.range.space;
+        instr.idx_count = 1;
+    }
+    else
+    {
+        instr.dsts[0].reg.idx[0].offset = sampler->range.first;
+        instr.dsts[0].reg.idx_count = 1;
+    }
+
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_hs_decls(const struct tpf_compiler *tpf)
+static void tpf_dcl_texture(const struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
-    struct sm4_instruction instr =
+    const struct vkd3d_shader_structured_resource *structured_resource = &ins->declaration.structured_resource;
+    const struct vkd3d_shader_semantic *semantic = &ins->declaration.semantic;
+    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
+    const struct vkd3d_sm4_opcode_info *info;
+    struct sm4_instruction instr = {0};
+    unsigned int i, k;
+    bool uav;
+
+    info = get_info_from_vsir_opcode(&tpf->lookup, ins->opcode);
+    VKD3D_ASSERT(info);
+
+    uav = ins->opcode == VKD3DSIH_DCL_UAV_TYPED
+            || ins->opcode == VKD3DSIH_DCL_UAV_RAW
+            || ins->opcode == VKD3DSIH_DCL_UAV_STRUCTURED;
+
+    instr.opcode = info->opcode;
+
+    instr.dsts[0] = semantic->resource.reg;
+    instr.dst_count = 1;
+
+    for (k = 0; k < 4; ++k)
     {
-        .opcode = VKD3D_SM5_OP_HS_DECLS,
-    };
+        for (i = ARRAY_SIZE(data_type_table) - 1; i < ARRAY_SIZE(data_type_table); --i)
+        {
+            if (semantic->resource_data_type[k] == data_type_table[i])
+            {
+                instr.idx[0] |= i << (4 * k);
+                break;
+            }
+        }
+    }
+    instr.idx_count = 1;
+
+    if (vkd3d_shader_ver_ge(version, 5, 1))
+    {
+        instr.dsts[0].reg.idx[0].offset = semantic->resource.reg.reg.idx[0].offset;
+        instr.dsts[0].reg.idx[1].offset = semantic->resource.range.first;
+        instr.dsts[0].reg.idx[2].offset = semantic->resource.range.last;
+        instr.dsts[0].reg.idx_count = 3;
+
+        instr.idx[1] = semantic->resource.range.space;
+        instr.idx_count = 2;
+    }
+    else
+    {
+        instr.dsts[0].reg.idx[0].offset = semantic->resource.range.first;
+        instr.dsts[0].reg.idx_count = 1;
+    }
+
+    if (uav)
+        instr.extra_bits |= ins->flags << VKD3D_SM5_UAV_FLAGS_SHIFT;
+
+    instr.extra_bits |= (sm4_resource_dimension(ins->resource_type) << VKD3D_SM4_RESOURCE_TYPE_SHIFT);
+    instr.extra_bits |= semantic->sample_count << VKD3D_SM4_RESOURCE_SAMPLE_COUNT_SHIFT;
+
+    if (ins->structured)
+        instr.byte_stride = structured_resource->byte_stride;
 
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_hs_control_point_phase(const struct tpf_compiler *tpf)
+static void write_sm4_dcl_global_flags(const struct tpf_compiler *tpf, uint32_t flags)
 {
     struct sm4_instruction instr =
     {
-        .opcode = VKD3D_SM5_OP_HS_CONTROL_POINT_PHASE,
+        .opcode = VKD3D_SM4_OP_DCL_GLOBAL_FLAGS,
+        .extra_bits = flags << VKD3D_SM4_GLOBAL_FLAGS_SHIFT,
     };
 
     write_sm4_instruction(tpf, &instr);
 }
 
-static void tpf_write_hs_fork_phase(const struct tpf_compiler *tpf)
+static void tpf_write_hs_decls(const struct tpf_compiler *tpf)
 {
     struct sm4_instruction instr =
     {
-        .opcode = VKD3D_SM5_OP_HS_FORK_PHASE,
+        .opcode = VKD3D_SM5_OP_HS_DECLS,
     };
 
     write_sm4_instruction(tpf, &instr);
@@ -5022,594 +3898,9 @@ static void tpf_write_dcl_tessellator_output_primitive(const struct tpf_compiler
     write_sm4_instruction(tpf, &instr);
 }
 
-static void write_sm4_ret(const struct tpf_compiler *tpf)
-{
-    struct sm4_instruction instr =
-    {
-        .opcode = VKD3D_SM4_OP_RET,
-    };
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_ld(const struct tpf_compiler *tpf, const struct hlsl_ir_node *dst,
-        const struct hlsl_deref *resource, const struct hlsl_ir_node *coords,
-        const struct hlsl_ir_node *sample_index, const struct hlsl_ir_node *texel_offset,
-        enum hlsl_sampler_dim dim)
-{
-    const struct hlsl_type *resource_type = hlsl_deref_get_type(tpf->ctx, resource);
-    bool multisampled = resource_type->class == HLSL_CLASS_TEXTURE
-            && (resource_type->sampler_dim == HLSL_SAMPLER_DIM_2DMS || resource_type->sampler_dim == HLSL_SAMPLER_DIM_2DMSARRAY);
-    bool uav = (hlsl_deref_get_regset(tpf->ctx, resource) == HLSL_REGSET_UAVS);
-    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
-    bool raw = resource_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER;
-    unsigned int coords_writemask = VKD3DSP_WRITEMASK_ALL;
-    struct sm4_instruction instr;
-
-    memset(&instr, 0, sizeof(instr));
-    if (uav)
-        instr.opcode = VKD3D_SM5_OP_LD_UAV_TYPED;
-    else if (raw)
-        instr.opcode = VKD3D_SM5_OP_LD_RAW;
-    else
-        instr.opcode = multisampled ? VKD3D_SM4_OP_LD2DMS : VKD3D_SM4_OP_LD;
-
-    if (texel_offset)
-    {
-        if (!encode_texel_offset_as_aoffimmi(&instr, texel_offset))
-        {
-            hlsl_error(tpf->ctx, &texel_offset->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TEXEL_OFFSET,
-                    "Offset must resolve to integer literal in the range -8 to 7.");
-            return;
-        }
-    }
-
-    sm4_dst_from_node(&instr.dsts[0], dst);
-    instr.dst_count = 1;
-
-    if (!uav)
-    {
-        /* Mipmap level is in the last component in the IR, but needs to be in the W
-         * component in the instruction. */
-        unsigned int dim_count = hlsl_sampler_dim_count(dim);
-
-        if (dim_count == 1)
-            coords_writemask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_3;
-        if (dim_count == 2)
-            coords_writemask = VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_1 | VKD3DSP_WRITEMASK_3;
-    }
-
-    sm4_src_from_node(tpf, &instr.srcs[0], coords, coords_writemask);
-
-    sm4_src_from_deref(tpf, &instr.srcs[1], resource, instr.dsts[0].write_mask, &instr);
-
-    instr.src_count = 2;
-
-    if (multisampled)
-    {
-        if (sample_index->type == HLSL_IR_CONSTANT)
-        {
-            struct vkd3d_shader_register *reg = &instr.srcs[2].reg;
-            struct hlsl_ir_constant *index;
-
-            index = hlsl_ir_constant(sample_index);
-
-            memset(&instr.srcs[2], 0, sizeof(instr.srcs[2]));
-            reg->type = VKD3DSPR_IMMCONST;
-            reg->dimension = VSIR_DIMENSION_SCALAR;
-            reg->u.immconst_u32[0] = index->value.u[0].u;
-        }
-        else if (version->major == 4 && version->minor == 0)
-        {
-            hlsl_error(tpf->ctx, &sample_index->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Expected literal sample index.");
-        }
-        else
-        {
-            sm4_src_from_node(tpf, &instr.srcs[2], sample_index, 0);
-        }
-
-        ++instr.src_count;
-    }
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_sample(const struct tpf_compiler *tpf, const struct hlsl_ir_resource_load *load)
-{
-    const struct hlsl_ir_node *texel_offset = load->texel_offset.node;
-    const struct hlsl_ir_node *coords = load->coords.node;
-    const struct hlsl_deref *resource = &load->resource;
-    const struct hlsl_deref *sampler = &load->sampler;
-    const struct hlsl_ir_node *dst = &load->node;
-    struct sm4_instruction instr;
-
-    memset(&instr, 0, sizeof(instr));
-    switch (load->load_type)
-    {
-        case HLSL_RESOURCE_SAMPLE:
-            instr.opcode = VKD3D_SM4_OP_SAMPLE;
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_CMP:
-            instr.opcode = VKD3D_SM4_OP_SAMPLE_C;
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_CMP_LZ:
-            instr.opcode = VKD3D_SM4_OP_SAMPLE_C_LZ;
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_LOD:
-            instr.opcode = VKD3D_SM4_OP_SAMPLE_LOD;
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_LOD_BIAS:
-            instr.opcode = VKD3D_SM4_OP_SAMPLE_B;
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_GRAD:
-            instr.opcode = VKD3D_SM4_OP_SAMPLE_GRAD;
-            break;
-
-        default:
-            vkd3d_unreachable();
-    }
-
-    if (texel_offset)
-    {
-        if (!encode_texel_offset_as_aoffimmi(&instr, texel_offset))
-        {
-            hlsl_error(tpf->ctx, &texel_offset->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TEXEL_OFFSET,
-                    "Offset must resolve to integer literal in the range -8 to 7.");
-            return;
-        }
-    }
-
-    sm4_dst_from_node(&instr.dsts[0], dst);
-    instr.dst_count = 1;
-
-    sm4_src_from_node(tpf, &instr.srcs[0], coords, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_deref(tpf, &instr.srcs[1], resource, instr.dsts[0].write_mask, &instr);
-    sm4_src_from_deref(tpf, &instr.srcs[2], sampler, VKD3DSP_WRITEMASK_ALL, &instr);
-    instr.src_count = 3;
-
-    if (load->load_type == HLSL_RESOURCE_SAMPLE_LOD
-           || load->load_type == HLSL_RESOURCE_SAMPLE_LOD_BIAS)
-    {
-        sm4_src_from_node(tpf, &instr.srcs[3], load->lod.node, VKD3DSP_WRITEMASK_ALL);
-        ++instr.src_count;
-    }
-    else if (load->load_type == HLSL_RESOURCE_SAMPLE_GRAD)
-    {
-        sm4_src_from_node(tpf, &instr.srcs[3], load->ddx.node, VKD3DSP_WRITEMASK_ALL);
-        sm4_src_from_node(tpf, &instr.srcs[4], load->ddy.node, VKD3DSP_WRITEMASK_ALL);
-        instr.src_count += 2;
-    }
-    else if (load->load_type == HLSL_RESOURCE_SAMPLE_CMP
-            || load->load_type == HLSL_RESOURCE_SAMPLE_CMP_LZ)
-    {
-        sm4_src_from_node(tpf, &instr.srcs[3], load->cmp.node, VKD3DSP_WRITEMASK_ALL);
-        ++instr.src_count;
-    }
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_sampleinfo(const struct tpf_compiler *tpf, const struct hlsl_ir_resource_load *load)
-{
-    const struct hlsl_deref *resource = &load->resource;
-    const struct hlsl_ir_node *dst = &load->node;
-    struct sm4_instruction instr;
-
-    VKD3D_ASSERT(dst->data_type->e.numeric.type == HLSL_TYPE_UINT || dst->data_type->e.numeric.type == HLSL_TYPE_FLOAT);
-
-    memset(&instr, 0, sizeof(instr));
-    instr.opcode = VKD3D_SM4_OP_SAMPLE_INFO;
-    if (dst->data_type->e.numeric.type == HLSL_TYPE_UINT)
-        instr.extra_bits |= VKD3DSI_SAMPLE_INFO_UINT << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT;
-
-    sm4_dst_from_node(&instr.dsts[0], dst);
-    instr.dst_count = 1;
-
-    sm4_src_from_deref(tpf, &instr.srcs[0], resource, instr.dsts[0].write_mask, &instr);
-    instr.src_count = 1;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_resinfo(const struct tpf_compiler *tpf, const struct hlsl_ir_resource_load *load)
-{
-    const struct hlsl_deref *resource = &load->resource;
-    const struct hlsl_ir_node *dst = &load->node;
-    struct sm4_instruction instr;
-
-    if (resource->data_type->sampler_dim == HLSL_SAMPLER_DIM_BUFFER
-            || resource->data_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
-    {
-        hlsl_fixme(tpf->ctx, &load->node.loc, "resinfo for buffers.");
-        return;
-    }
-
-    VKD3D_ASSERT(dst->data_type->e.numeric.type == HLSL_TYPE_UINT || dst->data_type->e.numeric.type == HLSL_TYPE_FLOAT);
-
-    memset(&instr, 0, sizeof(instr));
-    instr.opcode = VKD3D_SM4_OP_RESINFO;
-    if (dst->data_type->e.numeric.type == HLSL_TYPE_UINT)
-        instr.extra_bits |= VKD3DSI_RESINFO_UINT << VKD3D_SM4_INSTRUCTION_FLAGS_SHIFT;
-
-    sm4_dst_from_node(&instr.dsts[0], dst);
-    instr.dst_count = 1;
-
-    sm4_src_from_node(tpf, &instr.srcs[0], load->lod.node, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_deref(tpf, &instr.srcs[1], resource, instr.dsts[0].write_mask, &instr);
-    instr.src_count = 2;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_if(struct tpf_compiler *tpf, const struct hlsl_ir_if *iff)
-{
-    struct sm4_instruction instr =
-    {
-        .opcode = VKD3D_SM4_OP_IF,
-        .extra_bits = VKD3D_SM4_CONDITIONAL_NZ,
-        .src_count = 1,
-    };
-
-    VKD3D_ASSERT(iff->condition.node->data_type->dimx == 1);
-
-    sm4_src_from_node(tpf, &instr.srcs[0], iff->condition.node, VKD3DSP_WRITEMASK_ALL);
-    write_sm4_instruction(tpf, &instr);
-
-    write_sm4_block(tpf, &iff->then_block);
-
-    if (!list_empty(&iff->else_block.instrs))
-    {
-        instr.opcode = VKD3D_SM4_OP_ELSE;
-        instr.src_count = 0;
-        write_sm4_instruction(tpf, &instr);
-
-        write_sm4_block(tpf, &iff->else_block);
-    }
-
-    instr.opcode = VKD3D_SM4_OP_ENDIF;
-    instr.src_count = 0;
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_jump(const struct tpf_compiler *tpf, const struct hlsl_ir_jump *jump)
-{
-    struct sm4_instruction instr = {0};
-
-    switch (jump->type)
-    {
-        case HLSL_IR_JUMP_BREAK:
-            instr.opcode = VKD3D_SM4_OP_BREAK;
-            break;
-
-        case HLSL_IR_JUMP_CONTINUE:
-            instr.opcode = VKD3D_SM4_OP_CONTINUE;
-            break;
-
-        case HLSL_IR_JUMP_DISCARD_NZ:
-        {
-            instr.opcode = VKD3D_SM4_OP_DISCARD;
-            instr.extra_bits = VKD3D_SM4_CONDITIONAL_NZ;
-
-            memset(&instr.srcs[0], 0, sizeof(*instr.srcs));
-            instr.src_count = 1;
-            sm4_src_from_node(tpf, &instr.srcs[0], jump->condition.node, VKD3DSP_WRITEMASK_ALL);
-            break;
-        }
-
-        case HLSL_IR_JUMP_RETURN:
-            vkd3d_unreachable();
-
-        default:
-            hlsl_fixme(tpf->ctx, &jump->node.loc, "Jump type %s.", hlsl_jump_type_to_string(jump->type));
-            return;
-    }
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-/* Does this variable's data come directly from the API user, rather than being
- * temporary or from a previous shader stage?
- * I.e. is it a uniform or VS input? */
-static bool var_is_user_input(const struct vkd3d_shader_version *version, const struct hlsl_ir_var *var)
-{
-    if (var->is_uniform)
-        return true;
-
-    return var->is_input_semantic && version->type == VKD3D_SHADER_TYPE_VERTEX;
-}
-
-static void write_sm4_load(const struct tpf_compiler *tpf, const struct hlsl_ir_load *load)
-{
-    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
-    const struct hlsl_type *type = load->node.data_type;
-    struct sm4_instruction instr;
-
-    memset(&instr, 0, sizeof(instr));
-
-    sm4_dst_from_node(&instr.dsts[0], &load->node);
-    instr.dst_count = 1;
-
-    VKD3D_ASSERT(hlsl_is_numeric_type(type));
-    if (type->e.numeric.type == HLSL_TYPE_BOOL && var_is_user_input(version, load->src.var))
-    {
-        struct hlsl_constant_value value;
-
-        /* Uniform bools can be specified as anything, but internal bools always
-         * have 0 for false and ~0 for true. Normalize that here. */
-
-        instr.opcode = VKD3D_SM4_OP_MOVC;
-
-        sm4_src_from_deref(tpf, &instr.srcs[0], &load->src, instr.dsts[0].write_mask, &instr);
-
-        memset(&value, 0xff, sizeof(value));
-        sm4_src_from_constant_value(&instr.srcs[1], &value, type->dimx, instr.dsts[0].write_mask);
-        memset(&value, 0, sizeof(value));
-        sm4_src_from_constant_value(&instr.srcs[2], &value, type->dimx, instr.dsts[0].write_mask);
-        instr.src_count = 3;
-    }
-    else
-    {
-        instr.opcode = VKD3D_SM4_OP_MOV;
-
-        sm4_src_from_deref(tpf, &instr.srcs[0], &load->src, instr.dsts[0].write_mask, &instr);
-        instr.src_count = 1;
-    }
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_loop(struct tpf_compiler *tpf, const struct hlsl_ir_loop *loop)
-{
-    struct sm4_instruction instr =
-    {
-        .opcode = VKD3D_SM4_OP_LOOP,
-    };
-
-    write_sm4_instruction(tpf, &instr);
-
-    write_sm4_block(tpf, &loop->body);
-
-    instr.opcode = VKD3D_SM4_OP_ENDLOOP;
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_gather(const struct tpf_compiler *tpf, const struct hlsl_ir_node *dst,
-        const struct hlsl_deref *resource, const struct hlsl_deref *sampler,
-        const struct hlsl_ir_node *coords, uint32_t swizzle, const struct hlsl_ir_node *texel_offset)
-{
-    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
-    struct vkd3d_shader_src_param *src;
-    struct sm4_instruction instr;
-
-    memset(&instr, 0, sizeof(instr));
-
-    instr.opcode = VKD3D_SM4_OP_GATHER4;
-
-    sm4_dst_from_node(&instr.dsts[0], dst);
-    instr.dst_count = 1;
-
-    sm4_src_from_node(tpf, &instr.srcs[instr.src_count++], coords, VKD3DSP_WRITEMASK_ALL);
-
-    if (texel_offset)
-    {
-        if (!encode_texel_offset_as_aoffimmi(&instr, texel_offset))
-        {
-            if (!vkd3d_shader_ver_ge(version, 5, 0))
-            {
-                hlsl_error(tpf->ctx, &texel_offset->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TEXEL_OFFSET,
-                    "Offset must resolve to integer literal in the range -8 to 7 for profiles < 5.");
-                return;
-            }
-            instr.opcode = VKD3D_SM5_OP_GATHER4_PO;
-            sm4_src_from_node(tpf, &instr.srcs[instr.src_count++], texel_offset, VKD3DSP_WRITEMASK_ALL);
-        }
-    }
-
-    sm4_src_from_deref(tpf, &instr.srcs[instr.src_count++], resource, instr.dsts[0].write_mask, &instr);
-
-    src = &instr.srcs[instr.src_count++];
-    sm4_src_from_deref(tpf, src, sampler, VKD3DSP_WRITEMASK_ALL, &instr);
-    src->reg.dimension = VSIR_DIMENSION_VEC4;
-    src->swizzle = swizzle;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_resource_load(const struct tpf_compiler *tpf, const struct hlsl_ir_resource_load *load)
-{
-    const struct hlsl_ir_node *texel_offset = load->texel_offset.node;
-    const struct hlsl_ir_node *sample_index = load->sample_index.node;
-    const struct hlsl_ir_node *coords = load->coords.node;
-
-    if (load->sampler.var && !load->sampler.var->is_uniform)
-    {
-        hlsl_fixme(tpf->ctx, &load->node.loc, "Sample using non-uniform sampler variable.");
-        return;
-    }
-
-    if (!load->resource.var->is_uniform)
-    {
-        hlsl_fixme(tpf->ctx, &load->node.loc, "Load from non-uniform resource variable.");
-        return;
-    }
-
-    switch (load->load_type)
-    {
-        case HLSL_RESOURCE_LOAD:
-            write_sm4_ld(tpf, &load->node, &load->resource,
-                    coords, sample_index, texel_offset, load->sampling_dim);
-            break;
-
-        case HLSL_RESOURCE_SAMPLE:
-        case HLSL_RESOURCE_SAMPLE_CMP:
-        case HLSL_RESOURCE_SAMPLE_CMP_LZ:
-        case HLSL_RESOURCE_SAMPLE_LOD:
-        case HLSL_RESOURCE_SAMPLE_LOD_BIAS:
-        case HLSL_RESOURCE_SAMPLE_GRAD:
-            /* Combined sample expressions were lowered. */
-            VKD3D_ASSERT(load->sampler.var);
-            write_sm4_sample(tpf, load);
-            break;
-
-        case HLSL_RESOURCE_GATHER_RED:
-            write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    VKD3D_SHADER_SWIZZLE(X, X, X, X), texel_offset);
-            break;
-
-        case HLSL_RESOURCE_GATHER_GREEN:
-            write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    VKD3D_SHADER_SWIZZLE(Y, Y, Y, Y), texel_offset);
-            break;
-
-        case HLSL_RESOURCE_GATHER_BLUE:
-            write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    VKD3D_SHADER_SWIZZLE(Z, Z, Z, Z), texel_offset);
-            break;
-
-        case HLSL_RESOURCE_GATHER_ALPHA:
-            write_sm4_gather(tpf, &load->node, &load->resource, &load->sampler, coords,
-                    VKD3D_SHADER_SWIZZLE(W, W, W, W), texel_offset);
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_INFO:
-            write_sm4_sampleinfo(tpf, load);
-            break;
-
-        case HLSL_RESOURCE_RESINFO:
-            write_sm4_resinfo(tpf, load);
-            break;
-
-        case HLSL_RESOURCE_SAMPLE_PROJ:
-            vkd3d_unreachable();
-    }
-}
-
-static void write_sm4_resource_store(const struct tpf_compiler *tpf, const struct hlsl_ir_resource_store *store)
-{
-    struct hlsl_type *resource_type = hlsl_deref_get_type(tpf->ctx, &store->resource);
-    struct hlsl_ir_node *coords = store->coords.node, *value = store->value.node;
-    struct sm4_instruction instr;
-
-    if (!store->resource.var->is_uniform)
-    {
-        hlsl_fixme(tpf->ctx, &store->node.loc, "Store to non-uniform resource variable.");
-        return;
-    }
-
-    if (resource_type->sampler_dim == HLSL_SAMPLER_DIM_STRUCTURED_BUFFER)
-    {
-        hlsl_fixme(tpf->ctx, &store->node.loc, "Structured buffers store is not implemented.");
-        return;
-    }
-
-    memset(&instr, 0, sizeof(instr));
-
-    sm4_register_from_deref(tpf, &instr.dsts[0].reg, &instr.dsts[0].write_mask, &store->resource, &instr);
-    instr.dst_count = 1;
-    if (resource_type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
-    {
-        instr.opcode = VKD3D_SM5_OP_STORE_RAW;
-        instr.dsts[0].write_mask = vkd3d_write_mask_from_component_count(value->data_type->dimx);
-    }
-    else
-    {
-        instr.opcode = VKD3D_SM5_OP_STORE_UAV_TYPED;
-    }
-
-    sm4_src_from_node(tpf, &instr.srcs[0], coords, VKD3DSP_WRITEMASK_ALL);
-    sm4_src_from_node(tpf, &instr.srcs[1], value, VKD3DSP_WRITEMASK_ALL);
-    instr.src_count = 2;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_store(const struct tpf_compiler *tpf, const struct hlsl_ir_store *store)
-{
-    const struct hlsl_ir_node *rhs = store->rhs.node;
-    struct sm4_instruction instr;
-    uint32_t writemask;
-
-    memset(&instr, 0, sizeof(instr));
-    instr.opcode = VKD3D_SM4_OP_MOV;
-
-    sm4_register_from_deref(tpf, &instr.dsts[0].reg, &writemask, &store->lhs, &instr);
-    instr.dsts[0].write_mask = hlsl_combine_writemasks(writemask, store->writemask);
-    instr.dst_count = 1;
-
-    sm4_src_from_node(tpf, &instr.srcs[0], rhs, instr.dsts[0].write_mask);
-    instr.src_count = 1;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_switch(struct tpf_compiler *tpf, const struct hlsl_ir_switch *s)
-{
-    const struct hlsl_ir_node *selector = s->selector.node;
-    struct hlsl_ir_switch_case *c;
-    struct sm4_instruction instr;
-
-    memset(&instr, 0, sizeof(instr));
-    instr.opcode = VKD3D_SM4_OP_SWITCH;
-
-    sm4_src_from_node(tpf, &instr.srcs[0], selector, VKD3DSP_WRITEMASK_ALL);
-    instr.src_count = 1;
-
-    write_sm4_instruction(tpf, &instr);
-
-    LIST_FOR_EACH_ENTRY(c, &s->cases, struct hlsl_ir_switch_case, entry)
-    {
-        memset(&instr, 0, sizeof(instr));
-        if (c->is_default)
-        {
-            instr.opcode = VKD3D_SM4_OP_DEFAULT;
-        }
-        else
-        {
-            struct hlsl_constant_value value = { .u[0].u = c->value };
-
-            instr.opcode = VKD3D_SM4_OP_CASE;
-            sm4_src_from_constant_value(&instr.srcs[0], &value, 1, VKD3DSP_WRITEMASK_ALL);
-            instr.src_count = 1;
-        }
-
-        write_sm4_instruction(tpf, &instr);
-        write_sm4_block(tpf, &c->body);
-    }
-
-    memset(&instr, 0, sizeof(instr));
-    instr.opcode = VKD3D_SM4_OP_ENDSWITCH;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void write_sm4_swizzle(const struct tpf_compiler *tpf, const struct hlsl_ir_swizzle *swizzle)
-{
-    unsigned int hlsl_swizzle;
-    struct sm4_instruction instr;
-    uint32_t writemask;
-
-    memset(&instr, 0, sizeof(instr));
-    instr.opcode = VKD3D_SM4_OP_MOV;
-
-    sm4_dst_from_node(&instr.dsts[0], &swizzle->node);
-    instr.dst_count = 1;
-
-    sm4_register_from_node(&instr.srcs[0].reg, &writemask, swizzle->val.node);
-    hlsl_swizzle = hlsl_map_swizzle(hlsl_combine_swizzles(hlsl_swizzle_from_writemask(writemask),
-            swizzle->swizzle, swizzle->node.data_type->dimx), instr.dsts[0].write_mask);
-    instr.srcs[0].swizzle = swizzle_from_sm4(hlsl_swizzle);
-    instr.src_count = 1;
-
-    write_sm4_instruction(tpf, &instr);
-}
-
-static void tpf_simple_instruction(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
+static void tpf_simple_instruction(struct tpf_compiler *tpf, const struct vkd3d_shader_instruction *ins)
 {
+    struct sm4_instruction_modifier *modifier;
     const struct vkd3d_sm4_opcode_info *info;
     struct sm4_instruction instr = {0};
     unsigned int dst_count, src_count;
@@ -5655,6 +3946,22 @@ static void tpf_simple_instruction(struct tpf_compiler *tpf, const struct vkd3d_
     for (unsigned int i = 0; i < ins->src_count; ++i)
         instr.srcs[i] = ins->src[i];
 
+    if (ins->texel_offset.u || ins->texel_offset.v || ins->texel_offset.w)
+    {
+        VKD3D_ASSERT(instr.modifier_count < ARRAY_SIZE(instr.modifiers));
+        modifier = &instr.modifiers[instr.modifier_count++];
+        modifier->type = VKD3D_SM4_MODIFIER_AOFFIMMI;
+        modifier->u.aoffimmi.u = ins->texel_offset.u;
+        modifier->u.aoffimmi.v = ins->texel_offset.v;
+        modifier->u.aoffimmi.w = ins->texel_offset.w;
+    }
+
+    if (info->is_conditional_op)
+    {
+        if (ins->flags == VKD3D_SHADER_CONDITIONAL_OP_NZ)
+            instr.extra_bits = VKD3D_SM4_CONDITIONAL_NZ;
+    }
+
     write_sm4_instruction(tpf, &instr);
 }
 
@@ -5662,6 +3969,10 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
 {
     switch (ins->opcode)
     {
+        case VKD3DSIH_DCL_CONSTANT_BUFFER:
+            tpf_dcl_constant_buffer(tpf, ins);
+            break;
+
         case VKD3DSIH_DCL_TEMPS:
             tpf_dcl_temps(tpf, ins->declaration.count);
             break;
@@ -5702,8 +4013,25 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
             tpf_dcl_siv_semantic(tpf, VKD3D_SM4_OP_DCL_OUTPUT_SIV, &ins->declaration.register_semantic, 0);
             break;
 
+        case VKD3DSIH_DCL_SAMPLER:
+            tpf_dcl_sampler(tpf, ins);
+            break;
+
+        case VKD3DSIH_DCL:
+        case VKD3DSIH_DCL_RESOURCE_RAW:
+        case VKD3DSIH_DCL_UAV_RAW:
+        case VKD3DSIH_DCL_UAV_STRUCTURED:
+        case VKD3DSIH_DCL_UAV_TYPED:
+            tpf_dcl_texture(tpf, ins);
+            break;
+
         case VKD3DSIH_ADD:
         case VKD3DSIH_AND:
+        case VKD3DSIH_BREAK:
+        case VKD3DSIH_CASE:
+        case VKD3DSIH_CONTINUE:
+        case VKD3DSIH_DEFAULT:
+        case VKD3DSIH_DISCARD:
         case VKD3DSIH_DIV:
         case VKD3DSIH_DP2:
         case VKD3DSIH_DP3:
@@ -5714,6 +4042,10 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
         case VKD3DSIH_DSY:
         case VKD3DSIH_DSY_COARSE:
         case VKD3DSIH_DSY_FINE:
+        case VKD3DSIH_ELSE:
+        case VKD3DSIH_ENDIF:
+        case VKD3DSIH_ENDLOOP:
+        case VKD3DSIH_ENDSWITCH:
         case VKD3DSIH_EQO:
         case VKD3DSIH_EXP:
         case VKD3DSIH_F16TOF32:
@@ -5721,9 +4053,16 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
         case VKD3DSIH_FRC:
         case VKD3DSIH_FTOI:
         case VKD3DSIH_FTOU:
+        case VKD3DSIH_GATHER4:
+        case VKD3DSIH_GATHER4_PO:
+        case VKD3DSIH_GATHER4_C:
+        case VKD3DSIH_GATHER4_PO_C:
         case VKD3DSIH_GEO:
+        case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+        case VKD3DSIH_HS_FORK_PHASE:
         case VKD3DSIH_IADD:
         case VKD3DSIH_IEQ:
+        case VKD3DSIH_IF:
         case VKD3DSIH_IGE:
         case VKD3DSIH_ILT:
         case VKD3DSIH_IMAD:
@@ -5735,7 +4074,12 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
         case VKD3DSIH_ISHL:
         case VKD3DSIH_ISHR:
         case VKD3DSIH_ITOF:
+        case VKD3DSIH_LD:
+        case VKD3DSIH_LD2DMS:
+        case VKD3DSIH_LD_RAW:
+        case VKD3DSIH_LD_UAV_TYPED:
         case VKD3DSIH_LOG:
+        case VKD3DSIH_LOOP:
         case VKD3DSIH_LTO:
         case VKD3DSIH_MAD:
         case VKD3DSIH_MAX:
@@ -5747,14 +4091,25 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
         case VKD3DSIH_NOT:
         case VKD3DSIH_OR:
         case VKD3DSIH_RCP:
+        case VKD3DSIH_RESINFO:
+        case VKD3DSIH_RET:
         case VKD3DSIH_ROUND_NE:
         case VKD3DSIH_ROUND_NI:
         case VKD3DSIH_ROUND_PI:
         case VKD3DSIH_ROUND_Z:
         case VKD3DSIH_RSQ:
+        case VKD3DSIH_SAMPLE:
+        case VKD3DSIH_SAMPLE_B:
+        case VKD3DSIH_SAMPLE_C:
+        case VKD3DSIH_SAMPLE_C_LZ:
+        case VKD3DSIH_SAMPLE_GRAD:
         case VKD3DSIH_SAMPLE_INFO:
+        case VKD3DSIH_SAMPLE_LOD:
         case VKD3DSIH_SINCOS:
         case VKD3DSIH_SQRT:
+        case VKD3DSIH_STORE_RAW:
+        case VKD3DSIH_STORE_UAV_TYPED:
+        case VKD3DSIH_SWITCH:
         case VKD3DSIH_UDIV:
         case VKD3DSIH_UGE:
         case VKD3DSIH_ULT:
@@ -5772,102 +4127,23 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
     }
 }
 
-static void write_sm4_block(struct tpf_compiler *tpf, const struct hlsl_block *block)
+static void tpf_write_program(struct tpf_compiler *tpf, const struct vsir_program *program)
 {
-    const struct hlsl_ir_node *instr;
-    unsigned int vsir_instr_idx;
-
-    LIST_FOR_EACH_ENTRY(instr, &block->instrs, struct hlsl_ir_node, entry)
-    {
-        if (instr->data_type)
-        {
-            if (instr->data_type->class != HLSL_CLASS_SCALAR && instr->data_type->class != HLSL_CLASS_VECTOR)
-            {
-                hlsl_fixme(tpf->ctx, &instr->loc, "Class %#x should have been lowered or removed.",
-                        instr->data_type->class);
-                break;
-            }
-
-            if (!instr->reg.allocated)
-            {
-                VKD3D_ASSERT(instr->type == HLSL_IR_CONSTANT);
-                continue;
-            }
-        }
-
-        switch (instr->type)
-        {
-            case HLSL_IR_CALL:
-            case HLSL_IR_CONSTANT:
-                vkd3d_unreachable();
-
-            case HLSL_IR_IF:
-                write_sm4_if(tpf, hlsl_ir_if(instr));
-                break;
-
-            case HLSL_IR_JUMP:
-                write_sm4_jump(tpf, hlsl_ir_jump(instr));
-                break;
-
-            case HLSL_IR_LOAD:
-                write_sm4_load(tpf, hlsl_ir_load(instr));
-                break;
-
-            case HLSL_IR_RESOURCE_LOAD:
-                write_sm4_resource_load(tpf, hlsl_ir_resource_load(instr));
-                break;
-
-            case HLSL_IR_RESOURCE_STORE:
-                write_sm4_resource_store(tpf, hlsl_ir_resource_store(instr));
-                break;
-
-            case HLSL_IR_LOOP:
-                write_sm4_loop(tpf, hlsl_ir_loop(instr));
-                break;
-
-            case HLSL_IR_STORE:
-                write_sm4_store(tpf, hlsl_ir_store(instr));
-                break;
-
-            case HLSL_IR_SWITCH:
-                write_sm4_switch(tpf, hlsl_ir_switch(instr));
-                break;
-
-            case HLSL_IR_SWIZZLE:
-                write_sm4_swizzle(tpf, hlsl_ir_swizzle(instr));
-                break;
-
-            case HLSL_IR_VSIR_INSTRUCTION_REF:
-                vsir_instr_idx = hlsl_ir_vsir_instruction_ref(instr)->vsir_instr_idx;
-                tpf_handle_instruction(tpf, &tpf->program->instructions.elements[vsir_instr_idx]);
-                break;
-
-            default:
-                hlsl_fixme(tpf->ctx, &instr->loc, "Instruction type %s.", hlsl_node_type_to_string(instr->type));
-        }
-    }
-}
+    unsigned int i;
 
-static void tpf_write_shader_function(struct tpf_compiler *tpf, struct hlsl_ir_function_decl *func)
-{
     if (tpf->program->shader_version.type == VKD3D_SHADER_TYPE_COMPUTE)
         tpf_dcl_thread_group(tpf, &tpf->program->thread_group_size);
 
-    write_sm4_block(tpf, &func->body);
-
-    write_sm4_ret(tpf);
+    for (i = 0; i < program->instructions.count; ++i)
+        tpf_handle_instruction(tpf, &program->instructions.elements[i]);
 }
 
-static void tpf_write_shdr(struct tpf_compiler *tpf, struct hlsl_ir_function_decl *entry_func)
+static void tpf_write_shdr(struct tpf_compiler *tpf)
 {
-    const struct vkd3d_shader_version *version = &tpf->program->shader_version;
+    const struct vsir_program *program = tpf->program;
+    const struct vkd3d_shader_version *version;
     struct vkd3d_bytecode_buffer buffer = {0};
-    struct extern_resource *extern_resources;
-    unsigned int extern_resources_count, i;
-    const struct hlsl_buffer *cbuffer;
-    struct hlsl_ctx *ctx = tpf->ctx;
     size_t token_count_position;
-    uint32_t global_flags = 0;
 
     static const uint16_t shader_types[VKD3D_SHADER_TYPE_COUNT] =
     {
@@ -5884,101 +4160,45 @@ static void tpf_write_shdr(struct tpf_compiler *tpf, struct hlsl_ir_function_dec
 
     tpf->buffer = &buffer;
 
-    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
-
+    version = &program->shader_version;
     put_u32(&buffer, vkd3d_make_u32((version->major << 4) | version->minor, shader_types[version->type]));
     token_count_position = put_u32(&buffer, 0);
 
-    if (version->major == 4)
-    {
-        for (i = 0; i < extern_resources_count; ++i)
-        {
-            const struct extern_resource *resource = &extern_resources[i];
-            const struct hlsl_type *type = resource->component_type;
-
-            if (type && type->class == HLSL_CLASS_TEXTURE && type->sampler_dim == HLSL_SAMPLER_DIM_RAW_BUFFER)
-            {
-                global_flags |= VKD3DSGF_ENABLE_RAW_AND_STRUCTURED_BUFFERS;
-                break;
-            }
-        }
-    }
-
-    if (entry_func->early_depth_test && vkd3d_shader_ver_ge(version, 5, 0))
-        global_flags |= VKD3DSGF_FORCE_EARLY_DEPTH_STENCIL;
-
-    if (global_flags)
-        write_sm4_dcl_global_flags(tpf, global_flags);
+    if (program->global_flags)
+        write_sm4_dcl_global_flags(tpf, program->global_flags);
 
     if (version->type == VKD3D_SHADER_TYPE_HULL)
     {
         tpf_write_hs_decls(tpf);
 
-        tpf_write_dcl_input_control_point_count(tpf, 1); /* TODO: Obtain from InputPatch */
-        tpf_write_dcl_output_control_point_count(tpf, ctx->output_control_point_count);
-        tpf_write_dcl_tessellator_domain(tpf, ctx->domain);
-        tpf_write_dcl_tessellator_partitioning(tpf, ctx->partitioning);
-        tpf_write_dcl_tessellator_output_primitive(tpf, ctx->output_primitive);
+        tpf_write_dcl_input_control_point_count(tpf, program->input_control_point_count);
+        tpf_write_dcl_output_control_point_count(tpf, program->output_control_point_count);
+        tpf_write_dcl_tessellator_domain(tpf, program->tess_domain);
+        tpf_write_dcl_tessellator_partitioning(tpf, program->tess_partitioning);
+        tpf_write_dcl_tessellator_output_primitive(tpf, program->tess_output_primitive);
     }
     else if (version->type == VKD3D_SHADER_TYPE_DOMAIN)
     {
-        tpf_write_dcl_input_control_point_count(tpf, 0); /* TODO: Obtain from OutputPatch */
-        tpf_write_dcl_tessellator_domain(tpf, ctx->domain);
-    }
-
-    LIST_FOR_EACH_ENTRY(cbuffer, &ctx->buffers, struct hlsl_buffer, entry)
-    {
-        if (cbuffer->reg.allocated)
-            write_sm4_dcl_constant_buffer(tpf, cbuffer);
-    }
-
-    for (i = 0; i < extern_resources_count; ++i)
-    {
-        const struct extern_resource *resource = &extern_resources[i];
-
-        if (resource->regset == HLSL_REGSET_SAMPLERS)
-            write_sm4_dcl_samplers(tpf, resource);
-        else if (resource->regset == HLSL_REGSET_TEXTURES)
-            write_sm4_dcl_textures(tpf, resource, false);
-        else if (resource->regset == HLSL_REGSET_UAVS)
-            write_sm4_dcl_textures(tpf, resource, true);
+        tpf_write_dcl_input_control_point_count(tpf, program->input_control_point_count);
+        tpf_write_dcl_tessellator_domain(tpf, program->tess_domain);
     }
 
-    if (version->type == VKD3D_SHADER_TYPE_HULL)
-        tpf_write_hs_control_point_phase(tpf);
-
-    tpf_write_shader_function(tpf, entry_func);
-
-    if (version->type == VKD3D_SHADER_TYPE_HULL)
-    {
-        tpf_write_hs_fork_phase(tpf);
-        tpf_write_shader_function(tpf, ctx->patch_constant_func);
-    }
+    tpf_write_program(tpf, program);
 
     set_u32(&buffer, token_count_position, bytecode_get_size(&buffer) / sizeof(uint32_t));
 
-    add_section(ctx, &tpf->dxbc, TAG_SHDR, &buffer);
+    add_section(tpf, TAG_SHDR, &buffer);
     tpf->buffer = NULL;
-
-    sm4_free_extern_resources(extern_resources, extern_resources_count);
 }
 
 static void tpf_write_sfi0(struct tpf_compiler *tpf)
 {
-    struct extern_resource *extern_resources;
-    unsigned int extern_resources_count;
-    struct hlsl_ctx *ctx = tpf->ctx;
     uint64_t *flags;
 
     flags = vkd3d_calloc(1, sizeof(*flags));
 
-    extern_resources = sm4_get_extern_resources(ctx, &extern_resources_count);
-    for (unsigned int i = 0; i < extern_resources_count; ++i)
-    {
-        if (extern_resources[i].component_type && extern_resources[i].component_type->e.resource.rasteriser_ordered)
-            *flags |= VKD3D_SM4_REQUIRES_ROVS;
-    }
-    sm4_free_extern_resources(extern_resources, extern_resources_count);
+    if (tpf->program->features.rovs)
+        *flags |= DXBC_SFI0_REQUIRES_ROVS;
 
     /* FIXME: We also emit code that should require UAVS_AT_EVERY_STAGE,
      * STENCIL_REF, and TYPED_UAV_LOAD_ADDITIONAL_FORMATS. */
@@ -5993,7 +4213,6 @@ static void tpf_write_stat(struct tpf_compiler *tpf)
 {
     struct vkd3d_bytecode_buffer buffer = {0};
     const struct sm4_stat *stat = tpf->stat;
-    struct hlsl_ctx *ctx = tpf->ctx;
 
     put_u32(&buffer, stat->fields[VKD3D_STAT_INSTR_COUNT]);
     put_u32(&buffer, stat->fields[VKD3D_STAT_TEMPS]);
@@ -6025,7 +4244,7 @@ static void tpf_write_stat(struct tpf_compiler *tpf)
     put_u32(&buffer, stat->fields[VKD3D_STAT_LOD]);
     put_u32(&buffer, 0); /* Sample frequency */
 
-    if (hlsl_version_ge(ctx, 5, 0))
+    if (vkd3d_shader_ver_ge(&tpf->program->shader_version, 5, 0))
     {
         put_u32(&buffer, stat->fields[VKD3D_STAT_DCL_GS_INSTANCES]);
         put_u32(&buffer, stat->fields[VKD3D_STAT_TESS_CONTROL_POINT_COUNT]);
@@ -6037,15 +4256,19 @@ static void tpf_write_stat(struct tpf_compiler *tpf)
         put_u32(&buffer, stat->fields[VKD3D_STAT_STORE]);
     }
 
-    add_section(ctx, &tpf->dxbc, TAG_STAT, &buffer);
+    add_section(tpf, TAG_STAT, &buffer);
+}
+
+static void tpf_write_section(struct tpf_compiler *tpf, uint32_t tag, const struct vkd3d_shader_code *code)
+{
+    struct vkd3d_bytecode_buffer buffer = {0};
+
+    bytecode_put_bytes(&buffer, code->code, code->size);
+    add_section(tpf, tag, &buffer);
 }
 
-/* OBJECTIVE: Stop relying on ctx and entry_func on this function, receiving
- * data from the other parameters instead, so they can be removed from the
- * arguments and this function can be independent of HLSL structs.  */
-int tpf_compile(struct vsir_program *program, uint64_t config_flags,
-        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context,
-        struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func)
+int tpf_compile(struct vsir_program *program, uint64_t config_flags, const struct vkd3d_shader_code *rdef,
+        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context)
 {
     enum vkd3d_shader_type shader_type = program->shader_version.type;
     struct tpf_compiler tpf = {0};
@@ -6053,7 +4276,6 @@ int tpf_compile(struct vsir_program *program, uint64_t config_flags,
     size_t i;
     int ret;
 
-    tpf.ctx = ctx;
     tpf.program = program;
     tpf.buffer = NULL;
     tpf.stat = &stat;
@@ -6064,14 +4286,12 @@ int tpf_compile(struct vsir_program *program, uint64_t config_flags,
     tpf_write_signature(&tpf, &program->output_signature, TAG_OSGN);
     if (shader_type == VKD3D_SHADER_TYPE_HULL || shader_type == VKD3D_SHADER_TYPE_DOMAIN)
         tpf_write_signature(&tpf, &program->patch_constant_signature, TAG_PCSG);
-    write_sm4_rdef(ctx, &tpf.dxbc);
-    tpf_write_shdr(&tpf, entry_func);
+    tpf_write_section(&tpf, TAG_RDEF, rdef);
+    tpf_write_shdr(&tpf);
     tpf_write_sfi0(&tpf);
     tpf_write_stat(&tpf);
 
     ret = VKD3D_OK;
-    if (ctx->result)
-        ret = ctx->result;
     if (tpf.result)
         ret = tpf.result;
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index d751f2dc6bf..c7ad407f6fb 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -23,6 +23,8 @@
 #include <stdio.h>
 #include <math.h>
 
+/* VKD3D_DEBUG_ENV_NAME("VKD3D_SHADER_DEBUG"); */
+
 static inline int char_to_int(char c)
 {
     if ('0' <= c && c <= '9')
@@ -377,7 +379,8 @@ size_t bytecode_align(struct vkd3d_bytecode_buffer *buffer)
         return aligned_size;
     }
 
-    memset(buffer->data + buffer->size, 0xab, aligned_size - buffer->size);
+    if (aligned_size > buffer->size)
+        memset(&buffer->data[buffer->size], 0xab, aligned_size - buffer->size);
     buffer->size = aligned_size;
     return aligned_size;
 }
@@ -394,7 +397,8 @@ size_t bytecode_put_bytes_unaligned(struct vkd3d_bytecode_buffer *buffer, const
         buffer->status = VKD3D_ERROR_OUT_OF_MEMORY;
         return offset;
     }
-    memcpy(buffer->data + offset, bytes, size);
+    if (size)
+        memcpy(&buffer->data[offset], bytes, size);
     buffer->size = offset + size;
     return offset;
 }
@@ -805,6 +809,9 @@ struct vkd3d_shader_scan_context
 
     struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info;
     size_t combined_samplers_size;
+
+    enum vkd3d_shader_tessellator_output_primitive output_primitive;
+    enum vkd3d_shader_tessellator_partitioning partitioning;
 };
 
 static VKD3D_PRINTF_FUNC(3, 4) void vkd3d_shader_scan_error(struct vkd3d_shader_scan_context *context,
@@ -1262,6 +1269,12 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
                     VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_SHADER_RESOURCE_DATA_UINT, 0,
                     instruction->declaration.structured_resource.byte_stride, false, instruction->flags);
             break;
+        case VKD3DSIH_DCL_TESSELLATOR_OUTPUT_PRIMITIVE:
+            context->output_primitive = instruction->declaration.tessellator_output_primitive;
+            break;
+        case VKD3DSIH_DCL_TESSELLATOR_PARTITIONING:
+            context->partitioning = instruction->declaration.tessellator_partitioning;
+            break;
         case VKD3DSIH_IF:
         case VKD3DSIH_IFC:
             cf_info = vkd3d_shader_scan_push_cf_info(context);
@@ -1502,6 +1515,7 @@ static int vsir_program_scan(struct vsir_program *program, const struct vkd3d_sh
         struct vkd3d_shader_scan_descriptor_info1 *descriptor_info1)
 {
     struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info;
+    struct vkd3d_shader_scan_hull_shader_tessellation_info *tessellation_info;
     struct vkd3d_shader_scan_descriptor_info1 local_descriptor_info1 = {0};
     struct vkd3d_shader_scan_descriptor_info *descriptor_info;
     struct vkd3d_shader_scan_signature_info *signature_info;
@@ -1530,6 +1544,8 @@ static int vsir_program_scan(struct vsir_program *program, const struct vkd3d_sh
             descriptor_info1 = &local_descriptor_info1;
     }
 
+    tessellation_info = vkd3d_find_struct(compile_info->next, SCAN_HULL_SHADER_TESSELLATION_INFO);
+
     vkd3d_shader_scan_context_init(&context, &program->shader_version, compile_info,
             descriptor_info1, combined_sampler_info, message_context);
 
@@ -1573,6 +1589,12 @@ static int vsir_program_scan(struct vsir_program *program, const struct vkd3d_sh
     if (!ret && descriptor_info)
         ret = convert_descriptor_info(descriptor_info, descriptor_info1);
 
+    if (!ret && tessellation_info)
+    {
+        tessellation_info->output_primitive = context.output_primitive;
+        tessellation_info->partitioning = context.partitioning;
+    }
+
     if (ret < 0)
     {
         if (combined_sampler_info)
@@ -1959,7 +1981,7 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
     static const enum vkd3d_shader_target_type dxbc_tpf_types[] =
     {
         VKD3D_SHADER_TARGET_SPIRV_BINARY,
-#ifdef HAVE_SPIRV_TOOLS
+#if defined(HAVE_SPIRV_TOOLS) || defined(VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER)
         VKD3D_SHADER_TARGET_SPIRV_TEXT,
 #endif
         VKD3D_SHADER_TARGET_D3D_ASM,
@@ -1974,7 +1996,7 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
     static const enum vkd3d_shader_target_type hlsl_types[] =
     {
         VKD3D_SHADER_TARGET_SPIRV_BINARY,
-#ifdef HAVE_SPIRV_TOOLS
+#if defined(HAVE_SPIRV_TOOLS) || defined(VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER)
         VKD3D_SHADER_TARGET_SPIRV_TEXT,
 #endif
         VKD3D_SHADER_TARGET_D3D_ASM,
@@ -1986,7 +2008,7 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
     static const enum vkd3d_shader_target_type d3dbc_types[] =
     {
         VKD3D_SHADER_TARGET_SPIRV_BINARY,
-#ifdef HAVE_SPIRV_TOOLS
+#if defined(HAVE_SPIRV_TOOLS) || defined(VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER)
         VKD3D_SHADER_TARGET_SPIRV_TEXT,
 #endif
         VKD3D_SHADER_TARGET_D3D_ASM,
@@ -1996,7 +2018,7 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
     static const enum vkd3d_shader_target_type dxbc_dxil_types[] =
     {
         VKD3D_SHADER_TARGET_SPIRV_BINARY,
-# ifdef HAVE_SPIRV_TOOLS
+#if defined(HAVE_SPIRV_TOOLS) || defined(VKD3D_SHADER_UNSUPPORTED_SPIRV_PARSER)
         VKD3D_SHADER_TARGET_SPIRV_TEXT,
 # endif
         VKD3D_SHADER_TARGET_D3D_ASM,
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index be7c0b73a22..7e8ec156aad 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -62,6 +62,8 @@
 #define VKD3D_SHADER_COMPONENT_TYPE_COUNT (VKD3D_SHADER_COMPONENT_UINT64 + 1)
 #define VKD3D_SHADER_MINIMUM_PRECISION_COUNT (VKD3D_SHADER_MINIMUM_PRECISION_UINT_16 + 1)
 
+#define VKD3D_MAX_STREAM_COUNT 4
+
 enum vkd3d_shader_error
 {
     VKD3D_SHADER_ERROR_DXBC_INVALID_SIZE                = 1,
@@ -163,6 +165,7 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_HLSL_INVALID_OUTPUT_PRIMITIVE    = 5037,
     VKD3D_SHADER_ERROR_HLSL_INVALID_PARTITIONING        = 5038,
     VKD3D_SHADER_ERROR_HLSL_MISPLACED_SAMPLER_STATE     = 5039,
+    VKD3D_SHADER_ERROR_HLSL_AMBIGUOUS_CALL              = 5040,
 
     VKD3D_SHADER_WARNING_HLSL_IMPLICIT_TRUNCATION       = 5300,
     VKD3D_SHADER_WARNING_HLSL_DIVISION_BY_ZERO          = 5301,
@@ -247,6 +250,7 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_VSIR_INVALID_PARAMETER           = 9020,
     VKD3D_SHADER_ERROR_VSIR_MISSING_SEMANTIC            = 9021,
     VKD3D_SHADER_ERROR_VSIR_INVALID_SIGNATURE           = 9022,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_RANGE               = 9023,
 
     VKD3D_SHADER_WARNING_VSIR_DYNAMIC_DESCRIPTOR_ARRAY  = 9300,
 
@@ -591,28 +595,25 @@ enum vkd3d_shader_opcode
 
 enum vkd3d_shader_register_type
 {
-    VKD3DSPR_TEMP = 0,
-    VKD3DSPR_INPUT = 1,
-    VKD3DSPR_CONST = 2,
-    VKD3DSPR_ADDR = 3,
-    VKD3DSPR_TEXTURE = 3,
-    VKD3DSPR_RASTOUT = 4,
-    VKD3DSPR_ATTROUT = 5,
-    VKD3DSPR_TEXCRDOUT = 6,
-    VKD3DSPR_OUTPUT = 6,
-    VKD3DSPR_CONSTINT = 7,
-    VKD3DSPR_COLOROUT = 8,
-    VKD3DSPR_DEPTHOUT = 9,
-    VKD3DSPR_COMBINED_SAMPLER = 10,
-    VKD3DSPR_CONST2 = 11,
-    VKD3DSPR_CONST3 = 12,
-    VKD3DSPR_CONST4 = 13,
-    VKD3DSPR_CONSTBOOL = 14,
-    VKD3DSPR_LOOP = 15,
-    VKD3DSPR_TEMPFLOAT16 = 16,
-    VKD3DSPR_MISCTYPE = 17,
-    VKD3DSPR_LABEL = 18,
-    VKD3DSPR_PREDICATE = 19,
+    VKD3DSPR_TEMP,
+    VKD3DSPR_INPUT,
+    VKD3DSPR_CONST,
+    VKD3DSPR_ADDR,
+    VKD3DSPR_TEXTURE,
+    VKD3DSPR_RASTOUT,
+    VKD3DSPR_ATTROUT,
+    VKD3DSPR_TEXCRDOUT,
+    VKD3DSPR_OUTPUT,
+    VKD3DSPR_CONSTINT,
+    VKD3DSPR_COLOROUT,
+    VKD3DSPR_DEPTHOUT,
+    VKD3DSPR_COMBINED_SAMPLER,
+    VKD3DSPR_CONSTBOOL,
+    VKD3DSPR_LOOP,
+    VKD3DSPR_TEMPFLOAT16,
+    VKD3DSPR_MISCTYPE,
+    VKD3DSPR_LABEL,
+    VKD3DSPR_PREDICATE,
     VKD3DSPR_IMMCONST,
     VKD3DSPR_IMMCONST64,
     VKD3DSPR_CONSTBUFFER,
@@ -1123,6 +1124,12 @@ bool vsir_signature_find_sysval(const struct shader_signature *signature,
         enum vkd3d_shader_sysval_semantic sysval, unsigned int semantic_index, unsigned int *element_index);
 void shader_signature_cleanup(struct shader_signature *signature);
 
+struct vsir_features
+{
+    /* The shader requires rasteriser-ordered views. */
+    bool rovs;
+};
+
 struct dxbc_shader_desc
 {
     const uint32_t *byte_code;
@@ -1131,6 +1138,7 @@ struct dxbc_shader_desc
     struct shader_signature input_signature;
     struct shader_signature output_signature;
     struct shader_signature patch_constant_signature;
+    struct vsir_features features;
 };
 
 struct vkd3d_shader_register_semantic
@@ -1400,9 +1408,10 @@ enum vsir_control_flow_type
 
 enum vsir_normalisation_level
 {
-    VSIR_NOT_NORMALISED,
+    VSIR_NORMALISED_SM1,
+    VSIR_NORMALISED_SM4,
     VSIR_NORMALISED_HULL_CONTROL_POINT_IO,
-    VSIR_FULLY_NORMALISED_IO,
+    VSIR_NORMALISED_SM6,
 };
 
 struct vsir_program
@@ -1428,9 +1437,16 @@ struct vsir_program
     bool use_vocp;
     bool has_point_size;
     bool has_point_coord;
+    bool has_fog;
     uint8_t diffuse_written_mask;
     enum vsir_control_flow_type cf_type;
     enum vsir_normalisation_level normalisation_level;
+    enum vkd3d_tessellator_domain tess_domain;
+    enum vkd3d_shader_tessellator_partitioning tess_partitioning;
+    enum vkd3d_shader_tessellator_output_primitive tess_output_primitive;
+    uint32_t io_dcls[VKD3D_BITMAP_SIZE(VKD3DSPR_COUNT)];
+
+    struct vsir_features features;
 
     const char **block_names;
     size_t block_name_count;
@@ -1643,6 +1659,10 @@ int shader_extract_from_dxbc(const struct vkd3d_shader_code *dxbc,
 int shader_parse_input_signature(const struct vkd3d_shader_code *dxbc,
         struct vkd3d_shader_message_context *message_context, struct shader_signature *signature);
 
+int d3dbc_compile(struct vsir_program *program, uint64_t config_flags,
+        const struct vkd3d_shader_compile_info *compile_info, const struct vkd3d_shader_code *ctab,
+        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
+
 int glsl_compile(struct vsir_program *program, uint64_t config_flags,
         const struct vkd3d_shader_scan_descriptor_info1 *descriptor_info,
         const struct vkd3d_shader_scan_combined_resource_sampler_info *combined_sampler_info,
@@ -1661,6 +1681,9 @@ int msl_compile(struct vsir_program *program, uint64_t config_flags,
         const struct vkd3d_shader_compile_info *compile_info, struct vkd3d_shader_code *out,
         struct vkd3d_shader_message_context *message_context);
 
+int tpf_compile(struct vsir_program *program, uint64_t config_flags, const struct vkd3d_shader_code *rdef,
+        struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
+
 enum vkd3d_md5_variant
 {
     VKD3D_MD5_STANDARD,
@@ -1942,6 +1965,21 @@ static inline void *vkd3d_find_struct_(const struct vkd3d_struct *chain,
 
 #define DXBC_MAX_SECTION_COUNT 7
 
+#define DXBC_SFI0_REQUIRES_DOUBLES                              0x00000001u
+#define DXBC_SFI0_REQUIRES_EARLY_DEPTH_STENCIL                  0x00000002u
+#define DXBC_SFI0_REQUIRES_UAVS_AT_EVERY_STAGE                  0x00000004u
+#define DXBC_SFI0_REQUIRES_64_UAVS                              0x00000008u
+#define DXBC_SFI0_REQUIRES_MINIMUM_PRECISION                    0x00000010u
+#define DXBC_SFI0_REQUIRES_11_1_DOUBLE_EXTENSIONS               0x00000020u
+#define DXBC_SFI0_REQUIRES_11_1_SHADER_EXTENSIONS               0x00000040u
+#define DXBC_SFI0_REQUIRES_LEVEL_9_COMPARISON_FILTERING         0x00000080u
+#define DXBC_SFI0_REQUIRES_TILED_RESOURCES                      0x00000100u
+#define DXBC_SFI0_REQUIRES_STENCIL_REF                          0x00000200u
+#define DXBC_SFI0_REQUIRES_INNER_COVERAGE                       0x00000400u
+#define DXBC_SFI0_REQUIRES_TYPED_UAV_LOAD_ADDITIONAL_FORMATS    0x00000800u
+#define DXBC_SFI0_REQUIRES_ROVS                                 0x00001000u
+#define DXBC_SFI0_REQUIRES_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER 0x00002000u
+
 struct dxbc_writer
 {
     unsigned int section_count;
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index a55a97f6f2f..6c7bf167910 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -1255,6 +1255,74 @@ VkResult vkd3d_create_timeline_semaphore(const struct d3d12_device *device, uint
     return VK_CALL(vkCreateSemaphore(device->vk_device, &info, NULL, timeline_semaphore));
 }
 
+static void vkd3d_vk_descriptor_pool_array_cleanup(struct vkd3d_vk_descriptor_pool_array *array)
+{
+    vkd3d_free(array->pools);
+}
+
+static void vkd3d_vk_descriptor_pool_array_init(struct vkd3d_vk_descriptor_pool_array *array)
+{
+    memset(array, 0, sizeof(*array));
+}
+
+static bool vkd3d_vk_descriptor_pool_array_push_array(struct vkd3d_vk_descriptor_pool_array *array,
+        const struct vkd3d_vk_descriptor_pool *pools, size_t count)
+{
+    if (!vkd3d_array_reserve((void **)&array->pools, &array->capacity, array->count + count, sizeof(*array->pools)))
+        return false;
+
+    memcpy(&array->pools[array->count], pools, count * sizeof(*pools));
+    array->count += count;
+
+    return true;
+}
+
+static bool vkd3d_vk_descriptor_pool_array_push(struct vkd3d_vk_descriptor_pool_array *array,
+        unsigned int descriptor_count, VkDescriptorPool vk_pool)
+{
+    struct vkd3d_vk_descriptor_pool pool =
+    {
+        .descriptor_count = descriptor_count,
+        .vk_pool = vk_pool,
+    };
+
+    return vkd3d_vk_descriptor_pool_array_push_array(array, &pool, 1);
+}
+
+static VkDescriptorPool vkd3d_vk_descriptor_pool_array_find(struct vkd3d_vk_descriptor_pool_array *array,
+        unsigned int *descriptor_count)
+{
+    VkDescriptorPool vk_pool;
+    size_t i;
+
+    for (i = 0; i < array->count; ++i)
+    {
+        if (array->pools[i].descriptor_count >= *descriptor_count)
+        {
+            *descriptor_count = array->pools[i].descriptor_count;
+            vk_pool = array->pools[i].vk_pool;
+            array->pools[i] = array->pools[--array->count];
+
+            return vk_pool;
+        }
+    }
+
+    return VK_NULL_HANDLE;
+}
+
+static void vkd3d_vk_descriptor_pool_array_destroy_pools(struct vkd3d_vk_descriptor_pool_array *array,
+        const struct d3d12_device *device)
+{
+    const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
+    size_t i;
+
+    for (i = 0; i < array->count; ++i)
+    {
+        VK_CALL(vkDestroyDescriptorPool(device->vk_device, array->pools[i].vk_pool, NULL));
+    }
+    array->count = 0;
+}
+
 /* Command buffers */
 static void d3d12_command_list_mark_as_invalid(struct d3d12_command_list *list,
         const char *message, ...)
@@ -1376,18 +1444,6 @@ static bool d3d12_command_allocator_add_framebuffer(struct d3d12_command_allocat
     return true;
 }
 
-static bool d3d12_command_allocator_add_descriptor_pool(struct d3d12_command_allocator *allocator,
-        VkDescriptorPool pool)
-{
-    if (!vkd3d_array_reserve((void **)&allocator->descriptor_pools, &allocator->descriptor_pools_size,
-            allocator->descriptor_pool_count + 1, sizeof(*allocator->descriptor_pools)))
-        return false;
-
-    allocator->descriptor_pools[allocator->descriptor_pool_count++] = pool;
-
-    return true;
-}
-
 static bool d3d12_command_allocator_add_view(struct d3d12_command_allocator *allocator,
         struct vkd3d_view *view)
 {
@@ -1426,37 +1482,71 @@ static bool d3d12_command_allocator_add_transfer_buffer(struct d3d12_command_all
 }
 
 static VkDescriptorPool d3d12_command_allocator_allocate_descriptor_pool(
-        struct d3d12_command_allocator *allocator)
+        struct d3d12_command_allocator *allocator, enum vkd3d_shader_descriptor_type descriptor_type,
+        unsigned int descriptor_count, bool unbounded)
 {
     struct d3d12_device *device = allocator->device;
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     struct VkDescriptorPoolCreateInfo pool_desc;
     VkDevice vk_device = device->vk_device;
+    VkDescriptorPoolSize vk_pool_sizes[2];
+    unsigned int pool_size, pool_limit;
     VkDescriptorPool vk_pool;
     VkResult vr;
 
-    if (allocator->free_descriptor_pool_count > 0)
-    {
-        vk_pool = allocator->free_descriptor_pools[allocator->free_descriptor_pool_count - 1];
-        allocator->free_descriptor_pools[allocator->free_descriptor_pool_count - 1] = VK_NULL_HANDLE;
-        --allocator->free_descriptor_pool_count;
-    }
-    else
+    if (!(vk_pool = vkd3d_vk_descriptor_pool_array_find(&allocator->free_descriptor_pools[descriptor_type],
+            &descriptor_count)))
     {
+        pool_limit = device->vk_pool_limits[descriptor_type];
+
+        if (descriptor_count > pool_limit)
+        {
+            if (!unbounded)
+            {
+                ERR("Descriptor count %u exceeds maximum pool size %u.\n", descriptor_count, pool_limit);
+                return VK_NULL_HANDLE;
+            }
+
+            WARN("Clamping descriptor count %u to maximum pool size %u for unbounded allocation.\n",
+                    descriptor_count, pool_limit);
+            descriptor_count = pool_limit;
+        }
+
+        pool_size = allocator->vk_pool_sizes[descriptor_type];
+        if (descriptor_count > pool_size)
+        {
+            pool_size = 1u << (vkd3d_log2i(descriptor_count - 1) + 1);
+            pool_size = min(pool_limit, pool_size);
+        }
+        descriptor_count = pool_size;
+
+        vk_pool_sizes[0].type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, true);
+        vk_pool_sizes[0].descriptorCount = descriptor_count;
+
+        vk_pool_sizes[1].type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, false);
+        vk_pool_sizes[1].descriptorCount = descriptor_count;
+
         pool_desc.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
         pool_desc.pNext = NULL;
         pool_desc.flags = 0;
         pool_desc.maxSets = 512;
-        pool_desc.poolSizeCount = device->vk_pool_count;
-        pool_desc.pPoolSizes = device->vk_pool_sizes;
+        pool_desc.poolSizeCount = 1;
+        if (vk_pool_sizes[1].type != vk_pool_sizes[0].type)
+            ++pool_desc.poolSizeCount;
+        pool_desc.pPoolSizes = vk_pool_sizes;
+
         if ((vr = VK_CALL(vkCreateDescriptorPool(vk_device, &pool_desc, NULL, &vk_pool))) < 0)
         {
             ERR("Failed to create descriptor pool, vr %d.\n", vr);
             return VK_NULL_HANDLE;
         }
+
+        if (!unbounded || descriptor_count < pool_limit)
+            allocator->vk_pool_sizes[descriptor_type] = min(pool_limit, descriptor_count * 2);
     }
 
-    if (!(d3d12_command_allocator_add_descriptor_pool(allocator, vk_pool)))
+    if (!(vkd3d_vk_descriptor_pool_array_push(&allocator->descriptor_pools[descriptor_type],
+            descriptor_count, vk_pool)))
     {
         ERR("Failed to add descriptor pool.\n");
         VK_CALL(vkDestroyDescriptorPool(vk_device, vk_pool, NULL));
@@ -1466,9 +1556,9 @@ static VkDescriptorPool d3d12_command_allocator_allocate_descriptor_pool(
     return vk_pool;
 }
 
-static VkDescriptorSet d3d12_command_allocator_allocate_descriptor_set(
-        struct d3d12_command_allocator *allocator, VkDescriptorSetLayout vk_set_layout,
-        unsigned int variable_binding_size, bool unbounded)
+static VkDescriptorSet d3d12_command_allocator_allocate_descriptor_set(struct d3d12_command_allocator *allocator,
+        enum vkd3d_shader_descriptor_type descriptor_type, unsigned int descriptor_count,
+        VkDescriptorSetLayout vk_set_layout, unsigned int variable_binding_size, bool unbounded)
 {
     struct d3d12_device *device = allocator->device;
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
@@ -1478,14 +1568,15 @@ static VkDescriptorSet d3d12_command_allocator_allocate_descriptor_set(
     VkDescriptorSet vk_descriptor_set;
     VkResult vr;
 
-    if (!allocator->vk_descriptor_pool)
-        allocator->vk_descriptor_pool = d3d12_command_allocator_allocate_descriptor_pool(allocator);
-    if (!allocator->vk_descriptor_pool)
+    if (!allocator->vk_descriptor_pools[descriptor_type])
+        allocator->vk_descriptor_pools[descriptor_type] = d3d12_command_allocator_allocate_descriptor_pool(allocator,
+                descriptor_type, descriptor_count, unbounded);
+    if (!allocator->vk_descriptor_pools[descriptor_type])
         return VK_NULL_HANDLE;
 
     set_desc.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
     set_desc.pNext = NULL;
-    set_desc.descriptorPool = allocator->vk_descriptor_pool;
+    set_desc.descriptorPool = allocator->vk_descriptor_pools[descriptor_type];
     set_desc.descriptorSetCount = 1;
     set_desc.pSetLayouts = &vk_set_layout;
     if (unbounded)
@@ -1499,16 +1590,17 @@ static VkDescriptorSet d3d12_command_allocator_allocate_descriptor_set(
     if ((vr = VK_CALL(vkAllocateDescriptorSets(vk_device, &set_desc, &vk_descriptor_set))) >= 0)
         return vk_descriptor_set;
 
-    allocator->vk_descriptor_pool = VK_NULL_HANDLE;
+    allocator->vk_descriptor_pools[descriptor_type] = VK_NULL_HANDLE;
     if (vr == VK_ERROR_FRAGMENTED_POOL || vr == VK_ERROR_OUT_OF_POOL_MEMORY_KHR)
-        allocator->vk_descriptor_pool = d3d12_command_allocator_allocate_descriptor_pool(allocator);
-    if (!allocator->vk_descriptor_pool)
+        allocator->vk_descriptor_pools[descriptor_type] = d3d12_command_allocator_allocate_descriptor_pool(allocator,
+                descriptor_type, descriptor_count, unbounded);
+    if (!allocator->vk_descriptor_pools[descriptor_type])
     {
         ERR("Failed to allocate descriptor set, vr %d.\n", vr);
         return VK_NULL_HANDLE;
     }
 
-    set_desc.descriptorPool = allocator->vk_descriptor_pool;
+    set_desc.descriptorPool = allocator->vk_descriptor_pools[descriptor_type];
     if ((vr = VK_CALL(vkAllocateDescriptorSets(vk_device, &set_desc, &vk_descriptor_set))) < 0)
     {
         FIXME("Failed to allocate descriptor set from a new pool, vr %d.\n", vr);
@@ -1534,38 +1626,50 @@ static void vkd3d_buffer_destroy(struct vkd3d_buffer *buffer, struct d3d12_devic
     VK_CALL(vkDestroyBuffer(device->vk_device, buffer->vk_buffer, NULL));
 }
 
+static void d3d12_command_allocator_reset_descriptor_pool_array(struct d3d12_command_allocator *allocator,
+        enum vkd3d_shader_descriptor_type type)
+{
+    struct vkd3d_vk_descriptor_pool_array *array = &allocator->descriptor_pools[type];
+    struct d3d12_device *device = allocator->device;
+    const struct vkd3d_vk_device_procs *vk_procs;
+    const struct vkd3d_vk_descriptor_pool *pool;
+    size_t i;
+
+    vk_procs = &device->vk_procs;
+    for (i = 0; i < array->count; ++i)
+    {
+        pool = &array->pools[i];
+        if (pool->descriptor_count < allocator->vk_pool_sizes[type]
+                || !vkd3d_vk_descriptor_pool_array_push_array(&allocator->free_descriptor_pools[type], pool, 1))
+            VK_CALL(vkDestroyDescriptorPool(device->vk_device, pool->vk_pool, NULL));
+        else
+            VK_CALL(vkResetDescriptorPool(device->vk_device, pool->vk_pool, 0));
+    }
+    array->count = 0;
+}
+
 static void d3d12_command_allocator_free_resources(struct d3d12_command_allocator *allocator,
         bool keep_reusable_resources)
 {
     struct d3d12_device *device = allocator->device;
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
-    unsigned int i, j;
+    unsigned int i;
 
-    allocator->vk_descriptor_pool = VK_NULL_HANDLE;
+    memset(allocator->vk_descriptor_pools, 0, sizeof(allocator->vk_descriptor_pools));
 
     if (keep_reusable_resources)
     {
-        if (vkd3d_array_reserve((void **)&allocator->free_descriptor_pools,
-                &allocator->free_descriptor_pools_size,
-                allocator->free_descriptor_pool_count + allocator->descriptor_pool_count,
-                sizeof(*allocator->free_descriptor_pools)))
+        for (i = 0; i < ARRAY_SIZE(allocator->descriptor_pools); ++i)
         {
-            for (i = 0, j = allocator->free_descriptor_pool_count; i < allocator->descriptor_pool_count; ++i, ++j)
-            {
-                VK_CALL(vkResetDescriptorPool(device->vk_device, allocator->descriptor_pools[i], 0));
-                allocator->free_descriptor_pools[j] = allocator->descriptor_pools[i];
-            }
-            allocator->free_descriptor_pool_count += allocator->descriptor_pool_count;
-            allocator->descriptor_pool_count = 0;
+            d3d12_command_allocator_reset_descriptor_pool_array(allocator, i);
         }
     }
     else
     {
-        for (i = 0; i < allocator->free_descriptor_pool_count; ++i)
+        for (i = 0; i < ARRAY_SIZE(allocator->free_descriptor_pools); ++i)
         {
-            VK_CALL(vkDestroyDescriptorPool(device->vk_device, allocator->free_descriptor_pools[i], NULL));
+            vkd3d_vk_descriptor_pool_array_destroy_pools(&allocator->free_descriptor_pools[i], device);
         }
-        allocator->free_descriptor_pool_count = 0;
     }
 
     for (i = 0; i < allocator->transfer_buffer_count; ++i)
@@ -1586,11 +1690,10 @@ static void d3d12_command_allocator_free_resources(struct d3d12_command_allocato
     }
     allocator->view_count = 0;
 
-    for (i = 0; i < allocator->descriptor_pool_count; ++i)
+    for (i = 0; i < ARRAY_SIZE(allocator->descriptor_pools); ++i)
     {
-        VK_CALL(vkDestroyDescriptorPool(device->vk_device, allocator->descriptor_pools[i], NULL));
+        vkd3d_vk_descriptor_pool_array_destroy_pools(&allocator->descriptor_pools[i], device);
     }
-    allocator->descriptor_pool_count = 0;
 
     for (i = 0; i < allocator->framebuffer_count; ++i)
     {
@@ -1647,6 +1750,7 @@ static ULONG STDMETHODCALLTYPE d3d12_command_allocator_Release(ID3D12CommandAllo
 {
     struct d3d12_command_allocator *allocator = impl_from_ID3D12CommandAllocator(iface);
     unsigned int refcount = vkd3d_atomic_decrement_u32(&allocator->refcount);
+    size_t i;
 
     TRACE("%p decreasing refcount to %u.\n", allocator, refcount);
 
@@ -1664,8 +1768,11 @@ static ULONG STDMETHODCALLTYPE d3d12_command_allocator_Release(ID3D12CommandAllo
         vkd3d_free(allocator->transfer_buffers);
         vkd3d_free(allocator->buffer_views);
         vkd3d_free(allocator->views);
-        vkd3d_free(allocator->descriptor_pools);
-        vkd3d_free(allocator->free_descriptor_pools);
+        for (i = 0; i < ARRAY_SIZE(allocator->free_descriptor_pools); ++i)
+        {
+            vkd3d_vk_descriptor_pool_array_cleanup(&allocator->descriptor_pools[i]);
+            vkd3d_vk_descriptor_pool_array_cleanup(&allocator->free_descriptor_pools[i]);
+        }
         vkd3d_free(allocator->framebuffers);
         vkd3d_free(allocator->passes);
 
@@ -1822,6 +1929,7 @@ static HRESULT d3d12_command_allocator_init(struct d3d12_command_allocator *allo
     struct vkd3d_queue *queue;
     VkResult vr;
     HRESULT hr;
+    size_t i;
 
     if (FAILED(hr = vkd3d_private_store_init(&allocator->private_store)))
         return hr;
@@ -1851,11 +1959,12 @@ static HRESULT d3d12_command_allocator_init(struct d3d12_command_allocator *allo
         return hresult_from_vk_result(vr);
     }
 
-    allocator->vk_descriptor_pool = VK_NULL_HANDLE;
+    memset(allocator->vk_descriptor_pools, 0, sizeof(allocator->vk_descriptor_pools));
 
-    allocator->free_descriptor_pools = NULL;
-    allocator->free_descriptor_pools_size = 0;
-    allocator->free_descriptor_pool_count = 0;
+    for (i = 0; i < ARRAY_SIZE(allocator->free_descriptor_pools); ++i)
+    {
+        vkd3d_vk_descriptor_pool_array_init(&allocator->free_descriptor_pools[i]);
+    }
 
     allocator->passes = NULL;
     allocator->passes_size = 0;
@@ -1865,9 +1974,11 @@ static HRESULT d3d12_command_allocator_init(struct d3d12_command_allocator *allo
     allocator->framebuffers_size = 0;
     allocator->framebuffer_count = 0;
 
-    allocator->descriptor_pools = NULL;
-    allocator->descriptor_pools_size = 0;
-    allocator->descriptor_pool_count = 0;
+    for (i = 0; i < ARRAY_SIZE(allocator->descriptor_pools); ++i)
+    {
+        vkd3d_vk_descriptor_pool_array_init(&allocator->descriptor_pools[i]);
+        allocator->vk_pool_sizes[i] = min(VKD3D_INITIAL_DESCRIPTORS_POOL_SIZE, device->vk_pool_limits[i]);
+    }
 
     allocator->views = NULL;
     allocator->views_size = 0;
@@ -2749,7 +2860,8 @@ static void d3d12_command_list_prepare_descriptors(struct d3d12_command_list *li
         }
 
         vk_descriptor_set = d3d12_command_allocator_allocate_descriptor_set(list->allocator,
-                layout->vk_layout, variable_binding_size, unbounded_offset != UINT_MAX);
+                layout->descriptor_type, layout->descriptor_count + variable_binding_size, layout->vk_layout,
+                variable_binding_size, unbounded_offset != UINT_MAX);
         bindings->descriptor_sets[bindings->descriptor_set_count++] = vk_descriptor_set;
     }
 
@@ -2805,15 +2917,8 @@ static bool vk_write_descriptor_set_from_d3d12_desc(VkWriteDescriptorSet *vk_des
                 break;
             }
 
-            if (range->descriptor_count == UINT_MAX)
-            {
-                vk_descriptor_write->dstSet = vk_descriptor_sets[set + 1];
-                vk_descriptor_write->dstBinding = 0;
-            }
-            else
-            {
-                vk_descriptor_write->dstBinding += use_array ? 1 : range->descriptor_count;
-            }
+            vk_descriptor_write->dstSet = vk_descriptor_sets[range->image_set];
+            vk_descriptor_write->dstBinding = use_array ? range->image_binding : range->image_binding + index;
 
             vk_image_info->sampler = VK_NULL_HANDLE;
             vk_image_info->imageView = u.view->v.u.vk_image_view;
@@ -2934,10 +3039,11 @@ static void d3d12_command_list_update_descriptor_table(struct d3d12_command_list
 }
 
 static bool vk_write_descriptor_set_from_root_descriptor(VkWriteDescriptorSet *vk_descriptor_write,
-        const struct d3d12_root_parameter *root_parameter, VkDescriptorSet vk_descriptor_set,
+        const struct d3d12_root_parameter *root_parameter, const VkDescriptorSet *vk_descriptor_sets,
         VkBufferView *vk_buffer_view, const VkDescriptorBufferInfo *vk_buffer_info)
 {
     const struct d3d12_root_descriptor *root_descriptor;
+    VkDescriptorSet vk_descriptor_set;
 
     switch (root_parameter->parameter_type)
     {
@@ -2956,6 +3062,7 @@ static bool vk_write_descriptor_set_from_root_descriptor(VkWriteDescriptorSet *v
     }
 
     root_descriptor = &root_parameter->u.descriptor;
+    vk_descriptor_set = vk_descriptor_sets ? vk_descriptor_sets[root_descriptor->set] : VK_NULL_HANDLE;
 
     vk_descriptor_write->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
     vk_descriptor_write->pNext = NULL;
@@ -3011,7 +3118,7 @@ static void d3d12_command_list_update_push_descriptors(struct d3d12_command_list
         }
 
         if (!vk_write_descriptor_set_from_root_descriptor(&descriptor_writes[descriptor_count],
-                root_parameter, bindings->descriptor_sets[0], vk_buffer_view, vk_buffer_info))
+                root_parameter, bindings->descriptor_sets, vk_buffer_view, vk_buffer_info))
             continue;
 
         ++descriptor_count;
@@ -3039,8 +3146,8 @@ static void d3d12_command_list_update_uav_counter_descriptors(struct d3d12_comma
     uav_counter_count = state->uav_counters.binding_count;
     if (!(vk_descriptor_writes = vkd3d_calloc(uav_counter_count, sizeof(*vk_descriptor_writes))))
         return;
-    if (!(vk_descriptor_set = d3d12_command_allocator_allocate_descriptor_set(
-            list->allocator, state->uav_counters.vk_set_layout, 0, false)))
+    if (!(vk_descriptor_set = d3d12_command_allocator_allocate_descriptor_set(list->allocator,
+            VKD3D_SHADER_DESCRIPTOR_TYPE_UAV, uav_counter_count, state->uav_counters.vk_set_layout, 0, false)))
         goto done;
 
     for (i = 0; i < uav_counter_count; ++i)
@@ -4612,8 +4719,7 @@ static void d3d12_command_list_set_root_cbv(struct d3d12_command_list *list,
 
     if (vk_info->KHR_push_descriptor)
     {
-        vk_write_descriptor_set_from_root_descriptor(&descriptor_write,
-                root_parameter, VK_NULL_HANDLE, NULL, &buffer_info);
+        vk_write_descriptor_set_from_root_descriptor(&descriptor_write, root_parameter, NULL, NULL, &buffer_info);
         VK_CALL(vkCmdPushDescriptorSetKHR(list->vk_command_buffer, bindings->vk_bind_point,
                 root_signature->vk_pipeline_layout, 0, 1, &descriptor_write));
     }
@@ -4621,7 +4727,7 @@ static void d3d12_command_list_set_root_cbv(struct d3d12_command_list *list,
     {
         d3d12_command_list_prepare_descriptors(list, bind_point);
         vk_write_descriptor_set_from_root_descriptor(&descriptor_write,
-                root_parameter, bindings->descriptor_sets[0], NULL, &buffer_info);
+                root_parameter, bindings->descriptor_sets, NULL, &buffer_info);
         VK_CALL(vkUpdateDescriptorSets(list->device->vk_device, 1, &descriptor_write, 0, NULL));
 
         VKD3D_ASSERT(index < ARRAY_SIZE(bindings->push_descriptors));
@@ -4685,8 +4791,7 @@ static void d3d12_command_list_set_root_descriptor(struct d3d12_command_list *li
 
     if (vk_info->KHR_push_descriptor)
     {
-        vk_write_descriptor_set_from_root_descriptor(&descriptor_write,
-                root_parameter, VK_NULL_HANDLE, &vk_buffer_view, NULL);
+        vk_write_descriptor_set_from_root_descriptor(&descriptor_write, root_parameter, NULL, &vk_buffer_view, NULL);
         VK_CALL(vkCmdPushDescriptorSetKHR(list->vk_command_buffer, bindings->vk_bind_point,
                 root_signature->vk_pipeline_layout, 0, 1, &descriptor_write));
     }
@@ -4694,7 +4799,7 @@ static void d3d12_command_list_set_root_descriptor(struct d3d12_command_list *li
     {
         d3d12_command_list_prepare_descriptors(list, bind_point);
         vk_write_descriptor_set_from_root_descriptor(&descriptor_write,
-                root_parameter, bindings->descriptor_sets[0], &vk_buffer_view,  NULL);
+                root_parameter, bindings->descriptor_sets, &vk_buffer_view,  NULL);
         VK_CALL(vkUpdateDescriptorSets(list->device->vk_device, 1, &descriptor_write, 0, NULL));
 
         VKD3D_ASSERT(index < ARRAY_SIZE(bindings->push_descriptors));
@@ -5371,8 +5476,8 @@ static void d3d12_command_list_clear_uav(struct d3d12_command_list *list,
                 view->info.texture.vk_view_type, view->format->type, &pipeline);
     }
 
-    if (!(write_set.dstSet = d3d12_command_allocator_allocate_descriptor_set(
-            list->allocator, pipeline.vk_set_layout, 0, false)))
+    if (!(write_set.dstSet = d3d12_command_allocator_allocate_descriptor_set(list->allocator,
+            VKD3D_SHADER_DESCRIPTOR_TYPE_UAV, 1, pipeline.vk_set_layout, 0, false)))
     {
         ERR("Failed to allocate descriptor set.\n");
         return;
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index e92373a36fa..9aa4adb6c06 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -1473,16 +1473,21 @@ static void vkd3d_device_vk_heaps_descriptor_limits_init(struct vkd3d_device_des
         uav_divisor = properties->maxDescriptorSetUpdateAfterBindSampledImages >= (3u << 20) ? 3 : 2;
     }
 
-    limits->uniform_buffer_max_descriptors = min(properties->maxDescriptorSetUpdateAfterBindUniformBuffers,
-            properties->maxPerStageDescriptorUpdateAfterBindUniformBuffers - root_provision);
-    limits->sampled_image_max_descriptors = min(properties->maxDescriptorSetUpdateAfterBindSampledImages,
-            properties->maxPerStageDescriptorUpdateAfterBindSampledImages / srv_divisor - root_provision);
-    limits->storage_buffer_max_descriptors = min(properties->maxDescriptorSetUpdateAfterBindStorageBuffers,
-            properties->maxPerStageDescriptorUpdateAfterBindStorageBuffers - root_provision);
-    limits->storage_image_max_descriptors = min(properties->maxDescriptorSetUpdateAfterBindStorageImages,
-            properties->maxPerStageDescriptorUpdateAfterBindStorageImages / uav_divisor - root_provision);
-    limits->sampler_max_descriptors = min(properties->maxDescriptorSetUpdateAfterBindSamplers,
-            properties->maxPerStageDescriptorUpdateAfterBindSamplers - root_provision);
+    limits->uniform_buffer_max_descriptors = min(min(properties->maxDescriptorSetUpdateAfterBindUniformBuffers,
+            properties->maxPerStageDescriptorUpdateAfterBindUniformBuffers - root_provision),
+            VKD3D_MAX_DESCRIPTOR_SET_CBVS_SRVS_UAVS);
+    limits->sampled_image_max_descriptors = min(min(properties->maxDescriptorSetUpdateAfterBindSampledImages,
+            properties->maxPerStageDescriptorUpdateAfterBindSampledImages / srv_divisor - root_provision),
+            VKD3D_MAX_DESCRIPTOR_SET_CBVS_SRVS_UAVS);
+    limits->storage_buffer_max_descriptors = min(min(properties->maxDescriptorSetUpdateAfterBindStorageBuffers,
+            properties->maxPerStageDescriptorUpdateAfterBindStorageBuffers - root_provision),
+            VKD3D_MAX_DESCRIPTOR_SET_CBVS_SRVS_UAVS);
+    limits->storage_image_max_descriptors = min(min(properties->maxDescriptorSetUpdateAfterBindStorageImages,
+            properties->maxPerStageDescriptorUpdateAfterBindStorageImages / uav_divisor - root_provision),
+            VKD3D_MAX_DESCRIPTOR_SET_CBVS_SRVS_UAVS);
+    limits->sampler_max_descriptors = min(min(properties->maxDescriptorSetUpdateAfterBindSamplers,
+            properties->maxPerStageDescriptorUpdateAfterBindSamplers - root_provision),
+            VKD3D_MAX_DESCRIPTOR_SET_CBVS_SRVS_UAVS);
     limits->sampler_max_descriptors = min(limits->sampler_max_descriptors, VKD3D_MAX_DESCRIPTOR_SET_SAMPLERS);
 }
 
@@ -2677,39 +2682,16 @@ static void vkd3d_time_domains_init(struct d3d12_device *device)
 static void device_init_descriptor_pool_sizes(struct d3d12_device *device)
 {
     const struct vkd3d_device_descriptor_limits *limits = &device->vk_info.descriptor_limits;
-    VkDescriptorPoolSize *pool_sizes = device->vk_pool_sizes;
+    unsigned int *pool_sizes = device->vk_pool_limits;
 
-    if (device->use_vk_heaps)
-    {
-        pool_sizes[0].type = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
-        pool_sizes[0].descriptorCount = min(limits->storage_image_max_descriptors,
-                VKD3D_MAX_UAV_CLEAR_DESCRIPTORS_PER_TYPE);
-        pool_sizes[1].type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
-        pool_sizes[1].descriptorCount = pool_sizes[0].descriptorCount;
-        pool_sizes[2].type = VK_DESCRIPTOR_TYPE_SAMPLER;
-        pool_sizes[2].descriptorCount = min(limits->sampler_max_descriptors, D3D12_MAX_LIVE_STATIC_SAMPLERS);
-        device->vk_pool_count = 3;
-        return;
-    }
-
-    VKD3D_ASSERT(ARRAY_SIZE(device->vk_pool_sizes) >= 6);
-    pool_sizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
-    pool_sizes[0].descriptorCount = min(limits->uniform_buffer_max_descriptors,
+    pool_sizes[VKD3D_SHADER_DESCRIPTOR_TYPE_CBV] = min(limits->uniform_buffer_max_descriptors,
             VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE);
-    pool_sizes[1].type = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
-    pool_sizes[1].descriptorCount = min(limits->sampled_image_max_descriptors,
+    pool_sizes[VKD3D_SHADER_DESCRIPTOR_TYPE_SRV] = min(limits->sampled_image_max_descriptors,
             VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE);
-    pool_sizes[2].type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
-    pool_sizes[2].descriptorCount = pool_sizes[1].descriptorCount;
-    pool_sizes[3].type = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
-    pool_sizes[3].descriptorCount = min(limits->storage_image_max_descriptors,
+    pool_sizes[VKD3D_SHADER_DESCRIPTOR_TYPE_UAV] = min(limits->storage_image_max_descriptors,
             VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE);
-    pool_sizes[4].type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
-    pool_sizes[4].descriptorCount = pool_sizes[3].descriptorCount;
-    pool_sizes[5].type = VK_DESCRIPTOR_TYPE_SAMPLER;
-    pool_sizes[5].descriptorCount = min(limits->sampler_max_descriptors,
+    pool_sizes[VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER] = min(limits->sampler_max_descriptors,
             VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE);
-    device->vk_pool_count = 6;
 };
 
 static void vkd3d_desc_object_cache_init(struct vkd3d_desc_object_cache *cache, size_t size)
@@ -3461,6 +3443,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device9
             for (i = 0; i < data->NumFeatureLevels; ++i)
             {
                 D3D_FEATURE_LEVEL fl = data->pFeatureLevelsRequested[i];
+                TRACE("Requested feature level %#x.\n", fl);
                 if (data->MaxSupportedFeatureLevel < fl && fl <= vulkan_info->max_feature_level)
                     data->MaxSupportedFeatureLevel = fl;
             }
diff --git a/libs/vkd3d/libs/vkd3d/state.c b/libs/vkd3d/libs/vkd3d/state.c
index 2b0f81d3812..bd3c3758ecb 100644
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -265,25 +265,6 @@ static enum vkd3d_shader_visibility vkd3d_shader_visibility_from_d3d12(D3D12_SHA
     }
 }
 
-static VkDescriptorType vk_descriptor_type_from_vkd3d_descriptor_type(enum vkd3d_shader_descriptor_type type,
-        bool is_buffer)
-{
-    switch (type)
-    {
-        case VKD3D_SHADER_DESCRIPTOR_TYPE_SRV:
-            return is_buffer ? VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER : VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
-        case VKD3D_SHADER_DESCRIPTOR_TYPE_UAV:
-            return is_buffer ? VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER : VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
-        case VKD3D_SHADER_DESCRIPTOR_TYPE_CBV:
-            return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
-        case VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER:
-            return VK_DESCRIPTOR_TYPE_SAMPLER;
-        default:
-            FIXME("Unhandled descriptor range type type %#x.\n", type);
-            return VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
-    }
-}
-
 static enum vkd3d_shader_descriptor_type vkd3d_descriptor_type_from_d3d12_range_type(
         D3D12_DESCRIPTOR_RANGE_TYPE type)
 {
@@ -597,8 +578,9 @@ static HRESULT d3d12_root_signature_info_from_desc(struct d3d12_root_signature_i
             goto done;
     }
 
-    qsort(info->ranges, info->range_count, sizeof(*info->ranges),
-            d3d12_root_signature_info_range_compare);
+    if (info->ranges)
+        qsort(info->ranges, info->range_count, sizeof(*info->ranges),
+                d3d12_root_signature_info_range_compare);
 
     for (i = D3D12_SHADER_VISIBILITY_VERTEX; i <= D3D12_SHADER_VISIBILITY_MESH; ++i)
     {
@@ -717,6 +699,8 @@ struct vk_binding_array
     VkDescriptorSetLayoutBinding *bindings;
     size_t capacity, count;
 
+    enum vkd3d_shader_descriptor_type descriptor_type;
+    unsigned int descriptor_set;
     unsigned int table_index;
     unsigned int unbounded_offset;
     VkDescriptorSetLayoutCreateFlags flags;
@@ -754,14 +738,24 @@ static bool vk_binding_array_add_binding(struct vk_binding_array *array,
     return true;
 }
 
+static void vk_binding_array_make_unbound(struct vk_binding_array *array,
+        unsigned int offset, unsigned int table_index)
+{
+    array->unbounded_offset = offset;
+    array->table_index = table_index;
+}
+
 struct vkd3d_descriptor_set_context
 {
     struct vk_binding_array vk_bindings[VKD3D_MAX_DESCRIPTOR_SETS];
+    struct vk_binding_array *current_binding_array[VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT];
     unsigned int table_index;
-    unsigned int unbounded_offset;
     unsigned int descriptor_index;
     unsigned int uav_counter_index;
     unsigned int push_constant_index;
+
+    struct vk_binding_array *push_descriptor_set;
+    bool push_descriptor;
 };
 
 static void descriptor_set_context_cleanup(struct vkd3d_descriptor_set_context *context)
@@ -786,46 +780,66 @@ static bool vkd3d_validate_descriptor_set_count(struct d3d12_device *device, uns
     return true;
 }
 
-static struct vk_binding_array *d3d12_root_signature_current_vk_binding_array(
-        struct d3d12_root_signature *root_signature, struct vkd3d_descriptor_set_context *context)
+static struct vk_binding_array *d3d12_root_signature_append_vk_binding_array(
+        struct d3d12_root_signature *root_signature, enum vkd3d_shader_descriptor_type descriptor_type,
+        VkDescriptorSetLayoutCreateFlags flags, struct vkd3d_descriptor_set_context *context)
 {
+    struct vk_binding_array *array;
+    unsigned int set;
+
     if (root_signature->vk_set_count >= ARRAY_SIZE(context->vk_bindings))
         return NULL;
 
-    return &context->vk_bindings[root_signature->vk_set_count];
+    set = root_signature->vk_set_count++;
+    array = &context->vk_bindings[set];
+    array->descriptor_type = descriptor_type;
+    array->descriptor_set = set;
+    array->unbounded_offset = UINT_MAX;
+    array->flags = flags;
+
+    return array;
 }
 
-static void d3d12_root_signature_append_vk_binding_array(struct d3d12_root_signature *root_signature,
-        VkDescriptorSetLayoutCreateFlags flags, struct vkd3d_descriptor_set_context *context)
+static struct vk_binding_array *d3d12_root_signature_vk_binding_array_for_type(
+        struct d3d12_root_signature *root_signature, enum vkd3d_shader_descriptor_type descriptor_type,
+        struct vkd3d_descriptor_set_context *context)
 {
-    struct vk_binding_array *array;
+    struct vk_binding_array *array, **current;
 
-    if (!(array = d3d12_root_signature_current_vk_binding_array(root_signature, context)) || !array->count)
-        return;
+    if (context->push_descriptor)
+    {
+        if (!context->push_descriptor_set)
+            context->push_descriptor_set = d3d12_root_signature_append_vk_binding_array(root_signature,
+                    descriptor_type, VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, context);
 
-    array->table_index = context->table_index;
-    array->unbounded_offset = context->unbounded_offset;
-    array->flags = flags;
+        return context->push_descriptor_set;
+    }
 
-    ++root_signature->vk_set_count;
+    current = context->current_binding_array;
+    if (!(array = current[descriptor_type]))
+    {
+        array = d3d12_root_signature_append_vk_binding_array(root_signature, descriptor_type, 0, context);
+        current[descriptor_type] = array;
+    }
+
+    return array;
 }
 
 static HRESULT d3d12_root_signature_append_vk_binding(struct d3d12_root_signature *root_signature,
-        enum vkd3d_shader_descriptor_type descriptor_type, unsigned int register_space,
-        unsigned int register_idx, bool buffer_descriptor, enum vkd3d_shader_visibility shader_visibility,
-        unsigned int descriptor_count, struct vkd3d_descriptor_set_context *context,
-        const VkSampler *immutable_sampler, unsigned int *binding_idx)
+        struct vk_binding_array *array, enum vkd3d_shader_descriptor_type descriptor_type,
+        unsigned int register_space, unsigned int register_idx, bool buffer_descriptor,
+        enum vkd3d_shader_visibility shader_visibility, unsigned int descriptor_count,
+        struct vkd3d_descriptor_set_context *context, const VkSampler *immutable_sampler)
 {
     struct vkd3d_shader_descriptor_offset *offset = root_signature->descriptor_offsets
             ? &root_signature->descriptor_offsets[context->descriptor_index] : NULL;
     struct vkd3d_shader_resource_binding *mapping;
-    struct vk_binding_array *array;
+    VkDescriptorType vk_descriptor_type;
     unsigned int idx;
 
-    if (!(array = d3d12_root_signature_current_vk_binding_array(root_signature, context))
-            || !(vk_binding_array_add_binding(&context->vk_bindings[root_signature->vk_set_count],
-                    vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, buffer_descriptor), descriptor_count,
-                    stage_flags_from_vkd3d_shader_visibility(shader_visibility), immutable_sampler, &idx)))
+    vk_descriptor_type = vk_descriptor_type_from_vkd3d_descriptor_type(descriptor_type, buffer_descriptor);
+    if (!vk_binding_array_add_binding(array, vk_descriptor_type, descriptor_count,
+            stage_flags_from_vkd3d_shader_visibility(shader_visibility), immutable_sampler, &idx))
         return E_OUTOFMEMORY;
 
     mapping = &root_signature->descriptor_mapping[context->descriptor_index++];
@@ -834,7 +848,7 @@ static HRESULT d3d12_root_signature_append_vk_binding(struct d3d12_root_signatur
     mapping->register_index = register_idx;
     mapping->shader_visibility = shader_visibility;
     mapping->flags = buffer_descriptor ? VKD3D_SHADER_BINDING_FLAG_BUFFER : VKD3D_SHADER_BINDING_FLAG_IMAGE;
-    mapping->binding.set = root_signature->vk_set_count;
+    mapping->binding.set = array->descriptor_set;
     mapping->binding.binding = idx;
     mapping->binding.count = descriptor_count;
     if (offset)
@@ -843,12 +857,6 @@ static HRESULT d3d12_root_signature_append_vk_binding(struct d3d12_root_signatur
         offset->dynamic_offset_index = ~0u;
     }
 
-    if (context->unbounded_offset != UINT_MAX)
-        d3d12_root_signature_append_vk_binding_array(root_signature, 0, context);
-
-    if (binding_idx)
-        *binding_idx = idx;
-
     return S_OK;
 }
 
@@ -911,7 +919,7 @@ static unsigned int vk_binding_count_from_descriptor_range(const struct d3d12_ro
 }
 
 static HRESULT d3d12_root_signature_init_descriptor_table_binding(struct d3d12_root_signature *root_signature,
-        const struct d3d12_root_descriptor_table_range *range, D3D12_SHADER_VISIBILITY visibility,
+        struct d3d12_root_descriptor_table_range *range, D3D12_SHADER_VISIBILITY visibility,
         unsigned int vk_binding_array_count, unsigned int bindings_per_range,
         struct vkd3d_descriptor_set_context *context)
 {
@@ -919,34 +927,49 @@ static HRESULT d3d12_root_signature_init_descriptor_table_binding(struct d3d12_r
     bool is_buffer = range->type != VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER;
     enum vkd3d_shader_descriptor_type descriptor_type = range->type;
     unsigned int i, register_space = range->register_space;
+    struct vk_binding_array *array;
     HRESULT hr;
 
-    if (range->descriptor_count == UINT_MAX)
-        context->unbounded_offset = range->offset;
+    if (!(array = d3d12_root_signature_vk_binding_array_for_type(root_signature, descriptor_type, context)))
+        return E_OUTOFMEMORY;
 
+    range->set = array->descriptor_set - root_signature->main_set;
+    range->binding = array->count;
     for (i = 0; i < bindings_per_range; ++i)
     {
-        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature, descriptor_type,
+        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature, array, descriptor_type,
                 register_space, range->base_register_idx + i, is_buffer, shader_visibility,
-                vk_binding_array_count, context, NULL, NULL)))
+                vk_binding_array_count, context, NULL)))
             return hr;
     }
 
-    if (descriptor_type != VKD3D_SHADER_DESCRIPTOR_TYPE_SRV && descriptor_type != VKD3D_SHADER_DESCRIPTOR_TYPE_UAV)
+    if (range->descriptor_count == UINT_MAX)
     {
-        context->unbounded_offset = UINT_MAX;
-        return S_OK;
+        vk_binding_array_make_unbound(array, range->offset, context->table_index);
+        context->current_binding_array[descriptor_type] = NULL;
     }
 
+    if (descriptor_type != VKD3D_SHADER_DESCRIPTOR_TYPE_SRV && descriptor_type != VKD3D_SHADER_DESCRIPTOR_TYPE_UAV)
+        return S_OK;
+
+    if (!(array = d3d12_root_signature_vk_binding_array_for_type(root_signature, descriptor_type, context)))
+        return E_OUTOFMEMORY;
+
+    range->image_set = array->descriptor_set - root_signature->main_set;
+    range->image_binding = array->count;
     for (i = 0; i < bindings_per_range; ++i)
     {
-        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature, descriptor_type,
+        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature, array, descriptor_type,
                 register_space, range->base_register_idx + i, false, shader_visibility,
-                vk_binding_array_count, context, NULL, NULL)))
+                vk_binding_array_count, context, NULL)))
             return hr;
     }
 
-    context->unbounded_offset = UINT_MAX;
+    if (range->descriptor_count == UINT_MAX)
+    {
+        vk_binding_array_make_unbound(array, range->offset, context->table_index);
+        context->current_binding_array[descriptor_type] = NULL;
+    }
 
     return S_OK;
 }
@@ -1199,16 +1222,16 @@ static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_roo
 
             if (use_vk_heaps)
             {
-                 /* set, binding and vk_binding_count are not used. */
+                /* set, binding, image_set, image_binding, and vk_binding_count are not used. */
                 range->set = 0;
                 range->binding = 0;
+                range->image_set = 0;
+                range->image_binding = 0;
                 range->vk_binding_count = 0;
                 d3d12_root_signature_map_descriptor_heap_binding(root_signature, range, shader_visibility, context);
                 continue;
             }
 
-            range->set = root_signature->vk_set_count - root_signature->main_set;
-
             if (root_signature->use_descriptor_arrays)
             {
                 if (j && range->type != table->ranges[j - 1].type)
@@ -1229,6 +1252,8 @@ static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_roo
 
                     range->set = base_range->set;
                     range->binding = base_range->binding;
+                    range->image_set = base_range->image_set;
+                    range->image_binding = base_range->image_binding;
                     range->vk_binding_count = base_range->vk_binding_count - rel_offset;
                     d3d12_root_signature_map_descriptor_unbounded_binding(root_signature, range,
                             rel_offset, shader_visibility, context);
@@ -1251,8 +1276,6 @@ static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_roo
                 bindings_per_range = range->descriptor_count;
             }
 
-            range->binding = context->vk_bindings[root_signature->vk_set_count].count;
-
             if (FAILED(hr = d3d12_root_signature_init_descriptor_table_binding(root_signature, range,
                     p->ShaderVisibility, vk_binding_array_count, bindings_per_range, context)))
                 return hr;
@@ -1266,7 +1289,9 @@ static HRESULT d3d12_root_signature_init_root_descriptor_tables(struct d3d12_roo
 static HRESULT d3d12_root_signature_init_root_descriptors(struct d3d12_root_signature *root_signature,
         const D3D12_ROOT_SIGNATURE_DESC *desc, struct vkd3d_descriptor_set_context *context)
 {
-    unsigned int binding, i;
+    enum vkd3d_shader_descriptor_type descriptor_type;
+    struct vk_binding_array *array;
+    unsigned int i;
     HRESULT hr;
 
     root_signature->push_descriptor_mask = 0;
@@ -1281,14 +1306,19 @@ static HRESULT d3d12_root_signature_init_root_descriptors(struct d3d12_root_sign
 
         root_signature->push_descriptor_mask |= 1u << i;
 
-        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature,
-                vkd3d_descriptor_type_from_d3d12_root_parameter_type(p->ParameterType),
+        descriptor_type = vkd3d_descriptor_type_from_d3d12_root_parameter_type(p->ParameterType);
+        if (!(array = d3d12_root_signature_vk_binding_array_for_type(root_signature, descriptor_type, context)))
+            return E_OUTOFMEMORY;
+
+        root_signature->parameters[i].parameter_type = p->ParameterType;
+        root_signature->parameters[i].u.descriptor.set = array->descriptor_set;
+        root_signature->parameters[i].u.descriptor.binding = array->count;
+
+        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature, array, descriptor_type,
                 p->u.Descriptor.RegisterSpace, p->u.Descriptor.ShaderRegister, true,
-                vkd3d_shader_visibility_from_d3d12(p->ShaderVisibility), 1, context, NULL, &binding)))
+                vkd3d_shader_visibility_from_d3d12(p->ShaderVisibility), 1, context, NULL)))
             return hr;
 
-        root_signature->parameters[i].parameter_type = p->ParameterType;
-        root_signature->parameters[i].u.descriptor.binding = binding;
     }
 
     return S_OK;
@@ -1298,10 +1328,19 @@ static HRESULT d3d12_root_signature_init_static_samplers(struct d3d12_root_signa
         struct d3d12_device *device, const D3D12_ROOT_SIGNATURE_DESC *desc,
         struct vkd3d_descriptor_set_context *context)
 {
+    struct vk_binding_array *array;
     unsigned int i;
     HRESULT hr;
 
     VKD3D_ASSERT(root_signature->static_sampler_count == desc->NumStaticSamplers);
+
+    if (!desc->NumStaticSamplers)
+        return S_OK;
+
+    if (!(array = d3d12_root_signature_vk_binding_array_for_type(root_signature,
+            VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, context)))
+        return E_OUTOFMEMORY;
+
     for (i = 0; i < desc->NumStaticSamplers; ++i)
     {
         const D3D12_STATIC_SAMPLER_DESC *s = &desc->pStaticSamplers[i];
@@ -1309,16 +1348,13 @@ static HRESULT d3d12_root_signature_init_static_samplers(struct d3d12_root_signa
         if (FAILED(hr = vkd3d_create_static_sampler(device, s, &root_signature->static_samplers[i])))
             return hr;
 
-        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature,
+        if (FAILED(hr = d3d12_root_signature_append_vk_binding(root_signature, array,
                 VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, s->RegisterSpace, s->ShaderRegister, false,
                 vkd3d_shader_visibility_from_d3d12(s->ShaderVisibility), 1, context,
-                &root_signature->static_samplers[i], NULL)))
+                &root_signature->static_samplers[i])))
             return hr;
     }
 
-    if (device->use_vk_heaps)
-        d3d12_root_signature_append_vk_binding_array(root_signature, 0, context);
-
     return S_OK;
 }
 
@@ -1450,29 +1486,52 @@ static HRESULT vkd3d_create_pipeline_layout(struct d3d12_device *device,
     return S_OK;
 }
 
+static HRESULT d3d12_descriptor_set_layout_init(struct d3d12_descriptor_set_layout *layout,
+        struct d3d12_device *device, const struct vk_binding_array *array)
+{
+    unsigned int descriptor_count;
+    bool unbounded;
+    HRESULT hr;
+    size_t i;
+
+    descriptor_count = array->unbounded_offset;
+    if (!(unbounded = descriptor_count != UINT_MAX))
+    {
+        for (i = 0, descriptor_count = 0; i < array->count; ++i)
+        {
+            descriptor_count += array->bindings[i].descriptorCount;
+        }
+    }
+
+    if (FAILED(hr = vkd3d_create_descriptor_set_layout(device, array->flags,
+            array->count, unbounded, array->bindings, &layout->vk_layout)))
+        return hr;
+    layout->descriptor_type = array->descriptor_type;
+    layout->descriptor_count = descriptor_count;
+    layout->unbounded_offset = array->unbounded_offset;
+    layout->table_index = array->table_index;
+
+    return S_OK;
+}
+
 static HRESULT d3d12_root_signature_create_descriptor_set_layouts(struct d3d12_root_signature *root_signature,
         struct vkd3d_descriptor_set_context *context)
 {
     unsigned int i;
     HRESULT hr;
 
-    d3d12_root_signature_append_vk_binding_array(root_signature, 0, context);
-
     if (!vkd3d_validate_descriptor_set_count(root_signature->device, root_signature->vk_set_count))
         return E_INVALIDARG;
 
     for (i = 0; i < root_signature->vk_set_count; ++i)
     {
-        struct d3d12_descriptor_set_layout *layout = &root_signature->descriptor_set_layouts[i];
-        struct vk_binding_array *array = &context->vk_bindings[i];
+        const struct vk_binding_array *array = &context->vk_bindings[i];
 
         VKD3D_ASSERT(array->count);
 
-        if (FAILED(hr = vkd3d_create_descriptor_set_layout(root_signature->device, array->flags, array->count,
-                array->unbounded_offset != UINT_MAX, array->bindings, &layout->vk_layout)))
+        if (FAILED(hr = d3d12_descriptor_set_layout_init(&root_signature->descriptor_set_layouts[i],
+                root_signature->device, array)))
             return hr;
-        layout->unbounded_offset = array->unbounded_offset;
-        layout->table_index = array->table_index;
     }
 
     return S_OK;
@@ -1518,7 +1577,6 @@ static HRESULT d3d12_root_signature_init(struct d3d12_root_signature *root_signa
     HRESULT hr;
 
     memset(&context, 0, sizeof(context));
-    context.unbounded_offset = UINT_MAX;
 
     root_signature->ID3D12RootSignature_iface.lpVtbl = &d3d12_root_signature_vtbl;
     root_signature->refcount = 1;
@@ -1580,17 +1638,11 @@ static HRESULT d3d12_root_signature_init(struct d3d12_root_signature *root_signa
             sizeof(*root_signature->static_samplers))))
         goto fail;
 
+    context.push_descriptor = vk_info->KHR_push_descriptor;
     if (FAILED(hr = d3d12_root_signature_init_root_descriptors(root_signature, desc, &context)))
         goto fail;
-
-    /* We use KHR_push_descriptor for root descriptor parameters. */
-    if (vk_info->KHR_push_descriptor)
-    {
-        d3d12_root_signature_append_vk_binding_array(root_signature,
-                VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, &context);
-    }
-
-    root_signature->main_set = root_signature->vk_set_count;
+    root_signature->main_set = !!context.push_descriptor_set;
+    context.push_descriptor = false;
 
     if (FAILED(hr = d3d12_root_signature_init_push_constants(root_signature, desc,
             root_signature->push_constant_ranges, &root_signature->push_constant_range_count)))
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index 97a99782d6a..8488d5db3fa 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -58,12 +58,17 @@
 #define VKD3D_MAX_VK_SYNC_OBJECTS         4u
 #define VKD3D_MAX_DEVICE_BLOCKED_QUEUES  16u
 #define VKD3D_MAX_DESCRIPTOR_SETS        64u
+/* Direct3D 12 binding tier 3 has a limit of "1,000,000+" CBVs, SRVs and UAVs.
+ * I am not sure what the "+" is supposed to mean: it probably hints that
+ * implementations may have an even higher limit, but that's pretty obvious,
+ * that table is for guaranteed minimum limits. */
+#define VKD3D_MAX_DESCRIPTOR_SET_CBVS_SRVS_UAVS 1000000u
 /* D3D12 binding tier 3 has a limit of 2048 samplers. */
 #define VKD3D_MAX_DESCRIPTOR_SET_SAMPLERS 2048u
-/* The main limitation here is the simple descriptor pool recycling scheme
- * requiring each pool to contain all descriptor types used by vkd3d. Limit
- * this number to prevent excessive pool memory use. */
 #define VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE (16 * 1024u)
+#define VKD3D_INITIAL_DESCRIPTORS_POOL_SIZE 1024u
+
+#define VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT (VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER + 1)
 
 extern uint64_t object_global_serial_id;
 
@@ -770,6 +775,25 @@ static inline struct d3d12_dsv_desc *d3d12_dsv_desc_from_cpu_handle(D3D12_CPU_DE
 void d3d12_dsv_desc_create_dsv(struct d3d12_dsv_desc *dsv_desc, struct d3d12_device *device,
         struct d3d12_resource *resource, const D3D12_DEPTH_STENCIL_VIEW_DESC *desc);
 
+static inline VkDescriptorType vk_descriptor_type_from_vkd3d_descriptor_type(enum vkd3d_shader_descriptor_type type,
+        bool is_buffer)
+{
+    switch (type)
+    {
+        case VKD3D_SHADER_DESCRIPTOR_TYPE_SRV:
+            return is_buffer ? VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER : VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
+        case VKD3D_SHADER_DESCRIPTOR_TYPE_UAV:
+            return is_buffer ? VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER : VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+        case VKD3D_SHADER_DESCRIPTOR_TYPE_CBV:
+            return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
+        case VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER:
+            return VK_DESCRIPTOR_TYPE_SAMPLER;
+        default:
+            FIXME("Unhandled descriptor range type type %#x.\n", type);
+            return VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
+    }
+}
+
 enum vkd3d_vk_descriptor_set_index
 {
     VKD3D_SET_INDEX_SAMPLER,
@@ -899,6 +923,8 @@ struct d3d12_root_descriptor_table_range
     unsigned int vk_binding_count;
     uint32_t set;
     uint32_t binding;
+    uint32_t image_set;
+    uint32_t image_binding;
 
     enum vkd3d_shader_descriptor_type type;
     uint32_t descriptor_magic;
@@ -920,6 +946,7 @@ struct d3d12_root_constant
 
 struct d3d12_root_descriptor
 {
+    uint32_t set;
     uint32_t binding;
 };
 
@@ -936,7 +963,9 @@ struct d3d12_root_parameter
 
 struct d3d12_descriptor_set_layout
 {
+    enum vkd3d_shader_descriptor_type descriptor_type;
     VkDescriptorSetLayout vk_layout;
+    unsigned int descriptor_count;
     unsigned int unbounded_offset;
     unsigned int table_index;
 };
@@ -1135,6 +1164,18 @@ struct vkd3d_buffer
     VkDeviceMemory vk_memory;
 };
 
+struct vkd3d_vk_descriptor_pool
+{
+    unsigned int descriptor_count;
+    VkDescriptorPool vk_pool;
+};
+
+struct vkd3d_vk_descriptor_pool_array
+{
+    struct vkd3d_vk_descriptor_pool *pools;
+    size_t capacity, count;
+};
+
 /* ID3D12CommandAllocator */
 struct d3d12_command_allocator
 {
@@ -1146,11 +1187,9 @@ struct d3d12_command_allocator
 
     VkCommandPool vk_command_pool;
 
-    VkDescriptorPool vk_descriptor_pool;
+    VkDescriptorPool vk_descriptor_pools[VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT];
 
-    VkDescriptorPool *free_descriptor_pools;
-    size_t free_descriptor_pools_size;
-    size_t free_descriptor_pool_count;
+    struct vkd3d_vk_descriptor_pool_array free_descriptor_pools[VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT];
 
     VkRenderPass *passes;
     size_t passes_size;
@@ -1160,9 +1199,8 @@ struct d3d12_command_allocator
     size_t framebuffers_size;
     size_t framebuffer_count;
 
-    VkDescriptorPool *descriptor_pools;
-    size_t descriptor_pools_size;
-    size_t descriptor_pool_count;
+    struct vkd3d_vk_descriptor_pool_array descriptor_pools[VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT];
+    unsigned int vk_pool_sizes[VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT];
 
     struct vkd3d_view **views;
     size_t views_size;
@@ -1516,8 +1554,6 @@ struct vkd3d_desc_object_cache
     size_t size;
 };
 
-#define VKD3D_DESCRIPTOR_POOL_COUNT 6
-
 /* ID3D12Device */
 struct d3d12_device
 {
@@ -1536,8 +1572,7 @@ struct d3d12_device
     struct vkd3d_desc_object_cache view_desc_cache;
     struct vkd3d_desc_object_cache cbuffer_desc_cache;
 
-    VkDescriptorPoolSize vk_pool_sizes[VKD3D_DESCRIPTOR_POOL_COUNT];
-    unsigned int vk_pool_count;
+    unsigned int vk_pool_limits[VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT];
     struct vkd3d_vk_descriptor_heap_layout vk_descriptor_heap_layouts[VKD3D_SET_INDEX_COUNT];
     bool use_vk_heaps;
 

From ab46a57f561ae72e12df9045947c83a1ad81d600 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sat, 18 Jan 2025 16:15:28 +1100
Subject: [PATCH 139/244] Updated vkd3d to
 a082daeb56c239b41d67b5df5abceb342c0b32b9.

---
 libs/vkd3d/libs/vkd3d-shader/hlsl.c         |   1 +
 libs/vkd3d/libs/vkd3d-shader/hlsl.h         |   1 +
 libs/vkd3d/libs/vkd3d-shader/hlsl.y         |  14 ++
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c | 198 +++++++++++++++++++-
 libs/vkd3d/libs/vkd3d-shader/msl.c          |   1 -
 5 files changed, 207 insertions(+), 8 deletions(-)

diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 858186a1071..23f54d3edec 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -3238,6 +3238,7 @@ const char *debug_hlsl_expr_op(enum hlsl_ir_expr_op op)
         [HLSL_OP1_F32TOF16]     = "f32tof16",
         [HLSL_OP1_FLOOR]        = "floor",
         [HLSL_OP1_FRACT]        = "fract",
+        [HLSL_OP1_ISINF]        = "isinf",
         [HLSL_OP1_LOG2]         = "log2",
         [HLSL_OP1_LOGIC_NOT]    = "!",
         [HLSL_OP1_NEG]          = "-",
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index d712a325322..4d78dbebb34 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -704,6 +704,7 @@ enum hlsl_ir_expr_op
     HLSL_OP1_F32TOF16,
     HLSL_OP1_FLOOR,
     HLSL_OP1_FRACT,
+    HLSL_OP1_ISINF,
     HLSL_OP1_LOG2,
     HLSL_OP1_LOGIC_NOT,
     HLSL_OP1_NEG,
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index e6eaac78994..e5a03067d16 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -4313,6 +4313,19 @@ static bool intrinsic_fwidth(struct hlsl_ctx *ctx,
     return !!add_user_call(ctx, func, params, false, loc);
 }
 
+static bool intrinsic_isinf(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_type *type = params->args[0]->data_type, *bool_type;
+    struct hlsl_ir_node *args[HLSL_MAX_OPERANDS] = {0};
+
+    bool_type = hlsl_get_numeric_type(ctx, type->class, HLSL_TYPE_BOOL,
+            type->e.numeric.dimx, type->e.numeric.dimy);
+
+    args[0] = params->args[0];
+    return !!add_expr(ctx, params->instrs, HLSL_OP1_ISINF, args, bool_type, loc);
+}
+
 static bool intrinsic_ldexp(struct hlsl_ctx *ctx,
         const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
 {
@@ -5410,6 +5423,7 @@ intrinsic_functions[] =
     {"fmod",                                2, true,  intrinsic_fmod},
     {"frac",                                1, true,  intrinsic_frac},
     {"fwidth",                              1, true,  intrinsic_fwidth},
+    {"isinf",                               1, true,  intrinsic_isinf},
     {"ldexp",                               2, true,  intrinsic_ldexp},
     {"length",                              1, true,  intrinsic_length},
     {"lerp",                                3, true,  intrinsic_lerp},
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index c666599b342..cef6a87c8b6 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -2881,6 +2881,7 @@ static bool lower_separate_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
     load = hlsl_ir_resource_load(instr);
 
     if (load->load_type != HLSL_RESOURCE_SAMPLE
+            && load->load_type != HLSL_RESOURCE_SAMPLE_GRAD
             && load->load_type != HLSL_RESOURCE_SAMPLE_LOD
             && load->load_type != HLSL_RESOURCE_SAMPLE_LOD_BIAS)
         return false;
@@ -2908,6 +2909,13 @@ static bool lower_separate_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         return false;
     vkd3d_string_buffer_printf(name, "%s+%s", sampler->name, resource->name);
 
+    if (load->texel_offset.node)
+    {
+        hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
+                "Texel offsets are not supported on profiles lower than 4.0.\n");
+        return false;
+    }
+
     TRACE("Lowering to combined sampler %s.\n", debugstr_a(name->buffer));
 
     if (!(var = hlsl_get_var(ctx->globals, name->buffer)))
@@ -3099,11 +3107,24 @@ static bool sort_synthetic_separated_samplers_first(struct hlsl_ctx *ctx)
     return false;
 }
 
-/* Turn CAST to int or uint into FLOOR + REINTERPRET (which is written as a mere MOV). */
+/* Turn CAST to int or uint as follows:
+ *
+ *     CAST(x) = x - FRACT(x) + extra
+ *
+ * where
+ *
+ *      extra = FRACT(x) > 0 && x < 0
+ *
+ * where the comparisons in the extra term are performed using CMP or SLT
+ * depending on whether this is a pixel or vertex shader, respectively.
+ *
+ * A REINTERPET (which is written as a mere MOV) is also applied to the final
+ * result for type consistency.
+ */
 static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
 {
     struct hlsl_ir_node *operands[HLSL_MAX_OPERANDS] = { 0 };
-    struct hlsl_ir_node *arg, *floor, *res;
+    struct hlsl_ir_node *arg, *res;
     struct hlsl_ir_expr *expr;
 
     if (instr->type != HLSL_IR_EXPR)
@@ -3118,12 +3139,83 @@ static bool lower_casts_to_int(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
     if (arg->data_type->e.numeric.type != HLSL_TYPE_FLOAT && arg->data_type->e.numeric.type != HLSL_TYPE_HALF)
         return false;
 
-    if (!(floor = hlsl_new_unary_expr(ctx, HLSL_OP1_FLOOR, arg, &instr->loc)))
-        return false;
-    hlsl_block_add_instr(block, floor);
+    if (ctx->profile->type == VKD3D_SHADER_TYPE_PIXEL)
+    {
+        struct hlsl_ir_node *fract, *neg_fract, *has_fract, *floor, *extra, *zero, *one;
+        struct hlsl_constant_value zero_value, one_value;
+
+        memset(&zero_value, 0, sizeof(zero_value));
+        if (!(zero = hlsl_new_constant(ctx, arg->data_type, &zero_value, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, zero);
+
+        one_value.u[0].f = 1.0;
+        one_value.u[1].f = 1.0;
+        one_value.u[2].f = 1.0;
+        one_value.u[3].f = 1.0;
+        if (!(one = hlsl_new_constant(ctx, arg->data_type, &one_value, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, one);
+
+        if (!(fract = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, arg, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, fract);
+
+        if (!(neg_fract = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, fract, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, neg_fract);
+
+        if (!(has_fract = hlsl_new_ternary_expr(ctx, HLSL_OP3_CMP, neg_fract, zero, one)))
+            return false;
+        hlsl_block_add_instr(block, has_fract);
+
+        if (!(extra = hlsl_new_ternary_expr(ctx, HLSL_OP3_CMP, arg, zero, has_fract)))
+            return false;
+        hlsl_block_add_instr(block, extra);
+
+        if (!(floor = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg, neg_fract)))
+            return false;
+        hlsl_block_add_instr(block, floor);
+
+        if (!(res = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, floor, extra)))
+            return false;
+        hlsl_block_add_instr(block, res);
+    }
+    else
+    {
+        struct hlsl_ir_node *neg_arg, *is_neg, *fract, *neg_fract, *has_fract, *floor;
+
+        if (!(neg_arg = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, arg, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, neg_arg);
+
+        if (!(is_neg = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, arg, neg_arg)))
+            return false;
+        hlsl_block_add_instr(block, is_neg);
+
+        if (!(fract = hlsl_new_unary_expr(ctx, HLSL_OP1_FRACT, arg, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, fract);
+
+        if (!(neg_fract = hlsl_new_unary_expr(ctx, HLSL_OP1_NEG, fract, &instr->loc)))
+            return false;
+        hlsl_block_add_instr(block, neg_fract);
+
+        if (!(has_fract = hlsl_new_binary_expr(ctx, HLSL_OP2_SLT, neg_fract, fract)))
+            return false;
+        hlsl_block_add_instr(block, has_fract);
+
+        if (!(floor = hlsl_new_binary_expr(ctx, HLSL_OP2_ADD, arg, neg_fract)))
+            return false;
+        hlsl_block_add_instr(block, floor);
+
+        if (!(res = hlsl_new_ternary_expr(ctx, HLSL_OP3_MAD, is_neg, has_fract, floor)))
+            return false;
+        hlsl_block_add_instr(block, res);
+    }
 
     memset(operands, 0, sizeof(operands));
-    operands[0] = floor;
+    operands[0] = res;
     if (!(res = hlsl_new_expr(ctx, HLSL_OP1_REINTERPRET, operands, instr->data_type, &instr->loc)))
         return false;
     hlsl_block_add_instr(block, res);
@@ -6977,7 +7069,8 @@ static void sm1_generate_vsir_sampler_dcls(struct hlsl_ctx *ctx,
                         break;
 
                     case HLSL_SAMPLER_DIM_GENERIC:
-                        /* These can appear in sm4-style combined sample instructions. */
+                        /* These can appear in sm4-style separate sample
+                         * instructions that haven't been lowered. */
                         hlsl_fixme(ctx, &var->loc, "Generic samplers need to be lowered.");
                         continue;
 
@@ -11732,6 +11825,95 @@ static bool lower_f32tof16(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, stru
     return true;
 }
 
+static bool lower_isinf(struct hlsl_ctx *ctx, struct hlsl_ir_node *node, struct hlsl_block *block)
+{
+    struct hlsl_ir_node *call, *rhs, *store;
+    struct hlsl_ir_function_decl *func;
+    unsigned int component_count;
+    struct hlsl_ir_load *load;
+    struct hlsl_ir_expr *expr;
+    struct hlsl_ir_var *lhs;
+    const char *template;
+    char *body;
+
+    static const char template_sm2[] =
+        "typedef bool%u boolX;\n"
+        "typedef float%u floatX;\n"
+        "boolX isinf(floatX x)\n"
+        "{\n"
+        "    floatX v = 1 / x;\n"
+        "    v = v * v;\n"
+        "    return v <= 0;\n"
+        "}\n";
+
+    static const char template_sm3[] =
+        "typedef bool%u boolX;\n"
+        "typedef float%u floatX;\n"
+        "boolX isinf(floatX x)\n"
+        "{\n"
+        "    floatX v = 1 / x;\n"
+        "    return v <= 0;\n"
+        "}\n";
+
+    static const char template_sm4[] =
+        "typedef bool%u boolX;\n"
+        "typedef float%u floatX;\n"
+        "boolX isinf(floatX x)\n"
+        "{\n"
+        "    return (asuint(x) & 0x7fffffff) == 0x7f800000;\n"
+        "}\n";
+
+    static const char template_int[] =
+        "typedef bool%u boolX;\n"
+        "typedef float%u floatX;\n"
+        "boolX isinf(floatX x)\n"
+        "{\n"
+        "    return false;\n"
+        "}";
+
+    if (node->type != HLSL_IR_EXPR)
+        return false;
+
+    expr = hlsl_ir_expr(node);
+
+    if (expr->op != HLSL_OP1_ISINF)
+        return false;
+
+    rhs = expr->operands[0].node;
+
+    if (hlsl_version_lt(ctx, 3, 0))
+        template = template_sm2;
+    else if (hlsl_version_lt(ctx, 4, 0))
+        template = template_sm3;
+    else if (type_is_integer(rhs->data_type))
+        template = template_int;
+    else
+        template = template_sm4;
+
+    component_count = hlsl_type_component_count(rhs->data_type);
+    if (!(body = hlsl_sprintf_alloc(ctx, template, component_count, component_count)))
+        return false;
+
+    if (!(func = hlsl_compile_internal_function(ctx, "isinf", body)))
+        return false;
+
+    lhs = func->parameters.vars[0];
+
+    if (!(store = hlsl_new_simple_store(ctx, lhs, rhs)))
+        return false;
+    hlsl_block_add_instr(block, store);
+
+    if (!(call = hlsl_new_call(ctx, func, &node->loc)))
+        return false;
+    hlsl_block_add_instr(block, call);
+
+    if (!(load = hlsl_new_var_load(ctx, func->return_var, &node->loc)))
+        return false;
+    hlsl_block_add_instr(block, &load->node);
+
+    return true;
+}
+
 static void process_entry_function(struct hlsl_ctx *ctx,
         const struct hlsl_block *global_uniform_block, struct hlsl_ir_function_decl *entry_func)
 {
@@ -11765,6 +11947,8 @@ static void process_entry_function(struct hlsl_ctx *ctx,
         lower_ir(ctx, lower_f32tof16, body);
     }
 
+    lower_ir(ctx, lower_isinf, body);
+
     lower_return(ctx, entry_func, body, false);
 
     while (hlsl_transform_ir(ctx, lower_calls, body, NULL));
diff --git a/libs/vkd3d/libs/vkd3d-shader/msl.c b/libs/vkd3d/libs/vkd3d-shader/msl.c
index bb85e62e94c..e783128e236 100644
--- a/libs/vkd3d/libs/vkd3d-shader/msl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/msl.c
@@ -198,7 +198,6 @@ static void msl_print_register_name(struct vkd3d_string_buffer *buffer,
                             vkd3d_string_buffer_printf(buffer, "uint4(%#xu, %#xu, %#xu, %#xu)",
                                     reg->u.immconst_u32[0], reg->u.immconst_u32[1],
                                     reg->u.immconst_u32[2], reg->u.immconst_u32[3]);
-                            vkd3d_string_buffer_printf(buffer, "%#xu", reg->u.immconst_u32[0]);
                             break;
                         case VKD3D_DATA_FLOAT:
                             vkd3d_string_buffer_printf(buffer, "as_type<float4>(uint4(%#xu, %#xu, %#xu, %#xu))",

From 8e2a46d88854724c3753bccd8978df0dd71989a9 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 22 Jan 2025 07:08:19 +1100
Subject: [PATCH 140/244] Updated vkd3d to
 5b2d62e59a6365e32aac3fa37fe16ab3582deae4.

---
 libs/vkd3d/include/vkd3d.h                  |  29 ++-
 libs/vkd3d/libs/vkd3d-shader/d3d_asm.c      |   4 +-
 libs/vkd3d/libs/vkd3d-shader/hlsl.c         |  90 +++++++++
 libs/vkd3d/libs/vkd3d-shader/hlsl.h         |  36 ++++
 libs/vkd3d/libs/vkd3d-shader/hlsl.y         | 194 ++++++++++++++++++++
 libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c | 131 +++++++++++++
 libs/vkd3d/libs/vkd3d-shader/spirv.c        |   3 +-
 libs/vkd3d/libs/vkd3d-shader/tpf.c          |  19 ++
 libs/vkd3d/libs/vkd3d/command.c             |  57 +++++-
 libs/vkd3d/libs/vkd3d/device.c              |  34 ++--
 libs/vkd3d/libs/vkd3d/resource.c            |   9 +-
 libs/vkd3d/libs/vkd3d/utils.c               |   2 +-
 libs/vkd3d/libs/vkd3d/vkd3d_private.h       |   7 +-
 13 files changed, 581 insertions(+), 34 deletions(-)

diff --git a/libs/vkd3d/include/vkd3d.h b/libs/vkd3d/include/vkd3d.h
index b18fd14f4c3..2376693421c 100644
--- a/libs/vkd3d/include/vkd3d.h
+++ b/libs/vkd3d/include/vkd3d.h
@@ -411,9 +411,13 @@ VKD3D_API uint32_t vkd3d_get_vk_queue_family_index(ID3D12CommandQueue *queue);
  * the Vulkan driver as being submitted before other work submitted
  * though the Direct3D 12 API. If this is not desired, it is
  * recommended to synchronize work submission using an ID3D12Fence
- * object, by submitting to the queue a signal operation after all the
- * Direct3D 12 work is submitted and waiting for it before calling
- * vkd3d_acquire_vk_queue().
+ * object:
+ *  1. submit work through the Direct3D 12 API;
+ *  2. call vkd3d_queue_signal_on_cpu();
+ *  3. wait for the fence to be signalled;
+ *  4. call vkd3d_acquire_vk_queue(); it is guaranteed that all work submitted
+ *     at point 1 has already been submitted to Vulkan (though not necessarily
+ *     executed).
  *
  * \since 1.0
  */
@@ -466,6 +470,21 @@ VKD3D_API HRESULT vkd3d_create_versioned_root_signature_deserializer(const void
  */
 VKD3D_API void vkd3d_set_log_callback(PFN_vkd3d_log callback);
 
+/**
+ * Signal a fence on the CPU once all the currently outstanding queue work is
+ * submitted to Vulkan.
+ *
+ * The fence will be signalled on the CPU (as if ID3D12Fence_Signal() was
+ * called) once all the work submitted through the Direct3D 12 API before
+ * vkd3d_queue_signal_on_cpu() is called has left the internal queue and has
+ * been submitted to the underlying Vulkan queue. Read the documentation for
+ * vkd3d_acquire_vk_queue() for more details.
+ *
+ * \since 1.15
+ */
+VKD3D_API HRESULT vkd3d_queue_signal_on_cpu(ID3D12CommandQueue *queue,
+        ID3D12Fence *fence, uint64_t value);
+
 #endif  /* VKD3D_NO_PROTOTYPES */
 
 /*
@@ -512,6 +531,10 @@ typedef HRESULT (*PFN_vkd3d_create_versioned_root_signature_deserializer)(const
 /** Type of vkd3d_set_log_callback(). \since 1.4 */
 typedef void (*PFN_vkd3d_set_log_callback)(PFN_vkd3d_log callback);
 
+/** Type of vkd3d_queue_signal_on_cpu(). \since 1.15 */
+typedef HRESULT (*PFN_vkd3d_queue_signal_on_cpu)(ID3D12CommandQueue *queue,
+        ID3D12Fence *fence, uint64_t value);
+
 #ifdef __cplusplus
 }
 #endif  /* __cplusplus */
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 69e14e0c7bf..0639da83aa6 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -1180,8 +1180,8 @@ static void shader_print_register(struct vkd3d_d3d_asm_compiler *compiler, const
             bool is_sm_5_1 = vkd3d_shader_ver_ge(&compiler->shader_version, 5, 1);
 
             if (reg->idx[0].rel_addr || reg->type == VKD3DSPR_IMMCONSTBUFFER
-                    || reg->type == VKD3DSPR_INCONTROLPOINT || (reg->type == VKD3DSPR_INPUT
-                    && (compiler->shader_version.type == VKD3D_SHADER_TYPE_GEOMETRY
+                    || reg->type == VKD3DSPR_INCONTROLPOINT || reg->type == VKD3DSPR_OUTCONTROLPOINT
+                    || (reg->type == VKD3DSPR_INPUT && (compiler->shader_version.type == VKD3D_SHADER_TYPE_GEOMETRY
                     || compiler->shader_version.type == VKD3D_SHADER_TYPE_HULL)))
             {
                 vkd3d_string_buffer_printf(buffer, "%s", compiler->colours.reset);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index 23f54d3edec..48d9d4e0023 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -2031,6 +2031,25 @@ struct hlsl_ir_node *hlsl_new_stateblock_constant(struct hlsl_ctx *ctx, const ch
     return &constant->node;
 }
 
+struct hlsl_ir_node *hlsl_new_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op op, struct hlsl_type *type,
+        const struct hlsl_deref *dst, struct hlsl_ir_node *coords, struct hlsl_ir_node *cmp_value,
+        struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_interlocked *interlocked;
+
+    if (!(interlocked = hlsl_alloc(ctx, sizeof(*interlocked))))
+        return NULL;
+
+    init_node(&interlocked->node, HLSL_IR_INTERLOCKED, type, loc);
+    interlocked->op = op;
+    hlsl_copy_deref(ctx, &interlocked->dst, dst);
+    hlsl_src_from_node(&interlocked->coords, coords);
+    hlsl_src_from_node(&interlocked->cmp_value, cmp_value);
+    hlsl_src_from_node(&interlocked->value, value);
+
+    return &interlocked->node;
+}
+
 bool hlsl_index_is_noncontiguous(struct hlsl_ir_index *index)
 {
     struct hlsl_type *type = index->val.node->data_type;
@@ -2375,6 +2394,27 @@ static struct hlsl_ir_node *clone_index(struct hlsl_ctx *ctx, struct clone_instr
     return dst;
 }
 
+static struct hlsl_ir_node *clone_interlocked(struct hlsl_ctx *ctx,
+        struct clone_instr_map *map, struct hlsl_ir_interlocked *src)
+{
+    struct hlsl_ir_interlocked *dst;
+
+    if (!(dst = hlsl_alloc(ctx, sizeof(*dst))))
+        return NULL;
+    init_node(&dst->node, HLSL_IR_INTERLOCKED, NULL, &src->node.loc);
+    dst->op = src->op;
+
+    if (!clone_deref(ctx, map, &dst->dst, &src->dst))
+    {
+        vkd3d_free(dst);
+        return NULL;
+    }
+    clone_src(map, &dst->coords, &src->coords);
+    clone_src(map, &dst->cmp_value, &src->cmp_value);
+    clone_src(map, &dst->value, &src->value);
+    return &dst->node;
+}
+
 static struct hlsl_ir_node *clone_compile(struct hlsl_ctx *ctx,
         struct clone_instr_map *map, struct hlsl_ir_compile *compile)
 {
@@ -2575,6 +2615,9 @@ static struct hlsl_ir_node *clone_instr(struct hlsl_ctx *ctx,
         case HLSL_IR_SWIZZLE:
             return clone_swizzle(ctx, map, hlsl_ir_swizzle(instr));
 
+        case HLSL_IR_INTERLOCKED:
+            return clone_interlocked(ctx, map, hlsl_ir_interlocked(instr));
+
         case HLSL_IR_COMPILE:
             return clone_compile(ctx, map, hlsl_ir_compile(instr));
 
@@ -3013,6 +3056,7 @@ const char *hlsl_node_type_to_string(enum hlsl_ir_node_type type)
         [HLSL_IR_STORE          ] = "HLSL_IR_STORE",
         [HLSL_IR_SWITCH         ] = "HLSL_IR_SWITCH",
         [HLSL_IR_SWIZZLE        ] = "HLSL_IR_SWIZZLE",
+        [HLSL_IR_INTERLOCKED    ] = "HLSL_IR_INTERLOCKED",
 
         [HLSL_IR_COMPILE]             = "HLSL_IR_COMPILE",
         [HLSL_IR_SAMPLER_STATE]       = "HLSL_IR_SAMPLER_STATE",
@@ -3458,6 +3502,35 @@ static void dump_ir_index(struct vkd3d_string_buffer *buffer, const struct hlsl_
     vkd3d_string_buffer_printf(buffer, "]");
 }
 
+static void dump_ir_interlocked(struct vkd3d_string_buffer *buffer, const struct hlsl_ir_interlocked *interlocked)
+{
+    static const char *const op_names[] =
+    {
+        [HLSL_INTERLOCKED_ADD] = "add",
+        [HLSL_INTERLOCKED_AND] = "and",
+        [HLSL_INTERLOCKED_CMP_EXCH] = "cmp_exch",
+        [HLSL_INTERLOCKED_EXCH] = "exch",
+        [HLSL_INTERLOCKED_MAX] = "max",
+        [HLSL_INTERLOCKED_MIN] = "min",
+        [HLSL_INTERLOCKED_OR] = "or",
+        [HLSL_INTERLOCKED_XOR] = "xor",
+    };
+
+    VKD3D_ASSERT(interlocked->op < ARRAY_SIZE(op_names));
+    vkd3d_string_buffer_printf(buffer, "interlocked_%s(dst = ", op_names[interlocked->op]);
+    dump_deref(buffer, &interlocked->dst);
+    vkd3d_string_buffer_printf(buffer, ", coords = ");
+    dump_src(buffer, &interlocked->coords);
+    if (interlocked->cmp_value.node)
+    {
+        vkd3d_string_buffer_printf(buffer, ", cmp_value = ");
+        dump_src(buffer, &interlocked->cmp_value);
+    }
+    vkd3d_string_buffer_printf(buffer, ", value = ");
+    dump_src(buffer, &interlocked->value);
+    vkd3d_string_buffer_printf(buffer, ")");
+}
+
 static void dump_ir_compile(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer,
         const struct hlsl_ir_compile *compile)
 {
@@ -3591,6 +3664,10 @@ static void dump_instr(struct hlsl_ctx *ctx, struct vkd3d_string_buffer *buffer,
             dump_ir_swizzle(buffer, hlsl_ir_swizzle(instr));
             break;
 
+        case HLSL_IR_INTERLOCKED:
+            dump_ir_interlocked(buffer, hlsl_ir_interlocked(instr));
+            break;
+
         case HLSL_IR_COMPILE:
             dump_ir_compile(ctx, buffer, hlsl_ir_compile(instr));
             break;
@@ -3819,6 +3896,15 @@ static void free_ir_index(struct hlsl_ir_index *index)
     vkd3d_free(index);
 }
 
+static void free_ir_interlocked(struct hlsl_ir_interlocked *interlocked)
+{
+    hlsl_cleanup_deref(&interlocked->dst);
+    hlsl_src_remove(&interlocked->coords);
+    hlsl_src_remove(&interlocked->cmp_value);
+    hlsl_src_remove(&interlocked->value);
+    vkd3d_free(interlocked);
+}
+
 static void free_ir_compile(struct hlsl_ir_compile *compile)
 {
     unsigned int i;
@@ -3905,6 +3991,10 @@ void hlsl_free_instr(struct hlsl_ir_node *node)
             free_ir_switch(hlsl_ir_switch(node));
             break;
 
+        case HLSL_IR_INTERLOCKED:
+            free_ir_interlocked(hlsl_ir_interlocked(node));
+            break;
+
         case HLSL_IR_COMPILE:
             free_ir_compile(hlsl_ir_compile(node));
             break;
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index 4d78dbebb34..e9845f8f887 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -319,6 +319,7 @@ enum hlsl_ir_node_type
     HLSL_IR_STORE,
     HLSL_IR_SWIZZLE,
     HLSL_IR_SWITCH,
+    HLSL_IR_INTERLOCKED,
 
     HLSL_IR_COMPILE,
     HLSL_IR_SAMPLER_STATE,
@@ -950,6 +951,32 @@ struct hlsl_ir_stateblock_constant
     char *name;
 };
 
+enum hlsl_interlocked_op
+{
+    HLSL_INTERLOCKED_ADD,
+    HLSL_INTERLOCKED_AND,
+    HLSL_INTERLOCKED_CMP_EXCH,
+    HLSL_INTERLOCKED_EXCH,
+    HLSL_INTERLOCKED_MAX,
+    HLSL_INTERLOCKED_MIN,
+    HLSL_INTERLOCKED_OR,
+    HLSL_INTERLOCKED_XOR,
+};
+
+/* Represents an interlocked operation.
+ *
+ * The data_type of the node indicates whether or not the original value is returned.
+ * If the original value is not returned, the data_type is set to NULL.
+ * Otherwise, the data_type is set to the type of the original value.
+ */
+struct hlsl_ir_interlocked
+{
+    struct hlsl_ir_node node;
+    enum hlsl_interlocked_op op;
+    struct hlsl_deref dst;
+    struct hlsl_src coords, cmp_value, value;
+};
+
 struct hlsl_scope
 {
     /* Item entry for hlsl_ctx.scopes. */
@@ -1247,6 +1274,12 @@ static inline struct hlsl_ir_switch *hlsl_ir_switch(const struct hlsl_ir_node *n
     return CONTAINING_RECORD(node, struct hlsl_ir_switch, node);
 }
 
+static inline struct hlsl_ir_interlocked *hlsl_ir_interlocked(const struct hlsl_ir_node *node)
+{
+    VKD3D_ASSERT(node->type == HLSL_IR_INTERLOCKED);
+    return CONTAINING_RECORD(node, struct hlsl_ir_interlocked, node);
+}
+
 static inline struct hlsl_ir_compile *hlsl_ir_compile(const struct hlsl_ir_node *node)
 {
     VKD3D_ASSERT(node->type == HLSL_IR_COMPILE);
@@ -1554,6 +1587,9 @@ struct hlsl_ir_node *hlsl_new_compile(struct hlsl_ctx *ctx, enum hlsl_compile_ty
         struct hlsl_block *args_instrs, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_index(struct hlsl_ctx *ctx, struct hlsl_ir_node *val,
         struct hlsl_ir_node *idx, const struct vkd3d_shader_location *loc);
+struct hlsl_ir_node *hlsl_new_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op op, struct hlsl_type *type,
+        const struct hlsl_deref *dst, struct hlsl_ir_node *coords, struct hlsl_ir_node *cmp_value,
+        struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_node *hlsl_new_loop(struct hlsl_ctx *ctx, struct hlsl_block *iter,
         struct hlsl_block *block, enum hlsl_loop_unroll_type unroll_type,
         unsigned int unroll_limit, const struct vkd3d_shader_location *loc);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index e5a03067d16..da2f482b148 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -667,6 +667,7 @@ static struct hlsl_default_value evaluate_static_expression(struct hlsl_ctx *ctx
             case HLSL_IR_RESOURCE_LOAD:
             case HLSL_IR_RESOURCE_STORE:
             case HLSL_IR_SWITCH:
+            case HLSL_IR_INTERLOCKED:
             case HLSL_IR_STATEBLOCK_CONSTANT:
                 hlsl_error(ctx, &node->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
                         "Expected literal expression.");
@@ -1322,6 +1323,11 @@ static bool add_func_parameter(struct hlsl_ctx *ctx, struct hlsl_func_parameters
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
                 "Parameter '%s' is declared as both \"out\" and \"uniform\".", param->name);
 
+    if ((param->modifiers & HLSL_STORAGE_OUT) && !(param->modifiers & HLSL_STORAGE_IN)
+            && (param->type->modifiers & HLSL_MODIFIER_CONST))
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_MODIFIER,
+                "Parameter '%s' is declared as both \"out\" and \"const\".", param->name);
+
     if (param->reg_reservation.offset_type)
         hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_RESERVATION,
                 "packoffset() is not allowed on function parameters.");
@@ -5374,6 +5380,185 @@ static bool intrinsic_GetRenderTargetSampleCount(struct hlsl_ctx *ctx,
     return true;
 }
 
+static bool intrinsic_interlocked(struct hlsl_ctx *ctx, enum hlsl_interlocked_op op,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc, const char *name)
+{
+    struct hlsl_ir_node *lhs, *coords, *val, *cmp_val = NULL, *orig_val = NULL;
+    struct hlsl_ir_node *interlocked, *void_ret;
+    struct hlsl_type *lhs_type, *val_type;
+    struct vkd3d_string_buffer *string;
+    struct hlsl_deref dst_deref;
+
+    if (hlsl_version_lt(ctx, 5, 0))
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
+                "Interlocked functions can only be used in shader model 5.0 or higher.");
+
+    if (op != HLSL_INTERLOCKED_CMP_EXCH && op != HLSL_INTERLOCKED_EXCH
+            && params->args_count != 2 && params->args_count != 3)
+    {
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_WRONG_PARAMETER_COUNT,
+                "Unexpected number of arguments to function '%s': expected 2 or 3, but got %u.",
+                        name, params->args_count);
+        return false;
+    }
+
+    lhs = params->args[0];
+    lhs_type = lhs->data_type;
+
+    if (op == HLSL_INTERLOCKED_CMP_EXCH)
+    {
+        cmp_val = params->args[1];
+        val = params->args[2];
+        if (params->args_count == 4)
+            orig_val = params->args[3];
+    }
+    else
+    {
+        val = params->args[1];
+        if (params->args_count == 3)
+            orig_val = params->args[2];
+    }
+
+    if (lhs_type->class != HLSL_CLASS_SCALAR || (lhs_type->e.numeric.type != HLSL_TYPE_UINT
+            && lhs_type->e.numeric.type != HLSL_TYPE_INT))
+    {
+        if ((string = hlsl_type_to_string(ctx, lhs_type)))
+        {
+            hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "Unexpected type for argument 0 of '%s': expected 'uint' or 'int', but got '%s'.",
+                    name, string->buffer);
+            hlsl_release_string_buffer(ctx, string);
+        }
+        return false;
+    }
+
+    /* Interlocked*() functions always take uint for the value parameters,
+     * except for InterlockedMax()/InterlockedMin(). */
+    if (op == HLSL_INTERLOCKED_MAX || op == HLSL_INTERLOCKED_MIN)
+    {
+        enum hlsl_base_type val_base_type = val->data_type->e.numeric.type;
+
+        /* Floating values are always cast to signed integers. */
+        if (val_base_type == HLSL_TYPE_FLOAT || val_base_type == HLSL_TYPE_HALF || val_base_type == HLSL_TYPE_DOUBLE)
+            val_type = hlsl_get_scalar_type(ctx, HLSL_TYPE_INT);
+        else
+            val_type = hlsl_get_scalar_type(ctx, lhs_type->e.numeric.type);
+    }
+    else
+    {
+        val_type = hlsl_get_scalar_type(ctx, HLSL_TYPE_UINT);
+    }
+
+    if (cmp_val && !(cmp_val = add_implicit_conversion(ctx, params->instrs, cmp_val, val_type, loc)))
+        return false;
+    if (!(val = add_implicit_conversion(ctx, params->instrs, val, val_type, loc)))
+        return false;
+
+    /* TODO: groupshared variables */
+    if (lhs->type == HLSL_IR_INDEX && hlsl_index_chain_has_resource_access(hlsl_ir_index(lhs)))
+    {
+        if (!hlsl_index_is_resource_access(hlsl_ir_index(lhs)))
+        {
+            hlsl_fixme(ctx, &lhs->loc, "Non-direct structured resource interlocked targets.");
+            return false;
+        }
+
+        if (!hlsl_init_deref_from_index_chain(ctx, &dst_deref, hlsl_ir_index(lhs)->val.node))
+            return false;
+        coords = hlsl_ir_index(lhs)->idx.node;
+
+        VKD3D_ASSERT(coords->data_type->class == HLSL_CLASS_VECTOR);
+        VKD3D_ASSERT(coords->data_type->e.numeric.type == HLSL_TYPE_UINT);
+
+        if (hlsl_deref_get_type(ctx, &dst_deref)->class != HLSL_CLASS_UAV)
+        {
+            hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Interlocked targets must be UAV elements.");
+            return false;
+        }
+    }
+    else
+    {
+        hlsl_error(ctx, loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE, "Interlocked targets must be UAV elements.");
+        return false;
+    }
+
+    interlocked = hlsl_new_interlocked(ctx, op, orig_val ? lhs_type : NULL, &dst_deref, coords, cmp_val, val, loc);
+    hlsl_cleanup_deref(&dst_deref);
+    if (!interlocked)
+        return false;
+    hlsl_block_add_instr(params->instrs, interlocked);
+
+    if (orig_val)
+    {
+        if (orig_val->data_type->modifiers & HLSL_MODIFIER_CONST)
+            hlsl_error(ctx, &orig_val->loc, VKD3D_SHADER_ERROR_HLSL_MODIFIES_CONST,
+                    "Output argument to '%s' is const.", name);
+
+        if (!add_assignment(ctx, params->instrs, orig_val, ASSIGN_OP_ASSIGN, interlocked))
+            return false;
+    }
+
+    if (!(void_ret = hlsl_new_void_expr(ctx, loc)))
+        return false;
+    hlsl_block_add_instr(params->instrs, void_ret);
+
+    return true;
+}
+
+static bool intrinsic_InterlockedAdd(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_ADD, params, loc, "InterlockedAdd");
+}
+
+static bool intrinsic_InterlockedAnd(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_AND, params, loc, "InterlockedAnd");
+}
+
+static bool intrinsic_InterlockedCompareExchange(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_CMP_EXCH, params, loc, "InterlockedCompareExchange");
+}
+
+static bool intrinsic_InterlockedCompareStore(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_CMP_EXCH, params, loc, "InterlockedCompareStore");
+}
+
+static bool intrinsic_InterlockedExchange(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_EXCH, params, loc, "InterlockedExchange");
+}
+
+static bool intrinsic_InterlockedMax(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_MAX, params, loc, "InterlockedMax");
+}
+
+static bool intrinsic_InterlockedMin(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_MIN, params, loc, "InterlockedMin");
+}
+
+static bool intrinsic_InterlockedOr(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_OR, params, loc, "InterlockedOr");
+}
+
+static bool intrinsic_InterlockedXor(struct hlsl_ctx *ctx,
+        const struct parse_initializer *params, const struct vkd3d_shader_location *loc)
+{
+    return intrinsic_interlocked(ctx, HLSL_INTERLOCKED_XOR, params, loc, "InterlockedXor");
+}
+
 static const struct intrinsic_function
 {
     const char *name;
@@ -5387,6 +5572,15 @@ intrinsic_functions[] =
     /* Note: these entries should be kept in alphabetical order. */
     {"D3DCOLORtoUBYTE4",                    1, true,  intrinsic_d3dcolor_to_ubyte4},
     {"GetRenderTargetSampleCount",          0, true,  intrinsic_GetRenderTargetSampleCount},
+    {"InterlockedAdd",                     -1, true,  intrinsic_InterlockedAdd},
+    {"InterlockedAnd",                     -1, true,  intrinsic_InterlockedAnd},
+    {"InterlockedCompareExchange",          4, true,  intrinsic_InterlockedCompareExchange},
+    {"InterlockedCompareStore",             3, true,  intrinsic_InterlockedCompareStore},
+    {"InterlockedExchange",                 3, true,  intrinsic_InterlockedExchange},
+    {"InterlockedMax",                     -1, true,  intrinsic_InterlockedMax},
+    {"InterlockedMin",                     -1, true,  intrinsic_InterlockedMin},
+    {"InterlockedOr",                      -1, true,  intrinsic_InterlockedOr},
+    {"InterlockedXor",                     -1, true,  intrinsic_InterlockedXor},
     {"abs",                                 1, true,  intrinsic_abs},
     {"acos",                                1, true,  intrinsic_acos},
     {"all",                                 1, true,  intrinsic_all},
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index cef6a87c8b6..8d817b051ce 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -739,6 +739,10 @@ static bool transform_instr_derefs(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
             res = func(ctx, &hlsl_ir_resource_store(instr)->resource, instr);
             return res;
 
+        case HLSL_IR_INTERLOCKED:
+            res = func(ctx, &hlsl_ir_interlocked(instr)->dst, instr);
+            return res;
+
         default:
             return false;
     }
@@ -1836,6 +1840,15 @@ static bool copy_propagation_transform_resource_store(struct hlsl_ctx *ctx,
     return progress;
 }
 
+static bool copy_propagation_transform_interlocked(struct hlsl_ctx *ctx,
+        struct hlsl_ir_interlocked *interlocked, struct copy_propagation_state *state)
+{
+    bool progress = false;
+
+    progress |= copy_propagation_transform_object_load(ctx, &interlocked->dst, state, interlocked->node.index);
+    return progress;
+}
+
 static void copy_propagation_record_store(struct hlsl_ctx *ctx, struct hlsl_ir_store *store,
         struct copy_propagation_state *state)
 {
@@ -2042,6 +2055,9 @@ static bool copy_propagation_transform_block(struct hlsl_ctx *ctx, struct hlsl_b
                 progress |= copy_propagation_process_switch(ctx, hlsl_ir_switch(instr), state);
                 break;
 
+            case HLSL_IR_INTERLOCKED:
+                progress |= copy_propagation_transform_interlocked(ctx, hlsl_ir_interlocked(instr), state);
+
             default:
                 break;
         }
@@ -2225,6 +2241,24 @@ static bool validate_dereferences(struct hlsl_ctx *ctx, struct hlsl_ir_node *ins
             validate_component_index_range_from_deref(ctx, &store->lhs);
             break;
         }
+        case HLSL_IR_INTERLOCKED:
+        {
+            struct hlsl_ir_interlocked *interlocked = hlsl_ir_interlocked(instr);
+
+            if (!interlocked->dst.var->is_uniform)
+            {
+                hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_NON_STATIC_OBJECT_REF,
+                        "Accessed resource must have a single uniform source.");
+            }
+            else if (validate_component_index_range_from_deref(ctx, &interlocked->dst) == DEREF_VALIDATION_NOT_CONSTANT)
+            {
+                hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_NON_STATIC_OBJECT_REF,
+                        "Accessed resource from \"%s\" must be determinable at compile time.",
+                        interlocked->dst.var->name);
+                note_non_static_deref_expressions(ctx, &interlocked->dst, "accessed resource");
+            }
+            break;
+        }
         default:
             break;
     }
@@ -4478,6 +4512,7 @@ static bool dce(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
         case HLSL_IR_LOOP:
         case HLSL_IR_RESOURCE_STORE:
         case HLSL_IR_SWITCH:
+        case HLSL_IR_INTERLOCKED:
             break;
         case HLSL_IR_STATEBLOCK_CONSTANT:
             /* Stateblock constants should not appear in the shader program. */
@@ -4724,6 +4759,19 @@ static void compute_liveness_recurse(struct hlsl_block *block, unsigned int loop
             index->idx.node->last_read = last_read;
             break;
         }
+        case HLSL_IR_INTERLOCKED:
+        {
+            struct hlsl_ir_interlocked *interlocked = hlsl_ir_interlocked(instr);
+
+            var = interlocked->dst.var;
+            var->last_read = max(var->last_read, last_read);
+            deref_mark_last_read(&interlocked->dst, last_read);
+            interlocked->coords.node->last_read = last_read;
+            interlocked->value.node->last_read = last_read;
+            if (interlocked->cmp_value.node)
+                interlocked->cmp_value.node->last_read = last_read;
+            break;
+        }
         case HLSL_IR_JUMP:
         {
             struct hlsl_ir_jump *jump = hlsl_ir_jump(instr);
@@ -5135,6 +5183,10 @@ static bool track_components_usage(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
             register_deref_usage(ctx, &hlsl_ir_resource_store(instr)->resource);
             break;
 
+        case HLSL_IR_INTERLOCKED:
+            register_deref_usage(ctx, &hlsl_ir_interlocked(instr)->dst);
+            break;
+
         default:
             break;
     }
@@ -9942,6 +9994,81 @@ static bool sm4_generate_vsir_instr_resource_load(struct hlsl_ctx *ctx,
     }
 }
 
+static bool sm4_generate_vsir_instr_interlocked(struct hlsl_ctx *ctx,
+        struct vsir_program *program, struct hlsl_ir_interlocked *interlocked)
+{
+
+    static const enum vkd3d_shader_opcode opcodes[] =
+    {
+        [HLSL_INTERLOCKED_ADD] = VKD3DSIH_ATOMIC_IADD,
+        [HLSL_INTERLOCKED_AND] = VKD3DSIH_ATOMIC_AND,
+        [HLSL_INTERLOCKED_CMP_EXCH] = VKD3DSIH_ATOMIC_CMP_STORE,
+        [HLSL_INTERLOCKED_MAX] = VKD3DSIH_ATOMIC_UMAX,
+        [HLSL_INTERLOCKED_MIN] = VKD3DSIH_ATOMIC_UMIN,
+        [HLSL_INTERLOCKED_OR] = VKD3DSIH_ATOMIC_OR,
+        [HLSL_INTERLOCKED_XOR] = VKD3DSIH_ATOMIC_XOR,
+    };
+
+    static const enum vkd3d_shader_opcode imm_opcodes[] =
+    {
+        [HLSL_INTERLOCKED_ADD] = VKD3DSIH_IMM_ATOMIC_IADD,
+        [HLSL_INTERLOCKED_AND] = VKD3DSIH_IMM_ATOMIC_AND,
+        [HLSL_INTERLOCKED_CMP_EXCH] = VKD3DSIH_IMM_ATOMIC_CMP_EXCH,
+        [HLSL_INTERLOCKED_EXCH] = VKD3DSIH_IMM_ATOMIC_EXCH,
+        [HLSL_INTERLOCKED_MAX] = VKD3DSIH_IMM_ATOMIC_UMAX,
+        [HLSL_INTERLOCKED_MIN] = VKD3DSIH_IMM_ATOMIC_UMIN,
+        [HLSL_INTERLOCKED_OR] = VKD3DSIH_IMM_ATOMIC_OR,
+        [HLSL_INTERLOCKED_XOR] = VKD3DSIH_IMM_ATOMIC_XOR,
+    };
+
+    struct hlsl_ir_node *cmp_value = interlocked->cmp_value.node, *value = interlocked->value.node;
+    struct hlsl_ir_node *coords = interlocked->coords.node;
+    struct hlsl_ir_node *instr = &interlocked->node;
+    bool is_imm = interlocked->node.reg.allocated;
+    struct vkd3d_shader_dst_param *dst_param;
+    struct vkd3d_shader_instruction *ins;
+    enum vkd3d_shader_opcode opcode;
+
+    opcode = is_imm ? imm_opcodes[interlocked->op] : opcodes[interlocked->op];
+
+    if (value->data_type->e.numeric.type == HLSL_TYPE_INT)
+    {
+        if (opcode == VKD3DSIH_ATOMIC_UMAX)
+            opcode = VKD3DSIH_ATOMIC_IMAX;
+        else if (opcode == VKD3DSIH_ATOMIC_UMIN)
+            opcode = VKD3DSIH_ATOMIC_IMIN;
+        else if (opcode == VKD3DSIH_IMM_ATOMIC_UMAX)
+            opcode = VKD3DSIH_IMM_ATOMIC_IMAX;
+        else if (opcode == VKD3DSIH_IMM_ATOMIC_UMIN)
+            opcode = VKD3DSIH_IMM_ATOMIC_IMIN;
+    }
+
+    if (!(ins = generate_vsir_add_program_instruction(ctx, program, &instr->loc, opcode,
+            is_imm ? 2 : 1, cmp_value ? 3 : 2)))
+        return false;
+
+    if (is_imm)
+        vsir_dst_from_hlsl_node(&ins->dst[0], ctx, instr);
+
+    dst_param = is_imm ? &ins->dst[1] : &ins->dst[0];
+    if (!sm4_generate_vsir_init_dst_param_from_deref(ctx, program, dst_param, &interlocked->dst, &instr->loc, 0))
+        return false;
+    dst_param->reg.dimension = VSIR_DIMENSION_NONE;
+
+    vsir_src_from_hlsl_node(&ins->src[0], ctx, coords, VKD3DSP_WRITEMASK_ALL);
+    if (cmp_value)
+    {
+        vsir_src_from_hlsl_node(&ins->src[1], ctx, cmp_value, VKD3DSP_WRITEMASK_ALL);
+        vsir_src_from_hlsl_node(&ins->src[2], ctx, value, VKD3DSP_WRITEMASK_ALL);
+    }
+    else
+    {
+        vsir_src_from_hlsl_node(&ins->src[1], ctx, value, VKD3DSP_WRITEMASK_ALL);
+    }
+
+    return true;
+}
+
 static bool sm4_generate_vsir_instr_jump(struct hlsl_ctx *ctx,
         struct vsir_program *program, const struct hlsl_ir_jump *jump)
 {
@@ -10119,6 +10246,10 @@ static void sm4_generate_vsir_block(struct hlsl_ctx *ctx, struct hlsl_block *blo
                 generate_vsir_instr_swizzle(ctx, program, hlsl_ir_swizzle(instr));
                 break;
 
+            case HLSL_IR_INTERLOCKED:
+                sm4_generate_vsir_instr_interlocked(ctx, program, hlsl_ir_interlocked(instr));
+                break;
+
             default:
                 break;
         }
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index efa76983546..b1caf61d512 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -10923,7 +10923,8 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler, struct
     compiler->input_control_point_count = program->input_control_point_count;
     compiler->output_control_point_count = program->output_control_point_count;
 
-    if (program->shader_version.type == VKD3D_SHADER_TYPE_HULL && !spirv_compiler_is_opengl_target(compiler))
+    if (program->shader_version.type == VKD3D_SHADER_TYPE_DOMAIN
+            || (program->shader_version.type == VKD3D_SHADER_TYPE_HULL && !spirv_compiler_is_opengl_target(compiler)))
         spirv_compiler_emit_tessellator_domain(compiler, program->tess_domain);
 
     if (compiler->shader_type != VKD3D_SHADER_TYPE_HULL)
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index aa666086710..1ecfe32de45 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -4026,6 +4026,15 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
             break;
 
         case VKD3DSIH_ADD:
+        case VKD3DSIH_ATOMIC_AND:
+        case VKD3DSIH_ATOMIC_CMP_STORE:
+        case VKD3DSIH_ATOMIC_IADD:
+        case VKD3DSIH_ATOMIC_IMAX:
+        case VKD3DSIH_ATOMIC_IMIN:
+        case VKD3DSIH_ATOMIC_UMAX:
+        case VKD3DSIH_ATOMIC_UMIN:
+        case VKD3DSIH_ATOMIC_OR:
+        case VKD3DSIH_ATOMIC_XOR:
         case VKD3DSIH_AND:
         case VKD3DSIH_BREAK:
         case VKD3DSIH_CASE:
@@ -4068,6 +4077,16 @@ static void tpf_handle_instruction(struct tpf_compiler *tpf, const struct vkd3d_
         case VKD3DSIH_IMAD:
         case VKD3DSIH_IMAX:
         case VKD3DSIH_IMIN:
+        case VKD3DSIH_IMM_ATOMIC_AND:
+        case VKD3DSIH_IMM_ATOMIC_CMP_EXCH:
+        case VKD3DSIH_IMM_ATOMIC_EXCH:
+        case VKD3DSIH_IMM_ATOMIC_IADD:
+        case VKD3DSIH_IMM_ATOMIC_IMAX:
+        case VKD3DSIH_IMM_ATOMIC_IMIN:
+        case VKD3DSIH_IMM_ATOMIC_UMAX:
+        case VKD3DSIH_IMM_ATOMIC_UMIN:
+        case VKD3DSIH_IMM_ATOMIC_OR:
+        case VKD3DSIH_IMM_ATOMIC_XOR:
         case VKD3DSIH_IMUL:
         case VKD3DSIH_INE:
         case VKD3DSIH_INEG:
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index 6c7bf167910..ce0c3b9128f 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -327,9 +327,12 @@ static void *vkd3d_fence_worker_main(void *arg)
     struct vkd3d_waiting_fence *old_fences, *cur_fences = NULL;
     struct vkd3d_fence_worker *worker = arg;
     unsigned int i;
+    bool timeline;
 
     vkd3d_set_thread_name("vkd3d_fence");
 
+    timeline = worker->device->vk_info.KHR_timeline_semaphore;
+
     for (;;)
     {
         vkd3d_mutex_lock(&worker->mutex);
@@ -357,7 +360,12 @@ static void *vkd3d_fence_worker_main(void *arg)
         vkd3d_mutex_unlock(&worker->mutex);
 
         for (i = 0; i < cur_fence_count; ++i)
-            worker->wait_for_gpu_fence(worker, &cur_fences[i]);
+        {
+            if (timeline)
+                vkd3d_wait_for_gpu_timeline_semaphore(worker, &cur_fences[i]);
+            else
+                vkd3d_wait_for_gpu_fence(worker, &cur_fences[i]);
+        }
     }
 
     vkd3d_free(cur_fences);
@@ -379,9 +387,6 @@ static HRESULT vkd3d_fence_worker_start(struct vkd3d_fence_worker *worker,
     worker->fences = NULL;
     worker->fences_size = 0;
 
-    worker->wait_for_gpu_fence = device->vk_info.KHR_timeline_semaphore
-            ? vkd3d_wait_for_gpu_timeline_semaphore : vkd3d_wait_for_gpu_fence;
-
     vkd3d_mutex_init(&worker->mutex);
 
     vkd3d_cond_init(&worker->cond);
@@ -399,6 +404,7 @@ static HRESULT vkd3d_fence_worker_start(struct vkd3d_fence_worker *worker,
 static HRESULT vkd3d_fence_worker_stop(struct vkd3d_fence_worker *worker,
         struct d3d12_device *device)
 {
+    unsigned int i;
     HRESULT hr;
 
     TRACE("worker %p.\n", worker);
@@ -416,6 +422,9 @@ static HRESULT vkd3d_fence_worker_stop(struct vkd3d_fence_worker *worker,
     vkd3d_mutex_destroy(&worker->mutex);
     vkd3d_cond_destroy(&worker->cond);
 
+    for (i = 0; i < worker->fence_count; ++i)
+        d3d12_fence_decref(worker->fences[i].fence);
+
     vkd3d_free(worker->fences);
 
     return S_OK;
@@ -556,7 +565,8 @@ static void d3d12_fence_destroy_vk_objects(struct d3d12_fence *fence)
         fence->old_vk_fences[i] = VK_NULL_HANDLE;
     }
 
-    d3d12_fence_garbage_collect_vk_semaphores_locked(fence, true);
+    if (!device->vk_info.KHR_timeline_semaphore)
+        d3d12_fence_garbage_collect_vk_semaphores_locked(fence, true);
     VK_CALL(vkDestroySemaphore(device->vk_device, fence->timeline_semaphore, NULL));
 
     vkd3d_mutex_unlock(&fence->mutex);
@@ -6450,6 +6460,7 @@ static void d3d12_command_queue_destroy_op(struct vkd3d_cs_op_data *op)
             break;
 
         case VKD3D_CS_OP_SIGNAL:
+        case VKD3D_CS_OP_SIGNAL_ON_CPU:
             d3d12_fence_decref(op->u.signal.fence);
             break;
 
@@ -7440,6 +7451,7 @@ static HRESULT d3d12_command_queue_flush_ops_locked(struct d3d12_command_queue *
     struct vkd3d_cs_op_data *op;
     struct d3d12_fence *fence;
     unsigned int i;
+    HRESULT hr;
 
     queue->is_flushing = true;
 
@@ -7473,6 +7485,11 @@ static HRESULT d3d12_command_queue_flush_ops_locked(struct d3d12_command_queue *
                     d3d12_command_queue_signal(queue, op->u.signal.fence, op->u.signal.value);
                     break;
 
+                case VKD3D_CS_OP_SIGNAL_ON_CPU:
+                    if (FAILED(hr = d3d12_fence_Signal(&op->u.signal.fence->ID3D12Fence1_iface, op->u.signal.value)))
+                        ERR("Failed to signal fence %p, hr %s.\n", op->u.signal.fence, debugstr_hresult(hr));
+                    break;
+
                 case VKD3D_CS_OP_EXECUTE:
                     d3d12_command_queue_execute(queue, op->u.execute.buffers, op->u.execute.buffer_count);
                     break;
@@ -7615,6 +7632,36 @@ void vkd3d_release_vk_queue(ID3D12CommandQueue *queue)
     return vkd3d_queue_release(d3d12_queue->vkd3d_queue);
 }
 
+HRESULT vkd3d_queue_signal_on_cpu(ID3D12CommandQueue *iface, ID3D12Fence *fence_iface, uint64_t value)
+{
+    struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
+    struct d3d12_fence *fence = unsafe_impl_from_ID3D12Fence(fence_iface);
+    struct vkd3d_cs_op_data *op;
+    HRESULT hr = S_OK;
+
+    TRACE("iface %p, fence %p, value %#"PRIx64".\n", iface, fence_iface, value);
+
+    vkd3d_mutex_lock(&command_queue->op_mutex);
+
+    if (!(op = d3d12_command_queue_op_array_require_space(&command_queue->op_queue)))
+    {
+        ERR("Failed to add op.\n");
+        hr = E_OUTOFMEMORY;
+        goto done;
+    }
+    op->opcode = VKD3D_CS_OP_SIGNAL_ON_CPU;
+    op->u.signal.fence = fence;
+    op->u.signal.value = value;
+
+    d3d12_fence_incref(fence);
+
+    d3d12_command_queue_submit_locked(command_queue);
+
+done:
+    vkd3d_mutex_unlock(&command_queue->op_mutex);
+    return hr;
+}
+
 /* ID3D12CommandSignature */
 static inline struct d3d12_command_signature *impl_from_ID3D12CommandSignature(ID3D12CommandSignature *iface)
 {
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index 9aa4adb6c06..b51e2963efa 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -3557,12 +3557,6 @@ static HRESULT STDMETHODCALLTYPE d3d12_device_CheckFeatureSupport(ID3D12Device9
                 return E_INVALIDARG;
             }
 
-            if (data->Format == DXGI_FORMAT_UNKNOWN)
-            {
-                data->PlaneCount = 1;
-                return S_OK;
-            }
-
             if (!(format = vkd3d_get_format(device, data->Format, false)))
                 format = vkd3d_get_format(device, data->Format, true);
             if (!format)
@@ -4368,7 +4362,7 @@ static void d3d12_device_get_resource1_allocation_info(struct d3d12_device *devi
     {
         desc = &resource_descs[i];
 
-        if (FAILED(d3d12_resource_validate_desc(desc, device)))
+        if (FAILED(d3d12_resource_validate_desc(desc, device, 0)))
         {
             WARN("Invalid resource desc.\n");
             goto invalid;
@@ -4699,10 +4693,11 @@ static void d3d12_device_get_copyable_footprints(struct d3d12_device *device,
         uint64_t base_offset, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *layouts, UINT *row_counts,
         UINT64 *row_sizes, UINT64 *total_bytes)
 {
-    unsigned int i, sub_resource_idx, miplevel_idx, row_count, row_size, row_pitch;
+    unsigned int i, sub_resource_idx, plane_idx, miplevel_idx, row_count, row_size, row_pitch;
     unsigned int width, height, depth, plane_count, sub_resources_per_plane;
     const struct vkd3d_format *format;
     uint64_t offset, size, total;
+    DXGI_FORMAT plane_format;
 
     if (layouts)
         memset(layouts, 0xff, sizeof(*layouts) * sub_resource_count);
@@ -4713,20 +4708,19 @@ static void d3d12_device_get_copyable_footprints(struct d3d12_device *device,
     if (total_bytes)
         *total_bytes = ~(uint64_t)0;
 
-    if (!(format = vkd3d_format_from_d3d12_resource_desc(device, desc, 0)))
+    if (!(format = vkd3d_get_format(device, desc->Format, true)))
     {
         WARN("Invalid format %#x.\n", desc->Format);
         return;
     }
 
-    if (FAILED(d3d12_resource_validate_desc(desc, device)))
+    if (FAILED(d3d12_resource_validate_desc(desc, device, VKD3D_VALIDATE_FORCE_ALLOW_DS)))
     {
         WARN("Invalid resource desc.\n");
         return;
     }
 
-    plane_count = ((format->vk_aspect_mask & VK_IMAGE_ASPECT_DEPTH_BIT)
-            && (format->vk_aspect_mask & VK_IMAGE_ASPECT_STENCIL_BIT)) ? 2 : 1;
+    plane_count = format->plane_count;
     sub_resources_per_plane = d3d12_resource_desc_get_sub_resource_count(desc);
 
     if (!vkd3d_bound_range(first_sub_resource, sub_resource_count, sub_resources_per_plane * plane_count))
@@ -4737,21 +4731,31 @@ static void d3d12_device_get_copyable_footprints(struct d3d12_device *device,
 
     offset = 0;
     total = 0;
+    plane_format = desc->Format;
     for (i = 0; i < sub_resource_count; ++i)
     {
         sub_resource_idx = (first_sub_resource + i) % sub_resources_per_plane;
+        plane_idx = (first_sub_resource + i) / sub_resources_per_plane;
         miplevel_idx = sub_resource_idx % desc->MipLevels;
+
+        if (plane_count > 1)
+        {
+            plane_format = !plane_idx ? DXGI_FORMAT_R32_TYPELESS : DXGI_FORMAT_R8_TYPELESS;
+            format = vkd3d_get_format(device, plane_format, true);
+        }
+
         width = align(d3d12_resource_desc_get_width(desc, miplevel_idx), format->block_width);
         height = align(d3d12_resource_desc_get_height(desc, miplevel_idx), format->block_height);
         depth = d3d12_resource_desc_get_depth(desc, miplevel_idx);
         row_count = height / format->block_height;
         row_size = (width / format->block_width) * format->byte_count * format->block_byte_count;
-        row_pitch = align(row_size, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT);
+        /* Direct3D 12 requires double the alignment for dual planes. */
+        row_pitch = align(row_size, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT * plane_count);
 
         if (layouts)
         {
             layouts[i].Offset = base_offset + offset;
-            layouts[i].Footprint.Format = desc->Format;
+            layouts[i].Footprint.Format = plane_format;
             layouts[i].Footprint.Width = width;
             layouts[i].Footprint.Height = height;
             layouts[i].Footprint.Depth = depth;
@@ -4763,7 +4767,7 @@ static void d3d12_device_get_copyable_footprints(struct d3d12_device *device,
             row_sizes[i] = row_size;
 
         size = max(0, row_count - 1) * row_pitch + row_size;
-        size = max(0, depth - 1) * align(size, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT) + size;
+        size = max(0, depth - 1) * align(size, D3D12_TEXTURE_DATA_PITCH_ALIGNMENT * plane_count) + size;
 
         total = offset + size;
         offset = align(total, D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT);
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index 1f7d90eb95f..eab97715944 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -951,7 +951,7 @@ HRESULT vkd3d_get_image_allocation_info(struct d3d12_device *device,
     HRESULT hr;
 
     VKD3D_ASSERT(desc->Dimension != D3D12_RESOURCE_DIMENSION_BUFFER);
-    VKD3D_ASSERT(d3d12_resource_validate_desc(desc, device) == S_OK);
+    VKD3D_ASSERT(d3d12_resource_validate_desc(desc, device, 0) == S_OK);
 
     if (!desc->MipLevels)
     {
@@ -1847,7 +1847,7 @@ static bool d3d12_resource_validate_texture_alignment(const D3D12_RESOURCE_DESC1
     return true;
 }
 
-HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3d12_device *device)
+HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3d12_device *device, uint32_t flags)
 {
     const D3D12_MIP_REGION *mip_region = &desc->SamplerFeedbackMipRegion;
     const struct vkd3d_format *format;
@@ -1893,7 +1893,8 @@ HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3
                 return E_INVALIDARG;
             }
 
-            if (!(format = vkd3d_format_from_d3d12_resource_desc(device, desc, 0)))
+            if (!(format = vkd3d_get_format(device, desc->Format,
+                    desc->Flags & D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL || flags & VKD3D_VALIDATE_FORCE_ALLOW_DS)))
             {
                 WARN("Invalid format %#x.\n", desc->Format);
                 return E_INVALIDARG;
@@ -2013,7 +2014,7 @@ static HRESULT d3d12_resource_init(struct d3d12_resource *resource, struct d3d12
     resource->gpu_address = 0;
     resource->flags = 0;
 
-    if (FAILED(hr = d3d12_resource_validate_desc(&resource->desc, device)))
+    if (FAILED(hr = d3d12_resource_validate_desc(&resource->desc, device, 0)))
         return hr;
 
     resource->format = vkd3d_format_from_d3d12_resource_desc(device, desc, 0);
diff --git a/libs/vkd3d/libs/vkd3d/utils.c b/libs/vkd3d/libs/vkd3d/utils.c
index 839bb173854..c2832a61f67 100644
--- a/libs/vkd3d/libs/vkd3d/utils.c
+++ b/libs/vkd3d/libs/vkd3d/utils.c
@@ -29,7 +29,7 @@
 #define UINT          VKD3D_FORMAT_TYPE_UINT
 static const struct vkd3d_format vkd3d_formats[] =
 {
-    {DXGI_FORMAT_UNKNOWN,               VK_FORMAT_UNDEFINED,                1,  1, 1,  1},
+    {DXGI_FORMAT_UNKNOWN,               VK_FORMAT_UNDEFINED,                1,  1, 1,  1, 0,     1},
     {DXGI_FORMAT_R32G32B32A32_TYPELESS, VK_FORMAT_R32G32B32A32_SFLOAT,      16, 1, 1,  1, COLOR, 1, TYPELESS},
     {DXGI_FORMAT_R32G32B32A32_FLOAT,    VK_FORMAT_R32G32B32A32_SFLOAT,      16, 1, 1,  1, COLOR, 1},
     {DXGI_FORMAT_R32G32B32A32_UINT,     VK_FORMAT_R32G32B32A32_UINT,        16, 1, 1,  1, COLOR, 1, UINT},
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index 8488d5db3fa..fd1fbb1679a 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -70,6 +70,8 @@
 
 #define VKD3D_SHADER_DESCRIPTOR_TYPE_COUNT (VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER + 1)
 
+#define VKD3D_VALIDATE_FORCE_ALLOW_DS  0x1u
+
 extern uint64_t object_global_serial_id;
 
 struct d3d12_command_list;
@@ -240,8 +242,6 @@ struct vkd3d_fence_worker
     struct vkd3d_waiting_fence *fences;
     size_t fences_size;
 
-    void (*wait_for_gpu_fence)(struct vkd3d_fence_worker *worker, const struct vkd3d_waiting_fence *enqueued_fence);
-
     struct vkd3d_queue *queue;
     struct d3d12_device *device;
 };
@@ -534,7 +534,7 @@ struct vkd3d_resource_allocation_info
 };
 
 bool d3d12_resource_is_cpu_accessible(const struct d3d12_resource *resource);
-HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3d12_device *device);
+HRESULT d3d12_resource_validate_desc(const D3D12_RESOURCE_DESC1 *desc, struct d3d12_device *device, uint32_t flags);
 void d3d12_resource_get_tiling(struct d3d12_device *device, const struct d3d12_resource *resource,
         UINT *total_tile_count, D3D12_PACKED_MIP_INFO *packed_mip_info, D3D12_TILE_SHAPE *standard_tile_shape,
         UINT *sub_resource_tiling_count, UINT first_sub_resource_tiling,
@@ -1362,6 +1362,7 @@ enum vkd3d_cs_op
 {
     VKD3D_CS_OP_WAIT,
     VKD3D_CS_OP_SIGNAL,
+    VKD3D_CS_OP_SIGNAL_ON_CPU,
     VKD3D_CS_OP_EXECUTE,
     VKD3D_CS_OP_UPDATE_MAPPINGS,
     VKD3D_CS_OP_COPY_MAPPINGS,

From 5a28d96a6534ba95bea2edd8d61e9b0a0fbd1bcd Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 12 May 2021 11:46:48 +1000
Subject: [PATCH 141/244] wbemdisp: Support DISPATCH_METHOD in ISWbemObject
 Invoke

Wine-bug: https://bugs.winehq.org/show_bug.cgi?id=51120
Wine-bug: https://bugs.winehq.org/show_bug.cgi?id=39463
---
 dlls/wbemdisp/locator.c | 84 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 84 insertions(+)

diff --git a/dlls/wbemdisp/locator.c b/dlls/wbemdisp/locator.c
index c3e0c86f4ae..881fc0eeedd 100644
--- a/dlls/wbemdisp/locator.c
+++ b/dlls/wbemdisp/locator.c
@@ -1292,6 +1292,90 @@ static HRESULT WINAPI object_Invoke(
         memset( params, 0, sizeof(*params) );
         return IWbemClassObject_Get( object->object, name, 0, result, NULL, NULL );
     }
+    else if (flags == DISPATCH_METHOD)
+    {
+        IWbemClassObject *sig_in, *in, *out = NULL;
+        VARIANT path;
+        int i;
+        BSTR param;
+
+        if (!params->cArgs || !params->rgvarg)
+        {
+            WARN( "Missing property value\n" );
+            return E_INVALIDARG;
+        }
+
+        hr = IWbemClassObject_GetMethod( object->object, name, 0, &sig_in, NULL );
+        if (FAILED(hr))
+            return hr;
+
+        hr = IWbemClassObject_SpawnInstance( sig_in, 0, &in );
+        IWbemClassObject_Release( sig_in );
+        if (FAILED(hr))
+            return hr;
+
+        IWbemClassObject_BeginEnumeration( in, 0 );
+        i = params->cArgs - 1;
+        while (IWbemClassObject_Next( in, 0, &param, NULL, NULL, NULL ) == S_OK)
+        {
+            TRACE("Param %s = %s\n", debugstr_w(param), debugstr_variant(&params->rgvarg[i]));
+            hr = IWbemClassObject_Put( in, param, 0, &params->rgvarg[i], 0 );
+            SysFreeString( param );
+            if (FAILED(hr))
+            {
+                WARN("Failed to set paramter\n");
+                break;
+            }
+            i--;
+        }
+        IWbemClassObject_EndEnumeration( in );
+
+        V_VT( &path ) = VT_EMPTY;
+        hr = IWbemClassObject_Get( object->object, L"__PATH", 0, &path, NULL, NULL );
+        if (FAILED(hr))
+        {
+            IWbemClassObject_Release( in );
+            return hr;
+        }
+
+        hr = IWbemServices_ExecMethod( object->services->services, V_BSTR(&path), name, 0, NULL, in, &out, NULL );
+        IWbemClassObject_Release( in );
+        VariantClear(&path);
+        if (FAILED(hr))
+            return hr;
+
+        IWbemClassObject_BeginEnumeration( out, 0 );
+        while (IWbemClassObject_Next( out, 0, &param, NULL, NULL, NULL ) == S_OK)
+        {
+            TRACE("Output parameter %s\n", debugstr_w(param));
+
+            if (i < 0)
+            {
+                ERR("Unexpected output parameter\n");
+                hr = E_FAIL;
+                break;
+            }
+            if (!lstrcmpiW(param, L"ReturnValue"))
+            {
+                SysFreeString( param );
+                continue;
+            }
+            hr = IWbemClassObject_Get( out, param, 0, V_VARIANTREF(&params->rgvarg[i]), NULL, NULL );
+            if (FAILED(hr))
+            {
+                ERR("Failed to get output paramter\n");
+                break;
+            }
+
+            SysFreeString( param );
+            i--;
+        }
+        IWbemClassObject_EndEnumeration( out );
+
+        IWbemClassObject_Release( out );
+
+        return hr;
+    }
     else if (flags == DISPATCH_PROPERTYPUT)
     {
         if (!params->cArgs || !params->rgvarg)

From cb6fdb234ac25ed8521099a6183421f583437f21 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 17 May 2021 18:18:44 +1000
Subject: [PATCH 142/244] vbscript: Support VT_BSTR|VT_ARRAY Iterator

This isn't correct and the patch 4 show that this is the case.

The array being returned by Invoke, needs to convert the datatype
on return.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/vbscript/interp.c |  1 +
 dlls/vbscript/utils.c  | 24 ++++++++++++++----------
 2 files changed, 15 insertions(+), 10 deletions(-)

diff --git a/dlls/vbscript/interp.c b/dlls/vbscript/interp.c
index 937cdaf1c8c..1d760ea27b7 100644
--- a/dlls/vbscript/interp.c
+++ b/dlls/vbscript/interp.c
@@ -1501,6 +1501,7 @@ static HRESULT interp_newenum(exec_ctx_t *ctx)
         V_UNKNOWN(r) = (IUnknown*)iter;
         break;
     }
+    case VT_BSTR|VT_ARRAY:
     case VT_VARIANT|VT_ARRAY:
     case VT_VARIANT|VT_ARRAY|VT_BYREF: {
         IEnumVARIANT *iter;
diff --git a/dlls/vbscript/utils.c b/dlls/vbscript/utils.c
index 4bfc2c65a0a..9ad4f2abc35 100644
--- a/dlls/vbscript/utils.c
+++ b/dlls/vbscript/utils.c
@@ -110,11 +110,20 @@ static HRESULT WINAPI safearray_iter_IEnumVARIANT_Next(IEnumVARIANT *iface,
     if(!This->sa->cLocks)
         ERR("SAFEARRAY not locked\n");
 
-    v = (VARIANT*)(((BYTE*)This->sa->pvData) + This->i * This->sa->cbElements);
-    V_VT(rgVar) = VT_EMPTY;
-    hres = VariantCopy(rgVar, v);
-    if(FAILED(hres))
-        return hres;
+    if (This->sa->fFeatures & FADF_VARIANT)
+    {
+        v = (VARIANT*)(((BYTE*)This->sa->pvData) + This->i * This->sa->cbElements);
+        V_VT(rgVar) = VT_EMPTY;
+        hres = VariantCopy(rgVar, v);
+        if(FAILED(hres))
+            return hres;
+    }
+    else if (This->sa->fFeatures & FADF_BSTR)
+    {
+        BSTR bstr  = *(BSTR*)(((BYTE*)This->sa->pvData) + This->i * This->sa->cbElements);
+        V_VT(rgVar) = VT_BSTR;
+        V_BSTR(rgVar) = SysAllocString(bstr);
+    }
 
     This->i++;
     if(pCeltFetched)
@@ -169,11 +178,6 @@ HRESULT create_safearray_iter(SAFEARRAY *sa, BOOL owned, IEnumVARIANT **ev)
     safearray_iter *iter;
     HRESULT hres;
 
-    if(sa && !(sa->fFeatures & FADF_VARIANT)) {
-        FIXME("enumeration not supported: %x\n", sa->fFeatures);
-        return E_NOTIMPL;
-    }
-
     iter = malloc(sizeof(*iter));
     if(!iter)
         return E_OUTOFMEMORY;

From 483dffa2db766e9c204fd74842662b6aaf5cf99b Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sat, 29 May 2021 18:02:04 +1000
Subject: [PATCH 143/244] wbemprox: Support VT_BYREF in to_longlong

---
 dlls/wbemprox/query.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/wbemprox/query.c b/dlls/wbemprox/query.c
index ff7be29ed52..19d1d40c543 100644
--- a/dlls/wbemprox/query.c
+++ b/dlls/wbemprox/query.c
@@ -1332,6 +1332,9 @@ HRESULT to_longlong( VARIANT *var, LONGLONG *val, CIMTYPE *type )
         *val = 0;
         return S_OK;
     }
+    if (V_VT( var ) & VT_BYREF)
+        var = V_VARIANTREF( var );
+
     if (V_VT( var ) & VT_ARRAY)
     {
         *val = (INT_PTR)to_array( var, type );

From 157290bdc1a95a7e4afae21ad80143bd29976376 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sun, 30 May 2021 16:34:56 +1000
Subject: [PATCH 144/244] vbscript: Add wmi test

This shows that the data returned by the EnumKey call isn't the same type
as vbscript.  At a source leve EnumKey returns a VT_BSTR|VT_ARRAY whereas
vbscript converts it a VT_ARRAY|VT_VARIANT*.
---
 dlls/vbscript/tests/lang.vbs | 18 ++++++++++++++++++
 dlls/vbscript/tests/run.c    |  5 +++++
 2 files changed, 23 insertions(+)

diff --git a/dlls/vbscript/tests/lang.vbs b/dlls/vbscript/tests/lang.vbs
index 3c6ce656f1c..e329226b230 100644
--- a/dlls/vbscript/tests/lang.vbs
+++ b/dlls/vbscript/tests/lang.vbs
@@ -2239,4 +2239,22 @@ f1 not 1 = 0
 
 arr (0) = 2 xor -2
 
+function wmi_array_bstr()
+const HKEY_LOCAL_MACHINE = &H80000002
+Dim oReg
+
+Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
+
+Dim strKeyPath, strSubkey, arrSubKeys
+strKeyPath = "Software\Microsoft\NET Framework Setup\NDP"
+oReg.EnumKey HKEY_LOCAL_MACHINE, strKeyPath, arrSubKeys
+
+Call ok(getVT(arrSubKeys) = "VT_ARRAY|VT_VARIANT*", "getVT(arrSubKeys) = " & getVT(arrSubKeys))
+For Each strSubkey In arrSubKeys
+Next
+end function
+
+Call wmi_array_bstr()
+
+
 reportSuccess()
diff --git a/dlls/vbscript/tests/run.c b/dlls/vbscript/tests/run.c
index 8aaafbedf54..e7ef7f6c179 100644
--- a/dlls/vbscript/tests/run.c
+++ b/dlls/vbscript/tests/run.c
@@ -187,6 +187,11 @@ static const char *vt2a(VARIANT *v)
         sprintf(buf, "%s*", vt2a(V_BYREF(v)));
         return buf;
     }
+    else if(V_VT(v) == (VT_BYREF|VT_VARIANT|VT_ARRAY)) {
+        static char buf[64];
+        sprintf(buf, "%s*", vt2a(V_BYREF(v)));
+        return buf;
+    }
 
     switch(V_VT(v)) {
     case VT_EMPTY:

From 18ceb7bda069ad359414fc5c765e512c8c1611f2 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 20 Jan 2016 14:04:08 +0800
Subject: [PATCH 145/244] oleaut32: Fix logic for deciding whether type
 description follows the name (v2).

This makes it possible to load an SLTG typelib generated by widl.

It looks like the lowest bit actually indicates whether type description
follows the name, and since the name offsets are always aligned that makes
sense.
---
 dlls/oleaut32/typelib.c | 17 ++++++-----------
 1 file changed, 6 insertions(+), 11 deletions(-)

diff --git a/dlls/oleaut32/typelib.c b/dlls/oleaut32/typelib.c
index 1e43c3a91a1..61fa977d339 100644
--- a/dlls/oleaut32/typelib.c
+++ b/dlls/oleaut32/typelib.c
@@ -4177,7 +4177,7 @@ static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
 	pArg = (WORD*)(pBlk + pFunc->arg_off);
 
 	for(param = 0; param < pFuncDesc->funcdesc.cParams; param++) {
-	    char *paramName = pNameTable + *pArg;
+	    char *paramName = pNameTable + (*pArg & ~1);
 	    BOOL HaveOffs;
 	    /* If arg type follows then paramName points to the 2nd
 	       letter of the name, else the next WORD is an offset to
@@ -4188,26 +4188,21 @@ static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
 	       meaning that the next WORD is the type, the latter
 	       meaning that the next WORD is an offset to the type. */
 
-	    HaveOffs = FALSE;
-	    if(*pArg == 0xffff)
+	    if(*pArg == 0xffff || *pArg == 0xfffe)
 	        paramName = NULL;
-	    else if(*pArg == 0xfffe) {
-	        paramName = NULL;
-		HaveOffs = TRUE;
-	    }
-	    else if(paramName[-1] && !isalnum(paramName[-1]))
-	        HaveOffs = TRUE;
 
+	    HaveOffs = !(*pArg & 1);
 	    pArg++;
 
+            TRACE_(typelib)("param %d: paramName %s, *pArg %#x\n",
+                param, debugstr_a(paramName), *pArg);
+
 	    if(HaveOffs) { /* the next word is an offset to type */
 	        pType = (WORD*)(pBlk + *pArg);
 		SLTG_DoElem(pType, pBlk,
 			    &pFuncDesc->funcdesc.lprgelemdescParam[param], ref_lookup);
 		pArg++;
 	    } else {
-		if(paramName)
-		  paramName--;
 		pArg = SLTG_DoElem(pArg, pBlk,
                                    &pFuncDesc->funcdesc.lprgelemdescParam[param], ref_lookup);
 	    }

From b0bf6505da5bacd02bc80bc4dde4bafcfef75d6d Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 26 Jan 2016 15:05:54 +0800
Subject: [PATCH 146/244] oleaut32: Implement decoding of SLTG help strings.

Based on the patch by Sebastian Lackner <sebastian@fds-team.de>.
---
 dlls/oleaut32/typelib.c | 134 ++++++++++++++++++++++++++++++++--------
 dlls/oleaut32/typelib.h |   4 +-
 2 files changed, 111 insertions(+), 27 deletions(-)

diff --git a/dlls/oleaut32/typelib.c b/dlls/oleaut32/typelib.c
index 61fa977d339..96414e35019 100644
--- a/dlls/oleaut32/typelib.c
+++ b/dlls/oleaut32/typelib.c
@@ -3677,6 +3677,87 @@ static BOOL TLB_GUIDFromString(const char *str, GUID *guid)
   return TRUE;
 }
 
+struct bitstream
+{
+    const BYTE *buffer;
+    DWORD       length;
+    WORD        current;
+};
+
+static const char *lookup_code(const BYTE *table, DWORD table_size, struct bitstream *bits)
+{
+    const BYTE *p = table;
+
+    while (p < table + table_size && *p == 0x80)
+    {
+        if (p + 2 >= table + table_size) return NULL;
+
+        if (!(bits->current & 0xff))
+        {
+            if (!bits->length) return NULL;
+            bits->current = (*bits->buffer << 8) | 1;
+            bits->buffer++;
+            bits->length--;
+        }
+
+        if (bits->current & 0x8000)
+        {
+            p += 3;
+        }
+        else
+        {
+            p = table + (*(p + 2) | (*(p + 1) << 8));
+        }
+
+        bits->current <<= 1;
+    }
+
+    if (p + 1 < table + table_size && *(p + 1))
+    {
+        /* FIXME: Whats the meaning of *p? */
+        const BYTE *q = p + 1;
+        while (q < table + table_size && *q) q++;
+        return (q < table + table_size) ? (const char *)(p + 1) : NULL;
+    }
+
+    return NULL;
+}
+
+static const TLBString *decode_string(const BYTE *table, const char *stream, DWORD stream_length, ITypeLibImpl *lib)
+{
+    DWORD buf_size, table_size;
+    const char *p;
+    struct bitstream bits;
+    BSTR buf;
+    TLBString *tlbstr;
+
+    if (!stream_length) return NULL;
+
+    bits.buffer = (const BYTE *)stream;
+    bits.length = stream_length;
+    bits.current = 0;
+
+    buf_size = *(const WORD *)table;
+    table += sizeof(WORD);
+    table_size = *(const DWORD *)table;
+    table += sizeof(DWORD);
+
+    buf = SysAllocStringLen(NULL, buf_size);
+    buf[0] = 0;
+
+    while ((p = lookup_code(table, table_size, &bits)))
+    {
+        static const WCHAR spaceW[] = { ' ',0 };
+        if (buf[0]) lstrcatW(buf, spaceW);
+        MultiByteToWideChar(CP_ACP, 0, p, -1, buf + lstrlenW(buf), buf_size - lstrlenW(buf));
+    }
+
+    tlbstr = TLB_append_str(&lib->string_list, buf);
+    SysFreeString(buf);
+
+    return tlbstr;
+}
+
 static WORD SLTG_ReadString(const char *ptr, const TLBString **pStr, ITypeLibImpl *lib)
 {
     WORD bytelen;
@@ -4363,17 +4444,17 @@ static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
 /* Because SLTG_OtherTypeInfo is such a painful struct, we make a more
    manageable copy of it into this */
 typedef struct {
-  WORD small_no;
   char *index_name;
   char *other_name;
   WORD res1a;
   WORD name_offs;
-  WORD more_bytes;
+  WORD hlpstr_len;
   char *extra;
   WORD res20;
   DWORD helpcontext;
   WORD res26;
   GUID uuid;
+  WORD typekind;
 } SLTG_InternalOtherTypeInfo;
 
 /****************************************************************************
@@ -4392,8 +4473,8 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
     LPVOID pBlk, pFirstBlk;
     SLTG_LibBlk *pLibBlk;
     SLTG_InternalOtherTypeInfo *pOtherTypeInfoBlks;
-    char *pAfterOTIBlks = NULL;
     char *pNameTable, *ptr;
+    const BYTE *hlp_strings;
     int i;
     DWORD len, order;
     ITypeInfoImpl **ppTypeInfoImpl;
@@ -4459,53 +4540,55 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
     len += 0x40;
 
     /* And now TypeInfoCount of SLTG_OtherTypeInfo */
+    pTypeLibImpl->TypeInfoCount = *(WORD *)((char *)pLibBlk + len);
+    len += sizeof(WORD);
 
     pOtherTypeInfoBlks = calloc(pTypeLibImpl->TypeInfoCount, sizeof(*pOtherTypeInfoBlks));
 
-
     ptr = (char*)pLibBlk + len;
 
     for(i = 0; i < pTypeLibImpl->TypeInfoCount; i++) {
 	WORD w, extra;
 	len = 0;
 
-	pOtherTypeInfoBlks[i].small_no = *(WORD*)ptr;
-
-	w = *(WORD*)(ptr + 2);
+	w = *(WORD*)ptr;
 	if(w != 0xffff) {
 	    len += w;
-	    pOtherTypeInfoBlks[i].index_name = malloc(w + 1);
-	    memcpy(pOtherTypeInfoBlks[i].index_name, ptr + 4, w);
+	    pOtherTypeInfoBlks[i].index_name = malloc(w+1);
+	    memcpy(pOtherTypeInfoBlks[i].index_name, ptr + 2, w);
 	    pOtherTypeInfoBlks[i].index_name[w] = '\0';
 	}
-	w = *(WORD*)(ptr + 4 + len);
+	w = *(WORD*)(ptr + 2 + len);
 	if(w != 0xffff) {
-	    TRACE_(typelib)("\twith %s\n", debugstr_an(ptr + 6 + len, w));
-	    len += w;
-	    pOtherTypeInfoBlks[i].other_name = malloc(w + 1);
-	    memcpy(pOtherTypeInfoBlks[i].other_name, ptr + 6 + len, w);
+	    TRACE_(typelib)("\twith %s\n", debugstr_an(ptr + 4 + len, w));
+	    pOtherTypeInfoBlks[i].other_name = malloc(w+1);
+	    memcpy(pOtherTypeInfoBlks[i].other_name, ptr + 4 + len, w);
 	    pOtherTypeInfoBlks[i].other_name[w] = '\0';
+	    len += w;
 	}
-	pOtherTypeInfoBlks[i].res1a = *(WORD*)(ptr + len + 6);
-	pOtherTypeInfoBlks[i].name_offs = *(WORD*)(ptr + len + 8);
-	extra = pOtherTypeInfoBlks[i].more_bytes = *(WORD*)(ptr + 10 + len);
+	pOtherTypeInfoBlks[i].res1a = *(WORD*)(ptr + 4 + len);
+	pOtherTypeInfoBlks[i].name_offs = *(WORD*)(ptr + 6 + len);
+	extra = pOtherTypeInfoBlks[i].hlpstr_len = *(WORD*)(ptr + 8 + len);
 	if(extra) {
 	    pOtherTypeInfoBlks[i].extra = malloc(extra);
-	    memcpy(pOtherTypeInfoBlks[i].extra, ptr + 12, extra);
+	    memcpy(pOtherTypeInfoBlks[i].extra, ptr + 10 + len, extra);
 	    len += extra;
 	}
-	pOtherTypeInfoBlks[i].res20 = *(WORD*)(ptr + 12 + len);
-	pOtherTypeInfoBlks[i].helpcontext = *(DWORD*)(ptr + 14 + len);
-	pOtherTypeInfoBlks[i].res26 = *(WORD*)(ptr + 18 + len);
-	memcpy(&pOtherTypeInfoBlks[i].uuid, ptr + 20 + len, sizeof(GUID));
+	pOtherTypeInfoBlks[i].res20 = *(WORD*)(ptr + 10 + len);
+	pOtherTypeInfoBlks[i].helpcontext = *(DWORD*)(ptr + 12 + len);
+	pOtherTypeInfoBlks[i].res26 = *(WORD*)(ptr + 16 + len);
+	memcpy(&pOtherTypeInfoBlks[i].uuid, ptr + 18 + len, sizeof(GUID));
+	pOtherTypeInfoBlks[i].typekind = *(WORD*)(ptr + 18 + sizeof(GUID) + len);
 	len += sizeof(SLTG_OtherTypeInfo);
 	ptr += len;
     }
 
-    pAfterOTIBlks = ptr;
+    /* Get the next DWORD */
+    len = *(DWORD*)ptr;
 
-    /* Skip this WORD and get the next DWORD */
-    len = *(DWORD*)(pAfterOTIBlks + 2);
+    hlp_strings = (const BYTE *)ptr + sizeof(DWORD);
+    TRACE("max help string length %#x, help strings length %#lx\n",
+        *(WORD *)hlp_strings, *(DWORD *)(hlp_strings + 2));
 
     /* Now add this to pLibBLk look at what we're pointing at and
        possibly add 0x20, then add 0x216, sprinkle a bit a magic
@@ -4571,6 +4654,7 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
       (*ppTypeInfoImpl)->index = i;
       (*ppTypeInfoImpl)->Name = SLTG_ReadName(pNameTable, pOtherTypeInfoBlks[i].name_offs, pTypeLibImpl);
       (*ppTypeInfoImpl)->dwHelpContext = pOtherTypeInfoBlks[i].helpcontext;
+      (*ppTypeInfoImpl)->DocString = decode_string(hlp_strings, pOtherTypeInfoBlks[i].extra, pOtherTypeInfoBlks[i].hlpstr_len, pTypeLibImpl);
       (*ppTypeInfoImpl)->guid = TLB_append_guid(&pTypeLibImpl->guid_list, &pOtherTypeInfoBlks[i].uuid, 2);
       (*ppTypeInfoImpl)->typeattr.typekind = pTIHeader->typekind;
       (*ppTypeInfoImpl)->typeattr.wMajorVerNum = pTIHeader->major_version;
diff --git a/dlls/oleaut32/typelib.h b/dlls/oleaut32/typelib.h
index 515d4b557e6..bfe908c035f 100644
--- a/dlls/oleaut32/typelib.h
+++ b/dlls/oleaut32/typelib.h
@@ -382,18 +382,18 @@ typedef struct {
 /* we then get 0x40 bytes worth of 0xffff or small numbers followed by
    nrOfFileBlks - 2 of these */
 typedef struct {
-	WORD small_no;
 	SLTG_Name index_name; /* This refers to a name in the directory */
 	SLTG_Name other_name; /* Another one of these weird names */
 	WORD res1a;	      /* 0xffff */
 	WORD name_offs;	      /* offset to name in name table */
-	WORD more_bytes;      /* if this is non-zero we get this many
+	WORD hlpstr_len;      /* if this is non-zero we get this many
 				 bytes before the next element, which seem
 				 to reference the docstring of the type ? */
 	WORD res20;	      /* 0xffff */
 	DWORD helpcontext;
 	WORD res26;	      /* 0xffff */
         GUID uuid;
+        WORD typekind;
 } SLTG_OtherTypeInfo;
 
 /* Next we get WORD 0x0003 followed by a DWORD which if we add to

From ea92517447d853c8afff49e426a62543933af15e Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 26 Jan 2016 15:41:06 +0800
Subject: [PATCH 147/244] oleaut32: Add support for decoding SLTG function help
 strings.

---
 dlls/oleaut32/typelib.c | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/dlls/oleaut32/typelib.c b/dlls/oleaut32/typelib.c
index 96414e35019..6c10809d50c 100644
--- a/dlls/oleaut32/typelib.c
+++ b/dlls/oleaut32/typelib.c
@@ -4200,7 +4200,8 @@ static void SLTG_DoVars(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI, unsign
 }
 
 static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
-			 unsigned short cFuncs, char *pNameTable, const sltg_ref_lookup_t *ref_lookup)
+			 unsigned short cFuncs, char *pNameTable, const sltg_ref_lookup_t *ref_lookup,
+			 const BYTE *hlp_strings)
 {
     SLTG_Function *pFunc;
     unsigned short i;
@@ -4241,6 +4242,9 @@ static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
         else
 	    pFuncDesc->funcdesc.oVft = (unsigned short)(pFunc->vtblpos & ~1) * sizeof(void *) / pTI->pTypeLib->ptr_size;
 
+	if (pFunc->helpstring != 0xffff)
+		pFuncDesc->HelpString = decode_string(hlp_strings, pBlk + pFunc->helpstring, pNameTable - pBlk, pTI->pTypeLib);
+
 	if(pFunc->magic & SLTG_FUNCTION_FLAGS_PRESENT)
 	    pFuncDesc->funcdesc.wFuncFlags = pFunc->funcflags;
 
@@ -4327,7 +4331,7 @@ static void SLTG_ProcessCoClass(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessInterface(char *pBlk, ITypeInfoImpl *pTI,
 				  char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-				  const SLTG_TypeInfoTail *pTITail)
+				  const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
     char *pFirstItem;
     sltg_ref_lookup_t *ref_lookup = NULL;
@@ -4344,7 +4348,7 @@ static void SLTG_ProcessInterface(char *pBlk, ITypeInfoImpl *pTI,
     }
 
     if (pTITail->funcs_off != 0xffff)
-        SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup);
+        SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
 
     free(ref_lookup);
 
@@ -4389,7 +4393,7 @@ static void SLTG_ProcessAlias(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
 				 char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-				 const SLTG_TypeInfoTail *pTITail)
+				 const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
   sltg_ref_lookup_t *ref_lookup = NULL;
   if (pTIHeader->href_table != 0xffffffff)
@@ -4400,7 +4404,7 @@ static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
     SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup);
 
   if (pTITail->funcs_off != 0xffff)
-    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup);
+    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
 
   if (pTITail->impls_off != 0xffff)
     SLTG_DoImpls(pBlk + pTITail->impls_off, pTI, FALSE, ref_lookup);
@@ -4424,7 +4428,7 @@ static void SLTG_ProcessEnum(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
 			       char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-			       const SLTG_TypeInfoTail *pTITail)
+			       const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
   sltg_ref_lookup_t *ref_lookup = NULL;
   if (pTIHeader->href_table != 0xffffffff)
@@ -4435,7 +4439,7 @@ static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
     SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup);
 
   if (pTITail->funcs_off != 0xffff)
-    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup);
+    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
   free(ref_lookup);
   if (TRACE_ON(typelib))
     dump_TypeInfo(pTI);
@@ -4697,7 +4701,7 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
 
       case TKIND_INTERFACE:
 	SLTG_ProcessInterface((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                              pTIHeader, pTITail);
+                              pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_COCLASS:
@@ -4712,12 +4716,12 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
 
       case TKIND_DISPATCH:
 	SLTG_ProcessDispatch((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                             pTIHeader, pTITail);
+                             pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_MODULE:
 	SLTG_ProcessModule((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                           pTIHeader, pTITail);
+                           pTIHeader, pTITail, hlp_strings);
 	break;
 
       default:

From a4964fff9d47e15f824ddb2452c64d5717190dc8 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 26 Jan 2016 16:17:21 +0800
Subject: [PATCH 148/244] oleaut32: Add support for decoding SLTG variable help
 strings.

---
 dlls/oleaut32/typelib.c | 24 +++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/dlls/oleaut32/typelib.c b/dlls/oleaut32/typelib.c
index 6c10809d50c..c59c3e35001 100644
--- a/dlls/oleaut32/typelib.c
+++ b/dlls/oleaut32/typelib.c
@@ -4089,7 +4089,7 @@ static char *SLTG_DoImpls(char *pBlk, ITypeInfoImpl *pTI,
 }
 
 static void SLTG_DoVars(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI, unsigned short cVars,
-			const char *pNameTable, const sltg_ref_lookup_t *ref_lookup)
+			const char *pNameTable, const sltg_ref_lookup_t *ref_lookup, const BYTE *hlp_strings)
 {
   TLBVarDesc *pVarDesc;
   const TLBString *prevName = NULL;
@@ -4119,6 +4119,12 @@ static void SLTG_DoVars(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI, unsign
       TRACE_(typelib)("byte_offs = 0x%x\n", pItem->byte_offs);
       TRACE_(typelib)("memid = %#lx\n", pItem->memid);
 
+      if (pItem->helpstring != 0xffff)
+      {
+          pVarDesc->HelpString = decode_string(hlp_strings, pBlk + pItem->helpstring, pNameTable - pBlk, pTI->pTypeLib);
+          TRACE_(typelib)("helpstring = %s\n", debugstr_w(pVarDesc->HelpString->str));
+      }
+
       if(pItem->flags & 0x02)
 	  pType = &pItem->type;
       else
@@ -4358,9 +4364,9 @@ static void SLTG_ProcessInterface(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessRecord(char *pBlk, ITypeInfoImpl *pTI,
 			       const char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-			       const SLTG_TypeInfoTail *pTITail)
+			       const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
-  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL);
+  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL, hlp_strings);
 }
 
 static void SLTG_ProcessAlias(char *pBlk, ITypeInfoImpl *pTI,
@@ -4401,7 +4407,7 @@ static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
                                   pNameTable);
 
   if (pTITail->vars_off != 0xffff)
-    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup);
+    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup, hlp_strings);
 
   if (pTITail->funcs_off != 0xffff)
     SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
@@ -4421,9 +4427,9 @@ static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessEnum(char *pBlk, ITypeInfoImpl *pTI,
 			     const char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-			     const SLTG_TypeInfoTail *pTITail)
+			     const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
-  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL);
+  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL, hlp_strings);
 }
 
 static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
@@ -4436,7 +4442,7 @@ static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
                                   pNameTable);
 
   if (pTITail->vars_off != 0xffff)
-    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup);
+    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup, hlp_strings);
 
   if (pTITail->funcs_off != 0xffff)
     SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
@@ -4691,12 +4697,12 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
       switch(pTIHeader->typekind) {
       case TKIND_ENUM:
 	SLTG_ProcessEnum((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                         pTIHeader, pTITail);
+                         pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_RECORD:
 	SLTG_ProcessRecord((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                           pTIHeader, pTITail);
+                           pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_INTERFACE:

From 9fddd624e9fb1bbd8171d237e1cd3c232bff86e8 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 7 Feb 2024 19:14:29 +0300
Subject: [PATCH 149/244] win32u: Fix device<->world width/height converters.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/win32u/font.c | 130 +++++++++++++++++++++------------------------
 1 file changed, 60 insertions(+), 70 deletions(-)

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 762e9cc1cda..280773e1bd4 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -230,12 +230,10 @@ static inline int facename_compare( const WCHAR *str1, const WCHAR *str2, SIZE_T
  */
 static inline INT INTERNAL_XDSTOWS(DC *dc, INT width)
 {
-    double floatWidth;
+    float scale_x;
 
-    /* Perform operation with floating point */
-    floatWidth = (double)width * dc->xformVport2World.eM11;
-    /* Round to integers */
-    return GDI_ROUND(floatWidth);
+    scale_x = hypotf(dc->xformWorld2Vport.eM11, dc->xformWorld2Vport.eM12);
+    return GDI_ROUND( (float)width / scale_x );
 }
 
 /* Performs a device to world transformation on the specified size (which
@@ -243,34 +241,26 @@ static inline INT INTERNAL_XDSTOWS(DC *dc, INT width)
  */
 static inline INT INTERNAL_YDSTOWS(DC *dc, INT height)
 {
-    double floatHeight;
+    float scale_y;
 
-    /* Perform operation with floating point */
-    floatHeight = (double)height * dc->xformVport2World.eM22;
-    /* Round to integers */
-    return GDI_ROUND(floatHeight);
+    scale_y = hypotf(dc->xformWorld2Vport.eM21, dc->xformWorld2Vport.eM22);
+    return GDI_ROUND( (float)height / scale_y );
 }
 
-/* scale width and height but don't mirror them */
-
-static inline INT width_to_LP( DC *dc, INT width )
+static inline INT INTERNAL_XWSTODS(DC *dc, INT width)
 {
-    return GDI_ROUND( (double)width * fabs( dc->xformVport2World.eM11 ));
-}
+    float scale_x;
 
-static inline INT height_to_LP( DC *dc, INT height )
-{
-    return GDI_ROUND( (double)height * fabs( dc->xformVport2World.eM22 ));
+    scale_x = hypotf(dc->xformWorld2Vport.eM11, dc->xformWorld2Vport.eM12);
+    return GDI_ROUND( (float)width / scale_x );
 }
 
 static inline INT INTERNAL_YWSTODS(DC *dc, INT height)
 {
-    POINT pt[2];
-    pt[0].x = pt[0].y = 0;
-    pt[1].x = 0;
-    pt[1].y = height;
-    lp_to_dp(dc, pt, 2);
-    return pt[1].y - pt[0].y;
+    float scale_y;
+
+    scale_y = hypotf(dc->xformWorld2Vport.eM21, dc->xformWorld2Vport.eM22);
+    return GDI_ROUND( (float)height / scale_y );
 }
 
 static INT FONT_GetObjectW( HGDIOBJ handle, INT count, LPVOID buffer );
@@ -4234,8 +4224,8 @@ static void scale_outline_font_metrics( const struct gdi_font *font, OUTLINETEXT
     else
         scale_x = font->scale_y;
 
-    scale_x *= fabs(font->matrix.eM11);
-    scale_y = font->scale_y * fabs(font->matrix.eM22);
+    scale_x *= hypotf(font->matrix.eM11, font->matrix.eM12);
+    scale_y = font->scale_y * hypotf(font->matrix.eM21, font->matrix.eM22);
 
 /* Windows scales these values as signed integers even if they are unsigned */
 #define SCALE_X(x) (x) = GDI_ROUND((int)(x) * (scale_x))
@@ -4449,8 +4439,8 @@ static void scale_font_metrics( struct gdi_font *font, TEXTMETRICW *tm )
     else
         scale_x = font->scale_y;
 
-    scale_x *= fabs(font->matrix.eM11);
-    scale_y = font->scale_y * fabs(font->matrix.eM22);
+    scale_x *= hypotf(font->matrix.eM11, font->matrix.eM12);
+    scale_y = font->scale_y * hypotf(font->matrix.eM21, font->matrix.eM22);
 
 #define SCALE_X(x) (x) = GDI_ROUND((x) * scale_x)
 #define SCALE_Y(y) (y) = GDI_ROUND((y) * scale_y)
@@ -5420,14 +5410,14 @@ BOOL WINAPI NtGdiGetTextMetricsW( HDC hdc, TEXTMETRICW *metrics, ULONG flags )
 
         metrics->tmDigitizedAspectX = NtGdiGetDeviceCaps(hdc, LOGPIXELSX);
         metrics->tmDigitizedAspectY = NtGdiGetDeviceCaps(hdc, LOGPIXELSY);
-        metrics->tmHeight           = height_to_LP( dc, metrics->tmHeight );
-        metrics->tmAscent           = height_to_LP( dc, metrics->tmAscent );
-        metrics->tmDescent          = height_to_LP( dc, metrics->tmDescent );
-        metrics->tmInternalLeading  = height_to_LP( dc, metrics->tmInternalLeading );
-        metrics->tmExternalLeading  = height_to_LP( dc, metrics->tmExternalLeading );
-        metrics->tmAveCharWidth     = width_to_LP( dc, metrics->tmAveCharWidth );
-        metrics->tmMaxCharWidth     = width_to_LP( dc, metrics->tmMaxCharWidth );
-        metrics->tmOverhang         = width_to_LP( dc, metrics->tmOverhang );
+        metrics->tmHeight           = INTERNAL_YDSTOWS( dc, metrics->tmHeight );
+        metrics->tmAscent           = INTERNAL_YDSTOWS( dc, metrics->tmAscent );
+        metrics->tmDescent          = INTERNAL_YDSTOWS( dc, metrics->tmDescent );
+        metrics->tmInternalLeading  = INTERNAL_YDSTOWS( dc, metrics->tmInternalLeading );
+        metrics->tmExternalLeading  = INTERNAL_YDSTOWS( dc, metrics->tmExternalLeading );
+        metrics->tmAveCharWidth     = INTERNAL_XDSTOWS( dc, metrics->tmAveCharWidth );
+        metrics->tmMaxCharWidth     = INTERNAL_XDSTOWS( dc, metrics->tmMaxCharWidth );
+        metrics->tmOverhang         = INTERNAL_XDSTOWS( dc, metrics->tmOverhang );
         ret = TRUE;
 
         TRACE("text metrics:\n"
@@ -5483,38 +5473,38 @@ UINT WINAPI NtGdiGetOutlineTextMetricsInternalW( HDC hdc, UINT cbData,
     {
         output->otmTextMetrics.tmDigitizedAspectX = NtGdiGetDeviceCaps(hdc, LOGPIXELSX);
         output->otmTextMetrics.tmDigitizedAspectY = NtGdiGetDeviceCaps(hdc, LOGPIXELSY);
-        output->otmTextMetrics.tmHeight           = height_to_LP( dc, output->otmTextMetrics.tmHeight );
-        output->otmTextMetrics.tmAscent           = height_to_LP( dc, output->otmTextMetrics.tmAscent );
-        output->otmTextMetrics.tmDescent          = height_to_LP( dc, output->otmTextMetrics.tmDescent );
-        output->otmTextMetrics.tmInternalLeading  = height_to_LP( dc, output->otmTextMetrics.tmInternalLeading );
-        output->otmTextMetrics.tmExternalLeading  = height_to_LP( dc, output->otmTextMetrics.tmExternalLeading );
-        output->otmTextMetrics.tmAveCharWidth     = width_to_LP( dc, output->otmTextMetrics.tmAveCharWidth );
-        output->otmTextMetrics.tmMaxCharWidth     = width_to_LP( dc, output->otmTextMetrics.tmMaxCharWidth );
-        output->otmTextMetrics.tmOverhang         = width_to_LP( dc, output->otmTextMetrics.tmOverhang );
-        output->otmAscent                = height_to_LP( dc, output->otmAscent);
-        output->otmDescent               = height_to_LP( dc, output->otmDescent);
+        output->otmTextMetrics.tmHeight           = INTERNAL_YDSTOWS( dc, output->otmTextMetrics.tmHeight );
+        output->otmTextMetrics.tmAscent           = INTERNAL_YDSTOWS( dc, output->otmTextMetrics.tmAscent );
+        output->otmTextMetrics.tmDescent          = INTERNAL_YDSTOWS( dc, output->otmTextMetrics.tmDescent );
+        output->otmTextMetrics.tmInternalLeading  = INTERNAL_YDSTOWS( dc, output->otmTextMetrics.tmInternalLeading );
+        output->otmTextMetrics.tmExternalLeading  = INTERNAL_YDSTOWS( dc, output->otmTextMetrics.tmExternalLeading );
+        output->otmTextMetrics.tmAveCharWidth     = INTERNAL_XDSTOWS( dc, output->otmTextMetrics.tmAveCharWidth );
+        output->otmTextMetrics.tmMaxCharWidth     = INTERNAL_XDSTOWS( dc, output->otmTextMetrics.tmMaxCharWidth );
+        output->otmTextMetrics.tmOverhang         = INTERNAL_XDSTOWS( dc, output->otmTextMetrics.tmOverhang );
+        output->otmAscent                = INTERNAL_YDSTOWS( dc, output->otmAscent);
+        output->otmDescent               = INTERNAL_YDSTOWS( dc, output->otmDescent);
         output->otmLineGap               = INTERNAL_YDSTOWS(dc, output->otmLineGap);
         output->otmsCapEmHeight          = INTERNAL_YDSTOWS(dc, output->otmsCapEmHeight);
         output->otmsXHeight              = INTERNAL_YDSTOWS(dc, output->otmsXHeight);
-        output->otmrcFontBox.top         = height_to_LP( dc, output->otmrcFontBox.top);
-        output->otmrcFontBox.bottom      = height_to_LP( dc, output->otmrcFontBox.bottom);
-        output->otmrcFontBox.left        = width_to_LP( dc, output->otmrcFontBox.left);
-        output->otmrcFontBox.right       = width_to_LP( dc, output->otmrcFontBox.right);
-        output->otmMacAscent             = height_to_LP( dc, output->otmMacAscent);
-        output->otmMacDescent            = height_to_LP( dc, output->otmMacDescent);
+        output->otmrcFontBox.top         = INTERNAL_YDSTOWS( dc, output->otmrcFontBox.top);
+        output->otmrcFontBox.bottom      = INTERNAL_YDSTOWS( dc, output->otmrcFontBox.bottom);
+        output->otmrcFontBox.left        = INTERNAL_XDSTOWS( dc, output->otmrcFontBox.left);
+        output->otmrcFontBox.right       = INTERNAL_XDSTOWS( dc, output->otmrcFontBox.right);
+        output->otmMacAscent             = INTERNAL_YDSTOWS( dc, output->otmMacAscent);
+        output->otmMacDescent            = INTERNAL_YDSTOWS( dc, output->otmMacDescent);
         output->otmMacLineGap            = INTERNAL_YDSTOWS(dc, output->otmMacLineGap);
-        output->otmptSubscriptSize.x     = width_to_LP( dc, output->otmptSubscriptSize.x);
-        output->otmptSubscriptSize.y     = height_to_LP( dc, output->otmptSubscriptSize.y);
-        output->otmptSubscriptOffset.x   = width_to_LP( dc, output->otmptSubscriptOffset.x);
-        output->otmptSubscriptOffset.y   = height_to_LP( dc, output->otmptSubscriptOffset.y);
-        output->otmptSuperscriptSize.x   = width_to_LP( dc, output->otmptSuperscriptSize.x);
-        output->otmptSuperscriptSize.y   = height_to_LP( dc, output->otmptSuperscriptSize.y);
-        output->otmptSuperscriptOffset.x = width_to_LP( dc, output->otmptSuperscriptOffset.x);
-        output->otmptSuperscriptOffset.y = height_to_LP( dc, output->otmptSuperscriptOffset.y);
+        output->otmptSubscriptSize.x     = INTERNAL_XDSTOWS( dc, output->otmptSubscriptSize.x);
+        output->otmptSubscriptSize.y     = INTERNAL_YDSTOWS( dc, output->otmptSubscriptSize.y);
+        output->otmptSubscriptOffset.x   = INTERNAL_XDSTOWS( dc, output->otmptSubscriptOffset.x);
+        output->otmptSubscriptOffset.y   = INTERNAL_YDSTOWS( dc, output->otmptSubscriptOffset.y);
+        output->otmptSuperscriptSize.x   = INTERNAL_XDSTOWS( dc, output->otmptSuperscriptSize.x);
+        output->otmptSuperscriptSize.y   = INTERNAL_YDSTOWS( dc, output->otmptSuperscriptSize.y);
+        output->otmptSuperscriptOffset.x = INTERNAL_XDSTOWS( dc, output->otmptSuperscriptOffset.x);
+        output->otmptSuperscriptOffset.y = INTERNAL_YDSTOWS( dc, output->otmptSuperscriptOffset.y);
         output->otmsStrikeoutSize        = INTERNAL_YDSTOWS(dc, output->otmsStrikeoutSize);
-        output->otmsStrikeoutPosition    = height_to_LP( dc, output->otmsStrikeoutPosition);
-        output->otmsUnderscoreSize       = height_to_LP( dc, output->otmsUnderscoreSize);
-        output->otmsUnderscorePosition   = height_to_LP( dc, output->otmsUnderscorePosition);
+        output->otmsStrikeoutPosition    = INTERNAL_YDSTOWS( dc, output->otmsStrikeoutPosition);
+        output->otmsUnderscoreSize       = INTERNAL_YDSTOWS( dc, output->otmsUnderscoreSize);
+        output->otmsUnderscorePosition   = INTERNAL_YDSTOWS( dc, output->otmsUnderscorePosition);
 
         if(output != lpOTM)
         {
@@ -5574,7 +5564,7 @@ BOOL WINAPI NtGdiGetCharWidthW( HDC hdc, UINT first, UINT last, WCHAR *chars,
             INT *buffer = buf;
             /* convert device units to logical */
             for (i = 0; i < count; i++)
-                buffer[i] = width_to_LP( dc, buffer[i] );
+                buffer[i] = INTERNAL_XDSTOWS( dc, buffer[i] );
         }
         else
         {
@@ -5873,7 +5863,7 @@ BOOL nulldrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags, const RECT *rect
  */
 static inline int get_line_width( DC *dc, int metric_size )
 {
-    int width = abs( INTERNAL_YWSTODS( dc, metric_size ));
+    int width = abs( INTERNAL_XWSTODS( dc, metric_size ));
     if (width == 0) width = 1;
     if (metric_size < 0) width = -width;
     return width;
@@ -6336,9 +6326,9 @@ BOOL WINAPI NtGdiGetCharABCWidthsW( HDC hdc, UINT first, UINT last, WCHAR *chars
             /* convert device units to logical */
             for (i = 0; i < count; i++)
             {
-                abc[i].abcA = width_to_LP( dc, abc[i].abcA );
-                abc[i].abcB = width_to_LP( dc, abc[i].abcB );
-                abc[i].abcC = width_to_LP( dc, abc[i].abcC );
+                abc[i].abcA = INTERNAL_XDSTOWS( dc, abc[i].abcA );
+                abc[i].abcB = INTERNAL_XDSTOWS( dc, abc[i].abcB );
+                abc[i].abcC = INTERNAL_XDSTOWS( dc, abc[i].abcC );
             }
         }
         else
@@ -7127,8 +7117,8 @@ BOOL WINAPI NtGdiGetCharWidthInfo( HDC hdc, struct char_width_info *info )
 
     if (ret)
     {
-        info->lsb = width_to_LP( dc, info->lsb );
-        info->rsb = width_to_LP( dc, info->rsb );
+        info->lsb = INTERNAL_XDSTOWS( dc, info->lsb );
+        info->rsb = INTERNAL_XDSTOWS( dc, info->rsb );
     }
     release_dc_ptr(dc);
     return ret;

From 11e4111fd5bf4f7072fbf1b0f37f068a2d7d4448 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Wed, 22 Nov 2023 11:51:23 +0300
Subject: [PATCH 150/244] win32u: NtGdiExtTextOutW() should translate x,y from
 logical to device units at the last step.

Bug: https://bugs.winehq.org/show_bug.cgi?id=33190

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 dlls/win32u/font.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 280773e1bd4..97a4c143edb 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -5993,12 +5993,6 @@ BOOL WINAPI NtGdiExtTextOutW( HDC hdc, INT x, INT y, UINT flags, const RECT *lpr
         goto done;
     }
 
-    pt.x = x;
-    pt.y = y;
-    lp_to_dp(dc, &pt, 1);
-    x = pt.x;
-    y = pt.y;
-
     char_extra = dc->attr->char_extra;
     if (char_extra && lpDx && NtGdiGetDeviceCaps( hdc, TECHNOLOGY ) == DT_RASPRINTER)
         char_extra = 0; /* Printer drivers don't add char_extra if lpDx is supplied */
@@ -6123,8 +6117,6 @@ BOOL WINAPI NtGdiExtTextOutW( HDC hdc, INT x, INT y, UINT flags, const RECT *lpr
         width = desired[1];
     }
 
-    tm.tmAscent = abs(INTERNAL_YWSTODS(dc, tm.tmAscent));
-    tm.tmDescent = abs(INTERNAL_YWSTODS(dc, tm.tmDescent));
     switch( align & (TA_LEFT | TA_RIGHT | TA_CENTER) )
     {
     case TA_LEFT:
@@ -6186,12 +6178,19 @@ BOOL WINAPI NtGdiExtTextOutW( HDC hdc, INT x, INT y, UINT flags, const RECT *lpr
                 text_box.bottom = y + tm.tmDescent;
 
                 if (flags & ETO_CLIPPED) intersect_rect( &text_box, &text_box, &rc );
+                lp_to_dp(dc, (POINT *)&text_box, 2);
                 if (!IsRectEmpty( &text_box ))
                     physdev->funcs->pExtTextOut( physdev, 0, 0, ETO_OPAQUE, &text_box, NULL, 0, NULL );
             }
         }
     }
 
+    pt.x = x;
+    pt.y = y;
+    lp_to_dp(dc, &pt, 1);
+    x = pt.x;
+    y = pt.y;
+
     ret = physdev->funcs->pExtTextOut( physdev, x, y, (flags & ~ETO_OPAQUE), &rc,
                                        str, count, (INT*)deltas );
 

From e1fe3685a6e0439bd0da5888c3ba717f47a039ea Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 25 May 2018 15:25:56 +1000
Subject: [PATCH 151/244] windowscodecs/tests: Add IWICBitmapEncoderInfo test

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/windowscodecs/tests/converter.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/windowscodecs/tests/converter.c b/dlls/windowscodecs/tests/converter.c
index f6cef841d56..6ac86a36db3 100644
--- a/dlls/windowscodecs/tests/converter.c
+++ b/dlls/windowscodecs/tests/converter.c
@@ -1447,6 +1447,8 @@ static void test_multi_encoder_impl(const struct bitmap_data **srcs, const CLSID
 
         if (hglobal && SUCCEEDED(hr))
         {
+            IWICBitmapEncoderInfo *info = NULL;
+
             if (palette)
             {
                 hr = IWICBitmapEncoder_SetPalette(encoder, palette);
@@ -1466,6 +1468,20 @@ static void test_multi_encoder_impl(const struct bitmap_data **srcs, const CLSID
                 hr = S_OK;
             }
 
+            hr = IWICBitmapEncoder_GetEncoderInfo(encoder, &info);
+            ok(hr == S_OK || hr == WINCODEC_ERR_COMPONENTNOTFOUND, "wrong error %#lx\n", hr);
+            if (SUCCEEDED(hr))
+            {
+                CLSID clsid;
+
+                hr = IWICBitmapEncoderInfo_GetCLSID(info, &clsid);
+                ok(hr == S_OK, "wrong error %#lx\n", hr);
+                ok(!IsEqualGUID(clsid_encoder, &clsid), "wrong CLSID %s (%s)\n",
+                       wine_dbgstr_guid(clsid_encoder), wine_dbgstr_guid(&clsid));
+
+                IWICBitmapEncoderInfo_Release(info);
+            }
+
             i=0;
             while (SUCCEEDED(hr) && srcs[i])
             {

From 6b380e71a18125593e5fdb573a68b4c0bf7bca39 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Fri, 16 Dec 2016 18:08:51 +0800
Subject: [PATCH 152/244] windowscodecs: Tolerate partial reads in the IFD
 metadata loader.

---
 dlls/windowscodecs/metadatahandler.c | 37 +++++++++++-----------------
 1 file changed, 15 insertions(+), 22 deletions(-)

diff --git a/dlls/windowscodecs/metadatahandler.c b/dlls/windowscodecs/metadatahandler.c
index 2d60c38ee10..5864dbf9d98 100644
--- a/dlls/windowscodecs/metadatahandler.c
+++ b/dlls/windowscodecs/metadatahandler.c
@@ -791,7 +791,7 @@ static int tag_to_vt(SHORT tag)
 static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
                               MetadataItem *item, BOOL native_byte_order)
 {
-    ULONG count, value, i, bytesread;
+    ULONG count, value, i;
     SHORT type;
     LARGE_INTEGER pos;
     HRESULT hr;
@@ -843,9 +843,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.caub.pElems);
             return hr;
         }
-        hr = IStream_Read(input, item->value.caub.pElems, count, &bytesread);
-        if (bytesread != count) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.caub.pElems, count, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.caub.pElems);
             return hr;
@@ -878,7 +877,7 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
 
         item->value.vt |= VT_VECTOR;
         item->value.caui.cElems = count;
-        item->value.caui.pElems = CoTaskMemAlloc(count * 2);
+        item->value.caui.pElems = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, count * 2);
         if (!item->value.caui.pElems) return E_OUTOFMEMORY;
 
         pos.QuadPart = value;
@@ -888,9 +887,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.caui.pElems);
             return hr;
         }
-        hr = IStream_Read(input, item->value.caui.pElems, count * 2, &bytesread);
-        if (bytesread != count * 2) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.caui.pElems, count * 2, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.caui.pElems);
             return hr;
@@ -921,9 +919,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.caul.pElems);
             return hr;
         }
-        hr = IStream_Read(input, item->value.caul.pElems, count * 4, &bytesread);
-        if (bytesread != count * 4) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.caul.pElems, count * 4, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.caul.pElems);
             return hr;
@@ -949,8 +946,7 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             hr = IStream_Seek(input, pos, SEEK_SET, NULL);
             if (FAILED(hr)) return hr;
 
-            hr = IStream_Read(input, &ull, sizeof(ull), &bytesread);
-            if (bytesread != sizeof(ull)) hr = E_FAIL;
+            hr = IStream_Read(input, &ull, sizeof(ull), NULL);
             if (hr != S_OK) return hr;
 
             item->value.uhVal.QuadPart = ull;
@@ -978,9 +974,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
                 CoTaskMemFree(item->value.cauh.pElems);
                 return hr;
             }
-            hr = IStream_Read(input, item->value.cauh.pElems, count * 8, &bytesread);
-            if (bytesread != count * 8) hr = E_FAIL;
-            if (hr != S_OK)
+            hr = IStream_Read(input, item->value.cauh.pElems, count * 8, NULL);
+            if (FAILED(hr))
             {
                 CoTaskMemFree(item->value.cauh.pElems);
                 return hr;
@@ -1016,9 +1011,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.pszVal);
             return hr;
         }
-        hr = IStream_Read(input, item->value.pszVal, count, &bytesread);
-        if (bytesread != count) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.pszVal, count, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.pszVal);
             return hr;
@@ -1052,9 +1046,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.blob.pBlobData);
             return hr;
         }
-        hr = IStream_Read(input, item->value.blob.pBlobData, count, &bytesread);
-        if (bytesread != count) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.blob.pBlobData, count, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.blob.pBlobData);
             return hr;

From 96448df7dae6b83d722f8f763be14f353fb50642 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Fri, 16 Dec 2016 18:09:55 +0800
Subject: [PATCH 153/244] gdiplus: Add support for more image color formats.

---
 dlls/gdiplus/image.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/gdiplus/image.c b/dlls/gdiplus/image.c
index 6e55113dbce..25394eaebe6 100644
--- a/dlls/gdiplus/image.c
+++ b/dlls/gdiplus/image.c
@@ -59,7 +59,12 @@ static const struct
     { &GUID_WICPixelFormat24bppBGR, PixelFormat24bppRGB, 0 },
     { &GUID_WICPixelFormat32bppBGR, PixelFormat32bppRGB, 0 },
     { &GUID_WICPixelFormat32bppBGRA, PixelFormat32bppARGB, 0 },
+    { &GUID_WICPixelFormat32bppCMYK, PixelFormat32bppCMYK, 0 },
+    { &GUID_WICPixelFormat32bppGrayFloat, PixelFormat32bppARGB, 0 },
     { &GUID_WICPixelFormat32bppPBGRA, PixelFormat32bppPARGB, 0 },
+    { &GUID_WICPixelFormat48bppRGB, PixelFormat48bppRGB, 0 },
+    { &GUID_WICPixelFormat64bppCMYK, PixelFormat48bppRGB, 0 },
+    { &GUID_WICPixelFormat64bppRGBA, PixelFormat48bppRGB, 0 },
     { NULL }
 };
 

From 46baee46e8eb905df8624fe44672595a8a919a09 Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Fri, 16 Dec 2016 18:10:30 +0800
Subject: [PATCH 154/244] gdiplus/tests: Add some tests for loading TIFF images
 in various color formats.

---
 dlls/gdiplus/tests/image.c | 181 +++++++++++++++++++++++++++++++++++++
 1 file changed, 181 insertions(+)

diff --git a/dlls/gdiplus/tests/image.c b/dlls/gdiplus/tests/image.c
index df26f699e86..07716e2382e 100644
--- a/dlls/gdiplus/tests/image.c
+++ b/dlls/gdiplus/tests/image.c
@@ -6355,6 +6355,186 @@ static void test_graphics_clear(void)
     GdipDisposeImage((GpImage *)bitmap);
 }
 
+#include "pshpack2.h"
+static const struct tiff_1x1_data
+{
+    USHORT byte_order;
+    USHORT version;
+    ULONG  dir_offset;
+    USHORT number_of_entries;
+    struct IFD_entry entry[12];
+    ULONG next_IFD;
+    struct IFD_rational res;
+    short palette_data[3][256];
+    short bps_data[4];
+    BYTE pixel_data[32];
+} tiff_1x1_data =
+{
+#ifdef WORDS_BIGENDIAN
+    'M' | 'M' << 8,
+#else
+    'I' | 'I' << 8,
+#endif
+    42,
+    FIELD_OFFSET(struct tiff_1x1_data, number_of_entries),
+    12,
+    {
+        { 0xff, IFD_SHORT, 1, 0 }, /* SUBFILETYPE */
+        { 0x100, IFD_LONG, 1, 1 }, /* IMAGEWIDTH */
+        { 0x101, IFD_LONG, 1, 1 }, /* IMAGELENGTH */
+        { 0x102, IFD_SHORT, 3, FIELD_OFFSET(struct tiff_1x1_data, bps_data) }, /* BITSPERSAMPLE */
+        { 0x103, IFD_SHORT, 1, 1 }, /* COMPRESSION: XP doesn't accept IFD_LONG here */
+        { 0x106, IFD_SHORT, 1, 2 }, /* PHOTOMETRIC */
+        { 0x111, IFD_LONG, 1, FIELD_OFFSET(struct tiff_1x1_data, pixel_data) }, /* STRIPOFFSETS */
+        { 0x115, IFD_SHORT, 1, 3 }, /* SAMPLESPERPIXEL */
+        { 0x11a, IFD_RATIONAL, 1, FIELD_OFFSET(struct tiff_1x1_data, res) },
+        { 0x11b, IFD_RATIONAL, 1, FIELD_OFFSET(struct tiff_1x1_data, res) },
+        { 0x128, IFD_SHORT, 1, 2 }, /* RESOLUTIONUNIT */
+        { 0x140, IFD_SHORT, 256*3, FIELD_OFFSET(struct tiff_1x1_data, palette_data) } /* COLORMAP */
+    },
+    0,
+    { 96, 1 },
+    { { 0 } },
+    { 8,8,8,0 },
+    { 1,0,2,3,4,5,6,7,8,9,0,1,2,3,4,5 }
+};
+#include "poppack.h"
+
+static void test_tiff_color_formats(void)
+{
+    static const struct
+    {
+        int photometric; /* PhotometricInterpretation */
+        int samples; /* SamplesPerPixel */
+        int bps; /* BitsPerSample */
+        PixelFormat format;
+    } td[] =
+    {
+        /* 2 - RGB */
+        { 2, 3, 1, PixelFormat24bppRGB },
+        { 2, 3, 4, PixelFormat24bppRGB },
+        { 2, 3, 8, PixelFormat24bppRGB },
+        { 2, 3, 16, PixelFormat48bppRGB },
+        { 2, 3, 24, 0 },
+#if 0 /* FIXME */
+        { 2, 3, 32, 0 },
+#endif
+        { 2, 4, 1, PixelFormat32bppARGB },
+        { 2, 4, 4, PixelFormat32bppARGB },
+        { 2, 4, 8, PixelFormat32bppARGB },
+        { 2, 4, 16, PixelFormat48bppRGB },
+        { 2, 4, 24, 0 },
+        { 2, 4, 32, 0 },
+        /* 1 - BlackIsZero (Bilevel) */
+        { 1, 1, 1, PixelFormat1bppIndexed },
+#if 0 /* FIXME: PNG vs TIFF mismatch */
+        { 1, 1, 4, PixelFormat8bppIndexed },
+#endif
+        { 1, 1, 8, PixelFormat8bppIndexed },
+        { 1, 1, 16, PixelFormat32bppARGB },
+        { 1, 1, 24, 0 },
+        { 1, 1, 32, PixelFormat32bppARGB },
+        /* 3 - Palette Color */
+        { 3, 1, 1, PixelFormat1bppIndexed },
+        { 3, 1, 4, PixelFormat4bppIndexed },
+        { 3, 1, 8, PixelFormat8bppIndexed },
+#if 0 /* FIXME: for some reason libtiff replaces photometric 3 by 1 for bps > 8 */
+        { 3, 1, 16, 0 },
+        { 3, 1, 24, 0 },
+        { 3, 1, 32, 0 },
+#endif
+        /* 5 - Separated */
+        { 5, 4, 1, 0 },
+        { 5, 4, 4, 0 },
+        { 5, 4, 8, PixelFormat32bppCMYK },
+        { 5, 4, 16, PixelFormat48bppRGB },
+        { 5, 4, 24, 0 },
+        { 5, 4, 32, 0 },
+    };
+    BYTE buf[sizeof(tiff_1x1_data)];
+    GpStatus status;
+    GpImage *image;
+    UINT count, i;
+    struct IFD_entry *tag, *tag_photo = NULL, *tag_bps = NULL, *tag_samples = NULL, *tag_colormap = NULL;
+    short *bps;
+    ImageType type;
+    PixelFormat format;
+
+    memcpy(buf, &tiff_1x1_data, sizeof(tiff_1x1_data));
+
+    count = *(short *)(buf + tiff_1x1_data.dir_offset);
+    tag = (struct IFD_entry *)(buf + tiff_1x1_data.dir_offset + sizeof(short));
+
+    /* verify the TIFF structure */
+    for (i = 0; i < count; i++)
+    {
+        if (tag[i].id == 0x102) /* BitsPerSample */
+            tag_bps = &tag[i];
+        else if (tag[i].id == 0x106) /* PhotometricInterpretation */
+            tag_photo = &tag[i];
+        else if (tag[i].id == 0x115) /* SamplesPerPixel */
+            tag_samples = &tag[i];
+        else if (tag[i].id == 0x140) /* ColorMap */
+            tag_colormap = &tag[i];
+    }
+
+    ok(tag_bps && tag_photo && tag_samples && tag_colormap, "tag 0x102,0x106,0x115 or 0x140 is missing\n");
+    if (!tag_bps || !tag_photo || !tag_samples || !tag_colormap) return;
+
+    ok(tag_bps->type == IFD_SHORT, "tag 0x102 should have type IFD_SHORT\n");
+    bps = (short *)(buf + tag_bps->value);
+    ok(bps[0] == 8 && bps[1] == 8 && bps[2] == 8 && bps[3] == 0,
+       "expected bps 8,8,8,0 got %d,%d,%d,%d\n", bps[0], bps[1], bps[2], bps[3]);
+
+    for (i = 0; i < sizeof(td)/sizeof(td[0]); i++)
+    {
+        tag_colormap->count = (1 << td[i].bps) * 3;
+        tag_photo->value = td[i].photometric;
+        tag_bps->count = td[i].samples;
+        tag_samples->value = td[i].samples;
+
+        if (td[i].samples == 1)
+            tag_bps->value = td[i].bps;
+        else if (td[i].samples == 2)
+            tag_bps->value = MAKELONG(td[i].bps, td[i].bps);
+        else if (td[i].samples == 3)
+        {
+            tag_bps->value = (BYTE *)bps - buf;
+            bps[0] = bps[1] = bps[2] = td[i].bps;
+        }
+        else if (td[i].samples == 4)
+        {
+            tag_bps->value = (BYTE *)bps - buf;
+            bps[0] = bps[1] = bps[2] = bps[3] = td[i].bps;
+        }
+        else
+        {
+            ok(0, "%u: unsupported samples count %d\n", i, td[i].samples);
+            continue;
+        }
+
+        image = load_image(buf, sizeof(buf), TRUE, FALSE);
+        if (!td[i].format)
+            ok(!image,
+               "%u: (%d,%d,%d) TIFF image loading should have failed\n", i, td[i].photometric, td[i].samples, td[i].bps);
+        else
+            ok(image != NULL || broken(!image) /* XP */, "%u: failed to load TIFF image data (%d,%d,%d)\n",
+               i, td[i].photometric, td[i].samples, td[i].bps);
+        if (!image) continue;
+
+        status = GdipGetImageType(image, &type);
+        ok(status == Ok, "%u: GdipGetImageType error %d\n", i, status);
+        ok(type == ImageTypeBitmap, "%u: wrong image type %d\n", i, type);
+
+        status = GdipGetImagePixelFormat(image, &format);
+        expect(Ok, status);
+        ok(format == td[i].format,
+           "%u: expected %#x, got %#x\n", i, td[i].format, format);
+
+        GdipDisposeImage(image);
+    }
+}
+
 START_TEST(image)
 {
     HMODULE mod = GetModuleHandleA("gdiplus.dll");
@@ -6379,6 +6559,7 @@ START_TEST(image)
     pGdipBitmapGetHistogram = (void*)GetProcAddress(mod, "GdipBitmapGetHistogram");
     pGdipImageSetAbort = (void*)GetProcAddress(mod, "GdipImageSetAbort");
 
+    test_tiff_color_formats();
     test_GdipInitializePalette();
     test_png_color_formats();
     test_png_save_palette();

From 11cbe8e1fe66d73ca22517f4745cf96450ad3f8d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 13 Mar 2016 03:59:22 +0100
Subject: [PATCH 155/244] wine.inf.in: Add invalid dummy certificate to CA
 certificate store.

Pythons ssl module raises an exception if the CA certificate store is empty.
Wine currently doesn't add any certificates to this store and this patch tries
to solve the problem by adding a dummy certificate. The certificate shouldn't
have any effect though as it is invalid by design. The dates were choosen in a
way that this certificate can never be valid:

Not Before: Mar 13 02:13:31 2016 GMT
Not After : Mar 12 02:13:31 2016 GMT
---
 loader/wine.inf.in | 43 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 4f3a0fc74ac..9982c1920db 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -704,6 +704,49 @@ HKLM,Software\Microsoft\Rpc\SecurityService,68,2,"netlogon.dll"
 HKLM,Software\Microsoft\Rpc\SecurityService,9,2,"secur32.dll"
 HKLM,Software\Microsoft\Shared Tools\MSInfo,,16
 HKLM,Software\Microsoft\SystemCertificates,,16
+HKLM,Software\Microsoft\SystemCertificates\CA\Certificates\23340A0167398E341C5890709FD30EED44FC1964,"Blob",1,\
+    03,00,00,00,01,00,00,00,14,00,00,00,23,34,0a,01,67,39,8e,34,1c,58,90,70,9f,d3,0e,ed,44,fc,19,64,20,00,00,\
+    00,01,00,00,00,81,05,00,00,30,82,05,7d,30,82,03,65,a0,03,02,01,02,02,09,00,87,0d,26,f3,cb,4a,11,1b,30,0d,\
+    06,09,2a,86,48,86,f7,0d,01,01,0d,05,00,30,55,31,0b,30,09,06,03,55,04,06,13,02,55,53,31,13,30,11,06,03,55,\
+    04,08,0c,0a,53,6f,6d,65,2d,53,74,61,74,65,31,0d,30,0b,06,03,55,04,0a,0c,04,57,69,6e,65,31,22,30,20,06,03,\
+    55,04,03,0c,19,49,6e,76,61,6c,69,64,20,64,75,6d,6d,79,20,63,65,72,74,69,66,69,63,61,74,65,30,1e,17,0d,31,\
+    36,30,33,31,33,30,32,31,33,33,31,5a,17,0d,31,36,30,33,31,32,30,32,31,33,33,31,5a,30,55,31,0b,30,09,06,03,\
+    55,04,06,13,02,55,53,31,13,30,11,06,03,55,04,08,0c,0a,53,6f,6d,65,2d,53,74,61,74,65,31,0d,30,0b,06,03,55,\
+    04,0a,0c,04,57,69,6e,65,31,22,30,20,06,03,55,04,03,0c,19,49,6e,76,61,6c,69,64,20,64,75,6d,6d,79,20,63,65,\
+    72,74,69,66,69,63,61,74,65,30,82,02,22,30,0d,06,09,2a,86,48,86,f7,0d,01,01,01,05,00,03,82,02,0f,00,30,82,\
+    02,0a,02,82,02,01,00,ec,26,db,20,a6,25,fc,6d,d7,7f,35,45,2a,bd,26,9a,6c,a7,f3,4c,e7,d4,1b,c1,44,bf,13,61,\
+    9c,93,9f,ff,f2,89,d7,aa,52,d0,e0,d3,41,99,00,a5,82,0e,71,e2,f7,22,0c,9c,3a,21,e1,b2,ba,a8,e2,0b,6f,7c,7c,\
+    fb,92,c4,98,9f,01,dd,17,b4,f7,ac,ab,75,40,fb,b8,1d,7c,4f,c2,ac,6f,d5,ed,38,b6,b5,dd,73,fe,3d,21,f7,fd,81,\
+    e6,af,fe,85,a4,0b,9c,d2,d2,7f,fd,45,3e,7f,80,ce,69,69,38,e1,5c,9c,bc,fd,4c,8b,64,78,f7,45,56,53,8f,97,aa,\
+    98,3a,49,37,2e,45,a6,dc,04,fc,89,26,71,fd,15,24,3b,66,5c,3d,fe,7f,ef,25,b3,01,94,a1,8f,83,5d,b0,d7,d5,1c,\
+    8e,14,b2,95,f5,52,28,50,ab,81,74,0e,0f,5f,61,fe,4b,03,e0,c4,98,3a,f9,01,c7,f0,c9,66,12,d9,60,17,a9,1e,6b,\
+    2d,91,6b,de,95,96,58,f5,81,21,af,d1,7f,99,01,cb,e6,1d,cf,d3,0f,1e,70,4b,de,2b,2c,fe,1f,1d,d8,76,32,74,8d,\
+    bc,4f,0c,33,6d,3b,9f,ba,15,16,28,70,44,6b,da,c5,85,11,4f,bd,4c,00,b4,f1,03,93,89,18,63,1d,ec,3e,ad,6a,b1,\
+    fc,07,f7,65,7c,bf,6a,c8,e7,2a,19,40,0a,55,59,39,63,b1,b8,a8,95,20,62,ae,97,82,af,d6,b1,97,ce,ba,29,19,9f,\
+    dd,c8,63,a0,80,34,e5,a0,c5,f6,b2,95,b1,8e,34,39,34,08,cb,24,70,a7,fb,8e,34,2c,e4,41,77,ea,05,3b,30,5e,71,\
+    b9,64,9f,bf,a6,db,d8,ef,5e,42,9c,4e,5d,47,68,a5,23,15,4f,07,3c,d3,ea,62,ff,af,4c,08,e7,9b,2b,9c,0a,69,f7,\
+    3e,ab,8a,05,40,d2,17,7e,0f,c8,37,2b,e2,62,25,f7,e9,e0,d7,8f,18,ff,46,f9,35,3f,2d,d6,3e,cf,e2,fd,08,0d,1f,\
+    63,ff,80,75,50,3b,a9,44,11,c8,b4,ae,a4,24,17,e3,0d,8a,a5,d3,56,37,97,99,91,c1,62,f9,75,a6,77,e0,25,f6,a4,\
+    9c,83,36,bb,4a,c5,82,c4,86,03,2f,dd,6f,c4,45,ec,fe,d0,51,d6,e0,d2,6a,da,00,30,24,c0,8e,e8,a1,ce,4c,7f,bb,\
+    54,09,05,9e,2b,93,95,c8,ac,39,12,29,56,4e,b0,20,36,9c,a3,b6,cb,46,59,a3,2b,62,2c,2d,57,02,03,01,00,01,a3,\
+    50,30,4e,30,1d,06,03,55,1d,0e,04,16,04,14,d1,85,39,b7,9b,05,e7,f9,54,12,91,68,ed,93,ec,63,eb,d3,8f,14,30,\
+    1f,06,03,55,1d,23,04,18,30,16,80,14,d1,85,39,b7,9b,05,e7,f9,54,12,91,68,ed,93,ec,63,eb,d3,8f,14,30,0c,06,\
+    03,55,1d,13,04,05,30,03,01,01,ff,30,0d,06,09,2a,86,48,86,f7,0d,01,01,0d,05,00,03,82,02,01,00,be,a7,cf,6e,\
+    e7,3d,5d,f2,38,0c,f9,69,85,fe,79,25,cf,c5,5b,d3,4e,4b,ec,20,16,1b,46,1a,d9,a4,a1,84,24,9a,4d,0d,44,70,83,\
+    be,e3,af,5b,ac,c4,31,e3,d5,f8,cc,af,71,11,2d,ea,a8,44,20,81,8b,e3,f6,da,77,6a,f6,15,f3,11,78,78,76,4f,6d,\
+    b6,8c,a5,27,41,0a,16,b6,c8,56,dc,a6,a2,0a,e2,87,e9,ab,f0,05,8b,61,7c,a7,03,2f,30,cc,dd,21,7e,48,43,10,cd,\
+    aa,9e,37,69,7c,3e,2f,7b,c1,0c,78,80,aa,18,92,95,a0,2a,9e,2f,a6,33,6b,91,8d,fb,f1,47,16,ec,87,86,7a,26,d3,\
+    57,a9,89,37,76,86,76,9b,96,bf,f1,2a,e3,62,2a,bc,66,7b,91,62,fb,a2,7e,16,c6,6e,84,08,49,b0,9d,5d,42,b7,64,\
+    39,1f,49,a6,a2,98,bc,ca,57,e5,f5,91,c0,6b,6c,94,56,68,34,00,96,25,1d,e5,bb,9e,2f,1a,dd,c2,27,e4,49,f2,54,\
+    68,0a,e3,1b,4c,01,14,0d,64,8c,d6,ab,73,af,51,b6,fe,af,0a,b6,c1,99,36,97,f8,44,48,64,d3,c0,ab,d9,a8,da,06,\
+    1a,27,c3,24,cf,7a,30,12,38,20,6c,71,ea,57,fa,b6,24,23,42,3d,be,07,f9,d7,de,b2,91,20,a6,57,79,06,60,42,cb,\
+    73,2b,98,ea,49,78,ee,47,71,a5,1c,f1,f9,8f,78,49,ad,6f,21,72,1a,d2,90,02,59,01,7d,f1,cd,c7,43,4c,f4,6c,90,\
+    59,38,bf,46,92,09,24,3b,51,2b,49,2a,a7,f9,7c,96,44,e6,ed,8e,7d,85,64,6b,ca,7b,e3,af,bd,73,ae,17,31,52,2a,\
+    9f,a3,3b,dd,3d,33,59,26,7c,6d,46,ff,5b,dd,3c,82,dd,d1,3d,9c,31,2a,82,7e,85,ce,ef,a6,34,98,96,87,7a,2b,a0,\
+    a5,5a,9c,2a,5c,f4,79,36,b4,85,87,eb,fd,7e,94,83,40,b0,4f,d7,03,c1,df,75,37,30,4f,46,6b,29,b5,0f,b7,4f,19,\
+    73,79,dd,ee,2d,2c,c8,1f,72,ee,63,4a,32,85,33,57,1d,f5,89,53,4f,b2,1e,20,9b,11,e4,43,99,15,65,c4,a0,ec,cf,\
+    d3,0f,d6,b2,2c,8c,a7,6d,5f,11,2f,0e,e4,f7,e9,d4,13,db,fb,f6,0a,51,ac,6c,08,ef,d6,cb,81,86,53,36,a8,a0,02,\
+    de,31,47,56,db,65,f1,7e,3a,c8,69,5b,69,ab,34,3e,48,a3
 HKLM,Software\Microsoft\TermServLicensing,,16
 HKLM,Software\Microsoft\Transaction Server,,16
 HKLM,Software\Microsoft\WBEM,"Installation Directory",2,"%11%\wbem"

From 1dccd2a0b0e24a096d8a1de3399b6395c9829f2e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 16 Mar 2014 03:19:39 +0100
Subject: [PATCH 156/244] wineboot: Add some generic hardware in
 HKEY_DYN_DATA\Config Manager\Enum

---
 programs/wineboot/wineboot.c | 100 +++++++++++++++++++++++++++++++++++
 1 file changed, 100 insertions(+)

diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index f058ac9f378..691217a7b14 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -991,16 +991,116 @@ static void create_hardware_registry_keys(void)
     free( buf );
 }
 
+struct dyndata_enum_key{
+    WCHAR id[9];
+    WCHAR hardwarekey[64];
+    char  problem[4];
+    char  status[4];
+    char  allocation[12];
+    char  child[4];
+    char  sibling[4];
+    char  parent[4];
+};
+
+static struct dyndata_enum_key predefined_enums[] =
+{
+    {
+        {'C','2','9','A','2','3','D','0',0},
+        {'H','T','R','E','E','\\','R','O','O','T','\\','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4e, 0x08, 0x08, 0x1a},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x40, 0x5a, 0x9a, 0xc2},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00}
+    },
+    {
+        {'C','2','9','A','5','A','4','0',0},
+        {'H','T','R','E','E','\\','R','E','S','E','R','V','E','D','\\','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4e, 0x08, 0x08, 0x18},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x60, 0x5c, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','C','6','0',0},
+        {'R','O','O','T','\\','N','E','T','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4f, 0x6a, 0x08, 0x18},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0xf0, 0x93, 0x9b, 0xc2},
+        {0xc0, 0x5d, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','D','C','0',0},
+        {'R','O','O','T','\\','P','R','O','C','E','S','S','O','R','_','U','P','D','A','T','E','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0xcf, 0x6a, 0x88, 0x19},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x20, 0x5f, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','F','2','0',0},
+        {'R','O','O','T','\\','S','W','E','N','U','M','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0xcf, 0x6a, 0x88, 0x19},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x20, 0x5f, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    }
+};
+
+/* add entry to HKEY_DYN_DATA\Config Manager\Enum */
+static void add_dynamic_enum_keys(HKEY key, struct dyndata_enum_key *entry)
+{
+    static const WCHAR HardWareKeyW[] = {'H','a','r','d','W','a','r','e','K','e','y',0};
+    static const WCHAR ProblemW[]     = {'P','r','o','b','l','e','m',0};
+    static const WCHAR StatusW[]      = {'S','t','a','t','u','s',0};
+    static const WCHAR AllocationW[]  = {'A','l','l','o','c','a','t','i','o','n',0};
+    static const WCHAR ChildW[]       = {'C','h','i','l','d',0};
+    static const WCHAR SiblingW[]     = {'S','i','b','l','i','n','g',0};
+    static const WCHAR ParentW[]      = {'P','a','r','e','n','t',0};
+
+    HKEY subkey;
+
+    if (!entry)
+        return;
+
+    if (RegCreateKeyExW( key, entry->id, 0, NULL, 0, KEY_WRITE, NULL, &subkey, NULL ))
+        return;
+
+    set_reg_value( subkey, HardWareKeyW, entry->hardwarekey );
+    RegSetValueExW( subkey, ProblemW,    0, REG_BINARY, (const BYTE *)entry->problem,    sizeof(entry->problem) );
+    RegSetValueExW( subkey, StatusW,     0, REG_BINARY, (const BYTE *)entry->status,     sizeof(entry->status) );
+    RegSetValueExW( subkey, AllocationW, 0, REG_BINARY, (const BYTE *)entry->allocation, sizeof(entry->allocation) );
+    RegSetValueExW( subkey, ChildW,      0, REG_BINARY, (const BYTE *)entry->child,      sizeof(entry->child) );
+    RegSetValueExW( subkey, SiblingW,    0, REG_BINARY, (const BYTE *)entry->sibling,    sizeof(entry->sibling) );
+    RegSetValueExW( subkey, ParentW,     0, REG_BINARY, (const BYTE *)entry->parent,     sizeof(entry->parent) );
+
+    RegCloseKey( subkey );
+}
 
 /* create the DynData registry keys */
 static void create_dynamic_registry_keys(void)
 {
     HKEY key;
+    int entry;
 
     if (!RegCreateKeyExW( HKEY_DYN_DATA, L"PerfStats\\StatData", 0, NULL, 0, KEY_WRITE, NULL, &key, NULL ))
         RegCloseKey( key );
     if (!RegCreateKeyExW( HKEY_DYN_DATA, L"Config Manager\\Enum", 0, NULL, 0, KEY_WRITE, NULL, &key, NULL ))
+    {
+        for (entry = 0; entry < sizeof(predefined_enums) / sizeof(predefined_enums[0]); entry++)
+            add_dynamic_enum_keys( key, &predefined_enums[entry] );
+
         RegCloseKey( key );
+    }
 }
 
 /* create the ComputerName registry keys */

From 115a5371925d4b0416d9ace6952c68720a6f6418 Mon Sep 17 00:00:00 2001
From: Hao Peng <penghao@linuxdeepin.com>
Date: Thu, 5 Mar 2015 12:00:49 +0800
Subject: [PATCH 157/244] winecfg: Double click in dlls list to edit item's
 overides. (try 3)

Add a feature to winecfg. User can double click in dlls list to edit overides of selected item.
---
 programs/winecfg/libraries.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/programs/winecfg/libraries.c b/programs/winecfg/libraries.c
index 09fd397ab63..760258cebf6 100644
--- a/programs/winecfg/libraries.c
+++ b/programs/winecfg/libraries.c
@@ -658,6 +658,18 @@ LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
                         else
                             set_controls_from_selection(hDlg);
                         break;
+            case CBN_DBLCLK:
+                if (LOWORD(wParam) == IDC_DLLS_LIST)
+                {
+                    int index;
+                    POINT p;
+                    if (GetCursorPos(&p) && ScreenToClient((HWND)lParam, &p))
+                    {
+                        index = SendDlgItemMessageW(hDlg, IDC_DLLS_LIST, LB_ITEMFROMPOINT, 0, MAKELPARAM(p.x, p.y));
+                        if (!HIWORD(index)) on_edit_click(hDlg);
+                    }
+                }
+                break;
 		}
 		break;
 	}

From 36038e745eed625189c1205177049677004231a3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 14 Dec 2014 20:42:45 +0100
Subject: [PATCH 158/244] winecfg: Add staging tab for CSMT.

---
 programs/winecfg/Makefile.in |  1 +
 programs/winecfg/main.c      | 12 +++++-
 programs/winecfg/resource.h  |  5 +++
 programs/winecfg/staging.c   | 82 ++++++++++++++++++++++++++++++++++++
 programs/winecfg/winecfg.h   |  1 +
 programs/winecfg/winecfg.rc  | 10 +++++
 6 files changed, 110 insertions(+), 1 deletion(-)
 create mode 100644 programs/winecfg/staging.c

diff --git a/programs/winecfg/Makefile.in b/programs/winecfg/Makefile.in
index 780f0e7e183..99c829a9468 100644
--- a/programs/winecfg/Makefile.in
+++ b/programs/winecfg/Makefile.in
@@ -12,6 +12,7 @@ SOURCES = \
 	libraries.c \
 	logo.svg \
 	main.c \
+	staging.c \
 	theme.c \
 	winecfg.c \
 	winecfg.man.in \
diff --git a/programs/winecfg/main.c b/programs/winecfg/main.c
index 2697383d781..afecfd664a9 100644
--- a/programs/winecfg/main.c
+++ b/programs/winecfg/main.c
@@ -58,7 +58,7 @@ PropSheetCallback (HWND hWnd, UINT uMsg, LPARAM lParam)
     return 0;
 }
 
-#define NUM_PROPERTY_PAGES 7
+#define NUM_PROPERTY_PAGES 8
 
 static INT_PTR
 doPropertySheet (HINSTANCE hInstance, HWND hOwner)
@@ -139,6 +139,16 @@ doPropertySheet (HINSTANCE hInstance, HWND hOwner)
     psp[pg].lParam = 0;
     pg++;
 
+    psp[pg].dwSize = sizeof (PROPSHEETPAGEW);
+    psp[pg].dwFlags = PSP_USETITLE;
+    psp[pg].hInstance = hInstance;
+    psp[pg].pszTemplate = MAKEINTRESOURCEW (IDD_STAGING);
+    psp[pg].pszIcon = NULL;
+    psp[pg].pfnDlgProc = StagingDlgProc;
+    psp[pg].pszTitle =  load_string (IDS_TAB_STAGING);
+    psp[pg].lParam = 0;
+    pg++;
+
     /*
      * Fill out the (General) PROPSHEETPAGE data structure 
      * for the property sheet
diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index cd7eaaf711e..f9f71adfcf6 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -45,6 +45,7 @@
 #define IDS_SHELL_FOLDER                16
 #define IDS_LINKS_TO                    17
 #define IDS_WINECFG_TITLE_APP           18   /* App specific title */
+#define IDS_TAB_STAGING                 19
 #define IDI_WINECFG                     100
 #define IDI_LOGO                        102
 #define IDD_ABOUTCFG                    107
@@ -54,6 +55,7 @@
 #define IDD_DLLCFG                      111
 #define IDD_DRIVECFG                    112
 #define IDD_DESKTOP_INTEGRATION         115
+#define IDD_STAGING                     116
 #define IDC_WINVER                      1012
 #define IDC_DESKTOP_WIDTH               1023
 #define IDC_DESKTOP_HEIGHT              1024
@@ -213,6 +215,9 @@
 #define IDC_SYSPARAMS_MENU_HIGHLIGHT    8430
 #define IDC_SYSPARAMS_MENUBAR           8431
 
+/* Staging tab */
+#define IDC_ENABLE_CSMT                 9001
+
 /* About tab */
 #define IDC_ABT_OWNER                8432
 #define IDC_ABT_ORG                  8433
diff --git a/programs/winecfg/staging.c b/programs/winecfg/staging.c
new file mode 100644
index 00000000000..0bd6e1741a7
--- /dev/null
+++ b/programs/winecfg/staging.c
@@ -0,0 +1,82 @@
+/*
+ * WineCfg Staging panel
+ *
+ * Copyright 2014 Michael Müller
+ * Copyright 2015 Sebastian Lackner
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#define COBJMACROS
+
+#include <windows.h>
+
+#include "resource.h"
+#include "winecfg.h"
+
+/*
+ * Command stream multithreading
+ */
+static BOOL csmt_get(void)
+{
+    WCHAR *buf = get_reg_key(config_key, L"Direct3D", L"csmt", NULL);
+    BOOL ret = buf ? !!*buf : TRUE;
+    free(buf);
+    return ret;
+}
+static void csmt_set(BOOL status)
+{
+    set_reg_key_dword(config_key, L"Direct3D", L"csmt", status);
+}
+
+
+static void load_staging_settings(HWND dialog)
+{
+    CheckDlgButton(dialog, IDC_ENABLE_CSMT, csmt_get() ? BST_CHECKED : BST_UNCHECKED);
+}
+
+INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    switch (uMsg)
+    {
+    case WM_INITDIALOG:
+        break;
+
+    case WM_NOTIFY:
+        if (((LPNMHDR)lParam)->code == PSN_SETACTIVE)
+            load_staging_settings(hDlg);
+        break;
+
+    case WM_SHOWWINDOW:
+        set_window_title(hDlg);
+        break;
+
+    case WM_DESTROY:
+        break;
+
+    case WM_COMMAND:
+        if (HIWORD(wParam) != BN_CLICKED) break;
+        switch (LOWORD(wParam))
+        {
+        case IDC_ENABLE_CSMT:
+            csmt_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_CSMT) == BST_CHECKED);
+            SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
+            return TRUE;
+        }
+        break;
+    }
+    return FALSE;
+}
diff --git a/programs/winecfg/winecfg.h b/programs/winecfg/winecfg.h
index f3f3ad2addf..d4fedff5afb 100644
--- a/programs/winecfg/winecfg.h
+++ b/programs/winecfg/winecfg.h
@@ -85,6 +85,7 @@ INT_PTR CALLBACK AppDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
 INT_PTR CALLBACK LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AudioDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK ThemeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
+INT_PTR CALLBACK StagingDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AboutDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 
 /* Windows version management */
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 779a2f900e3..65aeb6986df 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -38,6 +38,7 @@ BEGIN
     IDS_TAB_GRAPHICS        "Graphics"
     IDS_TAB_DESKTOP_INTEGRATION "Desktop Integration"
     IDS_TAB_AUDIO           "Audio"
+    IDS_TAB_STAGING         "Staging"
     IDS_TAB_ABOUT           "About"
     IDS_WINECFG_TITLE       "Wine configuration"
     IDS_WINECFG_TITLE_APP   "Wine configuration for %s"
@@ -318,6 +319,15 @@ BEGIN
     PUSHBUTTON      "B&rowse...",IDC_BROWSE_SFPATH,195,195,50,13,WS_DISABLED
 END
 
+IDD_STAGING DIALOG  0, 0, 260, 220
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX    "Staging settings",IDC_STATIC,8,4,244,210
+    LTEXT       "The following settings are experimental and may break stuff!\nMake sure to reset them again in case of a problem.",IDC_STATIC,16,16,230,16
+    CONTROL     "Enable &CSMT for better graphic performance (deprecated)",IDC_ENABLE_CSMT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,40,230,8
+END
+
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 
 /* @makedep: winecfg.ico */

From b613aa58c11276f9020f13a75d0fcc4d0b1a023e Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 21 Feb 2015 23:37:26 +0100
Subject: [PATCH 159/244] winecfg: Add checkbox to enable/disable vaapi GPU
 decoder.

---
 programs/winecfg/resource.h |  1 +
 programs/winecfg/staging.c  | 20 ++++++++++++++++++++
 programs/winecfg/winecfg.rc |  1 +
 3 files changed, 22 insertions(+)

diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index f9f71adfcf6..98901537d76 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -217,6 +217,7 @@
 
 /* Staging tab */
 #define IDC_ENABLE_CSMT                 9001
+#define IDC_ENABLE_VAAPI                9002
 
 /* About tab */
 #define IDC_ABT_OWNER                8432
diff --git a/programs/winecfg/staging.c b/programs/winecfg/staging.c
index 0bd6e1741a7..13b43c6e909 100644
--- a/programs/winecfg/staging.c
+++ b/programs/winecfg/staging.c
@@ -42,10 +42,26 @@ static void csmt_set(BOOL status)
     set_reg_key_dword(config_key, L"Direct3D", L"csmt", status);
 }
 
+/*
+ * DXVA2
+ */
+static BOOL vaapi_get(void)
+{
+    BOOL ret;
+    WCHAR *value = get_reg_key(config_key, keypath(L"DXVA2"), L"backend", NULL);
+    ret = (value && !wcscmp(value, L"va"));
+    free(value);
+    return ret;
+}
+static void vaapi_set(BOOL status)
+{
+    set_reg_key(config_key, keypath(L"DXVA2"), L"backend", status ? L"va" : NULL);
+}
 
 static void load_staging_settings(HWND dialog)
 {
     CheckDlgButton(dialog, IDC_ENABLE_CSMT, csmt_get() ? BST_CHECKED : BST_UNCHECKED);
+    CheckDlgButton(dialog, IDC_ENABLE_VAAPI, vaapi_get() ? BST_CHECKED : BST_UNCHECKED);
 }
 
 INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -75,6 +91,10 @@ INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lPar
             csmt_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_CSMT) == BST_CHECKED);
             SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
             return TRUE;
+        case IDC_ENABLE_VAAPI:
+            vaapi_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_VAAPI) == BST_CHECKED);
+            SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
+            return TRUE;
         }
         break;
     }
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 65aeb6986df..3c421b6d3a4 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -326,6 +326,7 @@ BEGIN
     GROUPBOX    "Staging settings",IDC_STATIC,8,4,244,210
     LTEXT       "The following settings are experimental and may break stuff!\nMake sure to reset them again in case of a problem.",IDC_STATIC,16,16,230,16
     CONTROL     "Enable &CSMT for better graphic performance (deprecated)",IDC_ENABLE_CSMT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,40,230,8
+    CONTROL     "Enable &VAAPI as backend for DXVA2 GPU decoding",IDC_ENABLE_VAAPI,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,55,230,8
 END
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

From bb7c79877e43a697c5c6618471f7c8da4b4e5b74 Mon Sep 17 00:00:00 2001
From: Mark Harmstone <mark@harmstone.com>
Date: Sun, 5 Apr 2015 14:16:11 +0100
Subject: [PATCH 160/244] winecfg: Add checkbox to enable/disable EAX support.

---
 programs/winecfg/resource.h |  1 +
 programs/winecfg/staging.c  | 21 +++++++++++++++++++++
 programs/winecfg/winecfg.rc |  1 +
 3 files changed, 23 insertions(+)

diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index 98901537d76..a50e0b24b70 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -218,6 +218,7 @@
 /* Staging tab */
 #define IDC_ENABLE_CSMT                 9001
 #define IDC_ENABLE_VAAPI                9002
+#define IDC_ENABLE_EAX                  9003
 
 /* About tab */
 #define IDC_ABT_OWNER                8432
diff --git a/programs/winecfg/staging.c b/programs/winecfg/staging.c
index 13b43c6e909..018edf6aa30 100644
--- a/programs/winecfg/staging.c
+++ b/programs/winecfg/staging.c
@@ -58,10 +58,27 @@ static void vaapi_set(BOOL status)
     set_reg_key(config_key, keypath(L"DXVA2"), L"backend", status ? L"va" : NULL);
 }
 
+/*
+ * EAX
+ */
+static BOOL eax_get(void)
+{
+    BOOL ret;
+    WCHAR *value = get_reg_key(config_key, keypath(L"DirectSound"), L"EAXEnabled", L"N");
+    ret = IS_OPTION_TRUE(*value);
+    free(value);
+    return ret;
+}
+static void eax_set(BOOL status)
+{
+    set_reg_key(config_key, keypath(L"DirectSound"), L"EAXEnabled", status ? L"Y" : L"N");
+}
+
 static void load_staging_settings(HWND dialog)
 {
     CheckDlgButton(dialog, IDC_ENABLE_CSMT, csmt_get() ? BST_CHECKED : BST_UNCHECKED);
     CheckDlgButton(dialog, IDC_ENABLE_VAAPI, vaapi_get() ? BST_CHECKED : BST_UNCHECKED);
+    CheckDlgButton(dialog, IDC_ENABLE_EAX, eax_get() ? BST_CHECKED : BST_UNCHECKED);
 }
 
 INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -95,6 +112,10 @@ INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lPar
             vaapi_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_VAAPI) == BST_CHECKED);
             SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
             return TRUE;
+        case IDC_ENABLE_EAX:
+            eax_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_EAX) == BST_CHECKED);
+            SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
+            return TRUE;
         }
         break;
     }
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 3c421b6d3a4..b9f1d4ef462 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -327,6 +327,7 @@ BEGIN
     LTEXT       "The following settings are experimental and may break stuff!\nMake sure to reset them again in case of a problem.",IDC_STATIC,16,16,230,16
     CONTROL     "Enable &CSMT for better graphic performance (deprecated)",IDC_ENABLE_CSMT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,40,230,8
     CONTROL     "Enable &VAAPI as backend for DXVA2 GPU decoding",IDC_ENABLE_VAAPI,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,55,230,8
+    CONTROL     "Enable Environmental Audio E&xtensions (EAX)",IDC_ENABLE_EAX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,70,230,8
 END
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

From af2fa53a1609430b98b92d03bbf011b215533876 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sat, 30 May 2015 02:23:44 +0200
Subject: [PATCH 161/244] winecfg: Add checkbox to enable/disable
 HideWineExports registry key.

---
 programs/winecfg/resource.h |  1 +
 programs/winecfg/staging.c  | 22 ++++++++++++++++++++++
 programs/winecfg/winecfg.rc |  1 +
 3 files changed, 24 insertions(+)

diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index a50e0b24b70..94a3ccd6606 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -219,6 +219,7 @@
 #define IDC_ENABLE_CSMT                 9001
 #define IDC_ENABLE_VAAPI                9002
 #define IDC_ENABLE_EAX                  9003
+#define IDC_ENABLE_HIDEWINE             9004
 
 /* About tab */
 #define IDC_ABT_OWNER                8432
diff --git a/programs/winecfg/staging.c b/programs/winecfg/staging.c
index 018edf6aa30..7e74466fa9e 100644
--- a/programs/winecfg/staging.c
+++ b/programs/winecfg/staging.c
@@ -74,11 +74,29 @@ static void eax_set(BOOL status)
     set_reg_key(config_key, keypath(L"DirectSound"), L"EAXEnabled", status ? L"Y" : L"N");
 }
 
+/*
+ * Hide Wine exports from applications
+ */
+static BOOL hidewine_get(void)
+{
+    BOOL ret;
+    WCHAR *value = get_reg_key(config_key, keypath(L""), L"HideWineExports", L"N");
+    ret = IS_OPTION_TRUE(*value);
+    free(value);
+    return ret;
+}
+static void hidewine_set(BOOL status)
+{
+    set_reg_key(config_key, keypath(L""), L"HideWineExports", status ? L"Y" : L"N");
+}
+
+
 static void load_staging_settings(HWND dialog)
 {
     CheckDlgButton(dialog, IDC_ENABLE_CSMT, csmt_get() ? BST_CHECKED : BST_UNCHECKED);
     CheckDlgButton(dialog, IDC_ENABLE_VAAPI, vaapi_get() ? BST_CHECKED : BST_UNCHECKED);
     CheckDlgButton(dialog, IDC_ENABLE_EAX, eax_get() ? BST_CHECKED : BST_UNCHECKED);
+    CheckDlgButton(dialog, IDC_ENABLE_HIDEWINE, hidewine_get() ? BST_CHECKED : BST_UNCHECKED);
 }
 
 INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -116,6 +134,10 @@ INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lPar
             eax_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_EAX) == BST_CHECKED);
             SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
             return TRUE;
+        case IDC_ENABLE_HIDEWINE:
+            hidewine_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_HIDEWINE) == BST_CHECKED);
+            SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
+            return TRUE;
         }
         break;
     }
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index b9f1d4ef462..84e5a65122f 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -328,6 +328,7 @@ BEGIN
     CONTROL     "Enable &CSMT for better graphic performance (deprecated)",IDC_ENABLE_CSMT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,40,230,8
     CONTROL     "Enable &VAAPI as backend for DXVA2 GPU decoding",IDC_ENABLE_VAAPI,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,55,230,8
     CONTROL     "Enable Environmental Audio E&xtensions (EAX)",IDC_ENABLE_EAX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,70,230,8
+    CONTROL     "&Hide Wine version from applications",IDC_ENABLE_HIDEWINE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,85,230,8
 END
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

From 37a92ea76d954bf3721924d109ec0e2adfb9dd13 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sun, 9 Aug 2015 18:01:11 +0200
Subject: [PATCH 162/244] winecfg: Add option to enable/disable GTK3 theming.

---
 programs/winecfg/resource.h |  1 +
 programs/winecfg/staging.c  | 20 ++++++++++++++++++++
 programs/winecfg/winecfg.rc |  1 +
 3 files changed, 22 insertions(+)

diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index 94a3ccd6606..c0d7adadcc1 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -220,6 +220,7 @@
 #define IDC_ENABLE_VAAPI                9002
 #define IDC_ENABLE_EAX                  9003
 #define IDC_ENABLE_HIDEWINE             9004
+#define IDC_ENABLE_GTK3                 9005
 
 /* About tab */
 #define IDC_ABT_OWNER                8432
diff --git a/programs/winecfg/staging.c b/programs/winecfg/staging.c
index 7e74466fa9e..975735c6f9c 100644
--- a/programs/winecfg/staging.c
+++ b/programs/winecfg/staging.c
@@ -90,6 +90,21 @@ static void hidewine_set(BOOL status)
     set_reg_key(config_key, keypath(L""), L"HideWineExports", status ? L"Y" : L"N");
 }
 
+/*
+ * GTK3
+ */
+static BOOL gtk3_get(void)
+{
+    BOOL ret;
+    WCHAR *value = get_reg_key(config_key, keypath(L""), L"ThemeEngine", NULL);
+    ret = (value && !wcsicmp(value, L"GTK"));
+    free(value);
+    return ret;
+}
+static void gtk3_set(BOOL status)
+{
+    set_reg_key(config_key, keypath(L""), L"ThemeEngine", status ? L"GTK" : NULL);
+}
 
 static void load_staging_settings(HWND dialog)
 {
@@ -97,6 +112,7 @@ static void load_staging_settings(HWND dialog)
     CheckDlgButton(dialog, IDC_ENABLE_VAAPI, vaapi_get() ? BST_CHECKED : BST_UNCHECKED);
     CheckDlgButton(dialog, IDC_ENABLE_EAX, eax_get() ? BST_CHECKED : BST_UNCHECKED);
     CheckDlgButton(dialog, IDC_ENABLE_HIDEWINE, hidewine_get() ? BST_CHECKED : BST_UNCHECKED);
+    CheckDlgButton(dialog, IDC_ENABLE_GTK3, gtk3_get() ? BST_CHECKED : BST_UNCHECKED);
 }
 
 INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -138,6 +154,10 @@ INT_PTR CALLBACK StagingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lPar
             hidewine_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_HIDEWINE) == BST_CHECKED);
             SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
             return TRUE;
+        case IDC_ENABLE_GTK3:
+            gtk3_set(IsDlgButtonChecked(hDlg, IDC_ENABLE_GTK3) == BST_CHECKED);
+            SendMessageW(GetParent(hDlg), PSM_CHANGED, 0, 0);
+            return TRUE;
         }
         break;
     }
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 84e5a65122f..428c477413c 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -329,6 +329,7 @@ BEGIN
     CONTROL     "Enable &VAAPI as backend for DXVA2 GPU decoding",IDC_ENABLE_VAAPI,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,55,230,8
     CONTROL     "Enable Environmental Audio E&xtensions (EAX)",IDC_ENABLE_EAX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,70,230,8
     CONTROL     "&Hide Wine version from applications",IDC_ENABLE_HIDEWINE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,85,230,8
+    CONTROL     "Enable &GTK3 Theming",IDC_ENABLE_GTK3,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,100,230,8
 END
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

From 654ce4b53c092f00138448f1eda017bbe9ec09f5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 6 Jun 2015 06:53:34 +0200
Subject: [PATCH 163/244] wined3d: Use real values for memory accounting on
 NVIDIA cards.

FIXME: Reimplement wined3d_device_get_available_texture_mem
       without using the context on the main thread.
---
 dlls/wined3d/adapter_gl.c | 12 ++++++++++++
 dlls/wined3d/device.c     | 23 +++++++++++++++++++++++
 dlls/wined3d/wined3d_gl.h |  1 +
 3 files changed, 36 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index 1bbafc7957e..42127eeb642 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -236,6 +236,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_NV_vertex_program2_option",        NV_VERTEX_PROGRAM2_OPTION     },
     {"GL_NV_vertex_program3",               NV_VERTEX_PROGRAM3            },
     {"GL_NV_texture_barrier",               NV_TEXTURE_BARRIER            },
+    {"GL_NVX_gpu_memory_info",              NVX_GPU_MEMORY_INFO           },
 };
 
 static const struct wined3d_extension_map wgl_extension_map[] =
@@ -1010,6 +1011,17 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
 
         gpu_description = wined3d_get_gpu_description(vendor, device);
     }
+    else if (gl_info->supported[NVX_GPU_MEMORY_INFO])
+    {
+        GLint vram_kb;
+        gl_info->gl_ops.gl.p_glGetIntegerv(GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX, &vram_kb);
+
+        *vram_bytes = (UINT64)vram_kb * 1024;
+        TRACE("Got 0x%s as video memory from NVX_GPU_MEMORY_INFO extension.\n",
+                wine_dbgstr_longlong(*vram_bytes));
+
+        gpu_description = wined3d_get_gpu_description(vendor, device);
+    }
 
     if ((gpu_description_override = wined3d_get_user_override_gpu_description(vendor, device)))
         gpu_description = gpu_description_override;
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index a3e113a9103..98b717ad98c 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -1759,6 +1759,29 @@ UINT CDECL wined3d_device_get_available_texture_mem(const struct wined3d_device
 
     driver_info = &device->adapter->driver_info;
 
+    /* We can not acquire the context unless there is a swapchain. */
+    /*
+    if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+            !wined3d_settings.emulated_textureram)
+    {
+        GLint vram_free_kb;
+        UINT64 vram_free;
+
+        struct wined3d_context *context = context_acquire(device, NULL, 0);
+        gl_info->gl_ops.gl.p_glGetIntegerv(GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX, &vram_free_kb);
+        vram_free = (UINT64)vram_free_kb * 1024;
+        context_release(context);
+
+        TRACE("Total 0x%s bytes. emulation 0x%s left, driver 0x%s left.\n",
+                wine_dbgstr_longlong(device->adapter->vram_bytes),
+                wine_dbgstr_longlong(device->adapter->vram_bytes - device->adapter->vram_bytes_used),
+                wine_dbgstr_longlong(vram_free));
+
+        vram_free = min(vram_free, device->adapter->vram_bytes - device->adapter->vram_bytes_used);
+        return min(UINT_MAX, vram_free);
+    }
+    */
+
     TRACE("Emulating 0x%s bytes. 0x%s used, returning 0x%s left.\n",
             wine_dbgstr_longlong(driver_info->vram_bytes),
             wine_dbgstr_longlong(device->adapter->vram_bytes_used),
diff --git a/dlls/wined3d/wined3d_gl.h b/dlls/wined3d/wined3d_gl.h
index 24d7ebf663b..6ba5c241a92 100644
--- a/dlls/wined3d/wined3d_gl.h
+++ b/dlls/wined3d/wined3d_gl.h
@@ -222,6 +222,7 @@ enum wined3d_gl_extension
     NV_VERTEX_PROGRAM2_OPTION,
     NV_VERTEX_PROGRAM3,
     NV_TEXTURE_BARRIER,
+    NVX_GPU_MEMORY_INFO,
     /* WGL extensions */
     WGL_ARB_PIXEL_FORMAT,
     WGL_EXT_SWAP_CONTROL,

From 5819a7f2b6877ab411c69239389cc7a8e7ea87bd Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 29 Jul 2021 12:28:20 +1000
Subject: [PATCH 164/244] wined3d: Merged ATOMIC_IMIN and ATOMIC_UMIN together

Batman: Arkham Knight.

0670:fixme:d3d_shader:shader_glsl_atomic Unhandled opcode 0x6 for unsigned integers.
0670:fixme:d3d_shader:shader_glsl_atomic Unhandled opcode 0x7 for unsigned integers.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52233
---
 dlls/wined3d/glsl_shader.c | 36 ++++++++----------------------------
 1 file changed, 8 insertions(+), 28 deletions(-)

diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index d325c0fe472..88daa62d7db 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -5597,26 +5597,30 @@ static void shader_glsl_atomic(const struct wined3d_shader_instruction *ins)
                 op = "imageAtomicAdd";
             break;
         case WINED3DSIH_ATOMIC_IMAX:
+        case WINED3DSIH_ATOMIC_UMAX:
         case WINED3DSIH_IMM_ATOMIC_IMAX:
+        case WINED3DSIH_IMM_ATOMIC_UMAX:
             if (is_tgsm)
                 op = "atomicMax";
             else
                 op = "imageAtomicMax";
-            if (data_type != WINED3D_DATA_INT)
+            if (data_type != WINED3D_DATA_INT && data_type != WINED3D_DATA_UINT)
             {
-                FIXME("Unhandled opcode %#x for unsigned integers.\n", ins->handler_idx);
+                FIXME("Unhandled opcode %#x for integers.\n", ins->handler_idx);
                 return;
             }
             break;
         case WINED3DSIH_ATOMIC_IMIN:
+        case WINED3DSIH_ATOMIC_UMIN:
         case WINED3DSIH_IMM_ATOMIC_IMIN:
+        case WINED3DSIH_IMM_ATOMIC_UMIN:
             if (is_tgsm)
                 op = "atomicMin";
             else
                 op = "imageAtomicMin";
-            if (data_type != WINED3D_DATA_INT)
+            if (data_type != WINED3D_DATA_INT && data_type != WINED3D_DATA_UINT)
             {
-                FIXME("Unhandled opcode %#x for unsigned integers.\n", ins->handler_idx);
+                FIXME("Unhandled opcode %#x for integers.\n", ins->handler_idx);
                 return;
             }
             break;
@@ -5627,30 +5631,6 @@ static void shader_glsl_atomic(const struct wined3d_shader_instruction *ins)
             else
                 op = "imageAtomicOr";
             break;
-        case WINED3DSIH_ATOMIC_UMAX:
-        case WINED3DSIH_IMM_ATOMIC_UMAX:
-            if (is_tgsm)
-                op = "atomicMax";
-            else
-                op = "imageAtomicMax";
-            if (data_type != WINED3D_DATA_UINT)
-            {
-                FIXME("Unhandled opcode %#x for signed integers.\n", ins->handler_idx);
-                return;
-            }
-            break;
-        case WINED3DSIH_ATOMIC_UMIN:
-        case WINED3DSIH_IMM_ATOMIC_UMIN:
-            if (is_tgsm)
-                op = "atomicMin";
-            else
-                op = "imageAtomicMin";
-            if (data_type != WINED3D_DATA_UINT)
-            {
-                FIXME("Unhandled opcode %#x for signed integers.\n", ins->handler_idx);
-                return;
-            }
-            break;
         case WINED3DSIH_ATOMIC_XOR:
         case WINED3DSIH_IMM_ATOMIC_XOR:
             if (is_tgsm)

From 67677ec8e4a2234ac5c27e74e1fde11d51a83426 Mon Sep 17 00:00:00 2001
From: Henri Verbeet <hverbeet@codeweavers.com>
Date: Thu, 13 May 2021 17:58:12 +0200
Subject: [PATCH 165/244] wined3d: Do not rotate WINED3D_SWAP_EFFECT_DISCARD
 swapchains.

RenderDoc/Qt creates swapchains with 2 buffers, a front buffer and a back
buffer, and the DISCARD swap effect. It doesn't redraw the back buffer after a
Present(), seemingly expecting that the back buffer will only be copied to the
front buffer, and otherwise remain unmodified. Incidentally, CEF seems to
behave in a similar way.
---
 dlls/wined3d/swapchain.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 6f01d520add..0d55da5f47f 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -523,8 +523,9 @@ static void wined3d_swapchain_gl_rotate(struct wined3d_swapchain *swapchain, str
     unsigned int i;
     static const DWORD supported_locations = WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_RB_MULTISAMPLE;
 
-    if (swapchain->state.desc.backbuffer_count < 2)
-        return;
+    if (swapchain->state.desc.swap_effect == WINED3D_SWAP_EFFECT_DISCARD
+            || swapchain->state.desc.backbuffer_count < 2)
+         return;
 
     texture_prev = wined3d_texture_gl(swapchain->back_buffers[0]);
 
@@ -1177,7 +1178,8 @@ static void wined3d_swapchain_vk_rotate(struct wined3d_swapchain *swapchain, str
 
     static const DWORD supported_locations = WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_RB_MULTISAMPLE;
 
-    if (swapchain->state.desc.backbuffer_count < 2)
+    if (swapchain->state.desc.swap_effect == WINED3D_SWAP_EFFECT_DISCARD
+            || swapchain->state.desc.backbuffer_count < 2)
         return;
 
     texture_prev = wined3d_texture_vk(swapchain->back_buffers[0]);

From a48a4ddc5155bdc5980cc2d06ab6d025cef74121 Mon Sep 17 00:00:00 2001
From: Henri Verbeet <hverbeet@codeweavers.com>
Date: Fri, 28 Jun 2019 14:27:10 +1000
Subject: [PATCH 166/244] wined3d: Dont set DDSCAPS_FLIP for gdi renderer

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47419
---
 dlls/wined3d/adapter_gl.c | 1 +
 dlls/wined3d/adapter_vk.c | 1 +
 dlls/wined3d/directx.c    | 3 +--
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index 42127eeb642..5cb11f85ed0 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -4118,6 +4118,7 @@ static void adapter_gl_get_wined3d_caps(const struct wined3d_adapter *adapter, s
     const struct wined3d_d3d_info *d3d_info = &adapter->d3d_info;
 
     caps->ddraw_caps.dds_caps |= WINEDDSCAPS_BACKBUFFER
+            | WINEDDSCAPS_FLIP
             | WINEDDSCAPS_COMPLEX
             | WINEDDSCAPS_FRONTBUFFER
             | WINEDDSCAPS_3DDEVICE
diff --git a/dlls/wined3d/adapter_vk.c b/dlls/wined3d/adapter_vk.c
index 8c5f75c1316..829fa706846 100644
--- a/dlls/wined3d/adapter_vk.c
+++ b/dlls/wined3d/adapter_vk.c
@@ -545,6 +545,7 @@ static void adapter_vk_get_wined3d_caps(const struct wined3d_adapter *adapter, s
     const struct wined3d_vk_info *vk_info = &adapter_vk->vk_info;
 
     caps->ddraw_caps.dds_caps |= WINEDDSCAPS_BACKBUFFER
+            | WINEDDSCAPS_FLIP
             | WINEDDSCAPS_COMPLEX
             | WINEDDSCAPS_FRONTBUFFER
             | WINEDDSCAPS_3DDEVICE
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 175fa8d688d..47793d05b7f 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -2731,8 +2731,7 @@ HRESULT CDECL wined3d_get_device_caps(const struct wined3d_adapter *adapter,
     caps->ddraw_caps.ssb_color_key_caps = ckey_caps;
     caps->ddraw_caps.ssb_fx_caps = fx_caps;
 
-    caps->ddraw_caps.dds_caps = WINEDDSCAPS_FLIP
-            | WINEDDSCAPS_OFFSCREENPLAIN
+    caps->ddraw_caps.dds_caps = WINEDDSCAPS_OFFSCREENPLAIN
             | WINEDDSCAPS_PALETTE
             | WINEDDSCAPS_PRIMARYSURFACE
             | WINEDDSCAPS_TEXTURE

From 92eae92598bde37bd23b3937fa25e2c85189d3a5 Mon Sep 17 00:00:00 2001
From: Jarkko Korpi <jarkko_korpi@hotmail.com>
Date: Tue, 16 May 2017 15:39:29 +0300
Subject: [PATCH 167/244] wined3d: Also check for 'Brian Paul' to detect Mesa
 gl_vendor.

As already done in wined3d_guess_card_vendor.
---
 dlls/wined3d/adapter_gl.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index 5cb11f85ed0..976cd63f279 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1185,6 +1185,7 @@ static enum wined3d_gl_vendor wined3d_guess_gl_vendor(const struct wined3d_gl_in
         return GL_VENDOR_FGLRX;
 
     if (strstr(gl_vendor_string, "Mesa")
+            || strstr(gl_vendor_string, "Brian Paul")
             || strstr(gl_vendor_string, "X.Org")
             || strstr(gl_vendor_string, "Advanced Micro Devices, Inc.")
             || strstr(gl_vendor_string, "DRI R300 Project")

From e3fbf994d6ebbb279276881239bd2a21fbc4b311 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 21 Jan 2017 17:23:48 +0100
Subject: [PATCH 168/244] winedbg: Print process arguments in info threads.

---
 programs/winedbg/info.c | 107 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 105 insertions(+), 2 deletions(-)

diff --git a/programs/winedbg/info.c b/programs/winedbg/info.c
index 5c1cd100903..0046983c238 100644
--- a/programs/winedbg/info.c
+++ b/programs/winedbg/info.c
@@ -688,6 +688,103 @@ WCHAR* fetch_thread_description(DWORD tid)
     return desc;
 }
 
+static BOOL read_process_memory(HANDLE process, const void *ptr, void *buffer, SIZE_T length)
+{
+    SIZE_T read;
+    return ReadProcessMemory(process, ptr, buffer, length, &read) && (read == length);
+}
+
+static BOOL get_process_cmdline(HANDLE process, PEB *peb, UNICODE_STRING *cmdline)
+{
+    RTL_USER_PROCESS_PARAMETERS *params;
+
+    if (!read_process_memory(process, &peb->ProcessParameters, &params, sizeof(params)))
+        return FALSE;
+
+    if (!read_process_memory(process, &params->CommandLine, cmdline, sizeof(*cmdline)))
+        return FALSE;
+
+    return TRUE;
+}
+
+static BOOL get_process_cmdline_wow64(HANDLE process, PEB *peb, UNICODE_STRING *cmdline)
+{
+    DWORD params;
+    struct
+    {
+        USHORT Length;
+        USHORT MaximumLength;
+        DWORD  Buffer;
+    } cmdline32;
+
+    /* &peb->ProcessParameters */
+    if (!read_process_memory(process, (char *)peb + 0x10, &params, sizeof(params)))
+        return FALSE;
+
+    /* &params->CommandLine */
+    if (!read_process_memory(process, (char *)(DWORD_PTR)params + 0x40, &cmdline32, sizeof(cmdline32)))
+        return FALSE;
+
+    cmdline->Length = cmdline32.Length;
+    cmdline->MaximumLength = cmdline32.MaximumLength;
+    cmdline->Buffer = (WCHAR *)(DWORD_PTR)cmdline32.Buffer;
+    return TRUE;
+}
+
+static char *get_process_args(DWORD pid)
+{
+    PROCESS_BASIC_INFORMATION info;
+    BOOL self_wow64, process_wow64;
+    UNICODE_STRING cmdline;
+    WCHAR *tempW = NULL;
+    char *args = NULL;
+    HANDLE process;
+    DWORD len;
+    BOOL ret;
+
+    if (!(process = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ, FALSE, pid)))
+        return FALSE;
+    if (NtQueryInformationProcess(process, ProcessBasicInformation, &info, sizeof(info), NULL))
+        goto done;
+
+    IsWow64Process(GetCurrentProcess(), &self_wow64);
+    if (!IsWow64Process(process, &process_wow64))
+        goto done;
+
+    if (process_wow64 == self_wow64)
+        ret = get_process_cmdline(process, info.PebBaseAddress, &cmdline);
+    else if (!self_wow64 && process_wow64)
+        ret = get_process_cmdline_wow64(process, info.PebBaseAddress, &cmdline);
+    else
+        ret = FALSE; /* can't read process args of 64-bit process with 32-bit winedbg */
+
+    if (!ret) goto done;
+
+    /* protect against malicious content */
+    if (cmdline.Length > 4096 || (cmdline.Length & 1))
+        goto done;
+
+    if (!(tempW = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cmdline.Length + 2)))
+        goto done;
+    if (!read_process_memory(process, cmdline.Buffer, tempW, cmdline.Length))
+        goto done;
+
+    if (!(len = WideCharToMultiByte(CP_ACP, 0, tempW, -1, NULL, 0, NULL, NULL)))
+        goto done;
+    if (!(args = HeapAlloc(GetProcessHeap(), 0, len)))
+        goto done;
+    if (!WideCharToMultiByte(CP_ACP, 0, tempW, -1, args, len, NULL, NULL))
+    {
+        HeapFree(GetProcessHeap(), 0, args);
+        args = NULL;
+    }
+
+done:
+    HeapFree(GetProcessHeap(), 0, tempW);
+    CloseHandle(process);
+    return args;
+}
+
 void info_win32_threads(void)
 {
     HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
@@ -717,6 +814,7 @@ void info_win32_threads(void)
 		{
                     PROCESSENTRY32W pcs_entry;
                     const WCHAR* exename;
+                    char *args;
 
                     p = dbg_get_process(entry.th32OwnerProcessID);
                     if (p)
@@ -726,8 +824,13 @@ void info_win32_threads(void)
                     else
                         exename = L"";
 
-		    dbg_printf("%08lx%s %ls\n",
-                               entry.th32OwnerProcessID, p ? " (D)" : "", exename);
+                    dbg_printf("%08lx%s %ls\n", entry.th32OwnerProcessID, p ? " (D)" : "", exename);
+                    args = get_process_args(entry.th32OwnerProcessID);
+                    if (args)
+                    {
+                        dbg_printf("\t[%s]\n", args);
+                        HeapFree(GetProcessHeap(), 0, args);
+                    }
                     lastProcessId = entry.th32OwnerProcessID;
 		}
                 dbg_printf("\t%08lx %4ld%s ",

From dcdff69e5e7d7d2320c1901de6d34990defe7fc6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 8 Jun 2017 23:38:38 +0200
Subject: [PATCH 169/244] win32k.sys: Add stub driver.

---
 configure.ac                    |   1 +
 dlls/win32k.sys/Makefile.in     |   6 +
 dlls/win32k.sys/main.c          |  39 +++++
 dlls/win32k.sys/win32k.sys.spec | 246 ++++++++++++++++++++++++++++++++
 loader/wine.inf.in              |   1 +
 tools/make_specfiles            |   1 +
 6 files changed, 294 insertions(+)
 create mode 100644 dlls/win32k.sys/Makefile.in
 create mode 100644 dlls/win32k.sys/main.c
 create mode 100644 dlls/win32k.sys/win32k.sys.spec

diff --git a/configure.ac b/configure.ac
index ff21aee5038..2ffc31e0e03 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3270,6 +3270,7 @@ WINE_CONFIG_MAKEFILE(dlls/wevtsvc)
 WINE_CONFIG_MAKEFILE(dlls/wiaservc)
 WINE_CONFIG_MAKEFILE(dlls/wiaservc/tests)
 WINE_CONFIG_MAKEFILE(dlls/wimgapi)
+WINE_CONFIG_MAKEFILE(dlls/win32k.sys)
 WINE_CONFIG_MAKEFILE(dlls/win32s16.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/win32u)
 WINE_CONFIG_MAKEFILE(dlls/win32u/tests)
diff --git a/dlls/win32k.sys/Makefile.in b/dlls/win32k.sys/Makefile.in
new file mode 100644
index 00000000000..f88b6a9a2a2
--- /dev/null
+++ b/dlls/win32k.sys/Makefile.in
@@ -0,0 +1,6 @@
+MODULE    = win32k.sys
+IMPORTS   = ntoskrnl
+EXTRADLLFLAGS = -mno-cygwin -Wb,--subsystem,native
+
+SOURCES = \
+	main.c
diff --git a/dlls/win32k.sys/main.c b/dlls/win32k.sys/main.c
new file mode 100644
index 00000000000..a1ec2d4fa3f
--- /dev/null
+++ b/dlls/win32k.sys/main.c
@@ -0,0 +1,39 @@
+/*
+ * win32k.sys driver
+ *
+ * Copyright 2017 Michael Müller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#define NONAMELESSUNION
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "ddk/wdm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(win32k);
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    TRACE( "(%p, %s)\n", driver, debugstr_w(path->Buffer) );
+    return STATUS_SUCCESS;
+}
diff --git a/dlls/win32k.sys/win32k.sys.spec b/dlls/win32k.sys/win32k.sys.spec
new file mode 100644
index 00000000000..c79439151e4
--- /dev/null
+++ b/dlls/win32k.sys/win32k.sys.spec
@@ -0,0 +1,246 @@
+@ stub BRUSHOBJ_hGetColorTransform
+@ stub BRUSHOBJ_pvAllocRbrush
+@ stub BRUSHOBJ_pvGetRbrush
+@ stub BRUSHOBJ_ulGetBrushColor
+@ stub CLIPOBJ_GetRgn
+@ stub CLIPOBJ_bEnum
+@ stub CLIPOBJ_cEnumStart
+@ stub CLIPOBJ_ppoGetPath
+@ stub EngAcquireFastMutex
+@ stub EngAcquireSemaphore
+@ stub EngAcquireSemaphoreNoWait
+@ stub EngAcquireSemaphoreShared
+@ stub EngAcquireSemaphoreSharedNoWait
+@ stub EngAllocMem
+@ stub EngAllocPrivateUserMem
+@ stub EngAllocSectionMem
+@ stub EngAllocUserMem
+@ stub EngAlphaBlend
+@ stub EngAssociateSurface
+@ stub EngBitBlt
+@ stub EngBugCheckEx
+@ stub EngCTGetCurrentGamma
+@ stub EngCTGetGammaTable
+@ stub EngCheckAbort
+@ stub EngClearEvent
+@ stub EngCombineRgn
+@ stub EngComputeGlyphSet
+@ stub EngControlSprites
+@ stub EngCopyBits
+@ stub EngCopyRgn
+@ stub EngCreateBitmap
+@ stub EngCreateClip
+@ stub EngCreateDeviceBitmap
+@ stub EngCreateDeviceSurface
+@ stub EngCreateDriverObj
+@ stub EngCreateEvent
+@ stub EngCreateFastMutex
+@ stub EngCreatePalette
+@ stub EngCreatePath
+@ stub EngCreateRectRgn
+@ stub EngCreateRedirectionDeviceBitmap
+@ stub EngCreateSemaphore
+@ stub EngCreateWnd
+@ stub EngDebugBreak
+@ stub EngDebugPrint
+@ stub EngDeleteClip
+@ stub EngDeleteDriverObj
+@ stub EngDeleteEvent
+@ stub EngDeleteFastMutex
+@ stub EngDeleteFile
+@ stub EngDeletePalette
+@ stub EngDeletePath
+@ stub EngDeleteRgn
+@ stub EngDeleteSafeSemaphore
+@ stub EngDeleteSemaphore
+@ stub EngDeleteSurface
+@ stub EngDeleteWnd
+@ stub EngDeviceIoControl
+@ stub EngDitherColor
+@ stub EngDxIoctl
+@ stub EngEnumForms
+@ stub EngEqualRgn
+@ stub EngEraseSurface
+@ stub EngFileIoControl
+@ stub EngFileWrite
+@ stub EngFillPath
+@ stub EngFindImageProcAddress
+@ stub EngFindResource
+@ stub EngFntCacheAlloc
+@ stub EngFntCacheFault
+@ stub EngFntCacheLookUp
+@ stub EngFreeMem
+@ stub EngFreeModule
+@ stub EngFreePrivateUserMem
+@ stub EngFreeSectionMem
+@ stub EngFreeUserMem
+@ stub EngGetCurrentCodePage
+@ stub EngGetCurrentProcessId
+@ stub EngGetCurrentThreadId
+@ stub EngGetDriverName
+@ stub EngGetFileChangeTime
+@ stub EngGetFilePath
+@ stub EngGetForm
+@ stub EngGetLastError
+@ stub EngGetPrinter
+@ stub EngGetPrinterData
+@ stub EngGetPrinterDataFileName
+@ stub EngGetPrinterDriver
+@ stub EngGetProcessHandle
+@ stub EngGetRgnBox
+@ stub EngGetRgnData
+@ stub EngGetTickCount
+@ stub EngGetType1FontList
+@ stub EngGradientFill
+@ stub EngHangNotification
+@ stub EngInitializeSafeSemaphore
+@ stub EngIntersectRgn
+@ stub EngIsSemaphoreOwned
+@ stub EngIsSemaphoreOwnedByCurrentThread
+@ stub EngIsSemaphoreSharedByCurrentThread
+@ stub EngLineTo
+@ stub EngLoadImage
+@ stub EngLoadModule
+@ stub EngLoadModuleForWrite
+@ stub EngLockDirectDrawSurface
+@ stub EngLockDriverObj
+@ stub EngLockSurface
+@ stub EngLpkInstalled
+@ stub EngMapEvent
+@ stub EngMapFile
+@ stub EngMapFontFile
+@ stub EngMapFontFileFD
+@ stub EngMapModule
+@ stub EngMapSection
+@ stub EngMarkBandingSurface
+@ stub EngModifySurface
+@ stub EngMovePointer
+@ stub EngMulDiv
+@ stub EngMultiByteToUnicodeN
+@ stub EngMultiByteToWideChar
+@ stub EngNineGrid
+@ stub EngOffsetRgn
+@ stub EngPaint
+@ stub EngPlgBlt
+@ stub EngProbeForRead
+@ stub EngProbeForReadAndWrite
+@ stub EngQueryDeviceAttribute
+@ stub EngQueryLocalTime
+@ stub EngQueryPalette
+@ stub EngQueryPerformanceCounter
+@ stub EngQueryPerformanceFrequency
+@ stub EngQuerySystemAttribute
+@ stub EngQueryW32kCddInterface
+@ stub EngReadStateEvent
+@ stub EngRectInRgn
+@ stub EngReleaseFastMutex
+@ stub EngReleaseSemaphore
+@ stub EngRestoreFloatingPointState
+@ stub EngSaveFloatingPointState
+@ stub EngSecureMem
+@ stub EngSetEvent
+@ stub EngSetLastError
+@ stub EngSetPointerShape
+@ stub EngSetPointerTag
+@ stub EngSetPrinterData
+@ stub EngSetRectRgn
+@ stub EngSort
+@ stub EngStretchBlt
+@ stub EngStretchBltROP
+@ stub EngStrokeAndFillPath
+@ stub EngStrokePath
+@ stub EngSubtractRgn
+@ stub EngTextOut
+@ stub EngTransparentBlt
+@ stub EngUnicodeToMultiByteN
+@ stub EngUnionRgn
+@ stub EngUnloadImage
+@ stub EngUnlockDirectDrawSurface
+@ stub EngUnlockDriverObj
+@ stub EngUnlockSurface
+@ stub EngUnmapEvent
+@ stub EngUnmapFile
+@ stub EngUnmapFontFile
+@ stub EngUnmapFontFileFD
+@ stub EngUnsecureMem
+@ stub EngUpdateDeviceSurface
+@ stub EngWaitForSingleObject
+@ stub EngWideCharToMultiByte
+@ stub EngWritePrinter
+@ stub EngXorRgn
+@ stub FONTOBJ_cGetAllGlyphHandles
+@ stub FONTOBJ_cGetGlyphs
+@ stub FONTOBJ_pQueryGlyphAttrs
+@ stub FONTOBJ_pfdg
+@ stub FONTOBJ_pifi
+@ stub FONTOBJ_pjOpenTypeTablePointer
+@ stub FONTOBJ_pvTrueTypeFontFile
+@ stub FONTOBJ_pwszFontFilePaths
+@ stub FONTOBJ_pxoGetXform
+@ stub FONTOBJ_vGetInfo
+@ stub HT_ComputeRGBGammaTable
+@ stub HT_Get8BPPFormatPalette
+@ stub HT_Get8BPPMaskPalette
+@ stub HeapVidMemAllocAligned
+@ stub PALOBJ_cGetColors
+@ stub PATHOBJ_bCloseFigure
+@ stub PATHOBJ_bEnum
+@ stub PATHOBJ_bEnumClipLines
+@ stub PATHOBJ_bMoveTo
+@ stub PATHOBJ_bPolyBezierTo
+@ stub PATHOBJ_bPolyLineTo
+@ stub PATHOBJ_vEnumStart
+@ stub PATHOBJ_vEnumStartClipLines
+@ stub PATHOBJ_vGetBounds
+@ stdcall RtlAnsiCharToUnicodeChar(ptr) ntoskrnl.exe.RtlAnsiCharToUnicodeChar
+@ stdcall -norelay RtlCaptureContext(ptr) ntoskrnl.exe.RtlCaptureContext
+@ stdcall -arch=x86_64 RtlCopyMemory(ptr ptr long) ntoskrnl.exe.RtlCopyMemory
+@ stub RtlCopyMemoryNonTemporal
+@ stdcall RtlFillMemory(ptr long long) ntoskrnl.exe.RtlFillMemory
+@ stub RtlLookupFunctionEntry
+@ stdcall RtlMoveMemory(ptr ptr long) ntoskrnl.exe.RtlMoveMemory
+@ stdcall RtlMultiByteToUnicodeN(ptr long ptr ptr long) ntoskrnl.exe.RtlMultiByteToUnicodeN
+@ stub RtlPcToFileHeader
+@ stdcall -norelay RtlRaiseException(ptr) ntoskrnl.exe.RtlRaiseException
+@ stub RtlRestoreContext
+@ stdcall RtlUnicodeToMultiByteN(ptr long ptr ptr long) ntoskrnl.exe.RtlUnicodeToMultiByteN
+@ stdcall RtlUnicodeToMultiByteSize(ptr ptr long) ntoskrnl.exe.RtlUnicodeToMultiByteSize
+@ stdcall -norelay RtlUnwind(ptr ptr ptr ptr) ntoskrnl.exe.RtlUnwind
+@ stdcall -arch=x86_64 RtlUnwindEx(ptr ptr ptr ptr ptr ptr) ntoskrnl.exe.RtlUnwindEx
+@ stdcall RtlUpcaseUnicodeChar(long) ntoskrnl.exe.RtlUpcaseUnicodeChar
+@ stdcall RtlUpcaseUnicodeToMultiByteN(ptr long ptr ptr long) ntoskrnl.exe.RtlUpcaseUnicodeToMultiByteN
+@ stub RtlVirtualUnwind
+@ stdcall RtlZeroMemory(ptr long) ntoskrnl.exe.RtlZeroMemory
+@ stub STROBJ_bEnum
+@ stub STROBJ_bEnumPositionsOnly
+@ stub STROBJ_bGetAdvanceWidths
+@ stub STROBJ_dwGetCodePage
+@ stub STROBJ_fxBreakExtra
+@ stub STROBJ_fxCharacterExtra
+@ stub STROBJ_vEnumStart
+@ stub VidMemFree
+@ stub W32pArgumentTable
+@ stub W32pServiceLimit
+@ stub W32pServiceTable
+@ stub WNDOBJ_bEnum
+@ stub WNDOBJ_cEnumStart
+@ stub WNDOBJ_vSetConsumer
+@ stub XFORMOBJ_bApplyXform
+@ stub XFORMOBJ_iGetFloatObjXform
+@ stub XFORMOBJ_iGetXform
+@ stub XLATEOBJ_cGetPalette
+@ stub XLATEOBJ_hGetColorTransform
+@ stub XLATEOBJ_iXlate
+@ stub XLATEOBJ_piVector
+@ stub __C_specific_handler
+@ stub __chkstk
+@ cdecl -private _itoa(long ptr long) ntoskrnl.exe._itoa
+@ cdecl -private _itow(long ptr long) ntoskrnl.exe._itow
+@ cdecl -private -arch=x86_64 _local_unwind(ptr ptr) ntoskrnl.exe._local_unwind
+@ stub _setjmp
+@ stub _setjmpex
+@ stub longjmp
+@ stub memcmp
+@ cdecl -private memcpy(ptr ptr long) ntoskrnl.exe.memcpy
+@ cdecl -private memmove(ptr ptr long) ntoskrnl.exe.memmove
+@ cdecl -private memset(ptr long long) ntoskrnl.exe.memset
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 9982c1920db..c78f45c2d9e 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2632,6 +2632,7 @@ HKLM,SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x86,"Version",2,"14.42.344
 11,,explorer.exe
 11,,iexplore.exe
 11,,notepad.exe
+11,,win32k.sys
 11,,winetest.exe,-
 ; themes
 10,resources\themes\light,light.msstyles
diff --git a/tools/make_specfiles b/tools/make_specfiles
index 0509d41d5c1..24fc63fec00 100755
--- a/tools/make_specfiles
+++ b/tools/make_specfiles
@@ -130,6 +130,7 @@ my @dll_groups =
  [
   "ntoskrnl.exe",
   "hal",
+  "win32k.sys",
  ],
  [
   "mscoree",

From 4bf6435795e04af4cab6ea8ee878e7aa51e7f88f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 8 Jun 2017 23:41:02 +0200
Subject: [PATCH 170/244] dxgkrnl.sys: Add stub driver.

---
 configure.ac                      |  1 +
 dlls/dxgkrnl.sys/Makefile.in      |  6 +++++
 dlls/dxgkrnl.sys/dxgkrnl.sys.spec | 26 +++++++++++++++++++++
 dlls/dxgkrnl.sys/main.c           | 39 +++++++++++++++++++++++++++++++
 4 files changed, 72 insertions(+)
 create mode 100644 dlls/dxgkrnl.sys/Makefile.in
 create mode 100644 dlls/dxgkrnl.sys/dxgkrnl.sys.spec
 create mode 100644 dlls/dxgkrnl.sys/main.c

diff --git a/configure.ac b/configure.ac
index 2ffc31e0e03..ed7b521bfca 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2712,6 +2712,7 @@ WINE_CONFIG_MAKEFILE(dlls/dxdiagn)
 WINE_CONFIG_MAKEFILE(dlls/dxdiagn/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxgi)
 WINE_CONFIG_MAKEFILE(dlls/dxgi/tests)
+WINE_CONFIG_MAKEFILE(dlls/dxgkrnl.sys)
 WINE_CONFIG_MAKEFILE(dlls/dxtrans)
 WINE_CONFIG_MAKEFILE(dlls/dxva2)
 WINE_CONFIG_MAKEFILE(dlls/dxva2/tests)
diff --git a/dlls/dxgkrnl.sys/Makefile.in b/dlls/dxgkrnl.sys/Makefile.in
new file mode 100644
index 00000000000..564094de878
--- /dev/null
+++ b/dlls/dxgkrnl.sys/Makefile.in
@@ -0,0 +1,6 @@
+MODULE    = dxgkrnl.sys
+IMPORTS   = ntoskrnl
+EXTRADLLFLAGS = -mno-cygwin -Wb,--subsystem,native
+
+SOURCES = \
+	main.c
diff --git a/dlls/dxgkrnl.sys/dxgkrnl.sys.spec b/dlls/dxgkrnl.sys/dxgkrnl.sys.spec
new file mode 100644
index 00000000000..8487664f8a7
--- /dev/null
+++ b/dlls/dxgkrnl.sys/dxgkrnl.sys.spec
@@ -0,0 +1,26 @@
+@ stub TdrCompleteRecoveryContext
+@ stub TdrCreateRecoveryContext
+@ stub TdrIsRecoveryRequired
+@ stub TdrIsTimeoutForcedFlip
+@ stub TdrResetFromTimeout
+@ stub g_TdrConfig
+@ stub g_TdrForceTimeout
+@ stub DpSynchronizeExecution
+@ stub DpiGetDriverVersion
+@ stub DpiGetDxgAdapter
+@ stub DpiGetSchedulerCallbackState
+@ stub DpiSetSchedulerCallbackState
+@ stub DxgCoreInterface
+@ stub DxgkSqmAddToStream
+@ stub DxgkSqmCommonGeneric
+@ stub DxgkSqmCreateDwordStreamEntry
+@ stub DxgkSqmCreateStringStreamEntry
+@ stub DxgkSqmGenericDword
+@ stub DxgkSqmGenericDword64
+@ stub TraceDxgkBlockThread
+@ stub TraceDxgkContext
+@ stub TraceDxgkDevice
+@ stub TraceDxgkFunctionProfiler
+@ stub TraceDxgkPerformanceWarning
+@ stub TraceDxgkPresentHistory
+@ stub g_loggerInfo
diff --git a/dlls/dxgkrnl.sys/main.c b/dlls/dxgkrnl.sys/main.c
new file mode 100644
index 00000000000..c5639c237c8
--- /dev/null
+++ b/dlls/dxgkrnl.sys/main.c
@@ -0,0 +1,39 @@
+/*
+ * dxgkrnl.sys driver
+ *
+ * Copyright 2017 Michael Müller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#define NONAMELESSUNION
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "ddk/wdm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxgkrnl);
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    TRACE( "(%p, %s)\n", driver, debugstr_w(path->Buffer) );
+    return STATUS_SUCCESS;
+}

From 4186a0dfe9e0c6f59d959d55e6f1cc7acb9763b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 8 Jun 2017 23:42:32 +0200
Subject: [PATCH 171/244] dxgmms1.sys: Add stub driver.

---
 configure.ac                      |  1 +
 dlls/dxgmms1.sys/Makefile.in      |  6 +++++
 dlls/dxgmms1.sys/dxgmms1.sys.spec |  2 ++
 dlls/dxgmms1.sys/main.c           | 39 +++++++++++++++++++++++++++++++
 4 files changed, 48 insertions(+)
 create mode 100644 dlls/dxgmms1.sys/Makefile.in
 create mode 100644 dlls/dxgmms1.sys/dxgmms1.sys.spec
 create mode 100644 dlls/dxgmms1.sys/main.c

diff --git a/configure.ac b/configure.ac
index ed7b521bfca..6a506d4000c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2713,6 +2713,7 @@ WINE_CONFIG_MAKEFILE(dlls/dxdiagn/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxgi)
 WINE_CONFIG_MAKEFILE(dlls/dxgi/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxgkrnl.sys)
+WINE_CONFIG_MAKEFILE(dlls/dxgmms1.sys)
 WINE_CONFIG_MAKEFILE(dlls/dxtrans)
 WINE_CONFIG_MAKEFILE(dlls/dxva2)
 WINE_CONFIG_MAKEFILE(dlls/dxva2/tests)
diff --git a/dlls/dxgmms1.sys/Makefile.in b/dlls/dxgmms1.sys/Makefile.in
new file mode 100644
index 00000000000..a548331e0ea
--- /dev/null
+++ b/dlls/dxgmms1.sys/Makefile.in
@@ -0,0 +1,6 @@
+MODULE    = dxgmms1.sys
+IMPORTS   = ntoskrnl
+EXTRADLLFLAGS = -mno-cygwin -Wb,--subsystem,native
+
+SOURCES = \
+	main.c
diff --git a/dlls/dxgmms1.sys/dxgmms1.sys.spec b/dlls/dxgmms1.sys/dxgmms1.sys.spec
new file mode 100644
index 00000000000..124b0bf944d
--- /dev/null
+++ b/dlls/dxgmms1.sys/dxgmms1.sys.spec
@@ -0,0 +1,2 @@
+@ stub VidMmInterface
+@ stub VidSchInterface
diff --git a/dlls/dxgmms1.sys/main.c b/dlls/dxgmms1.sys/main.c
new file mode 100644
index 00000000000..686493d3296
--- /dev/null
+++ b/dlls/dxgmms1.sys/main.c
@@ -0,0 +1,39 @@
+/*
+ * dxgmms1.sys driver
+ *
+ * Copyright 2017 Michael Müller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#define NONAMELESSUNION
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "ddk/wdm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dxgmms1);
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    TRACE( "(%p, %s)\n", driver, debugstr_w(path->Buffer) );
+    return STATUS_SUCCESS;
+}

From a3a9bcfadf7bb109b0792e8da4e30cf098cc28f8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 8 Jun 2017 23:50:03 +0200
Subject: [PATCH 172/244] programs/winedevice: Load some common drivers and fix
 ldr order.

---
 dlls/ntoskrnl.exe/tests/driver.c | 50 ++++++++++++++++++++++++++++++++
 programs/winedevice/device.c     | 26 +++++++++++++++++
 2 files changed, 76 insertions(+)

diff --git a/dlls/ntoskrnl.exe/tests/driver.c b/dlls/ntoskrnl.exe/tests/driver.c
index f82e34fca3b..02f25b173cc 100644
--- a/dlls/ntoskrnl.exe/tests/driver.c
+++ b/dlls/ntoskrnl.exe/tests/driver.c
@@ -57,6 +57,7 @@ static int kmemcmp( const void *ptr1, const void *ptr2, size_t n )
 
 static DRIVER_OBJECT *driver_obj;
 static DEVICE_OBJECT *lower_device, *upper_device;
+static LDR_DATA_TABLE_ENTRY *ldr_module;
 
 static POBJECT_TYPE *pExEventObjectType, *pIoFileObjectType, *pPsThreadType, *pIoDriverObjectType;
 static PEPROCESS *pPsInitialSystemProcess;
@@ -1716,6 +1717,7 @@ static void test_resource(void)
     ok(status == STATUS_SUCCESS, "got status %#lx\n", status);
 }
 
+
 static void test_lookup_thread(void)
 {
     NTSTATUS status;
@@ -2432,6 +2434,52 @@ static void test_default_security(void)
     FltFreeSecurityDescriptor(sd);
 }
 
+static void test_default_modules(void)
+{
+    BOOL win32k = FALSE, dxgkrnl = FALSE, dxgmms1 = FALSE;
+    LIST_ENTRY *start, *entry;
+    ANSI_STRING name_a;
+    LDR_DATA_TABLE_ENTRY *mod;
+    NTSTATUS status;
+
+    /* Try to find start of the InLoadOrderModuleList list */
+    for (start = ldr_module->InLoadOrderLinks.Flink; ; start = start->Flink)
+    {
+        mod = CONTAINING_RECORD(start, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+
+        if (!MmIsAddressValid(&mod->DllBase) || !mod->DllBase) break;
+        if (!MmIsAddressValid(&mod->LoadCount) || !mod->LoadCount) break;
+        if (!MmIsAddressValid(&mod->SizeOfImage) || !mod->SizeOfImage) break;
+        if (!MmIsAddressValid(&mod->EntryPoint) || mod->EntryPoint < mod->DllBase ||
+            (DWORD_PTR)mod->EntryPoint > (DWORD_PTR)mod->DllBase + mod->SizeOfImage) break;
+    }
+
+    for (entry = start->Flink; entry != start; entry = entry->Flink)
+    {
+        mod = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+
+        status = RtlUnicodeStringToAnsiString(&name_a, &mod->BaseDllName, TRUE);
+        ok(!status, "RtlUnicodeStringToAnsiString failed with %08lx\n", status);
+        if (status) continue;
+
+        if (entry == start->Flink)
+        {
+            ok(!strncmp(name_a.Buffer, "ntoskrnl.exe", name_a.Length),
+               "Expected ntoskrnl.exe, got %.*s\n", name_a.Length, name_a.Buffer);
+        }
+
+        if (!strncmp(name_a.Buffer, "win32k.sys", name_a.Length)) win32k = TRUE;
+        if (!strncmp(name_a.Buffer, "dxgkrnl.sys", name_a.Length)) dxgkrnl = TRUE;
+        if (!strncmp(name_a.Buffer, "dxgmms1.sys", name_a.Length)) dxgmms1 = TRUE;
+
+        RtlFreeAnsiString(&name_a);
+    }
+
+    ok(win32k, "Failed to find win32k.sys\n");
+    ok(dxgkrnl, "Failed to find dxgkrnl.sys\n");
+    ok(dxgmms1, "Failed to find dxgmms1.sys\n");
+}
+
 static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *stack)
 {
     void *buffer = irp->AssociatedIrp.SystemBuffer;
@@ -2464,6 +2512,7 @@ static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *st
     test_stack_callout();
     test_lookaside_list();
     test_ob_reference();
+    test_default_modules();
     test_resource();
     test_lookup_thread();
     test_IoAttachDeviceToDeviceStack();
@@ -2945,6 +2994,7 @@ NTSTATUS WINAPI DriverEntry(DRIVER_OBJECT *driver, PUNICODE_STRING registry)
     DbgPrint("loading driver\n");
 
     driver_obj = driver;
+    ldr_module = (LDR_DATA_TABLE_ENTRY *)driver->DriverSection;
 
     /* Allow unloading of the driver */
     driver->DriverUnload = driver_Unload;
diff --git a/programs/winedevice/device.c b/programs/winedevice/device.c
index bb585087230..9b4395ff098 100644
--- a/programs/winedevice/device.c
+++ b/programs/winedevice/device.c
@@ -122,8 +122,16 @@ static DWORD WINAPI service_handler( DWORD ctrl, DWORD event_type, LPVOID event_
 
 static void WINAPI ServiceMain( DWORD argc, LPWSTR *argv )
 {
+    static const WCHAR ntoskrnlW[] = L"C:\\windows\\system32\\ntoskrnl.exe";
+    static const WCHAR win32kW[]   = L"C:\\windows\\system32\\win32k.sys";
+    static const WCHAR dxgkrnlW[]  = L"C:\\windows\\system32\\drivers\\dxgkrnl.sys";
+    static const WCHAR dxgmms1W[]  = L"C:\\windows\\system32\\drivers\\dxgmms1.sys";
+    static const WCHAR *stubs[] = { win32kW, dxgkrnlW, dxgmms1W };
     WCHAR driver_dir[MAX_PATH];
     const WCHAR *service_group = (argc >= 2) ? argv[1] : argv[0];
+    LDR_DATA_TABLE_ENTRY *ldr;
+    ULONG_PTR magic;
+    int i;
 
     if (!(stop_event = CreateEventW( NULL, TRUE, FALSE, NULL )))
         return;
@@ -136,6 +144,24 @@ static void WINAPI ServiceMain( DWORD argc, LPWSTR *argv )
     wcscat( driver_dir, L"\\drivers" );
     AddDllDirectory( driver_dir );
 
+    /* Load some default drivers (required by anticheat drivers) */
+    for (i = 0; i < sizeof(stubs)/sizeof(stubs[0]); i++)
+    {
+        if (!LoadLibraryW( stubs[i] ))
+            ERR( "Failed to load %s\n", debugstr_w( stubs[i] ) );
+    }
+
+    /* ntoskrnl.exe must be the first module */
+    LdrLockLoaderLock( 0, NULL, &magic );
+    if (!LdrFindEntryForAddress( GetModuleHandleW( ntoskrnlW ), &ldr ))
+    {
+        RemoveEntryList( &ldr->InLoadOrderLinks );
+        InsertHeadList( &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList, &ldr->InLoadOrderLinks );
+        RemoveEntryList( &ldr->InMemoryOrderLinks );
+        InsertHeadList( &NtCurrentTeb()->Peb->LdrData->InMemoryOrderModuleList, &ldr->InMemoryOrderLinks );
+    }
+    LdrUnlockLoaderLock( 0, magic );
+
     TRACE( "starting service group %s\n", wine_dbgstr_w(service_group) );
     set_service_status( service_handle, SERVICE_RUNNING,
                         SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN );

From 7447ba14dcbe4b1b113b99f970525341bf4d5d93 Mon Sep 17 00:00:00 2001
From: Ken Thomases <ken@codeweavers.com>
Date: Tue, 22 Jun 2021 07:56:43 +1000
Subject: [PATCH 173/244] winemac.drv: No Flicker patch

---
 dlls/winemac.drv/macdrv.h      | 1 +
 dlls/winemac.drv/macdrv_main.c | 4 ++++
 dlls/winemac.drv/opengl.c      | 2 +-
 3 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/winemac.drv/macdrv.h b/dlls/winemac.drv/macdrv.h
index b6eeb4ecb8e..d6178b7f190 100644
--- a/dlls/winemac.drv/macdrv.h
+++ b/dlls/winemac.drv/macdrv.h
@@ -43,6 +43,7 @@ extern BOOL skip_single_buffer_flushes;
 extern BOOL allow_vsync;
 extern BOOL allow_set_gamma;
 extern BOOL allow_software_rendering;
+extern BOOL force_backing_store;
 
 extern UINT64 app_icon_callback;
 extern UINT64 app_quit_request_callback;
diff --git a/dlls/winemac.drv/macdrv_main.c b/dlls/winemac.drv/macdrv_main.c
index 24f6ac973df..923a6fc2ef5 100644
--- a/dlls/winemac.drv/macdrv_main.c
+++ b/dlls/winemac.drv/macdrv_main.c
@@ -59,6 +59,7 @@ int use_precise_scrolling = TRUE;
 int gl_surface_mode = GL_SURFACE_IN_FRONT_OPAQUE;
 int retina_enabled = FALSE;
 int enable_app_nap = FALSE;
+BOOL force_backing_store = FALSE;
 
 UINT64 app_icon_callback = 0;
 UINT64 app_quit_request_callback = 0;
@@ -376,6 +377,9 @@ static void setup_options(void)
     if (!get_config_key(hkey, appkey, "EnableAppNap", buffer, sizeof(buffer)))
         enable_app_nap = IS_OPTION_TRUE(buffer[0]);
 
+    if (!get_config_key(hkey, appkey, "ForceOpenGLBackingStore", buffer, sizeof(buffer)))
+        force_backing_store = IS_OPTION_TRUE(buffer[0]);
+
     /* Don't use appkey.  The DPI and monitor sizes should be consistent for all
        processes in the prefix. */
     if (!get_config_key(hkey, NULL, "RetinaMode", buffer, sizeof(buffer)))
diff --git a/dlls/winemac.drv/opengl.c b/dlls/winemac.drv/opengl.c
index ac87cfc1313..68de39f49cd 100644
--- a/dlls/winemac.drv/opengl.c
+++ b/dlls/winemac.drv/opengl.c
@@ -1451,7 +1451,7 @@ static BOOL create_context(struct wgl_context *context, CGLContextObj share, uns
         attribs[n++] = pf->samples;
     }
 
-    if (pf->backing_store)
+    if (force_backing_store || pf->backing_store)
         attribs[n++] = kCGLPFABackingStore;
 
     if (core)

From 4d68e98a59c96abc0525c292c8e5e0fe278a1797 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 4 Nov 2015 02:57:56 +0100
Subject: [PATCH 174/244] winepulse.drv: Use a separate mainloop and ctx for
 pulse_test_connect.

---
 dlls/winepulse.drv/pulse.c | 64 ++++++++++++++++++--------------------
 1 file changed, 30 insertions(+), 34 deletions(-)

diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 9cb29be21b6..b44b1feaaf6 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -703,7 +703,8 @@ static void convert_channel_map(const pa_channel_map *pa_map, WAVEFORMATEXTENSIB
     fmt->dwChannelMask = pa_mask;
 }
 
-static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATEXTENSIBLE *fmt, REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
+static void pulse_probe_settings(pa_mainloop *ml, pa_context *ctx, int render, const char *pulse_name,
+                                 WAVEFORMATEXTENSIBLE *fmt, REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
 {
     WAVEFORMATEX *wfx = &fmt->Format;
     pa_stream *stream;
@@ -726,7 +727,7 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
     attr.minreq = attr.fragsize = pa_frame_size(&ss);
     attr.prebuf = 0;
 
-    stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
+    stream = pa_stream_new(ctx, "format test stream", &ss, &map);
     if (stream)
         pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
     if (!stream)
@@ -737,7 +738,7 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
     else
         ret = pa_stream_connect_record(stream, pulse_name, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
     if (ret >= 0) {
-        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                 pa_stream_get_state(stream) == PA_STREAM_CREATING)
         {}
         if (pa_stream_get_state(stream) == PA_STREAM_READY) {
@@ -748,7 +749,7 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
             else
                 length = pa_stream_get_buffer_attr(stream)->fragsize;
             pa_stream_disconnect(stream);
-            while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+            while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                     pa_stream_get_state(stream) == PA_STREAM_READY)
             {}
         }
@@ -790,34 +791,33 @@ static NTSTATUS pulse_test_connect(void *args)
     pa_operation *o;
     int ret;
     char *name = wstr_to_str(params->name);
+    pa_mainloop *ml;
+    pa_context *ctx;
 
     pulse_lock();
-    pulse_ml = pa_mainloop_new();
+    ml = pa_mainloop_new();
 
-    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
-
-    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), name);
+    pa_mainloop_set_poll_func(ml, pulse_poll_func, NULL);
 
+    ctx = pa_context_new(pa_mainloop_get_api(ml), name);
     free(name);
-
-    if (!pulse_ctx) {
+    if (!ctx) {
         ERR("Failed to create context\n");
-        pa_mainloop_free(pulse_ml);
-        pulse_ml = NULL;
+        pa_mainloop_free(ml);
         pulse_unlock();
         params->priority = Priority_Unavailable;
         return STATUS_SUCCESS;
     }
 
-    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+    pa_context_set_state_callback(ctx, pulse_contextcallback, NULL);
 
-    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
-    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(ctx), PA_API_VERSION);
+    if (pa_context_connect(ctx, NULL, 0, NULL) < 0)
         goto fail;
 
     /* Wait for connection */
-    while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0) {
-        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+    while (pa_mainloop_iterate(ml, 1, &ret) >= 0) {
+        pa_context_state_t state = pa_context_get_state(ctx);
 
         if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
             goto fail;
@@ -826,12 +826,12 @@ static NTSTATUS pulse_test_connect(void *args)
             break;
     }
 
-    if (pa_context_get_state(pulse_ctx) != PA_CONTEXT_READY)
+    if (pa_context_get_state(ctx) != PA_CONTEXT_READY)
         goto fail;
 
     TRACE("Test-connected to server %s with protocol version: %i.\n",
-        pa_context_get_server(pulse_ctx),
-        pa_context_get_server_protocol_version(pulse_ctx));
+        pa_context_get_server(ctx),
+        pa_context_get_server_protocol_version(ctx));
 
     free_phys_device_lists();
     list_init(&g_phys_speakers);
@@ -841,34 +841,32 @@ static NTSTATUS pulse_test_connect(void *args)
     pulse_add_device(&g_phys_speakers, NULL, 0, Speakers, 0, "", "PulseAudio Output");
     pulse_add_device(&g_phys_sources, NULL, 0, Microphone, 0, "", "PulseAudio Input");
 
-    o = pa_context_get_sink_info_list(pulse_ctx, &pulse_phys_speakers_cb, NULL);
+    o = pa_context_get_sink_info_list(ctx, &pulse_phys_speakers_cb, NULL);
     if (o) {
-        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                 pa_operation_get_state(o) == PA_OPERATION_RUNNING)
         {}
         pa_operation_unref(o);
     }
 
-    o = pa_context_get_source_info_list(pulse_ctx, &pulse_phys_sources_cb, NULL);
+    o = pa_context_get_source_info_list(ctx, &pulse_phys_sources_cb, NULL);
     if (o) {
-        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                 pa_operation_get_state(o) == PA_OPERATION_RUNNING)
         {}
         pa_operation_unref(o);
     }
 
     LIST_FOR_EACH_ENTRY(dev, &g_phys_speakers, PhysDevice, entry) {
-        pulse_probe_settings(1, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
+        pulse_probe_settings(ml, ctx, 1, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
     }
 
     LIST_FOR_EACH_ENTRY(dev, &g_phys_sources, PhysDevice, entry) {
-        pulse_probe_settings(0, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
+        pulse_probe_settings(ml, ctx, 0, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
     }
 
-    pa_context_unref(pulse_ctx);
-    pulse_ctx = NULL;
-    pa_mainloop_free(pulse_ml);
-    pulse_ml = NULL;
+    pa_context_unref(ctx);
+    pa_mainloop_free(ml);
 
     pulse_unlock();
 
@@ -876,10 +874,8 @@ static NTSTATUS pulse_test_connect(void *args)
     return STATUS_SUCCESS;
 
 fail:
-    pa_context_unref(pulse_ctx);
-    pulse_ctx = NULL;
-    pa_mainloop_free(pulse_ml);
-    pulse_ml = NULL;
+    pa_context_unref(ctx);
+    pa_mainloop_free(ml);
     pulse_unlock();
     params->priority = Priority_Unavailable;
     return STATUS_SUCCESS;

From 34fc6421c4d3ef239fb73ee9eb5c2256532dbc2b Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Wed, 30 Mar 2022 03:12:30 -0400
Subject: [PATCH 175/244] winepulse: Add aux0 and aux1 channels.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52572
---
 dlls/winepulse.drv/pulse.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index b44b1feaaf6..4d4a7b78014 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -443,9 +443,11 @@ static UINT pulse_channel_map_to_channel_mask(const pa_channel_map *map)
     for (i = 0; i < map->channels; ++i) {
         switch (map->map[i]) {
             default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(map->map[i])); break;
+            case PA_CHANNEL_POSITION_AUX0:
             case PA_CHANNEL_POSITION_FRONT_LEFT: mask |= SPEAKER_FRONT_LEFT; break;
             case PA_CHANNEL_POSITION_MONO:
             case PA_CHANNEL_POSITION_FRONT_CENTER: mask |= SPEAKER_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_AUX1:
             case PA_CHANNEL_POSITION_FRONT_RIGHT: mask |= SPEAKER_FRONT_RIGHT; break;
             case PA_CHANNEL_POSITION_REAR_LEFT: mask |= SPEAKER_BACK_LEFT; break;
             case PA_CHANNEL_POSITION_REAR_CENTER: mask |= SPEAKER_BACK_CENTER; break;
@@ -925,7 +927,9 @@ static const enum pa_channel_position pulse_pos_from_wfx[] = {
     PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
     PA_CHANNEL_POSITION_TOP_REAR_LEFT,
     PA_CHANNEL_POSITION_TOP_REAR_CENTER,
-    PA_CHANNEL_POSITION_TOP_REAR_RIGHT
+    PA_CHANNEL_POSITION_TOP_REAR_RIGHT,
+    PA_CHANNEL_POSITION_AUX0,
+    PA_CHANNEL_POSITION_AUX1
 };
 
 static HRESULT pulse_spec_from_waveformat(struct pulse_stream *stream, const WAVEFORMATEX *fmt)

From d946cdc0c6865dbcb1d41ac73ce8f199132cf6d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Jan 2023 21:16:38 +0100
Subject: [PATCH 176/244] winecfg: Move input config options to a dedicated
 tab.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 MAINTAINERS                  |   1 +
 programs/winecfg/Makefile.in |   1 +
 programs/winecfg/input.c     | 105 +++++++++++++++++++++++++++++++++++
 programs/winecfg/main.c      |  12 +++-
 programs/winecfg/resource.h  |   6 +-
 programs/winecfg/winecfg.h   |   4 ++
 programs/winecfg/winecfg.rc  |  38 ++++++++-----
 programs/winecfg/x11drvdlg.c |  18 +-----
 8 files changed, 151 insertions(+), 34 deletions(-)
 create mode 100644 programs/winecfg/input.c

diff --git a/MAINTAINERS b/MAINTAINERS
index c50c5d235c9..cb2791770c0 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -187,6 +187,7 @@ F:	dlls/user32/input.c
 F:	dlls/win32u/input.c
 F:	dlls/win32u/rawinput.c
 F:	server/queue.c
+F:	programs/winecfg/input.c
 
 Input methods
 M:	Rémi Bernon <rbernon@codeweavers.com>
diff --git a/programs/winecfg/Makefile.in b/programs/winecfg/Makefile.in
index 99c829a9468..1105a99e177 100644
--- a/programs/winecfg/Makefile.in
+++ b/programs/winecfg/Makefile.in
@@ -9,6 +9,7 @@ SOURCES = \
 	audio.c \
 	drive.c \
 	driveui.c \
+	input.c \
 	libraries.c \
 	logo.svg \
 	main.c \
diff --git a/programs/winecfg/input.c b/programs/winecfg/input.c
new file mode 100644
index 00000000000..115161b9040
--- /dev/null
+++ b/programs/winecfg/input.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2023 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+
+#include "winecfg.h"
+#include "resource.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(winecfg);
+
+static BOOL updating_ui;
+
+static void init_dialog( HWND dialog )
+{
+    WCHAR *buffer;
+
+    convert_x11_desktop_key();
+
+    updating_ui = TRUE;
+
+    buffer = get_reg_key( config_key, keypath( L"X11 Driver" ), L"GrabFullscreen", L"N" );
+    if (IS_OPTION_TRUE( *buffer )) CheckDlgButton( dialog, IDC_FULLSCREEN_GRAB, BST_CHECKED );
+    else CheckDlgButton( dialog, IDC_FULLSCREEN_GRAB, BST_UNCHECKED );
+    free( buffer );
+
+    updating_ui = FALSE;
+}
+
+static void on_fullscreen_grab_clicked( HWND dialog )
+{
+    BOOL checked = IsDlgButtonChecked( dialog, IDC_FULLSCREEN_GRAB ) == BST_CHECKED;
+    if (checked) set_reg_key( config_key, keypath( L"X11 Driver" ), L"GrabFullscreen", L"Y" );
+    else set_reg_key( config_key, keypath( L"X11 Driver" ), L"GrabFullscreen", L"N" );
+}
+
+INT_PTR CALLBACK InputDlgProc( HWND dialog, UINT message, WPARAM wparam, LPARAM lparam )
+{
+    TRACE( "dialog %p, message %#x, wparam %#Ix, lparam %#Ix\n", dialog, message, wparam, lparam );
+
+    switch (message)
+    {
+    case WM_SHOWWINDOW:
+        set_window_title( dialog );
+        break;
+
+    case WM_COMMAND:
+        switch (HIWORD(wparam))
+        {
+        case BN_CLICKED:
+            if (updating_ui) break;
+            SendMessageW( GetParent( dialog ), PSM_CHANGED, 0, 0 );
+            switch (LOWORD(wparam))
+            {
+            case IDC_FULLSCREEN_GRAB: on_fullscreen_grab_clicked( dialog ); break;
+            }
+            break;
+        }
+        break;
+
+    case WM_NOTIFY:
+        switch (((LPNMHDR)lparam)->code)
+        {
+        case PSN_KILLACTIVE:
+            SetWindowLongPtrW( dialog, DWLP_MSGRESULT, FALSE );
+            break;
+        case PSN_APPLY:
+            apply();
+            SetWindowLongPtrW( dialog, DWLP_MSGRESULT, PSNRET_NOERROR );
+            break;
+        case PSN_SETACTIVE:
+            init_dialog( dialog );
+            break;
+        case LVN_ITEMCHANGED:
+            break;
+        }
+        break;
+    case WM_INITDIALOG:
+        break;
+    }
+
+    return FALSE;
+}
diff --git a/programs/winecfg/main.c b/programs/winecfg/main.c
index afecfd664a9..b733b11be5e 100644
--- a/programs/winecfg/main.c
+++ b/programs/winecfg/main.c
@@ -58,7 +58,7 @@ PropSheetCallback (HWND hWnd, UINT uMsg, LPARAM lParam)
     return 0;
 }
 
-#define NUM_PROPERTY_PAGES 8
+#define NUM_PROPERTY_PAGES 9
 
 static INT_PTR
 doPropertySheet (HINSTANCE hInstance, HWND hOwner)
@@ -149,6 +149,16 @@ doPropertySheet (HINSTANCE hInstance, HWND hOwner)
     psp[pg].lParam = 0;
     pg++;
 
+    psp[pg].dwSize = sizeof (PROPSHEETPAGEW);
+    psp[pg].dwFlags = PSP_USETITLE;
+    psp[pg].hInstance = hInstance;
+    psp[pg].pszTemplate = MAKEINTRESOURCEW (IDD_INPUT_CONFIG);
+    psp[pg].pszIcon = NULL;
+    psp[pg].pfnDlgProc = InputDlgProc;
+    psp[pg].pszTitle =  load_string (IDS_TAB_INPUT);
+    psp[pg].lParam = 0;
+    pg++;
+
     /*
      * Fill out the (General) PROPSHEETPAGE data structure 
      * for the property sheet
diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index c0d7adadcc1..6e2953c0d70 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -46,6 +46,7 @@
 #define IDS_LINKS_TO                    17
 #define IDS_WINECFG_TITLE_APP           18   /* App specific title */
 #define IDS_TAB_STAGING                 19
+#define IDS_TAB_INPUT                   20
 #define IDI_WINECFG                     100
 #define IDI_LOGO                        102
 #define IDD_ABOUTCFG                    107
@@ -56,6 +57,7 @@
 #define IDD_DRIVECFG                    112
 #define IDD_DESKTOP_INTEGRATION         115
 #define IDD_STAGING                     116
+#define IDD_INPUT_CONFIG                117
 #define IDC_WINVER                      1012
 #define IDC_DESKTOP_WIDTH               1023
 #define IDC_DESKTOP_HEIGHT              1024
@@ -126,7 +128,6 @@
 /* graphics */
 #define IDC_ENABLE_MANAGED              1100
 #define IDC_ENABLE_DECORATED            1101
-#define IDC_FULLSCREEN_GRAB             1102
 
 #define IDC_RES_TRACKBAR                1107
 #define IDC_RES_DPIEDIT                 1108
@@ -230,3 +231,6 @@
 #define IDC_ABT_TITLE_TEXT           8436
 #define IDC_ABT_WEB_LINK             8437
 #define IDC_ABT_LICENSE_TEXT         8438
+
+/* input tab */
+#define IDC_FULLSCREEN_GRAB             1501
diff --git a/programs/winecfg/winecfg.h b/programs/winecfg/winecfg.h
index d4fedff5afb..b83234470c1 100644
--- a/programs/winecfg/winecfg.h
+++ b/programs/winecfg/winecfg.h
@@ -74,6 +74,9 @@ WCHAR *keypath(const WCHAR *section);
 BOOL initialize(HINSTANCE hInstance);
 extern HKEY config_key;
 
+/* winex11 registry */
+void convert_x11_desktop_key(void);
+
 /* hack for the property sheet control  */
 void set_window_title(HWND dialog);
 
@@ -87,6 +90,7 @@ INT_PTR CALLBACK AudioDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lPara
 INT_PTR CALLBACK ThemeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK StagingDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AboutDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
+INT_PTR CALLBACK InputDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 
 /* Windows version management */
 BOOL set_winver_from_string(const WCHAR *version);
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 428c477413c..1231e5319c5 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -40,6 +40,7 @@ BEGIN
     IDS_TAB_AUDIO           "Audio"
     IDS_TAB_STAGING         "Staging"
     IDS_TAB_ABOUT           "About"
+    IDS_TAB_INPUT           "Input"
     IDS_WINECFG_TITLE       "Wine configuration"
     IDS_WINECFG_TITLE_APP   "Wine configuration for %s"
     IDS_THEMEFILE           "Theme files (*.msstyles; *.theme)"
@@ -171,22 +172,21 @@ IDD_GRAPHCFG DIALOG  0, 0, 260, 220
 STYLE WS_CHILD | WS_DISABLED
 FONT 8, "MS Shell Dlg"
 BEGIN
-    GROUPBOX    "Window settings",IDC_STATIC,8,4,244,84
-    CONTROL     "Automatically capture the &mouse in full-screen windows",IDC_FULLSCREEN_GRAB,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
-    CONTROL     "Allow the window manager to &decorate the windows",IDC_ENABLE_DECORATED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,32,230,10
-    CONTROL     "Allow the &window manager to control the windows",IDC_ENABLE_MANAGED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,44,230,10
+    GROUPBOX    "Window settings",IDC_STATIC,8,4,244,72
+    CONTROL     "Allow the window manager to &decorate the windows",IDC_ENABLE_DECORATED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
+    CONTROL     "Allow the &window manager to control the windows",IDC_ENABLE_MANAGED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,32,230,10
     CONTROL     "&Emulate a virtual desktop",IDC_ENABLE_DESKTOP,"Button",
-                BS_AUTOCHECKBOX | WS_TABSTOP,15,56,230,10
-    LTEXT       "Desktop &size:",IDC_DESKTOP_SIZE,15,70,64,16,WS_DISABLED
-    LTEXT       "#msgctxt#do not translate#X",IDC_DESKTOP_BY,129,70,8,8,WS_DISABLED
-    EDITTEXT    IDC_DESKTOP_WIDTH,84,68,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
-    EDITTEXT    IDC_DESKTOP_HEIGHT,137,68,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
-
-    GROUPBOX    "Screen resolution",IDC_STATIC,8,95,244,84
-    CONTROL     "", IDC_RES_TRACKBAR, "msctls_trackbar32",WS_TABSTOP,12,105,171,15
-    EDITTEXT    IDC_RES_DPIEDIT,188,105,23,13,ES_NUMBER|WS_TABSTOP
-    LTEXT       "#msgctxt#unit: dots/inch#dpi",IDC_STATIC,215,107,30,8
-    LTEXT       "This is a sample text using 10 point Tahoma",IDC_RES_FONT_PREVIEW,15,124,230,49
+                BS_AUTOCHECKBOX | WS_TABSTOP,15,44,230,10
+    LTEXT       "Desktop &size:",IDC_DESKTOP_SIZE,15,58,64,16,WS_DISABLED
+    LTEXT       "#msgctxt#do not translate#X",IDC_DESKTOP_BY,129,58,8,8,WS_DISABLED
+    EDITTEXT    IDC_DESKTOP_WIDTH,84,56,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
+    EDITTEXT    IDC_DESKTOP_HEIGHT,137,56,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
+
+    GROUPBOX    "Screen resolution",IDC_STATIC,8,83,244,84
+    CONTROL     "", IDC_RES_TRACKBAR, "msctls_trackbar32",WS_TABSTOP,12,93,171,15
+    EDITTEXT    IDC_RES_DPIEDIT,188,93,23,13,ES_NUMBER|WS_TABSTOP
+    LTEXT       "#msgctxt#unit: dots/inch#dpi",IDC_STATIC,215,95,30,8
+    LTEXT       "This is a sample text using 10 point Tahoma",IDC_RES_FONT_PREVIEW,15,112,230,49
 END
 
 IDD_DLLCFG DIALOG  0, 0, 260, 220
@@ -332,6 +332,14 @@ BEGIN
     CONTROL     "Enable &GTK3 Theming",IDC_ENABLE_GTK3,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,100,230,8
 END
 
+IDD_INPUT_CONFIG DIALOG  0, 0, 260, 220
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX    "Mouse settings",IDC_STATIC,8,4,244,64
+    CONTROL     "Automatically capture the &mouse in full-screen windows",IDC_FULLSCREEN_GRAB,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
+END
+
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 
 /* @makedep: winecfg.ico */
diff --git a/programs/winecfg/x11drvdlg.c b/programs/winecfg/x11drvdlg.c
index aea52717a78..2f739564c23 100644
--- a/programs/winecfg/x11drvdlg.c
+++ b/programs/winecfg/x11drvdlg.c
@@ -46,7 +46,7 @@ static const UINT dpi_values[] = { 96, 120, 144, 168, 192, 216, 240, 288, 336, 3
 static BOOL updating_ui;
 
 /* convert the x11 desktop key to the new explorer config */
-static void convert_x11_desktop_key(void)
+void convert_x11_desktop_key(void)
 {
     WCHAR *buf;
 
@@ -138,13 +138,6 @@ static void init_dialog(HWND dialog)
         SendDlgItemMessageW(dialog, IDC_DESKTOP_HEIGHT, EM_LIMITTEXT, RES_MAXLEN, 0);
     }
 
-    buf = get_reg_key(config_key, keypath(L"X11 Driver"), L"GrabFullscreen", L"N");
-    if (IS_OPTION_TRUE(*buf))
-	CheckDlgButton(dialog, IDC_FULLSCREEN_GRAB, BST_CHECKED);
-    else
-	CheckDlgButton(dialog, IDC_FULLSCREEN_GRAB, BST_UNCHECKED);
-    free(buf);
-
     buf = get_reg_key(config_key, keypath(L"X11 Driver"), L"Managed", L"Y");
     if (IS_OPTION_TRUE(*buf))
 	CheckDlgButton(dialog, IDC_ENABLE_MANAGED, BST_CHECKED);
@@ -219,14 +212,6 @@ static void on_enable_decorated_clicked(HWND dialog) {
     }
 }
 
-static void on_fullscreen_grab_clicked(HWND dialog)
-{
-    if (IsDlgButtonChecked(dialog, IDC_FULLSCREEN_GRAB) == BST_CHECKED)
-        set_reg_key(config_key, keypath(L"X11 Driver"), L"GrabFullscreen", L"Y");
-    else
-        set_reg_key(config_key, keypath(L"X11 Driver"), L"GrabFullscreen", L"N");
-}
-
 static INT read_logpixels_reg(void)
 {
     DWORD dwLogPixels;
@@ -382,7 +367,6 @@ GraphDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
 			case IDC_ENABLE_DESKTOP: on_enable_desktop_clicked(hDlg); break;
                         case IDC_ENABLE_MANAGED: on_enable_managed_clicked(hDlg); break;
                         case IDC_ENABLE_DECORATED: on_enable_decorated_clicked(hDlg); break;
-			case IDC_FULLSCREEN_GRAB:  on_fullscreen_grab_clicked(hDlg); break;
 		    }
 		    break;
 		}

From 70cbb6b17af421af069150ae8a84d755de137239 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Jan 2023 11:22:10 +0100
Subject: [PATCH 177/244] winex11: Always create the HKCU configuration
 registry key.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 dlls/winex11.drv/x11drv_main.c | 67 ++++++++++++++++++++++++++++++++--
 1 file changed, 64 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 22a1e370b41..3ffd3e1724f 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -341,11 +341,61 @@ HKEY reg_open_key( HKEY root, const WCHAR *name, ULONG name_len )
     return NtOpenKeyEx( &ret, MAXIMUM_ALLOWED, &attr, 0 ) ? 0 : ret;
 }
 
+/* wrapper for NtCreateKey that creates the key recursively if necessary */
+static HKEY reg_create_key( HKEY root, const WCHAR *name, ULONG name_len,
+                            DWORD options, DWORD *disposition )
+{
+    UNICODE_STRING nameW = { name_len, name_len, (WCHAR *)name };
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    HANDLE ret;
 
-HKEY open_hkcu_key( const char *name )
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = NtCreateKey( &ret, MAXIMUM_ALLOWED, &attr, 0, NULL, options, disposition );
+    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+    {
+        static const WCHAR registry_rootW[] = { '\\','R','e','g','i','s','t','r','y','\\' };
+        DWORD pos = 0, i = 0, len = name_len / sizeof(WCHAR);
+
+        /* don't try to create registry root */
+        if (!root && len > ARRAY_SIZE(registry_rootW) &&
+            !memcmp( name, registry_rootW, sizeof(registry_rootW) ))
+            i += ARRAY_SIZE(registry_rootW);
+
+        while (i < len && name[i] != '\\') i++;
+        if (i == len) return 0;
+        for (;;)
+        {
+            unsigned int subkey_options = options;
+            if (i < len) subkey_options &= ~(REG_OPTION_CREATE_LINK | REG_OPTION_OPEN_LINK);
+            nameW.Buffer = (WCHAR *)name + pos;
+            nameW.Length = (i - pos) * sizeof(WCHAR);
+            status = NtCreateKey( &ret, MAXIMUM_ALLOWED, &attr, 0, NULL, subkey_options, disposition );
+
+            if (attr.RootDirectory != root) NtClose( attr.RootDirectory );
+            if (!NT_SUCCESS(status)) return 0;
+            if (i == len) break;
+            attr.RootDirectory = ret;
+            while (i < len && name[i] == '\\') i++;
+            pos = i;
+            while (i < len && name[i] != '\\') i++;
+        }
+    }
+    return ret;
+}
+
+static HKEY reg_open_hkcu_key( const char *name, BOOL create )
 {
     WCHAR bufferW[256];
     static HKEY hkcu;
+    DWORD disp;
+    HKEY key;
 
     if (!hkcu)
     {
@@ -370,7 +420,18 @@ HKEY open_hkcu_key( const char *name )
         hkcu = reg_open_key( NULL, bufferW, len * sizeof(WCHAR) );
     }
 
-    return reg_open_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR) );
+    if ((key = reg_open_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR) )) || !create) return key;
+    return reg_create_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR), 0, &disp );
+}
+
+HKEY open_hkcu_key( const char *name )
+{
+    return reg_open_hkcu_key( name, FALSE );
+}
+
+static HKEY create_hkcu_key( const char *name )
+{
+    return reg_open_hkcu_key( name, TRUE );
 }
 
 
@@ -434,7 +495,7 @@ static void setup_options(void)
     DWORD len;
 
     /* @@ Wine registry key: HKCU\Software\Wine\X11 Driver */
-    hkey = open_hkcu_key( "Software\\Wine\\X11 Driver" );
+    hkey = create_hkcu_key( "Software\\Wine\\X11 Driver" );
 
     /* open the app-specific key */
 

From c01699a36f4b5ada7c4290d08e59a0cd400b9818 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Jan 2023 08:09:11 +0100
Subject: [PATCH 178/244] winex11: Write supported keyboard layout list in
 registry.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 dlls/winex11.drv/keyboard.c    | 21 +++++++++++++++++++++
 dlls/winex11.drv/x11drv.h      |  4 ++++
 dlls/winex11.drv/x11drv_main.c | 17 +++++++++++++++++
 3 files changed, 42 insertions(+)

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index efc44d3084a..39f3b93ad46 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1083,6 +1083,27 @@ static const WORD xfree86_vendor_key_vkey[256] =
     0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
+WCHAR *x11drv_get_keyboard_layout_list( DWORD *length )
+{
+    WCHAR *tmp, *layouts = calloc( 1, sizeof(WCHAR) );
+    int i;
+
+    for (i = 0, *length = 1; main_key_tab[i].comment; i++)
+    {
+        const char *name = main_key_tab[i].comment;
+        int len = strlen( name ) + 1;
+
+        if (!(tmp = realloc( layouts, (*length + len) * sizeof(WCHAR) ))) return layouts;
+        layouts = tmp;
+
+        asciiz_to_unicode( layouts + *length - 1, name );
+        layouts[*length + len - 1] = 0;
+        (*length) += len;
+    }
+
+    return layouts;
+}
+
 /* Returns the Windows virtual key code associated with the X event <e> */
 /* kbd_section must be held */
 static WORD EVENT_event_to_vkey( XIC xic, XKeyEvent *e)
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index ad7dc69dfbb..428f5dda1ec 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -764,6 +764,10 @@ extern BOOL xinerama_get_fullscreen_monitors( const RECT *rect, long *indices );
 extern void xinerama_init( unsigned int width, unsigned int height );
 extern void init_recursive_mutex( pthread_mutex_t *mutex );
 
+/* keyboard.c */
+
+extern WCHAR *x11drv_get_keyboard_layout_list( DWORD *size );
+
 #define DEPTH_COUNT 3
 extern const unsigned int *depths;
 extern RECT gamescope_screen_rect;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 3ffd3e1724f..3c96cd449d4 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -434,6 +434,19 @@ static HKEY create_hkcu_key( const char *name )
     return reg_open_hkcu_key( name, TRUE );
 }
 
+static BOOL set_reg_value( HKEY hkey, const WCHAR *name, UINT type, const void *value, DWORD count )
+{
+    unsigned int name_size = name ? lstrlenW( name ) * sizeof(WCHAR) : 0;
+    UNICODE_STRING nameW = { name_size, name_size, (WCHAR *)name };
+    return !NtSetValueKey( hkey, &nameW, 0, type, value, count );
+}
+
+static void set_reg_string_value( HKEY hkey, const char *name, const WCHAR *value, DWORD count )
+{
+    WCHAR nameW[64];
+    asciiz_to_unicode( nameW, name );
+    set_reg_value( hkey, nameW, REG_MULTI_SZ, value, count );
+}
 
 ULONG query_reg_value( HKEY hkey, const WCHAR *name, KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size )
 {
@@ -543,6 +556,10 @@ static void setup_options(void)
     if (!get_config_key( hkey, appkey, "GrabFullscreen", buffer, sizeof(buffer) ))
         grab_fullscreen = IS_OPTION_TRUE( buffer[0] );
 
+    p = x11drv_get_keyboard_layout_list( &len );
+    if (p) set_reg_string_value( hkey, "KeyboardLayoutList", p, len * sizeof(WCHAR) );
+    free( p );
+
     if (!get_config_key( hkey, appkey, "ScreenDepth", buffer, sizeof(buffer) ))
         default_visual.depth = wcstol( buffer, NULL, 0 );
 

From 934d9c00469783e2ec509ec30fb832fb49042587 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Jan 2023 08:15:41 +0100
Subject: [PATCH 179/244] winecfg: Add a keyboard layout selection config
 option.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 programs/winecfg/input.c    | 48 ++++++++++++++++++++++++++++++++++++-
 programs/winecfg/resource.h |  3 +++
 programs/winecfg/winecfg.rc |  9 +++++++
 3 files changed, 59 insertions(+), 1 deletion(-)

diff --git a/programs/winecfg/input.c b/programs/winecfg/input.c
index 115161b9040..f2f035df80f 100644
--- a/programs/winecfg/input.c
+++ b/programs/winecfg/input.c
@@ -35,7 +35,9 @@ static BOOL updating_ui;
 
 static void init_dialog( HWND dialog )
 {
-    WCHAR *buffer;
+    WCHAR auto_detect_layout[256];
+    WCHAR *buffer, *layout;
+    HWND layouts;
 
     convert_x11_desktop_key();
 
@@ -46,6 +48,23 @@ static void init_dialog( HWND dialog )
     else CheckDlgButton( dialog, IDC_FULLSCREEN_GRAB, BST_UNCHECKED );
     free( buffer );
 
+    layouts = GetDlgItem( dialog, IDC_KEYBOARD_LAYOUT );
+    LoadStringW( GetModuleHandleW( NULL ), IDS_INPUT_AUTO_DETECT_LAYOUT, auto_detect_layout,
+                 ARRAY_SIZE(auto_detect_layout) );
+
+    SendMessageW( layouts, CB_RESETCONTENT, 0, 0 );
+    SendMessageW( layouts, CB_ADDSTRING, 0, (LPARAM)auto_detect_layout );
+
+    buffer = get_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardLayoutList", L"" );
+    for (layout = buffer; *layout; layout += wcslen( layout ) + 1)
+        SendMessageW( layouts, CB_ADDSTRING, 0, (LPARAM)layout );
+    free( buffer );
+
+    buffer = get_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardLayout", L"" );
+    if (!buffer || !buffer[0]) SendMessageW( layouts, CB_SETCURSEL, 0, 0 );
+    else SendMessageW( layouts, CB_SELECTSTRING, -1, (LPARAM)buffer );
+    free( buffer );
+
     updating_ui = FALSE;
 }
 
@@ -56,6 +75,24 @@ static void on_fullscreen_grab_clicked( HWND dialog )
     else set_reg_key( config_key, keypath( L"X11 Driver" ), L"GrabFullscreen", L"N" );
 }
 
+static void on_keyboard_layout_changed( HWND dialog )
+{
+    int len, index;
+    WCHAR *buffer;
+
+    if (!(index = SendMessageW( GetDlgItem( dialog, IDC_KEYBOARD_LAYOUT ), CB_GETCURSEL, 0, 0 )))
+        set_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardLayout", L"" );
+    else
+    {
+        len = SendMessageW( GetDlgItem( dialog, IDC_KEYBOARD_LAYOUT ), CB_GETLBTEXTLEN, index, 0 ) + 1;
+        if (!(buffer = malloc( len * sizeof(WCHAR) ))) return;
+
+        SendMessageW( GetDlgItem( dialog, IDC_KEYBOARD_LAYOUT ), CB_GETLBTEXT, index, (LPARAM)buffer );
+        set_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardLayout", buffer );
+        free( buffer );
+    }
+}
+
 INT_PTR CALLBACK InputDlgProc( HWND dialog, UINT message, WPARAM wparam, LPARAM lparam )
 {
     TRACE( "dialog %p, message %#x, wparam %#Ix, lparam %#Ix\n", dialog, message, wparam, lparam );
@@ -77,6 +114,15 @@ INT_PTR CALLBACK InputDlgProc( HWND dialog, UINT message, WPARAM wparam, LPARAM
             case IDC_FULLSCREEN_GRAB: on_fullscreen_grab_clicked( dialog ); break;
             }
             break;
+
+        case CBN_SELCHANGE:
+            if (updating_ui) break;
+            SendMessageW( GetParent( dialog ), PSM_CHANGED, 0, 0 );
+            switch (LOWORD(wparam))
+            {
+            case IDC_KEYBOARD_LAYOUT: on_keyboard_layout_changed( dialog ); break;
+            }
+            break;
         }
         break;
 
diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index 6e2953c0d70..2013d913e72 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -234,3 +234,6 @@
 
 /* input tab */
 #define IDC_FULLSCREEN_GRAB             1501
+#define IDC_KEYBOARD_LAYOUT             1502
+
+#define IDS_INPUT_AUTO_DETECT_LAYOUT    8501
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 1231e5319c5..8ad03b7967b 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -136,6 +136,11 @@ BEGIN
     IDC_SYSPARAMS_MENUBAR           "Menu Bar"
 END
 
+STRINGTABLE
+BEGIN
+    IDS_INPUT_AUTO_DETECT_LAYOUT  "(Auto detect)"
+END
+
 IDD_ABOUTCFG DIALOGEX 0, 0, 260, 220
 STYLE WS_CHILD
 FONT 8, "MS Shell Dlg"
@@ -338,6 +343,10 @@ FONT 8, "MS Shell Dlg"
 BEGIN
     GROUPBOX    "Mouse settings",IDC_STATIC,8,4,244,64
     CONTROL     "Automatically capture the &mouse in full-screen windows",IDC_FULLSCREEN_GRAB,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
+
+    GROUPBOX    "Keyboard settings",IDC_STATIC,8,70,244,64
+    LTEXT       "&Layout:",IDC_STATIC,15,82,230,8
+    COMBOBOX    IDC_KEYBOARD_LAYOUT,110,80,135,60,CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_SORT | WS_VSCROLL | WS_TABSTOP
 END
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

From c7b8025c16bb02db3c89031c38a474a7fe1392c7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Jan 2023 08:09:11 +0100
Subject: [PATCH 180/244] winex11: Use the user configured keyboard layout if
 any.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 dlls/winex11.drv/keyboard.c    | 33 +++++++++++++++++++++++++++------
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c |  4 ++++
 3 files changed, 33 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 39f3b93ad46..44dc168490e 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -928,7 +928,6 @@ static const struct {
 
  {0, NULL, NULL, NULL, NULL} /* sentinel */
 };
-static unsigned kbd_layout=0; /* index into above table of layouts */
 
 /* maybe more of these scancodes should be extended? */
                 /* extended must be set for ALT_R, CTRL_R,
@@ -1083,6 +1082,26 @@ static const WORD xfree86_vendor_key_vkey[256] =
     0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
+int x11drv_find_keyboard_layout( const WCHAR *layout )
+{
+    int i, len;
+    char *tmp;
+
+    len = lstrlenW( layout );
+    if (!(tmp = malloc( len * 3 + 1 ))) return -1;
+    ntdll_wcstoumbs( layout, len + 1, tmp, len * 3 + 1, FALSE );
+
+    for (i = 0; main_key_tab[i].comment; i++)
+    {
+        const char *name = main_key_tab[i].comment;
+        if (!strcmp( name, tmp )) break;
+    }
+    free( tmp );
+
+    if (!main_key_tab[i].comment) return -1;
+    return i;
+}
+
 WCHAR *x11drv_get_keyboard_layout_list( DWORD *length )
 {
     WCHAR *tmp, *layouts = calloc( 1, sizeof(WCHAR) );
@@ -1483,11 +1502,11 @@ static char keysym_to_char( KeySym keysym )
  *  whichever matches most closely.
  * kbd_section must be held.
  */
-static void
+static int
 X11DRV_KEYBOARD_DetectLayout( Display *display )
 {
   unsigned current, match, mismatch, seq, i, syms;
-  int score, keyc, key, pkey, ok;
+  int score, keyc, key, pkey, ok, kbd_layout = 0;
   KeySym keysym = 0;
   const char (*lkey)[MAIN_LEN][4];
   unsigned max_seq = 0;
@@ -1582,6 +1601,7 @@ X11DRV_KEYBOARD_DetectLayout( Display *display )
         main_key_tab[kbd_layout].comment);
 
   TRACE("detected layout is \"%s\"\n", main_key_tab[kbd_layout].comment);
+  return kbd_layout;
 }
 
 
@@ -1617,7 +1637,7 @@ void X11DRV_InitKeyboard( Display *display )
         { 0x41, 0x5a }, /* VK_A - VK_Z */
         { 0, 0 }
     };
-    int vkey_range;
+    int vkey_range, kbd_layout;
 
     pthread_mutex_lock( &kbd_mutex );
     XDisplayKeycodes(display, &min_keycode, &max_keycode);
@@ -1649,8 +1669,9 @@ void X11DRV_InitKeyboard( Display *display )
     }
     XFreeModifiermap(mmp);
 
-    /* Detect the keyboard layout */
-    X11DRV_KEYBOARD_DetectLayout( display );
+    /* use the configured layout from registry or auto detect it */
+    kbd_layout = keyboard_layout;
+    if (kbd_layout == -1) kbd_layout = X11DRV_KEYBOARD_DetectLayout( display );
     lkey = main_key_tab[kbd_layout].key;
     syms = (keysyms_per_keycode > 4) ? 4 : keysyms_per_keycode;
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 428f5dda1ec..82fea0a4135 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -459,6 +459,7 @@ extern BOOL use_take_focus;
 extern BOOL use_primary_selection;
 extern BOOL use_system_cursors;
 extern BOOL grab_fullscreen;
+extern int keyboard_layout;
 extern BOOL usexcomposite;
 extern BOOL use_xfixes;
 extern BOOL managed_mode;
@@ -766,6 +767,7 @@ extern void init_recursive_mutex( pthread_mutex_t *mutex );
 
 /* keyboard.c */
 
+extern int x11drv_find_keyboard_layout( const WCHAR *layout );
 extern WCHAR *x11drv_get_keyboard_layout_list( DWORD *size );
 
 #define DEPTH_COUNT 3
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 3c96cd449d4..c3a5f9a396c 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -74,6 +74,7 @@ BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
 BOOL grab_fullscreen = FALSE;
+int keyboard_layout = -1;
 BOOL managed_mode = TRUE;
 BOOL private_color_map = FALSE;
 int primary_monitor = 0;
@@ -556,6 +557,9 @@ static void setup_options(void)
     if (!get_config_key( hkey, appkey, "GrabFullscreen", buffer, sizeof(buffer) ))
         grab_fullscreen = IS_OPTION_TRUE( buffer[0] );
 
+    if (!get_config_key( hkey, appkey, "KeyboardLayout", buffer, sizeof(buffer) ))
+        keyboard_layout = x11drv_find_keyboard_layout( buffer );
+
     p = x11drv_get_keyboard_layout_list( &len );
     if (p) set_reg_string_value( hkey, "KeyboardLayoutList", p, len * sizeof(WCHAR) );
     free( p );

From d7c758545f188b9582f9b946fc7abef364df0f69 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Jan 2023 09:27:18 +0100
Subject: [PATCH 181/244] winecfg: Add a keyboard scancode detection toggle
 option.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 programs/winecfg/input.c    | 13 +++++++++++++
 programs/winecfg/resource.h |  1 +
 programs/winecfg/winecfg.rc |  1 +
 3 files changed, 15 insertions(+)

diff --git a/programs/winecfg/input.c b/programs/winecfg/input.c
index f2f035df80f..a9d83b45f00 100644
--- a/programs/winecfg/input.c
+++ b/programs/winecfg/input.c
@@ -65,6 +65,11 @@ static void init_dialog( HWND dialog )
     else SendMessageW( layouts, CB_SELECTSTRING, -1, (LPARAM)buffer );
     free( buffer );
 
+    buffer = get_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardScancodeDetect", L"Y" );
+    if (IS_OPTION_TRUE( *buffer )) CheckDlgButton( dialog, IDC_KEYBOARD_SCANCODE_DETECT, BST_CHECKED );
+    else CheckDlgButton( dialog, IDC_KEYBOARD_SCANCODE_DETECT, BST_UNCHECKED );
+    free( buffer );
+
     updating_ui = FALSE;
 }
 
@@ -93,6 +98,13 @@ static void on_keyboard_layout_changed( HWND dialog )
     }
 }
 
+static void on_keyboard_scancode_detect_clicked( HWND dialog )
+{
+    BOOL checked = IsDlgButtonChecked( dialog, IDC_KEYBOARD_SCANCODE_DETECT ) == BST_CHECKED;
+    if (checked) set_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardScancodeDetect", L"Y" );
+    else set_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardScancodeDetect", L"N" );
+}
+
 INT_PTR CALLBACK InputDlgProc( HWND dialog, UINT message, WPARAM wparam, LPARAM lparam )
 {
     TRACE( "dialog %p, message %#x, wparam %#Ix, lparam %#Ix\n", dialog, message, wparam, lparam );
@@ -112,6 +124,7 @@ INT_PTR CALLBACK InputDlgProc( HWND dialog, UINT message, WPARAM wparam, LPARAM
             switch (LOWORD(wparam))
             {
             case IDC_FULLSCREEN_GRAB: on_fullscreen_grab_clicked( dialog ); break;
+            case IDC_KEYBOARD_SCANCODE_DETECT: on_keyboard_scancode_detect_clicked( dialog ); break;
             }
             break;
 
diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index 2013d913e72..803a0fc150e 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -235,5 +235,6 @@
 /* input tab */
 #define IDC_FULLSCREEN_GRAB             1501
 #define IDC_KEYBOARD_LAYOUT             1502
+#define IDC_KEYBOARD_SCANCODE_DETECT    1503
 
 #define IDS_INPUT_AUTO_DETECT_LAYOUT    8501
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 8ad03b7967b..4370d9b360c 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -347,6 +347,7 @@ BEGIN
     GROUPBOX    "Keyboard settings",IDC_STATIC,8,70,244,64
     LTEXT       "&Layout:",IDC_STATIC,15,82,230,8
     COMBOBOX    IDC_KEYBOARD_LAYOUT,110,80,135,60,CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_SORT | WS_VSCROLL | WS_TABSTOP
+    CONTROL     "Enable keyboard scancode auto-detection",IDC_KEYBOARD_SCANCODE_DETECT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,96,230,10
 END
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

From 32d7da39dfb5674504792f8459a0dcca72b8b8de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 30 Nov 2022 18:46:00 +0100
Subject: [PATCH 182/244] winex11: Use scancode high bit to set
 KEYEVENTF_EXTENDEDKEY flag.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 dlls/winex11.drv/keyboard.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 44dc168490e..9ca00fa40f3 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1370,7 +1370,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     char buf[24];
     char *Str = buf;
     KeySym keysym = 0;
-    WORD vkey = 0, bScan;
+    WORD vkey = 0, scan;
     DWORD dwFlags;
     int ascii_chars;
     XIC xic = X11DRV_get_ic( hwnd );
@@ -1446,10 +1446,10 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     vkey = EVENT_event_to_vkey(xic,event);
     /* X returns keycode 0 for composed characters */
     if (!vkey && ascii_chars) vkey = VK_NONAME;
-    bScan = keyc2scan[event->keycode] & 0xFF;
+    scan = keyc2scan[event->keycode];
 
-    TRACE_(key)("keycode %u converted to vkey 0x%X scan %02x\n",
-                event->keycode, vkey, bScan);
+    TRACE_(key)("keycode %u converted to vkey 0x%X scan %04x\n",
+                event->keycode, vkey, scan);
 
     pthread_mutex_unlock( &kbd_mutex );
 
@@ -1457,11 +1457,11 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
 
     dwFlags = 0;
     if ( event->type == KeyRelease ) dwFlags |= KEYEVENTF_KEYUP;
-    if ( vkey & 0x100 )              dwFlags |= KEYEVENTF_EXTENDEDKEY;
+    if ( scan & 0x100 )             dwFlags |= KEYEVENTF_EXTENDEDKEY;
 
     update_lock_state( hwnd, vkey, event->state, event_time );
 
-    X11DRV_send_keyboard_input( hwnd, vkey & 0xff, bScan, dwFlags, event_time );
+    X11DRV_send_keyboard_input( hwnd, vkey & 0xff, scan & 0xff, dwFlags, event_time );
     return TRUE;
 }
 

From 01a938eefb9ce5bd5a8700d3936812afbf27c2d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 30 Nov 2022 18:46:00 +0100
Subject: [PATCH 183/244] winex11: Support fixed X11 keycode to scancode
 conversion.

X11 keycodes are just Linux keycodes + 8 nowadays according to evdev or
libinput drivers, and we can avoid innacurate reconstruction in the most
common case.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 dlls/winex11.drv/keyboard.c    | 44 ++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/x11drv.h      |  1 +
 dlls/winex11.drv/x11drv_main.c |  4 ++++
 3 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 9ca00fa40f3..ad903234fe3 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -64,6 +64,46 @@ static const unsigned int ControlMask = 1 << 2;
 static int min_keycode, max_keycode, keysyms_per_keycode;
 static WORD keyc2vkey[256], keyc2scan[256];
 
+/* default scancode mapping if keyboard_scancode_detect is FALSE,
+ * as most common X11 implementation use hardware scancode + 8.
+ */
+static WORD keyc2scan[256] =
+{
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
+    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
+    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
+    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
+    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0136, 0x0037,
+    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
+    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0145, 0x0046, 0x0047,
+    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
+    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
+    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
+    0x011c, 0x011d, 0x0135, 0x0063, 0x0138, 0x0065, 0x0147, 0x0148,
+    0x0149, 0x014b, 0x014d, 0x014f, 0x0150, 0x0151, 0x0152, 0x0153,
+    0x0070, 0x0000, 0x0000, 0x0000, 0x0074, 0x0075, 0x0076, 0x0045,
+    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x015b, 0x015c, 0x015d,
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x0000, 0x00a5, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x00aa, 0x0000, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+};
+
+
 static int NumLockMask, ScrollLockMask, AltGrMask; /* mask in the XKeyEvent state */
 
 static pthread_mutex_t kbd_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -1737,7 +1777,7 @@ void X11DRV_InitKeyboard( Display *display )
         }
         TRACE("keycode %u => vkey %04X\n", e2.keycode, vkey);
         keyc2vkey[e2.keycode] = vkey;
-        keyc2scan[e2.keycode] = scan;
+        if (keyboard_scancode_detect) keyc2scan[e2.keycode] = scan;
         if ((vkey & 0xff) && vkey_used[(vkey & 0xff)])
             WARN("vkey %04X is being used by more than one keycode\n", vkey);
         vkey_used[(vkey & 0xff)] = 1;
@@ -1848,7 +1888,7 @@ void X11DRV_InitKeyboard( Display *display )
 #undef VKEY_IF_NOT_USED
 
     /* If some keys still lack scancodes, assign some arbitrary ones to them now */
-    for (scan = 0x60, keyc = min_keycode; keyc <= max_keycode; keyc++)
+    for (scan = 0x60, keyc = min_keycode; keyboard_scancode_detect && keyc <= max_keycode; keyc++)
       if (keyc2vkey[keyc]&&!keyc2scan[keyc]) {
 	const char *ksname;
 	keysym = XkbKeycodeToKeysym( display, keyc, 0, 0 );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 82fea0a4135..db3f00d69d0 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -460,6 +460,7 @@ extern BOOL use_primary_selection;
 extern BOOL use_system_cursors;
 extern BOOL grab_fullscreen;
 extern int keyboard_layout;
+extern BOOL keyboard_scancode_detect;
 extern BOOL usexcomposite;
 extern BOOL use_xfixes;
 extern BOOL managed_mode;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index c3a5f9a396c..595ae92fdb6 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -75,6 +75,7 @@ BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
 BOOL grab_fullscreen = FALSE;
 int keyboard_layout = -1;
+BOOL keyboard_scancode_detect = TRUE;
 BOOL managed_mode = TRUE;
 BOOL private_color_map = FALSE;
 int primary_monitor = 0;
@@ -564,6 +565,9 @@ static void setup_options(void)
     if (p) set_reg_string_value( hkey, "KeyboardLayoutList", p, len * sizeof(WCHAR) );
     free( p );
 
+    if (!get_config_key( hkey, appkey, "KeyboardScancodeDetect", buffer, sizeof(buffer) ))
+        keyboard_scancode_detect = IS_OPTION_TRUE( buffer[0] );
+
     if (!get_config_key( hkey, appkey, "ScreenDepth", buffer, sizeof(buffer) ))
         default_visual.depth = wcstol( buffer, NULL, 0 );
 

From b98d78ad3e48bff49b4248f90e69bae9bc6a60c6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Jan 2023 11:31:36 +0100
Subject: [PATCH 184/244] winex11: Disable keyboard scancode auto-detection by
 default.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 programs/winecfg/input.c       | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 595ae92fdb6..a895dc4aed4 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -75,7 +75,7 @@ BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
 BOOL grab_fullscreen = FALSE;
 int keyboard_layout = -1;
-BOOL keyboard_scancode_detect = TRUE;
+BOOL keyboard_scancode_detect = FALSE;
 BOOL managed_mode = TRUE;
 BOOL private_color_map = FALSE;
 int primary_monitor = 0;
diff --git a/programs/winecfg/input.c b/programs/winecfg/input.c
index a9d83b45f00..3ee20d49874 100644
--- a/programs/winecfg/input.c
+++ b/programs/winecfg/input.c
@@ -65,7 +65,7 @@ static void init_dialog( HWND dialog )
     else SendMessageW( layouts, CB_SELECTSTRING, -1, (LPARAM)buffer );
     free( buffer );
 
-    buffer = get_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardScancodeDetect", L"Y" );
+    buffer = get_reg_key( config_key, keypath( L"X11 Driver" ), L"KeyboardScancodeDetect", L"N" );
     if (IS_OPTION_TRUE( *buffer )) CheckDlgButton( dialog, IDC_KEYBOARD_SCANCODE_DETECT, BST_CHECKED );
     else CheckDlgButton( dialog, IDC_KEYBOARD_SCANCODE_DETECT, BST_UNCHECKED );
     free( buffer );

From 888a94d7ea49b64c81e7257317a10e9d145d11ea Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Sat, 24 Jan 2015 05:12:49 +0100
Subject: [PATCH 185/244] winex11: Fix handling of window attributes for
 WS_EX_LAYERED | WS_EX_COMPOSITED.

---
 dlls/winex11.drv/window.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 56c2dab6620..c34adb0363a 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -480,7 +480,7 @@ static unsigned long get_mwm_decorations_for_style( DWORD style, DWORD ex_style
     if (X11DRV_HasWindowManager( "Mutter" )) return 0;
 
     if (ex_style & WS_EX_TOOLWINDOW) return 0;
-    if (ex_style & WS_EX_LAYERED) return 0;
+    if ((ex_style & (WS_EX_LAYERED | WS_EX_COMPOSITED)) == WS_EX_LAYERED) return 0;
 
     if ((style & WS_CAPTION) == WS_CAPTION)
     {
@@ -3377,8 +3377,9 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, HWND owner_hint, UIN
             BOOL needs_map = TRUE;
 
             /* layered windows are mapped only once their attributes are set */
-            if (NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED)
+            if ((NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & (WS_EX_LAYERED | WS_EX_COMPOSITED)) == WS_EX_LAYERED)
                 needs_map = data->layered || IsRectEmpty( &new_rects->window );
+
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
             if (needs_map) map_window( hwnd, new_style, swp_flags );

From 41ca4751e3b65ebeb1e6be41f78613f344fa9462 Mon Sep 17 00:00:00 2001
From: Enrico Horn <farmboy0+winehq@googlemail.com>
Date: Sat, 21 Apr 2018 02:40:37 +0200
Subject: [PATCH 186/244] winex11.drv: handle missing thread data in
 X11DRV_get_ic

Hi,
This patch fixes a crash in winex11.drv when loading IME.

This happens in Final Fantasy XI when using Ashita or Windower
3rd party applications.

There has been no bug reported I just fixed the bug for myself.

Here is the crash record:

Unhandled exception: page fault on write access to 0x00000014 in 32-bit code (0x7d85a94b).
Register dump:
 CS:0023 SS:002b DS:002b ES:002b FS:0063 GS:006b
 EIP:7d85a94b ESP:0836fd10 EBP:0836fd38 EFLAGS:00010212(  R- --  I   -A- - )
 EAX:00000000 EBX:0015abe8 ECX:00010050 EDX:00000000
 ESI:00000000 EDI:7d894000
Stack dump:
0x0836fd10:  001e60c8 00000158 0836fdb8 00010050
0x0836fd20:  00000000 7d894000 7d85a90b 7d894000
0x0836fd30:  001e60cc 001e60c8 0836fd58 7d86560b
0x0836fd40:  00010050 00000035 7d827a09 7d8655fa
0x0836fd50:  7d894000 001e60cc 0836fd98 7d83c0ef
0x0836fd60:  00010050 7d894000 0836fd98 7d83bfb0
Backtrace:
=>0 0x7d85a94b X11DRV_get_ic+0x4b(hwnd=0x10050) [/mnt/work/Repositories/wine/dlls/winex11.drv/window.c:2040] in winex11 (0x0836fd38)
  1 0x7d86560b X11DRV_ForceXIMReset+0x1a(hwnd=0x10050) [/mnt/work/Repositories/wine/dlls/winex11.drv/xim.c:255] in winex11 (0x0836fd58)
  2 0x7d83c0ef NotifyIME+0x17e(hIMC=<couldn't compute location>, dwAction=<couldn't compute location>, dwIndex=<couldn't compute location>, dwValue=<couldn't compute location>) [/mnt/work/Repositories/wine/dlls/winex11.drv/ime.c:764] in winex11 (0x0836fd98)
  3 0x7dc80793 ImmNotifyIME+0x62(hIMC=<couldn't compute location>, dwAction=<couldn't compute location>, dwIndex=<couldn't compute location>, dwValue=<couldn't compute location>) [/mnt/work/Repositories/wine/dlls/imm32/imm.c:2189] in imm32 (0x0836fde8)
0x7d85a94b X11DRV_get_ic+0x4b [/mnt/work/Repositories/wine/dlls/winex11.drv/window.c:2040] in winex11: movl     %ecx,0x14(%eax)
2040            x11drv_thread_data()->last_xic_hwnd = hwnd;

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46263
Signed-off-by: Enrico Horn <farmboy0+winehq@googlemail.com>
---
 dlls/winex11.drv/xim.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index f09067f232e..ca67fc3bca9 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -472,6 +472,11 @@ XIC X11DRV_get_ic( HWND hwnd )
     XIM xim;
     XIC ret;
 
+    if (!x11drv_thread_data())
+    {
+        release_win_data( data );
+        return NULL;
+    }
     if (!(data = get_win_data( hwnd ))) return 0;
     x11drv_init_thread_data()->last_xic_hwnd = hwnd;
     if (!(ret = data->xic) && (xim = x11drv_thread_data()->xim))

From 6470596177c4d3e3d9e830647084c00f054a6da9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Mon, 24 Dec 2018 14:26:57 +0200
Subject: [PATCH 187/244] winex11.drv/window: Query the X server for the actual
 rect of the window before unmapping it
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Some applications control their own position when they are being moved. This
can become out of sync with the X server because certain WMs interfere with
this on purpose.

Thus we shouldn't just rely on our window rect when deciding whether to unmap
a window (if it's out of the screen), but query the X server in this case
as the last resort to make sure it really is outside and should be unmapped.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=15346
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/winex11.drv/window.c | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index c34adb0363a..022ce36aa67 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -377,6 +377,25 @@ static BOOL has_owned_popups( HWND hwnd )
     return ret;
 }
 
+static BOOL is_actual_window_rect_mapped(const struct x11drv_win_data *data)
+{
+    XWindowAttributes attr;
+    Window child;
+    RECT rect;
+    POINT pt;
+    int x, y;
+
+    /* Query the X server for the actual position of the window,
+       as some WMs tend to mess with it, so we need to make sure
+       we aren't unmapping the window wrongly with a bogus rect */
+    XTranslateCoordinates(data->display, data->whole_window, root_window, 0, 0, &x, &y, &child);
+    XGetWindowAttributes(data->display, data->whole_window, &attr);
+
+    pt = root_to_virtual_screen(x - attr.x, y - attr.y);
+    SetRect(&rect, pt.x, pt.y, pt.x + attr.width, pt.y + attr.height);
+    return is_window_rect_mapped(&rect);
+}
+
 
 /***********************************************************************
  *              alloc_win_data
@@ -3338,7 +3357,8 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     if (old_style & WS_VISIBLE)
     {
         if (((swp_flags & SWP_HIDEWINDOW) && !(new_style & WS_VISIBLE)) ||
-            (!(new_style & WS_MINIMIZE) && !is_window_rect_mapped( &new_rects->window ) && is_window_rect_mapped( &old_rects.window )))
+            (!(new_style & WS_MINIMIZE) && !is_window_rect_mapped( &new_rects->window ) && is_window_rect_mapped( &old_rects.window ) &
+            !is_actual_window_rect_mapped( data )))
         {
             unmap_window( hwnd );
             if (was_fullscreen) NtUserClipCursor( NULL );

From 6808e27a6dc6bf4414560476163144a9e5a6d38c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 15 May 2015 20:37:19 +0200
Subject: [PATCH 188/244] wininet/tests: Add more tests for cookies.

---
 dlls/wininet/tests/http.c | 92 +++++++++++++++++++++++++++++++++++++--
 1 file changed, 89 insertions(+), 3 deletions(-)

diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index d63f42e27d7..a7f471693c7 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -2421,6 +2421,14 @@ static const char largemsg[] =
 "Content-Length: %I64u\r\n"
 "\r\n";
 
+static const char okmsg_cookie_path[] =
+"HTTP/1.1 200 OK\r\n"
+"Date: Mon, 01 Dec 2008 13:44:34 GMT\r\n"
+"Server: winetest\r\n"
+"Content-Length: 0\r\n"
+"Set-Cookie: subcookie2=data; path=/test_cookie_set_path\r\n"
+"\r\n";
+
 static const char notokmsg[] =
 "HTTP/1.1 400 Bad Request\r\n"
 "Server: winetest\r\n"
@@ -2845,6 +2853,32 @@ static DWORD CALLBACK server_thread(LPVOID param)
             else
                 send(c, noauthmsg, sizeof noauthmsg-1, 0);
         }
+        if (strstr(buffer, "/test_cookie_path1"))
+        {
+            if (strstr(buffer, "subcookie=data"))
+                 send(c, okmsg, sizeof okmsg-1, 0);
+             else
+                 send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_path2"))
+        {
+            if (strstr(buffer, "subcookie2=data"))
+                 send(c, okmsg, sizeof okmsg-1, 0);
+             else
+                 send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_set_path"))
+        {
+            send(c, okmsg_cookie_path, sizeof okmsg_cookie_path-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_merge"))
+        {
+            if (strstr(buffer, "subcookie=data") &&
+                !strstr(buffer, "manual_cookie=test"))
+                 send(c, okmsg, sizeof okmsg-1, 0);
+             else
+                 send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
         if (strstr(buffer, "/test_host_override"))
         {
             if (strstr(buffer, host_header_override))
@@ -4370,7 +4404,7 @@ static void test_cookie_header(int port)
     HINTERNET ses, con, req;
     DWORD size, error;
     BOOL ret;
-    char buffer[64];
+    char buffer[256];
 
     ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
     ok(ses != NULL, "InternetOpen failed\n");
@@ -4398,7 +4432,7 @@ static void test_cookie_header(int port)
     size = sizeof(buffer);
     ret = HttpQueryInfoA(req, HTTP_QUERY_COOKIE | HTTP_QUERY_FLAG_REQUEST_HEADERS, buffer, &size, NULL);
     ok(ret, "HttpQueryInfo failed: %lu\n", GetLastError());
-    ok(!strcmp(buffer, "cookie=not biscuit"), "got '%s' expected \'cookie=not biscuit\'\n", buffer);
+    ok(!!strstr(buffer, "cookie=not biscuit"), "got '%s' expected \'cookie=not biscuit\'\n", buffer);
 
     ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed: %lu\n", GetLastError());
@@ -4409,9 +4443,61 @@ static void test_cookie_header(int port)
     size = sizeof(buffer);
     ret = HttpQueryInfoA(req, HTTP_QUERY_COOKIE | HTTP_QUERY_FLAG_REQUEST_HEADERS, buffer, &size, NULL);
     ok(ret, "HttpQueryInfo failed: %lu\n", GetLastError());
-    ok(!strcmp(buffer, "cookie=biscuit"), "got '%s' expected \'cookie=biscuit\'\n", buffer);
+    ok(!strstr(buffer, "cookie=not biscuit"), "'%s' should not contain \'cookie=not biscuit\'\n", buffer);
+    ok(!!strstr(buffer, "cookie=biscuit"), "'%s' should contain \'cookie=biscuit\'\n", buffer);
+
+    InternetCloseHandle(req);
+
+    InternetSetCookieA("http://localhost/testCCCC", "subcookie", "data");
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_path1", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_path1/abc", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_set_path", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_path2", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
 
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 400);
     InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_merge", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, "Cookie: manual_cookie=test\r\n", ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed: %lu\n", GetLastError());
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
     InternetCloseHandle(con);
     InternetCloseHandle(ses);
 }

From 8dd7e3bd47746fc6440f837297a86caecf7c3dac Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 15 May 2015 21:18:37 +0200
Subject: [PATCH 189/244] wininet/tests: Test auth credential reusage with host
 override.

---
 dlls/wininet/tests/http.c | 92 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index a7f471693c7..62e13069622 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -2916,6 +2916,20 @@ static DWORD CALLBACK server_thread(LPVOID param)
             sprintf(msg, largemsg, content_length);
             send(c, msg, strlen(msg), 0);
         }
+        if (strstr(buffer, "HEAD /test_auth_host1"))
+        {
+            if (strstr(buffer, "Authorization: Basic dGVzdDE6cGFzcw=="))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, noauthmsg, sizeof noauthmsg-1, 0);
+        }
+        if (strstr(buffer, "HEAD /test_auth_host2"))
+        {
+            if (strstr(buffer, "Authorization: Basic dGVzdDE6cGFzczI="))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, noauthmsg, sizeof noauthmsg-1, 0);
+        }
         if (strstr(buffer, "GET /proxy.pac"))
         {
             char script[sizeof(proxy_pac) + 16];
@@ -3626,6 +3640,84 @@ static void test_header_override(int port)
     InternetCloseHandle(req);
     InternetCloseHandle(con);
     InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA(ses, "localhost", port, "test1", "pass", INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA( con, "HEAD", "/test_auth_host1", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequestA failed %lu\n", GetLastError());
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA( ses, "localhost", port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA(con, "HEAD", "/test_auth_host1", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA( req, NULL, 0, NULL, 0 );
+    ok( ret, "HttpSendRequestA failed %lu\n", GetLastError() );
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA(ses, "localhost", port, "test1", "pass2", INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA(con, "HEAD", "/test_auth_host2", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequestA failed %lu\n", GetLastError());
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA(ses, "localhost", port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA(con, "HEAD", "/test_auth_host2", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequestA failed %lu\n", GetLastError());
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
 }
 
 static void test_connection_closing(int port)

From 888fa89fcc752cf7e9eb51c23f48b74f4a794287 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 15 May 2015 23:09:20 +0200
Subject: [PATCH 190/244] wininet/tests: Check cookie behaviour when overriding
 host.

---
 dlls/wininet/tests/http.c | 95 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index 62e13069622..2c6b19c2f42 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -2429,6 +2429,14 @@ static const char okmsg_cookie_path[] =
 "Set-Cookie: subcookie2=data; path=/test_cookie_set_path\r\n"
 "\r\n";
 
+static const char okmsg_cookie[] =
+"HTTP/1.1 200 OK\r\n"
+"Date: Mon, 01 Dec 2008 13:44:34 GMT\r\n"
+"Server: winetest\r\n"
+"Content-Length: 0\r\n"
+"Set-Cookie: testcookie=testvalue\r\n"
+"\r\n";
+
 static const char notokmsg[] =
 "HTTP/1.1 400 Bad Request\r\n"
 "Server: winetest\r\n"
@@ -2879,6 +2887,25 @@ static DWORD CALLBACK server_thread(LPVOID param)
              else
                  send(c, notokmsg, sizeof notokmsg-1, 0);
         }
+        if (strstr(buffer, "/test_cookie_set_host_override"))
+        {
+            send(c, okmsg_cookie, sizeof okmsg_cookie-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_check_host_override"))
+        {
+            if (strstr(buffer, "Cookie:") && strstr(buffer, "testcookie=testvalue"))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_check_different_host"))
+        {
+            if (!strstr(buffer, "foo") &&
+                strstr(buffer, "cookie=biscuit"))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
         if (strstr(buffer, "/test_host_override"))
         {
             if (strstr(buffer, host_header_override))
@@ -3637,6 +3664,74 @@ static void test_header_override(int port)
         test_status_code(req, 400);
     }
 
+    InternetCloseHandle(req);
+    InternetSetCookieA("http://localhost", "cookie", "biscuit");
+    req = HttpOpenRequestA(con, NULL, "/testC", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_set_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code_todo(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code_todo(req, 200);
+
+    InternetCloseHandle(req);
+    InternetSetCookieA("http://test.local", "foo", "bar");
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_different_host", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_different_host", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
     InternetCloseHandle(req);
     InternetCloseHandle(con);
     InternetCloseHandle(ses);

From 15ebe1a6397a1e87c50c082d89c7c7d2f4177ab2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 16 May 2015 00:24:35 +0200
Subject: [PATCH 191/244] wininet: Strip filename if no path is set in cookie.

The order of the stored cookies doesn't match in /testC, so
be a bit less strict in the test.
---
 dlls/wininet/http.c       | 11 ++++++++++-
 dlls/wininet/tests/http.c |  6 +++---
 2 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/dlls/wininet/http.c b/dlls/wininet/http.c
index 48bfe35866a..a3266007136 100644
--- a/dlls/wininet/http.c
+++ b/dlls/wininet/http.c
@@ -649,10 +649,18 @@ static void HTTP_ProcessCookies( http_request_t *request )
     int HeaderIndex;
     int numCookies = 0;
     LPHTTPHEADERW setCookieHeader;
+    WCHAR *path, *tmp;
 
     if(request->hdr.dwFlags & INTERNET_FLAG_NO_COOKIES)
         return;
 
+    path = wcsdup(request->path);
+    if (!path)
+        return;
+
+    tmp = wcsrchr(path, '/');
+    if (tmp && tmp[1]) tmp[1] = 0;
+
     EnterCriticalSection( &request->headers_section );
 
     while((HeaderIndex = HTTP_GetCustomHeaderIndex(request, L"Set-Cookie", numCookies++, FALSE)) != -1)
@@ -671,10 +679,11 @@ static void HTTP_ProcessCookies( http_request_t *request )
 
         name = substr(setCookieHeader->lpszValue, data - setCookieHeader->lpszValue);
         data++;
-        set_cookie(substrz(request->server->name), substrz(request->path), name, substrz(data), INTERNET_COOKIE_HTTPONLY);
+        set_cookie(substrz(request->server->name), substrz(path), name, substrz(data), INTERNET_COOKIE_HTTPONLY);
     }
 
     LeaveCriticalSection( &request->headers_section );
+    free(path);
 }
 
 static void strip_spaces(LPWSTR start)
diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index 2c6b19c2f42..fda29394be2 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -2660,7 +2660,7 @@ static DWORD CALLBACK server_thread(LPVOID param)
         }
         if (strstr(buffer, "/testC"))
         {
-            if (strstr(buffer, "Cookie: cookie=biscuit"))
+            if (strstr(buffer, "cookie=biscuit"))
                 send(c, okmsg, sizeof okmsg-1, 0);
             else
                 send(c, notokmsg, sizeof notokmsg-1, 0);
@@ -3699,7 +3699,7 @@ static void test_header_override(int port)
     ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed\n");
 
-    test_status_code_todo(req, 200);
+    test_status_code(req, 200);
 
     InternetCloseHandle(req);
     req = HttpOpenRequestA(con, NULL, "/test_cookie_check_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
@@ -3708,7 +3708,7 @@ static void test_header_override(int port)
     ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed\n");
 
-    test_status_code_todo(req, 200);
+    test_status_code(req, 200);
 
     InternetCloseHandle(req);
     InternetSetCookieA("http://test.local", "foo", "bar");

From fc396fa9a2025c56dcbebae9acf044e0e76462ee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Sat, 16 May 2015 03:16:15 +0200
Subject: [PATCH 192/244] wininet: Replacing header fields should fail if they
 do not exist yet.

A lot of details are not properly covered by tests yet and were
marked with FIXME comments. The implementation was written in such
a way that it behaves identical to the old code in such situations.
---
 dlls/wininet/http.c | 197 ++++++++++++++++++++++----------------------
 1 file changed, 99 insertions(+), 98 deletions(-)

diff --git a/dlls/wininet/http.c b/dlls/wininet/http.c
index a3266007136..debfbe049b5 100644
--- a/dlls/wininet/http.c
+++ b/dlls/wininet/http.c
@@ -6188,130 +6188,131 @@ static LPWSTR * HTTP_InterpretHttpHeader(LPCWSTR buffer)
 
 static DWORD HTTP_ProcessHeader(http_request_t *request, LPCWSTR field, LPCWSTR value, DWORD dwModifier)
 {
-    LPHTTPHEADERW lphttpHdr = NULL;
+    LPHTTPHEADERW lphttpHdr;
     INT index;
     BOOL request_only = !!(dwModifier & HTTP_ADDHDR_FLAG_REQ);
-    DWORD res = ERROR_HTTP_INVALID_HEADER;
+    DWORD res = ERROR_SUCCESS;
 
     TRACE("--> %s: %s - 0x%08lx\n", debugstr_w(field), debugstr_w(value), dwModifier);
 
     EnterCriticalSection( &request->headers_section );
 
-    /* REPLACE wins out over ADD */
-    if (dwModifier & HTTP_ADDREQ_FLAG_REPLACE)
-        dwModifier &= ~HTTP_ADDREQ_FLAG_ADD;
+    index = HTTP_GetCustomHeaderIndex(request, field, 0, request_only);
+     if (index >= 0)
+     {
+         lphttpHdr = &request->custHeaders[index];
 
-    if (dwModifier & HTTP_ADDREQ_FLAG_ADD)
-        index = -1;
-    else
-        index = HTTP_GetCustomHeaderIndex(request, field, 0, request_only);
-
-    if (index >= 0)
-    {
-        if (dwModifier & HTTP_ADDREQ_FLAG_ADD_IF_NEW)
+        /* replace existing header if FLAG_REPLACE is given */
+        if (dwModifier & HTTP_ADDREQ_FLAG_REPLACE)
         {
-            LeaveCriticalSection( &request->headers_section );
-            return ERROR_HTTP_INVALID_HEADER;
-        }
-        lphttpHdr = &request->custHeaders[index];
-    }
-    else if (value)
-    {
-        HTTPHEADERW hdr;
+            HTTP_DeleteCustomHeader( request, index );
 
-        hdr.lpszField = (LPWSTR)field;
-        hdr.lpszValue = (LPWSTR)value;
-        hdr.wFlags = hdr.wCount = 0;
+            if (value && value[0])
+            {
+                HTTPHEADERW hdr;
 
-        if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
-            hdr.wFlags |= HDR_ISREQUEST;
+                hdr.lpszField = (LPWSTR)field;
+                hdr.lpszValue = (LPWSTR)value;
+                hdr.wFlags = hdr.wCount = 0;
 
-        res = HTTP_InsertCustomHeader(request, &hdr);
-        LeaveCriticalSection( &request->headers_section );
-        return res;
-    }
-    /* no value to delete */
-    else
-    {
-        LeaveCriticalSection( &request->headers_section );
-        return ERROR_SUCCESS;
-    }
+                if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
+                    hdr.wFlags |= HDR_ISREQUEST;
 
-    if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
-	    lphttpHdr->wFlags |= HDR_ISREQUEST;
-    else
-        lphttpHdr->wFlags &= ~HDR_ISREQUEST;
+                res = HTTP_InsertCustomHeader( request, &hdr );
+            }
 
-    if (dwModifier & HTTP_ADDREQ_FLAG_REPLACE)
-    {
-        HTTP_DeleteCustomHeader( request, index );
+            goto out;
+        }
+
+        /* do not add new header if FLAG_ADD_IF_NEW is set */
+        if (dwModifier & HTTP_ADDREQ_FLAG_ADD_IF_NEW)
+         {
+            res = ERROR_HTTP_INVALID_HEADER; /* FIXME */
+            goto out;
+        }
 
-        if (value && value[0])
+        /* handle appending to existing header */
+        if (dwModifier & COALESCEFLAGS)
         {
-            HTTPHEADERW hdr;
+            LPWSTR lpsztmp;
+            WCHAR ch = 0;
+            INT len = 0;
+            INT origlen = lstrlenW(lphttpHdr->lpszValue);
+            INT valuelen = lstrlenW(value);
+
+            /* FIXME: Should it really clear HDR_ISREQUEST? */
+             if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
+                lphttpHdr->wFlags |= HDR_ISREQUEST;
+            else
+                lphttpHdr->wFlags &= ~HDR_ISREQUEST;
 
-            hdr.lpszField = (LPWSTR)field;
-            hdr.lpszValue = (LPWSTR)value;
-            hdr.wFlags = hdr.wCount = 0;
+            if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA)
+            {
+                ch = ',';
+                lphttpHdr->wFlags |= HDR_COMMADELIMITED;
+            }
+            else if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON)
+            {
+                ch = ';';
+                lphttpHdr->wFlags |= HDR_COMMADELIMITED;
+            }
 
-            if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
-                hdr.wFlags |= HDR_ISREQUEST;
+            len = origlen + valuelen + ((ch > 0) ? 2 : 0);
 
-            res = HTTP_InsertCustomHeader(request, &hdr);
-            LeaveCriticalSection( &request->headers_section );
-            return res;
-        }
+            lpsztmp = realloc(lphttpHdr->lpszValue, (len+1)*sizeof(WCHAR));
+            if (lpsztmp)
+            {
+                lphttpHdr->lpszValue = lpsztmp;
+                /* FIXME: Increment lphttpHdr->wCount. Perhaps lpszValue should be an array */
+                if (ch > 0)
+                {
+                    lphttpHdr->lpszValue[origlen] = ch;
+                    origlen++;
+                    lphttpHdr->lpszValue[origlen] = ' ';
+                    origlen++;
+                }
 
-        LeaveCriticalSection( &request->headers_section );
-        return ERROR_SUCCESS;
-    }
-    else if (dwModifier & COALESCEFLAGS)
+                memcpy(&lphttpHdr->lpszValue[origlen], value, valuelen*sizeof(WCHAR));
+                lphttpHdr->lpszValue[len] = '\0';
+            }
+            else
+             {
+                WARN("realloc (%d bytes) failed\n",len+1);
+                res = ERROR_OUTOFMEMORY;
+             }
+
+            goto out;
+         }
+     }
+
+    /* FIXME: What about other combinations? */
+    if ((dwModifier & ~HTTP_ADDHDR_FLAG_REQ) == HTTP_ADDREQ_FLAG_REPLACE)
     {
-        LPWSTR lpsztmp;
-        WCHAR ch = 0;
-        INT len = 0;
-        INT origlen = lstrlenW(lphttpHdr->lpszValue);
-        INT valuelen = lstrlenW(value);
+        res = ERROR_HTTP_HEADER_NOT_FOUND;
+        goto out;
+    }
 
-        if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA)
-        {
-            ch = ',';
-            lphttpHdr->wFlags |= HDR_COMMADELIMITED;
-        }
-        else if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON)
-        {
-            ch = ';';
-            lphttpHdr->wFlags |= HDR_COMMADELIMITED;
-        }
+    /* FIXME: What if value == ""? */
+    if (value)
+    {
+        HTTPHEADERW hdr;
 
-        len = origlen + valuelen + ((ch > 0) ? 2 : 0);
+        hdr.lpszField = (LPWSTR)field;
+        hdr.lpszValue = (LPWSTR)value;
+        hdr.wFlags = hdr.wCount = 0;
 
-        lpsztmp = realloc(lphttpHdr->lpszValue, (len + 1) * sizeof(WCHAR));
-        if (lpsztmp)
-        {
-            lphttpHdr->lpszValue = lpsztmp;
-    /* FIXME: Increment lphttpHdr->wCount. Perhaps lpszValue should be an array */
-            if (ch > 0)
-            {
-                lphttpHdr->lpszValue[origlen] = ch;
-                origlen++;
-                lphttpHdr->lpszValue[origlen] = ' ';
-                origlen++;
-            }
+        if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
+            hdr.wFlags |= HDR_ISREQUEST;
 
-            memcpy(&lphttpHdr->lpszValue[origlen], value, valuelen*sizeof(WCHAR));
-            lphttpHdr->lpszValue[len] = '\0';
-            res = ERROR_SUCCESS;
-        }
-        else
-        {
-            WARN("realloc (%d bytes) failed\n",len+1);
-            res = ERROR_OUTOFMEMORY;
-        }
+        res = HTTP_InsertCustomHeader( request, &hdr );
+        goto out;
     }
-    TRACE("<-- %ld\n", res);
-    LeaveCriticalSection( &request->headers_section );
-    return res;
+
+    /* FIXME: What if value == NULL? */
+out:
+     TRACE("<-- %ld\n", res);
+     LeaveCriticalSection( &request->headers_section );
+     return res;
 }
 
 /***********************************************************************

From 8ef60f6610418f764b2f43f3ae7ebb47b394b491 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 4 Mar 2016 16:15:50 +0100
Subject: [PATCH 193/244] winmm: Do not crash in Win 9X mode when an invalid
 device ptr is passed to MCI_OPEN.

---
 dlls/winmm/mci.c | 44 +++++++++++++++++++++-----------------------
 1 file changed, 21 insertions(+), 23 deletions(-)

diff --git a/dlls/winmm/mci.c b/dlls/winmm/mci.c
index 959801aa835..c56a69def11 100644
--- a/dlls/winmm/mci.c
+++ b/dlls/winmm/mci.c
@@ -204,7 +204,7 @@ static LPWSTR MCI_strdupAtoW( LPCSTR str )
     return ret;
 }
 
-static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
+static DWORD MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
 {
     if (msg < DRV_RESERVED) return 0;
 
@@ -247,8 +247,12 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_ANIM_OPEN_PARMSW *mci_openW;
             DWORD_PTR *ptr;
 
+            if ((dwParam1 & (MCI_OPEN_TYPE|MCI_OPEN_TYPE_ID)) == MCI_OPEN_TYPE &&
+                (GetVersion() & 0x80000000) && IsBadStringPtrA(mci_openA->lpstrDeviceType, -1))
+                return MCIERR_MISSING_COMMAND_STRING;
+
             ptr = malloc(sizeof(DWORD_PTR) + sizeof(*mci_openW));
-            if (!ptr) return -1;
+            if (!ptr) return MCIERR_OUT_OF_MEMORY;
 
             *ptr++ = *dwParam2; /* save the previous pointer */
             *dwParam2 = (DWORD_PTR)ptr;
@@ -278,7 +282,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             if (HIWORD(dwParam1))
                 memcpy(&mci_openW->dwStyle, &mci_openA->dwStyle, sizeof(MCI_ANIM_OPEN_PARMSW) - sizeof(MCI_OPEN_PARMSW));
         }
-        return 1;
+        return 0;
 
     case MCI_WINDOW:
         if (dwParam1 & MCI_ANIM_WINDOW_TEXT)
@@ -286,8 +290,8 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_ANIM_WINDOW_PARMSA *mci_windowA = (MCI_ANIM_WINDOW_PARMSA *)*dwParam2;
             MCI_ANIM_WINDOW_PARMSW *mci_windowW;
 
-            mci_windowW = malloc(sizeof(*mci_windowW));
-            if (!mci_windowW) return -1;
+            mci_windowW = malloc( sizeof(*mci_windowW));
+            if (!mci_windowW) return MCIERR_OUT_OF_MEMORY;
 
             *dwParam2 = (DWORD_PTR)mci_windowW;
 
@@ -299,8 +303,6 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
                 mci_windowW->hWnd = mci_windowA->hWnd;
             if (dwParam1 & MCI_ANIM_WINDOW_STATE)
                 mci_windowW->nCmdShow = mci_windowA->nCmdShow;
-
-            return 1;
         }
         return 0;
 
@@ -312,7 +314,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             DWORD_PTR *ptr;
 
             ptr = malloc(sizeof(*mci_sysinfoW) + sizeof(DWORD_PTR));
-            if (!ptr) return -1;
+            if (!ptr) return MCIERR_OUT_OF_MEMORY;
 
             *ptr++ = *dwParam2; /* save the previous pointer */
             *dwParam2 = (DWORD_PTR)ptr;
@@ -326,7 +328,6 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             mci_sysinfoW->lpstrReturn = malloc(mci_sysinfoW->dwRetSize * sizeof(WCHAR));
             mci_sysinfoW->dwNumber = mci_sysinfoA->dwNumber;
             mci_sysinfoW->wDeviceType = mci_sysinfoA->wDeviceType;
-            return 1;
         }
         return 0;
     case MCI_INFO:
@@ -336,7 +337,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             DWORD_PTR *ptr;
 
             ptr = malloc(sizeof(*mci_infoW) + sizeof(DWORD_PTR));
-            if (!ptr) return -1;
+            if (!ptr) return MCIERR_OUT_OF_MEMORY;
 
             *ptr++ = *dwParam2; /* save the previous pointer */
             *dwParam2 = (DWORD_PTR)ptr;
@@ -350,8 +351,8 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             mci_infoW->lpstrReturn = malloc(mci_infoW->dwRetSize * sizeof(WCHAR));
             if (dwParam1 & MCI_DGV_INFO_ITEM)
                 mci_infoW->dwItem = mci_infoA->dwItem;
-            return 1;
         }
+        return 0;
     case MCI_SAVE:
     case MCI_LOAD:
     case MCI_CAPTURE:
@@ -361,7 +362,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_OVLY_LOAD_PARMSW *mci_loadW;
 
             mci_loadW = malloc(sizeof(*mci_loadW));
-            if (!mci_loadW) return -1;
+            if (!mci_loadW) return MCIERR_OUT_OF_MEMORY;
 
             *dwParam2 = (DWORD_PTR)mci_loadW;
             if (dwParam1 & MCI_NOTIFY)
@@ -372,8 +373,8 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
                 (MCI_CAPTURE == msg && dwParam1 & MCI_DGV_CAPTURE_AT) ||
                 (MCI_RESTORE == msg && dwParam1 & MCI_DGV_RESTORE_AT))
                 mci_loadW->rc = mci_loadA->rc;
-            return 1;
         }
+        return 0;
     case MCI_SOUND:
     case MCI_ESCAPE:
         {   /* All these commands have the same layout: callback + string */
@@ -381,14 +382,14 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_VD_ESCAPE_PARMSW *mci_vd_escapeW;
 
             mci_vd_escapeW = malloc(sizeof(*mci_vd_escapeW));
-            if (!mci_vd_escapeW) return -1;
+            if (!mci_vd_escapeW) return MCIERR_OUT_OF_MEMORY;
 
             *dwParam2 = (DWORD_PTR)mci_vd_escapeW;
             if (dwParam1 & MCI_NOTIFY)
                 mci_vd_escapeW->dwCallback = mci_vd_escapeA->dwCallback;
             mci_vd_escapeW->lpstrCommand = MCI_strdupAtoW(mci_vd_escapeA->lpstrCommand);
-            return 1;
         }
+        return 0;
     case MCI_SETAUDIO:
     case MCI_SETVIDEO:
         if (!(dwParam1 & (MCI_DGV_SETVIDEO_QUALITY | MCI_DGV_SETVIDEO_ALG
@@ -501,7 +502,6 @@ static void MCI_UnmapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR dwParam2,
         break;
 
     default:
-        FIXME("Message %s needs unmapping\n", MCI_MessageToString(msg));
         break;
     }
 }
@@ -2282,20 +2282,18 @@ DWORD WINAPI mciSendCommandW(MCIDEVICEID wDevID, UINT wMsg, DWORD_PTR dwParam1,
 DWORD WINAPI mciSendCommandA(MCIDEVICEID wDevID, UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
 {
     DWORD ret;
-    int mapped;
 
     TRACE("(%08x, %s, %08Ix, %08Ix)\n",
 	  wDevID, MCI_MessageToString(wMsg), dwParam1, dwParam2);
 
-    mapped = MCI_MapMsgAtoW(wMsg, dwParam1, &dwParam2);
-    if (mapped == -1)
+    ret = MCI_MapMsgAtoW(wMsg, dwParam1, &dwParam2);
+    if (ret)
     {
         FIXME("message %04x mapping failed\n", wMsg);
-        return MCIERR_OUT_OF_MEMORY;
+        return ret;
     }
-    ret = mciSendCommandW(wDevID, wMsg, dwParam1, dwParam2);
-    if (mapped)
-        MCI_UnmapMsgAtoW(wMsg, dwParam1, dwParam2, ret);
+     ret = mciSendCommandW(wDevID, wMsg, dwParam1, dwParam2);
+    MCI_UnmapMsgAtoW(wMsg, dwParam1, dwParam2, ret);
     return ret;
 }
 

From 7fe58368dbf1c99eef57d4eafb7ff3fbb9fec35d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 31 May 2018 11:45:10 +1000
Subject: [PATCH 194/244] wintab32: Set lcSysExtX/Y for the first index of
 WTI_DDCTXS

---
 dlls/wintab32/context.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/wintab32/context.c b/dlls/wintab32/context.c
index bd0c982da2d..dd17c8a2585 100644
--- a/dlls/wintab32/context.c
+++ b/dlls/wintab32/context.c
@@ -409,7 +409,7 @@ static UINT WTInfoT(UINT wCategory, UINT nIndex, LPVOID lpOutput, BOOL bUnicode)
             pWTInfoW(wCategory, nIndex, &buf);
 
             /*  Handle system extents here, as we can use user32.dll code to set them */
-            if(wCategory == WTI_DEFSYSCTX)
+            if(wCategory == WTI_DEFSYSCTX || wCategory == WTI_DDCTXS)
             {
                 buf.lcSysExtX = GetSystemMetrics(SM_CXSCREEN);
                 buf.lcSysExtY = GetSystemMetrics(SM_CYSCREEN);

From 3632d1fb6f9fb800757ed5def1cf60d9ff0bca19 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 31 May 2018 11:52:09 +1000
Subject: [PATCH 195/244] winex11: Handle negative orAltitude values

---
 dlls/winex11.drv/wintab.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winex11.drv/wintab.c b/dlls/winex11.drv/wintab.c
index eff872fa873..df03995e94a 100644
--- a/dlls/winex11.drv/wintab.c
+++ b/dlls/winex11.drv/wintab.c
@@ -905,6 +905,11 @@ static BOOL motion_event( HWND hwnd, XEvent *event )
                                             (abs(motion->axis_data[3]),
                                              abs(motion->axis_data[4])))
                                            * (gMsgPacket.pkStatus & TPS_INVERT?-1:1));
+
+    if (gMsgPacket.pkOrientation.orAltitude < 0)
+    {
+        FIXME("Negative orAltitude detected\n");
+    }
     gMsgPacket.pkNormalPressure = motion->axis_data[2];
     gMsgPacket.pkButtons = get_button_state(curnum);
     gMsgPacket.pkChanged = get_changed_state(&gMsgPacket);
@@ -931,6 +936,7 @@ static BOOL button_event( HWND hwnd, XEvent *event )
     gMsgPacket.pkTime = EVENT_x11_time_to_win32_time(button->time);
     gMsgPacket.pkSerialNumber = gSerial++;
     gMsgPacket.pkCursor = curnum;
+
     if (button->axes_count > 0) {
         gMsgPacket.pkX = button->axis_data[0];
         gMsgPacket.pkY = button->axis_data[1];
@@ -945,6 +951,12 @@ static BOOL button_event( HWND hwnd, XEvent *event )
         gMsgPacket.pkOrientation = last_packet.pkOrientation;
         gMsgPacket.pkNormalPressure = last_packet.pkNormalPressure;
     }
+
+    if (gMsgPacket.pkOrientation.orAltitude < 0)
+    {
+        FIXME("Negative orAltitude detected\n");
+    }
+
     gMsgPacket.pkButtons = get_button_state(curnum);
     gMsgPacket.pkChanged = get_changed_state(&gMsgPacket);
     send_message( hwndTabletDefault, WT_PACKET, gMsgPacket.pkSerialNumber, (LPARAM)hwnd );
@@ -987,6 +999,10 @@ static BOOL proximity_event( HWND hwnd, XEvent *event )
     gMsgPacket.pkOrientation.orAltitude = ((1000 - 15 * max(abs(proximity->axis_data[3]),
                                                             abs(proximity->axis_data[4])))
                                            * (gMsgPacket.pkStatus & TPS_INVERT?-1:1));
+    if (gMsgPacket.pkOrientation.orAltitude < 0)
+    {
+        FIXME("Negative orAltitude detected\n");
+    }
     gMsgPacket.pkNormalPressure = proximity->axis_data[2];
     gMsgPacket.pkButtons = get_button_state(curnum);
 

From fc41e67a9967bacef07d617dcbe38c76942fe34a Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 25 Jun 2018 10:09:20 +1000
Subject: [PATCH 196/244] winex11.drv: Support multiplex categories WTI_DSCTXS
 and WTI_DDCTXS

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/winex11.drv/wintab.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winex11.drv/wintab.c b/dlls/winex11.drv/wintab.c
index df03995e94a..2331c920231 100644
--- a/dlls/winex11.drv/wintab.c
+++ b/dlls/winex11.drv/wintab.c
@@ -1156,6 +1156,17 @@ NTSTATUS x11drv_tablet_info( void *arg )
 
     if (!xinput_handle) return 0;
 
+    if(wCategory >= WTI_DSCTXS)
+    {
+        nIndex = wCategory - WTI_DSCTXS;
+        wCategory = WTI_DSCTXS;
+    }
+    else if(wCategory >= WTI_DDCTXS)
+    {
+        nIndex = wCategory - WTI_DDCTXS;
+        wCategory = WTI_DDCTXS;
+    }
+
     switch(wCategory)
     {
         case 0:

From 9d8a3d1044a3e1b4cce71ee44bc7a732b5c6d62e Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 25 Jun 2018 10:44:14 +1000
Subject: [PATCH 197/244] winex11: Support WTI_STATUS in WTInfo

WIP: Improve default values.
---
 dlls/winex11.drv/wintab.c | 56 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/dlls/winex11.drv/wintab.c b/dlls/winex11.drv/wintab.c
index 2331c920231..dc6a8f2da27 100644
--- a/dlls/winex11.drv/wintab.c
+++ b/dlls/winex11.drv/wintab.c
@@ -1210,6 +1210,62 @@ NTSTATUS x11drv_tablet_info( void *arg )
                     rc = 0;
             }
             break;
+        case WTI_STATUS:
+            switch (nIndex)
+            {
+                case STA_CONTEXTS:
+                {
+                    FIXME("STA_CONTEXTS unhandled\n");
+                    rc = 1;
+                    break;
+                }
+                case STA_SYSCTXS:
+                {
+                    FIXME("STA_SYSCTXS unhandled\n");
+                    rc = 1;
+                    break;
+                }
+                case STA_PKTRATE:
+                {
+                    FIXME("STA_PKTRATE unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                case STA_PKTDATA:
+                {
+                    FIXME("STA_PKTDATA unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                case STA_MANAGERS:
+                {
+                    FIXME("STA_MANAGERS unhandled\n");
+                    rc = 1;
+                    break;
+                }
+                case STA_SYSTEM:
+                {
+                    FIXME("STA_SYSTEM unhandled\n");
+                    rc = TRUE;
+                    break;
+                }
+                case STA_BUTTONUSE:
+                {
+                    FIXME("STA_BUTTONUSE unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                case STA_SYSBTNUSE:
+                {
+                    FIXME("STA_SYSBTNUSE unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                default:
+                    FIXME("WTI_STATUS unhandled index %i\n",nIndex);
+                    rc = 0;
+            }
+            break;
         case WTI_DEFSYSCTX:
         case WTI_DDCTXS:
         case WTI_DEFCONTEXT:

From 49670a56d34318200750f0756f5c42f622dc7000 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 18 Apr 2018 03:55:16 +0000
Subject: [PATCH 198/244] wintrust: Add parameter check in
 WTHelperGetProvCertFromChain

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/wintrust/tests/softpub.c | 9 +++++++++
 dlls/wintrust/wintrust_main.c | 2 +-
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/wintrust/tests/softpub.c b/dlls/wintrust/tests/softpub.c
index 7091f5a7553..250aea2566c 100644
--- a/dlls/wintrust/tests/softpub.c
+++ b/dlls/wintrust/tests/softpub.c
@@ -1946,6 +1946,14 @@ static void test_pe_image_hash(void)
     DeleteFileW(path);
 }
 
+static void test_WTHelperGetProvCertFromChain(void)
+{
+    CRYPT_PROVIDER_CERT *cert;
+
+    cert = WTHelperGetProvCertFromChain(NULL, 0);
+    ok(!cert, "got certificate\n");
+}
+
 START_TEST(softpub)
 {
     InitFunctionPtrs();
@@ -1954,6 +1962,7 @@ START_TEST(softpub)
     test_wintrust();
     test_wintrust_digest();
     test_get_known_usages();
+    test_WTHelperGetProvCertFromChain();
     test_multiple_signatures();
     test_pe_image_hash();
 }
diff --git a/dlls/wintrust/wintrust_main.c b/dlls/wintrust/wintrust_main.c
index 66e274a24ae..1f03d89ed53 100644
--- a/dlls/wintrust/wintrust_main.c
+++ b/dlls/wintrust/wintrust_main.c
@@ -759,7 +759,7 @@ CRYPT_PROVIDER_CERT * WINAPI WTHelperGetProvCertFromChain(
 
     TRACE("(%p %ld)\n", pSgnr, idxCert);
 
-    if (idxCert >= pSgnr->csCertChain || !pSgnr->pasCertChain)
+    if (!pSgnr || idxCert >= pSgnr->csCertChain || !pSgnr->pasCertChain)
         return NULL;
     cert = &pSgnr->pasCertChain[idxCert];
     TRACE("returning %p\n", cert);

From c26e132cf941d309ed4e8f59ee3fddc203fcefe5 Mon Sep 17 00:00:00 2001
From: Dmitry Kislyuk <dimaki@rocketmail.com>
Date: Wed, 28 Apr 2021 09:47:41 -0500
Subject: [PATCH 199/244] wscript: return TRUE for /d and /u stub switches

Patch by Robert Wilhelm from bug:
https://bugs.winehq.org/show_bug.cgi?id=49905

VbsEdit is able to execute scripts with this patch applied.

Signed-off-by: Dmitry Kislyuk <dimaki@rocketmail.com>
---
 programs/wscript/main.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/programs/wscript/main.c b/programs/wscript/main.c
index 12571181491..befb97a19e8 100644
--- a/programs/wscript/main.c
+++ b/programs/wscript/main.c
@@ -393,6 +393,10 @@ static BOOL set_host_properties(const WCHAR *prop)
         wshInteractive = VARIANT_FALSE;
     else if(wcsicmp(prop, L"nologo") == 0)
         WINE_FIXME("ignored %s switch\n", debugstr_w(L"nologo"));
+    else if(wcsicmp(prop, L"d") == 0)
+        WINE_FIXME("ignored %s switch\n", debugstr_w(L"d"));
+   else if(wcsicmp(prop, L"u") == 0)
+        WINE_FIXME("ignored %s switch\n", debugstr_w(L"u"));
     else
     {
         WINE_FIXME("unsupported switch %s\n", debugstr_w(prop));

From 6e093ba1d3bd296b9be868b6f78e42cf5d1a46e7 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 1 Oct 2020 18:37:06 +1000
Subject: [PATCH 200/244] x3daudio1_7: Create import library

---
 dlls/x3daudio1_7/Makefile.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/x3daudio1_7/Makefile.in b/dlls/x3daudio1_7/Makefile.in
index b906e9146a5..6aeb0895948 100644
--- a/dlls/x3daudio1_7/Makefile.in
+++ b/dlls/x3daudio1_7/Makefile.in
@@ -1,5 +1,6 @@
 EXTRADEFS = -DX3DAUDIO1_VER=7 -DXAUDIO2_VER=7
 MODULE    = x3daudio1_7.dll
+IMPORTLIB = x3daudio1_7
 PARENTSRC = ../xaudio2_7
 IMPORTS   = $(FAUDIO_PE_LIBS)
 EXTRAINCL = $(FAUDIO_PE_CFLAGS)

From e7a13dda900a97b222fe191f1a3793d7bd85b1e2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Mon, 26 Dec 2016 16:37:40 +0100
Subject: [PATCH 205/244] wineboot: Initialize proxy settings registry key.

---
 programs/wineboot/Makefile.in | 2 +-
 programs/wineboot/wineboot.c  | 9 +++++++++
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/programs/wineboot/Makefile.in b/programs/wineboot/Makefile.in
index 035197970d8..19854e945c8 100644
--- a/programs/wineboot/Makefile.in
+++ b/programs/wineboot/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = wineboot.exe
 IMPORTS   = uuid advapi32 ws2_32 kernelbase
-DELAYIMPORTS = shell32 shlwapi version user32 gdi32 setupapi newdev crypt32
+DELAYIMPORTS = shell32 shlwapi version user32 gdi32 setupapi newdev crypt32 wininet
 
 EXTRADLLFLAGS = -mconsole
 
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 691217a7b14..3021f0827dd 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -78,6 +78,7 @@
 #include <shlwapi.h>
 #include <shellapi.h>
 #include <setupapi.h>
+#include <wininet.h>
 #include <newdev.h>
 #include <wincrypt.h>
 #include "resource.h"
@@ -1190,6 +1191,13 @@ static void create_volatile_environment_registry_key(void)
     RegCloseKey( hkey );
 }
 
+static void create_proxy_settings(void)
+{
+    HINTERNET inet;
+    inet = InternetOpenA( "Wine", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );
+    if (inet) InternetCloseHandle( inet );
+}
+
 /* Performs the rename operations dictated in %SystemRoot%\Wininit.ini.
  * Returns FALSE if there was an error, or otherwise if all is ok.
  */
@@ -2067,6 +2075,7 @@ int __cdecl main( int argc, char *argv[] )
 
     create_digitalproductid();
     create_volatile_environment_registry_key();
+    create_proxy_settings();
 
     ProcessRunKeys( HKEY_LOCAL_MACHINE, L"RunOnce", TRUE, TRUE );
 

From d86b626e78d970f2553117e11ee49801ab4125ec Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Fri, 5 Jul 2019 13:20:23 +0800
Subject: [PATCH 206/244] cryptext: Implement CryptExtOpenCER.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 configure.ac                    |  1 +
 dlls/cryptext/Makefile.in       |  3 +-
 dlls/cryptext/cryptext.spec     |  4 +--
 dlls/cryptext/cryptext_main.c   | 64 +++++++++++++++++++++++++++++++++
 dlls/cryptext/tests/Makefile.in |  4 +++
 dlls/cryptext/tests/cryptext.c  | 61 +++++++++++++++++++++++++++++++
 6 files changed, 134 insertions(+), 3 deletions(-)
 create mode 100644 dlls/cryptext/tests/Makefile.in
 create mode 100644 dlls/cryptext/tests/cryptext.c

diff --git a/configure.ac b/configure.ac
index 6a506d4000c..d4e999fb727 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2530,6 +2530,7 @@ WINE_CONFIG_MAKEFILE(dlls/crypt32/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptdlg)
 WINE_CONFIG_MAKEFILE(dlls/cryptdll)
 WINE_CONFIG_MAKEFILE(dlls/cryptext)
+WINE_CONFIG_MAKEFILE(dlls/cryptext/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptnet)
 WINE_CONFIG_MAKEFILE(dlls/cryptnet/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptowinrt)
diff --git a/dlls/cryptext/Makefile.in b/dlls/cryptext/Makefile.in
index 5598bfb78e0..acda4e4ac6d 100644
--- a/dlls/cryptext/Makefile.in
+++ b/dlls/cryptext/Makefile.in
@@ -1,4 +1,5 @@
-MODULE = cryptext.dll
+MODULE  = cryptext.dll
+IMPORTS = crypt32 cryptui user32
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
diff --git a/dlls/cryptext/cryptext.spec b/dlls/cryptext/cryptext.spec
index ee3e155f457..24b4794c198 100644
--- a/dlls/cryptext/cryptext.spec
+++ b/dlls/cryptext/cryptext.spec
@@ -12,8 +12,8 @@
 @ stub CryptExtAddSPCW
 @ stub CryptExtOpenCAT
 @ stub CryptExtOpenCATW
-@ stub CryptExtOpenCER
-@ stub CryptExtOpenCERW
+@ stdcall CryptExtOpenCER(long ptr str long)
+@ stdcall CryptExtOpenCERW(long ptr wstr long)
 @ stub CryptExtOpenCRL
 @ stub CryptExtOpenCRLW
 @ stub CryptExtOpenCTL
diff --git a/dlls/cryptext/cryptext_main.c b/dlls/cryptext/cryptext_main.c
index 537ba66cd3b..a4314518eac 100644
--- a/dlls/cryptext/cryptext_main.c
+++ b/dlls/cryptext/cryptext_main.c
@@ -22,10 +22,29 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "winnls.h"
+#include "wincrypt.h"
+#include "winuser.h"
+#include "cryptuiapi.h"
+
+#include "wine/heap.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cryptext);
 
+static WCHAR *heap_strdupAtoW(const char *str)
+{
+    WCHAR *ret;
+    INT len;
+
+    if (!str) return NULL;
+    len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
+    ret = heap_alloc(len * sizeof(WCHAR));
+    if (ret)
+        MultiByteToWideChar(CP_ACP, 0, str, -1, ret, len);
+    return ret;
+}
+
 /***********************************************************************
  * CryptExtAddPFX (CRYPTEXT.@)
  */
@@ -43,3 +62,48 @@ HRESULT WINAPI CryptExtAddPFXW(LPCWSTR filename)
     FIXME("stub: %s\n", debugstr_w(filename));
     return E_NOTIMPL;
 }
+
+/***********************************************************************
+ * CryptExtOpenCERW (CRYPTEXT.@)
+ */
+HRESULT WINAPI CryptExtOpenCERW(HWND hwnd, HINSTANCE hinst, LPCWSTR filename, DWORD showcmd)
+{
+    PCCERT_CONTEXT ctx;
+    CRYPTUI_VIEWCERTIFICATE_STRUCTW info;
+
+    TRACE("(%p, %p, %s, %lu)\n", hwnd, hinst, debugstr_w(filename), showcmd);
+
+    if (!CryptQueryObject(CERT_QUERY_OBJECT_FILE, filename, CERT_QUERY_CONTENT_FLAG_CERT,
+                          CERT_QUERY_FORMAT_FLAG_ALL, 0, NULL, NULL, NULL, NULL, NULL,
+                          (const void **)&ctx))
+    {
+        /* FIXME: move to the resources */
+        static const WCHAR msg[] = {'T','h','i','s',' ','i','s',' ','n','o','t',' ','a',' ','v','a','l','i','d',' ','c','e','r','t','i','f','i','c','a','t','e',0};
+        MessageBoxW(NULL, msg, filename, MB_OK | MB_ICONERROR);
+        return S_OK; /* according to the tests */
+    }
+
+    memset(&info, 0, sizeof(info));
+    info.dwSize = sizeof(info);
+    info.pCertContext = ctx;
+    CryptUIDlgViewCertificateW(&info, NULL);
+    CertFreeCertificateContext(ctx);
+
+    return S_OK;
+}
+
+/***********************************************************************
+ * CryptExtOpenCER (CRYPTEXT.@)
+ */
+HRESULT WINAPI CryptExtOpenCER(HWND hwnd, HINSTANCE hinst, LPCSTR filename, DWORD showcmd)
+{
+    HRESULT hr;
+    LPWSTR filenameW;
+
+    TRACE("(%p, %p, %s, %lu)\n", hwnd, hinst, debugstr_a(filename), showcmd);
+
+    filenameW = heap_strdupAtoW(filename);
+    hr = CryptExtOpenCERW(hwnd, hinst, filenameW, showcmd);
+    heap_free(filenameW);
+    return hr;
+}
diff --git a/dlls/cryptext/tests/Makefile.in b/dlls/cryptext/tests/Makefile.in
new file mode 100644
index 00000000000..c3f4551fc00
--- /dev/null
+++ b/dlls/cryptext/tests/Makefile.in
@@ -0,0 +1,4 @@
+TESTDLL = cryptext.dll
+
+SOURCES = \
+	cryptext.c
diff --git a/dlls/cryptext/tests/cryptext.c b/dlls/cryptext/tests/cryptext.c
new file mode 100644
index 00000000000..ab1007dbd82
--- /dev/null
+++ b/dlls/cryptext/tests/cryptext.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2019 Dmitry Timoshkov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdarg.h>
+#include <assert.h>
+#include <windef.h>
+#include <winbase.h>
+#include <winuser.h>
+#include <winerror.h>
+
+#include "wine/test.h"
+
+static HRESULT (WINAPI *pCryptExtOpenCER)(HWND,HINSTANCE,LPCSTR,DWORD);
+
+static void test_CryptExtOpenCER(void)
+{
+    HRESULT hr;
+
+    if (!pCryptExtOpenCER)
+    {
+        win_skip("CryptExtOpenCER is not available on this platform\n");
+        return;
+    }
+
+    if (!winetest_interactive)
+    {
+        skip("CryptExtOpenCER test needs user interaction\n");
+        return;
+    }
+
+    SetLastError(0xdeadbeef);
+    hr = pCryptExtOpenCER(0, 0, "dead.beef", SW_HIDE);
+    ok(hr == S_OK, "got %#lx\n", hr);
+
+    hr = pCryptExtOpenCER(0, 0, "VeriSign Class 3 Public Primary Certification Authority - G4.txt", SW_SHOW);
+    ok(hr == S_OK, "got %#lx\n", hr);
+}
+
+START_TEST(cryptext)
+{
+    HMODULE hmod = LoadLibraryA("cryptext.dll");
+
+    pCryptExtOpenCER = (void *)GetProcAddress(hmod, "CryptExtOpenCER");
+
+    test_CryptExtOpenCER();
+}

From 31602a4ba9b03ce9be2fc502944940751e42d3de Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Wed, 14 May 2025 01:41:14 +0300
Subject: [PATCH 207/244] Revert "winex11.drv: handle missing thread data in
 X11DRV_get_ic"

This reverts commit 3cd6ecfda275396f5d5e1ba25b7dfd52865153de.
---
 dlls/winex11.drv/xim.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index ca67fc3bca9..f09067f232e 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -472,11 +472,6 @@ XIC X11DRV_get_ic( HWND hwnd )
     XIM xim;
     XIC ret;
 
-    if (!x11drv_thread_data())
-    {
-        release_win_data( data );
-        return NULL;
-    }
     if (!(data = get_win_data( hwnd ))) return 0;
     x11drv_init_thread_data()->last_xic_hwnd = hwnd;
     if (!(ret = data->xic) && (xim = x11drv_thread_data()->xim))

From 672005479689673cc25ae1326224e1d4de961138 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 22:31:06 +0200
Subject: [PATCH 209/244] server: Add an object operation to retrieve an
 in-process synchronization object.

---
 server/async.c      |  2 ++
 server/atom.c       |  1 +
 server/change.c     |  1 +
 server/clipboard.c  |  1 +
 server/completion.c |  2 ++
 server/console.c    |  7 +++++++
 server/debugger.c   |  2 ++
 server/device.c     |  4 ++++
 server/directory.c  |  2 ++
 server/esync.c      |  1 +
 server/event.c      |  2 ++
 server/fd.c         |  4 ++++
 server/file.c       |  1 +
 server/fsync.c      |  1 +
 server/handle.c     |  1 +
 server/hook.c       |  1 +
 server/mailslot.c   |  4 ++++
 server/mapping.c    |  3 +++
 server/mutex.c      |  1 +
 server/named_pipe.c |  6 ++++++
 server/object.c     |  8 ++++++++
 server/object.h     |  8 +++++++-
 server/process.c    |  3 +++
 server/protocol.def | 11 +++++++++++
 server/queue.c      |  2 ++
 server/registry.c   |  1 +
 server/request.c    |  1 +
 server/semaphore.c  |  1 +
 server/serial.c     |  1 +
 server/signal.c     |  1 +
 server/sock.c       |  3 +++
 server/symlink.c    |  1 +
 server/thread.c     |  3 +++
 server/timer.c      |  1 +
 server/token.c      |  1 +
 server/window.c     |  1 +
 server/winstation.c |  2 ++
 37 files changed, 95 insertions(+), 1 deletion(-)

diff --git a/server/async.c b/server/async.c
index 10089b20a0e..bda3021d06f 100644
--- a/server/async.c
+++ b/server/async.c
@@ -92,6 +92,7 @@ static const struct object_ops async_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     async_destroy              /* destroy */
 };
@@ -714,6 +715,7 @@ static const struct object_ops iosb_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     iosb_destroy              /* destroy */
 };
diff --git a/server/atom.c b/server/atom.c
index 6b95a546597..25d7f6041c2 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -93,6 +93,7 @@ static const struct object_ops atom_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     atom_table_destroy            /* destroy */
 };
diff --git a/server/change.c b/server/change.c
index ea551676c25..f5129001836 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,6 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/clipboard.c b/server/clipboard.c
index a2e0af2ba32..5e709842712 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -90,6 +90,7 @@ static const struct object_ops clipboard_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     clipboard_destroy             /* destroy */
 };
diff --git a/server/completion.c b/server/completion.c
index 4c5d2f79bc1..e2fd3b39924 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -110,6 +110,7 @@ static const struct object_ops completion_wait_ops =
     NULL,                           /* unlink_name */
     no_open_file,                   /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                /* close_handle */
     completion_wait_destroy         /* destroy */
 };
@@ -193,6 +194,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     completion_close_handle,   /* close_handle */
     completion_destroy         /* destroy */
 };
diff --git a/server/console.c b/server/console.c
index 58ec10fa856..530ee31581f 100644
--- a/server/console.c
+++ b/server/console.c
@@ -97,6 +97,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -180,6 +181,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -251,6 +253,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -302,6 +305,7 @@ static const struct object_ops console_device_ops =
     default_unlink_name,              /* unlink_name */
     console_device_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     no_destroy                        /* destroy */
 };
@@ -341,6 +345,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -400,6 +405,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -460,6 +466,7 @@ static const struct object_ops console_connection_ops =
     default_unlink_name,              /* unlink_name */
     console_connection_open_file,     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     console_connection_close_handle,  /* close_handle */
     console_connection_destroy        /* destroy */
 };
diff --git a/server/debugger.c b/server/debugger.c
index 5494eb517df..249c530e9b1 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -100,6 +100,7 @@ static const struct object_ops debug_event_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_event_destroy            /* destroy */
 };
@@ -130,6 +131,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 20950f50710..78a37ae3bc0 100644
--- a/server/device.c
+++ b/server/device.c
@@ -82,6 +82,7 @@ static const struct object_ops irp_call_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     irp_call_destroy                  /* destroy */
 };
@@ -128,6 +129,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -187,6 +189,7 @@ static const struct object_ops device_ops =
     default_unlink_name,              /* unlink_name */
     device_open_file,                 /* open_file */
     device_get_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_destroy                    /* destroy */
 };
@@ -241,6 +244,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/directory.c b/server/directory.c
index cd17883458e..1e3f71d6e81 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -83,6 +83,7 @@ static const struct object_ops object_type_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     no_destroy                    /* destroy */
 };
@@ -135,6 +136,7 @@ static const struct object_ops directory_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     directory_destroy             /* destroy */
 };
diff --git a/server/esync.c b/server/esync.c
index d6057d1a45c..586ecc08059 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -143,6 +143,7 @@ const struct object_ops esync_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     esync_destroy              /* destroy */
 };
diff --git a/server/event.c b/server/event.c
index be120695e6e..e6c86472c71 100644
--- a/server/event.c
+++ b/server/event.c
@@ -93,6 +93,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -142,6 +143,7 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     no_destroy                   /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 47c7ec7ee9a..5d99eedd340 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -185,6 +185,7 @@ static const struct object_ops fd_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     fd_destroy                /* destroy */
 };
@@ -228,6 +229,7 @@ static const struct object_ops device_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     device_destroy            /* destroy */
 };
@@ -270,6 +272,7 @@ static const struct object_ops inode_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     inode_destroy             /* destroy */
 };
@@ -314,6 +317,7 @@ static const struct object_ops file_lock_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/file.c b/server/file.c
index 934c394ae34..40ff667c98e 100644
--- a/server/file.c
+++ b/server/file.c
@@ -137,6 +137,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/fsync.c b/server/fsync.c
index b83cdc10a51..0fbfc690a66 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -164,6 +164,7 @@ const struct object_ops fsync_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     fsync_destroy              /* destroy */
 };
diff --git a/server/handle.c b/server/handle.c
index 2dca6d8155d..85e90577d48 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -140,6 +140,7 @@ static const struct object_ops handle_table_ops =
     NULL,                            /* unlink_name */
     no_open_file,                    /* open_file */
     no_kernel_obj_list,              /* get_kernel_obj_list */
+    no_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                 /* close_handle */
     handle_table_destroy             /* destroy */
 };
diff --git a/server/hook.c b/server/hook.c
index 499b333dc3a..521f28e085f 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -95,6 +95,7 @@ static const struct object_ops hook_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     hook_table_destroy            /* destroy */
 };
diff --git a/server/mailslot.c b/server/mailslot.c
index 37f8f1a679c..f89778b924e 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -95,6 +95,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -158,6 +159,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -225,6 +227,7 @@ static const struct object_ops mailslot_device_ops =
     default_unlink_name,            /* unlink_name */
     mailslot_device_open_file,      /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                /* close_handle */
     mailslot_device_destroy         /* destroy */
 };
@@ -257,6 +260,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
+    no_get_inproc_sync,                     /* get_inproc_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/mapping.c b/server/mapping.c
index e68edf8aba4..572d3ba66e7 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -81,6 +81,7 @@ static const struct object_ops ranges_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     ranges_destroy             /* destroy */
 };
@@ -119,6 +120,7 @@ static const struct object_ops shared_map_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     shared_map_destroy         /* destroy */
 };
@@ -196,6 +198,7 @@ static const struct object_ops mapping_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     mapping_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
diff --git a/server/mutex.c b/server/mutex.c
index 2503d12057f..58ac83bd3f7 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -87,6 +87,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 2beb590c2cc..ad0c9f549a6 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -136,6 +136,7 @@ static const struct object_ops named_pipe_ops =
     default_unlink_name,          /* unlink_name */
     named_pipe_open_file,         /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     named_pipe_destroy            /* destroy */
 };
@@ -186,6 +187,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -232,6 +234,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -281,6 +284,7 @@ static const struct object_ops named_pipe_device_ops =
     default_unlink_name,              /* unlink_name */
     named_pipe_device_open_file,      /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     named_pipe_device_destroy         /* destroy */
 };
@@ -314,6 +318,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    no_get_inproc_sync,                      /* get_inproc_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
@@ -367,6 +372,7 @@ static const struct object_ops named_pipe_dir_ops =
     NULL,                                    /* unlink_name */
     named_pipe_dir_open_file,                /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    no_get_inproc_sync,                      /* get_inproc_sync */
     named_pipe_dir_close_handle,             /* close_handle */
     named_pipe_dir_destroy                   /* destroy */
 };
diff --git a/server/object.c b/server/object.c
index 0fc9aef451a..cd5c4dd4ceb 100644
--- a/server/object.c
+++ b/server/object.c
@@ -122,6 +122,7 @@ static const struct object_ops apc_reserve_ops =
     default_unlink_name,        /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -148,6 +149,7 @@ static const struct object_ops completion_reserve_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     no_destroy                 /* destroy */
 };
@@ -643,6 +645,12 @@ struct fd *no_get_fd( struct object *obj )
     return NULL;
 }
 
+struct inproc_sync *no_get_inproc_sync( struct object *obj )
+{
+    set_error( STATUS_OBJECT_TYPE_MISMATCH );
+    return NULL;
+}
+
 unsigned int default_map_access( struct object *obj, unsigned int access )
 {
     return map_access( access, &obj->ops->type->mapping );
diff --git a/server/object.h b/server/object.h
index fb3f3211fae..403dfa3b141 100644
--- a/server/object.h
+++ b/server/object.h
@@ -42,7 +42,7 @@ struct async;
 struct async_queue;
 struct winstation;
 struct object_type;
-
+struct inproc_sync;
 
 struct unicode_str
 {
@@ -107,6 +107,8 @@ struct object_ops
                                 unsigned int options);
     /* return list of kernel objects */
     struct list *(*get_kernel_obj_list)(struct object *);
+    /* get a client-waitable in-process synchronization handle to this object */
+    struct inproc_sync *(*get_inproc_sync)(struct object *);
     /* close a handle to this object */
     int (*close_handle)(struct object *,struct process *,obj_handle_t);
     /* destroy on refcount == 0 */
@@ -235,6 +237,10 @@ extern void reset_event( struct event *event );
 
 extern void abandon_mutexes( struct thread *thread );
 
+/* in-process synchronization functions */
+
+extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
+
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
diff --git a/server/process.c b/server/process.c
index 73e85e9d61a..bfa50cdfcb2 100644
--- a/server/process.c
+++ b/server/process.c
@@ -124,6 +124,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -177,6 +178,7 @@ static const struct object_ops startup_info_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     startup_info_destroy           /* destroy */
 };
@@ -240,6 +242,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
diff --git a/server/protocol.def b/server/protocol.def
index 72cb633397a..e240c4212db 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4203,6 +4203,17 @@ enum fsync_type
     FSYNC_QUEUE,
 };
 
+enum inproc_sync_type
+{
+    INPROC_SYNC_SEMAPHORE = 1,
+    INPROC_SYNC_MUTEX,
+    INPROC_SYNC_AUTO_EVENT,
+    INPROC_SYNC_MANUAL_EVENT,
+    INPROC_SYNC_AUTO_SERVER,
+    INPROC_SYNC_MANUAL_SERVER,
+    INPROC_SYNC_QUEUE,
+};
+
 /* Create a new futex-based synchronization object */
 @REQ(create_fsync)
     unsigned int access;        /* wanted access rights */
diff --git a/server/queue.c b/server/queue.c
index cb43e56a436..6a28c3daac5 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -197,6 +197,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -236,6 +237,7 @@ static const struct object_ops thread_input_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     thread_input_destroy          /* destroy */
 };
diff --git a/server/registry.c b/server/registry.c
index 4c683440fea..f1d368ce946 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -195,6 +195,7 @@ static const struct object_ops key_ops =
     key_unlink_name,         /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_inproc_sync,      /* get_inproc_sync */
     key_close_handle,        /* close_handle */
     key_destroy              /* destroy */
 };
diff --git a/server/request.c b/server/request.c
index 478e1f9cabf..ffa0ccd1c85 100644
--- a/server/request.c
+++ b/server/request.c
@@ -103,6 +103,7 @@ static const struct object_ops master_socket_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     master_socket_destroy          /* destroy */
 };
diff --git a/server/semaphore.c b/server/semaphore.c
index d354892c224..567a922c0ac 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -84,6 +84,7 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     no_destroy                     /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 2d9b2cd5318..93619ebccde 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -105,6 +105,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/signal.c b/server/signal.c
index 802b7f936b9..2f58105452f 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -76,6 +76,7 @@ static const struct object_ops handler_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     handler_destroy           /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 21b4621bb0c..0e0bfd70793 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -485,6 +485,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
@@ -3619,6 +3620,7 @@ static const struct object_ops ifchange_ops =
     NULL,                    /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_inproc_sync,      /* get_inproc_sync */
     no_close_handle,         /* close_handle */
     ifchange_destroy         /* destroy */
 };
@@ -3842,6 +3844,7 @@ static const struct object_ops socket_device_ops =
     default_unlink_name,        /* unlink_name */
     socket_device_open_file,    /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/symlink.c b/server/symlink.c
index 27a90d91dff..5a3f35054a2 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -85,6 +85,7 @@ static const struct object_ops symlink_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     symlink_destroy               /* destroy */
 };
diff --git a/server/thread.c b/server/thread.c
index 25b91a9b74a..8fbfd553cc6 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -115,6 +115,7 @@ static const struct object_ops thread_apc_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     thread_apc_destroy          /* destroy */
 };
@@ -159,6 +160,7 @@ static const struct object_ops context_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -212,6 +214,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
diff --git a/server/timer.c b/server/timer.c
index 53286dbc56c..ca367a6fb7d 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -96,6 +96,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
diff --git a/server/token.c b/server/token.c
index 31fc4b8ddc6..16f74a32cae 100644
--- a/server/token.c
+++ b/server/token.c
@@ -164,6 +164,7 @@ static const struct object_ops token_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     token_destroy              /* destroy */
 };
diff --git a/server/window.c b/server/window.c
index 3920eaeb4ec..2891f659894 100644
--- a/server/window.c
+++ b/server/window.c
@@ -123,6 +123,7 @@ static const struct object_ops window_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     window_destroy            /* destroy */
 };
diff --git a/server/winstation.c b/server/winstation.c
index 5a83171e659..a8a0d2b7125 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -90,6 +90,7 @@ static const struct object_ops winstation_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     winstation_close_handle,      /* close_handle */
     winstation_destroy            /* destroy */
 };
@@ -132,6 +133,7 @@ static const struct object_ops desktop_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     desktop_close_handle,         /* close_handle */
     desktop_destroy               /* destroy */
 };

From 175d3eb08416a1d8b5d043d255bd80651ce5c069 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 00:38:18 +0200
Subject: [PATCH 210/244] server: Create in-process synchronization objects for
 events.

---
 configure.ac         |   1 +
 server/Makefile.in   |   1 +
 server/event.c       |  22 +++-
 server/inproc_sync.c | 304 +++++++++++++++++++++++++++++++++++++++++++
 server/object.h      |   4 +
 5 files changed, 331 insertions(+), 1 deletion(-)
 create mode 100644 server/inproc_sync.c

diff --git a/configure.ac b/configure.ac
index d4e999fb727..2a5808b65d7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -387,6 +387,7 @@ AC_CHECK_HEADERS(\
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
+	linux/ntsync.h \
 	linux/param.h \
 	linux/seccomp.h \
 	linux/serial.h \
diff --git a/server/Makefile.in b/server/Makefile.in
index 4e2008a761f..6866b847b46 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -18,6 +18,7 @@ SOURCES = \
 	fsync.c \
 	handle.c \
 	hook.c \
+	inproc_sync.c \
 	mach.c \
 	mailslot.c \
 	main.c \
diff --git a/server/event.c b/server/event.c
index e6c86472c71..a9dc739a257 100644
--- a/server/event.c
+++ b/server/event.c
@@ -58,6 +58,7 @@ struct event
     struct list    kernel_object;   /* list of kernel object pointers */
     int            manual_reset;    /* is it a manual reset event? */
     int            signaled;        /* event has been signaled */
+    struct inproc_sync *inproc_sync;/* in-process synchronization object */
     int            esync_fd;        /* esync file descriptor */
     unsigned int   fsync_idx;
 };
@@ -69,6 +70,7 @@ static int event_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int event_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
+static struct inproc_sync *event_get_inproc_sync( struct object *obj );
 static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
@@ -93,7 +95,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    event_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -163,6 +165,7 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             list_init( &event->kernel_object );
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
+            event->inproc_sync    = NULL;
             event->fsync_idx = 0;
 
             if (do_fsync())
@@ -216,6 +219,7 @@ void set_event( struct event *event )
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
+    set_inproc_event( event->inproc_sync );
 }
 
 void reset_event( struct event *event )
@@ -238,6 +242,8 @@ void reset_event( struct event *event )
 
     if (do_esync())
         esync_clear( event->esync_fd );
+
+    reset_inproc_event( event->inproc_sync );
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -297,6 +303,19 @@ static struct list *event_get_kernel_obj_list( struct object *obj )
     return &event->kernel_object;
 }
 
+static struct inproc_sync *event_get_inproc_sync( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (!event->inproc_sync)
+    {
+        enum inproc_sync_type type = event->manual_reset ? INPROC_SYNC_MANUAL_EVENT : INPROC_SYNC_AUTO_EVENT;
+        event->inproc_sync = create_inproc_event( type, event->signaled );
+    }
+    if (event->inproc_sync) grab_object( event->inproc_sync );
+    return event->inproc_sync;
+}
+
 static void event_destroy( struct object *obj )
 {
     struct event *event = (struct event *)obj;
@@ -304,6 +323,7 @@ static void event_destroy( struct object *obj )
     if (do_esync())
         close( event->esync_fd );
     if (event->fsync_idx) fsync_free_shm_idx( event->fsync_idx );
+    if (event->inproc_sync) release_object( event->inproc_sync );
 }
 
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
diff --git a/server/inproc_sync.c b/server/inproc_sync.c
new file mode 100644
index 00000000000..9054d48fca4
--- /dev/null
+++ b/server/inproc_sync.c
@@ -0,0 +1,304 @@
+/*
+ * In-process synchronization primitives
+ *
+ * Copyright (C) 2021-2022 Elizabeth Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
+
+#include "file.h"
+#include "thread.h"
+
+#ifdef HAVE_LINUX_NTSYNC_H
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <linux/ntsync.h>
+
+struct linux_device
+{
+    struct object obj;      /* object header */
+    struct fd *fd;          /* fd for unix fd */
+};
+
+static struct linux_device *linux_device_object;
+
+static void linux_device_dump( struct object *obj, int verbose );
+static struct fd *linux_device_get_fd( struct object *obj );
+static void linux_device_destroy( struct object *obj );
+static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd );
+
+static const struct object_ops linux_device_ops =
+{
+    sizeof(struct linux_device),        /* size */
+    &no_type,                           /* type */
+    linux_device_dump,                  /* dump */
+    no_add_queue,                       /* add_queue */
+    NULL,                               /* remove_queue */
+    NULL,                               /* signaled */
+    NULL,                               /* get_esync_fd */
+    NULL,                               /* get_fsync_idx */
+    NULL,                               /* satisfied */
+    no_signal,                          /* signal */
+    linux_device_get_fd,                /* get_fd */
+    default_map_access,                 /* map_access */
+    default_get_sd,                     /* get_sd */
+    default_set_sd,                     /* set_sd */
+    no_get_full_name,                   /* get_full_name */
+    no_lookup_name,                     /* lookup_name */
+    no_link_name,                       /* link_name */
+    NULL,                               /* unlink_name */
+    no_open_file,                       /* open_file */
+    no_kernel_obj_list,                 /* get_kernel_obj_list */
+    no_get_inproc_sync,                 /* get_inproc_sync */
+    no_close_handle,                    /* close_handle */
+    linux_device_destroy                /* destroy */
+};
+
+static const struct fd_ops inproc_sync_fd_ops =
+{
+    default_fd_get_poll_events,     /* get_poll_events */
+    default_poll_event,             /* poll_event */
+    inproc_sync_get_fd_type,        /* get_fd_type */
+    no_fd_read,                     /* read */
+    no_fd_write,                    /* write */
+    no_fd_flush,                    /* flush */
+    no_fd_get_file_info,            /* get_file_info */
+    no_fd_get_volume_info,          /* get_volume_info */
+    no_fd_ioctl,                    /* ioctl */
+    default_fd_cancel_async,        /* cancel_async */
+    no_fd_queue_async,              /* queue_async */
+    default_fd_reselect_async       /* reselect_async */
+};
+
+static void linux_device_dump( struct object *obj, int verbose )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    assert( obj->ops == &linux_device_ops );
+    fprintf( stderr, "In-process synchronization device fd=%p\n", device->fd );
+}
+
+static struct fd *linux_device_get_fd( struct object *obj )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    return (struct fd *)grab_object( device->fd );
+}
+
+static void linux_device_destroy( struct object *obj )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    assert( obj->ops == &linux_device_ops );
+    if (device->fd) release_object( device->fd );
+    linux_device_object = NULL;
+}
+
+static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd )
+{
+    return FD_TYPE_FILE;
+}
+
+static struct linux_device *get_linux_device(void)
+{
+    struct linux_device *device;
+    int unix_fd;
+
+    if (linux_device_object)
+        return (struct linux_device *)grab_object( linux_device_object );
+
+    unix_fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
+    if (unix_fd == -1)
+    {
+        file_set_error();
+        return NULL;
+    }
+
+    if (!(device = alloc_object( &linux_device_ops )))
+    {
+        close( unix_fd );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+
+    if (!(device->fd = create_anonymous_fd( &inproc_sync_fd_ops, unix_fd, &device->obj, 0 )))
+    {
+        release_object( device );
+        return NULL;
+    }
+
+    linux_device_object = device;
+    return device;
+}
+
+struct inproc_sync
+{
+    struct object obj;
+    enum inproc_sync_type type;
+    struct fd *fd;
+};
+
+static void linux_obj_dump( struct object *obj, int verbose );
+static void linux_obj_destroy( struct object *obj );
+
+static const struct object_ops inproc_sync_ops =
+{
+    sizeof(struct inproc_sync), /* size */
+    &no_type,                   /* type */
+    linux_obj_dump,             /* dump */
+    no_add_queue,               /* add_queue */
+    NULL,                       /* remove_queue */
+    NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
+    NULL,                       /* satisfied */
+    no_signal,                  /* signal */
+    no_get_fd,                  /* get_fd */
+    default_map_access,         /* map_access */
+    default_get_sd,             /* get_sd */
+    default_set_sd,             /* set_sd */
+    no_get_full_name,           /* get_full_name */
+    no_lookup_name,             /* lookup_name */
+    no_link_name,               /* link_name */
+    NULL,                       /* unlink_name */
+    no_open_file,               /* open_file */
+    no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
+    no_close_handle,            /* close_handle */
+    linux_obj_destroy           /* destroy */
+};
+
+static void linux_obj_dump( struct object *obj, int verbose )
+{
+    struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
+    assert( obj->ops == &inproc_sync_ops );
+    fprintf( stderr, "In-process synchronization object type=%u fd=%p\n", inproc_sync->type, inproc_sync->fd );
+}
+
+static void linux_obj_destroy( struct object *obj )
+{
+    struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
+    assert( obj->ops == &inproc_sync_ops );
+    if (inproc_sync->fd) release_object( inproc_sync->fd );
+}
+
+static struct inproc_sync *create_inproc_sync( enum inproc_sync_type type, int unix_fd )
+{
+    struct inproc_sync *inproc_sync;
+
+    if (!(inproc_sync = alloc_object( &inproc_sync_ops )))
+    {
+        close( unix_fd );
+        return NULL;
+    }
+
+    inproc_sync->type = type;
+
+    if (!(inproc_sync->fd = create_anonymous_fd( &inproc_sync_fd_ops, unix_fd, &inproc_sync->obj, 0 )))
+    {
+        release_object( inproc_sync );
+        return NULL;
+    }
+
+    return inproc_sync;
+}
+
+struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled )
+{
+    struct ntsync_event_args args;
+    struct linux_device *device;
+    int event;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.signaled = signaled;
+    switch (type)
+    {
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_AUTO_SERVER:
+            args.manual = 0;
+            break;
+
+        case INPROC_SYNC_MANUAL_EVENT:
+        case INPROC_SYNC_MANUAL_SERVER:
+        case INPROC_SYNC_QUEUE:
+            args.manual = 1;
+            break;
+
+        case INPROC_SYNC_MUTEX:
+        case INPROC_SYNC_SEMAPHORE:
+            assert(0);
+            break;
+    }
+    if ((event = ioctl( get_unix_fd( device->fd ), NTSYNC_IOC_CREATE_EVENT, &args )) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+    release_object( device );
+
+    return create_inproc_sync( type, event );
+}
+
+void set_inproc_event( struct inproc_sync *inproc_sync )
+{
+    __u32 count;
+
+    if (!inproc_sync) return;
+
+    if (debug_level) fprintf( stderr, "set_inproc_event %p\n", inproc_sync->fd );
+
+    ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_EVENT_SET, &count );
+}
+
+void reset_inproc_event( struct inproc_sync *inproc_sync )
+{
+    __u32 count;
+
+    if (!inproc_sync) return;
+
+    if (debug_level) fprintf( stderr, "set_inproc_event %p\n", inproc_sync->fd );
+
+    ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_EVENT_RESET, &count );
+}
+
+#else
+
+struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
+void set_inproc_event( struct inproc_sync *inproc_sync )
+{
+}
+
+void reset_inproc_event( struct inproc_sync *obj )
+{
+}
+
+#endif
diff --git a/server/object.h b/server/object.h
index 403dfa3b141..346ee6abc98 100644
--- a/server/object.h
+++ b/server/object.h
@@ -239,6 +239,10 @@ extern void abandon_mutexes( struct thread *thread );
 
 /* in-process synchronization functions */
 
+extern struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled );
+extern void set_inproc_event( struct inproc_sync *obj );
+extern void reset_inproc_event( struct inproc_sync *obj );
+
 extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
 
 /* serial functions */

From 3c22efe21eeb14fb8153d95efc88c7503328c33a Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 11 Mar 2021 16:45:30 -0600
Subject: [PATCH 211/244] server: Create in-process synchronization objects for
 semaphores.

---
 server/inproc_sync.c | 46 +++++++++++++++++++++++++++++++++++++++-----
 server/object.h      |  1 +
 server/semaphore.c   | 25 ++++++++++++++++++++++--
 3 files changed, 65 insertions(+), 7 deletions(-)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 9054d48fca4..8d01deffa1a 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -162,8 +162,9 @@ struct inproc_sync
 
 static void linux_obj_dump( struct object *obj, int verbose );
 static void linux_obj_destroy( struct object *obj );
+static struct fd *linux_obj_get_fd( struct object *obj );
 
-static const struct object_ops inproc_sync_ops =
+static const struct object_ops linux_obj_ops =
 {
     sizeof(struct inproc_sync), /* size */
     &no_type,                   /* type */
@@ -175,7 +176,7 @@ static const struct object_ops inproc_sync_ops =
     NULL,                       /* get_fsync_idx */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
-    no_get_fd,                  /* get_fd */
+    linux_obj_get_fd,           /* get_fd */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -193,22 +194,29 @@ static const struct object_ops inproc_sync_ops =
 static void linux_obj_dump( struct object *obj, int verbose )
 {
     struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
+    assert( obj->ops == &linux_obj_ops );
     fprintf( stderr, "In-process synchronization object type=%u fd=%p\n", inproc_sync->type, inproc_sync->fd );
 }
 
 static void linux_obj_destroy( struct object *obj )
 {
     struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
+    assert( obj->ops == &linux_obj_ops );
     if (inproc_sync->fd) release_object( inproc_sync->fd );
 }
 
+static struct fd *linux_obj_get_fd( struct object *obj )
+{
+    struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
+    assert( obj->ops == &linux_obj_ops );
+    return (struct fd *)grab_object( inproc_sync->fd );
+}
+
 static struct inproc_sync *create_inproc_sync( enum inproc_sync_type type, int unix_fd )
 {
     struct inproc_sync *inproc_sync;
 
-    if (!(inproc_sync = alloc_object( &inproc_sync_ops )))
+    if (!(inproc_sync = alloc_object( &linux_obj_ops )))
     {
         close( unix_fd );
         return NULL;
@@ -263,6 +271,28 @@ struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signale
     return create_inproc_sync( type, event );
 }
 
+struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max )
+{
+    struct ntsync_sem_args args;
+    struct linux_device *device;
+    int semaphore;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.count = count;
+    args.max = max;
+    if ((semaphore = ioctl( get_unix_fd( device->fd ), NTSYNC_IOC_CREATE_SEM, &args )) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    release_object( device );
+
+    return create_inproc_sync( INPROC_SYNC_SEMAPHORE, semaphore );
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
     __u32 count;
@@ -293,6 +323,12 @@ struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signale
     return NULL;
 }
 
+struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
 }
diff --git a/server/object.h b/server/object.h
index 346ee6abc98..56e9c7c24db 100644
--- a/server/object.h
+++ b/server/object.h
@@ -240,6 +240,7 @@ extern void abandon_mutexes( struct thread *thread );
 /* in-process synchronization functions */
 
 extern struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled );
+extern struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max );
 extern void set_inproc_event( struct inproc_sync *obj );
 extern void reset_inproc_event( struct inproc_sync *obj );
 
diff --git a/server/semaphore.c b/server/semaphore.c
index 567a922c0ac..778823394a6 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -55,12 +55,15 @@ struct semaphore
     struct object  obj;    /* object header */
     unsigned int   count;  /* current count */
     unsigned int   max;    /* maximum possible count */
+    struct inproc_sync *inproc_sync; /* fast synchronization object */
 };
 
 static void semaphore_dump( struct object *obj, int verbose );
 static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int semaphore_signal( struct object *obj, unsigned int access );
+static struct inproc_sync *semaphore_get_inproc_sync( struct object *obj );
+static void semaphore_destroy( struct object *obj );
 
 static const struct object_ops semaphore_ops =
 {
@@ -84,9 +87,9 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_inproc_sync,            /* get_inproc_sync */
+    semaphore_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,               /* close_handle */
-    no_destroy                     /* destroy */
+    semaphore_destroy              /* destroy */
 };
 
 
@@ -108,6 +111,7 @@ static struct semaphore *create_semaphore( struct object *root, const struct uni
             /* initialize it if it didn't already exist */
             sem->count = initial;
             sem->max   = max;
+            sem->inproc_sync = NULL;
         }
     }
     return sem;
@@ -170,6 +174,23 @@ static int semaphore_signal( struct object *obj, unsigned int access )
     return release_semaphore( sem, 1, NULL );
 }
 
+static struct inproc_sync *semaphore_get_inproc_sync( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (!semaphore->inproc_sync)
+        semaphore->inproc_sync = create_inproc_semaphore( semaphore->count, semaphore->max );
+    if (semaphore->inproc_sync) grab_object( semaphore->inproc_sync );
+    return semaphore->inproc_sync;
+}
+
+static void semaphore_destroy( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (semaphore->inproc_sync) release_object( semaphore->inproc_sync );
+}
+
 /* create a semaphore */
 DECL_HANDLER(create_semaphore)
 {

From cd163bf87df56fa5059f1569477704d1370df87d Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 11 Mar 2021 16:52:55 -0600
Subject: [PATCH 212/244] server: Create in-process synchronization objects for
 mutexes.

---
 server/inproc_sync.c | 37 +++++++++++++++++++++++++++++++++++++
 server/mutex.c       | 40 +++++++++++++++++++++++++++++++++++-----
 server/object.h      |  2 ++
 3 files changed, 74 insertions(+), 5 deletions(-)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 8d01deffa1a..11c0a87d13f 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -293,6 +293,28 @@ struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int ma
     return create_inproc_sync( INPROC_SYNC_SEMAPHORE, semaphore );
 }
 
+struct inproc_sync *create_inproc_mutex( thread_id_t owner, unsigned int count )
+{
+    struct ntsync_mutex_args args;
+    struct linux_device *device;
+    int mutex;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.owner = owner;
+    args.count = count;
+    if ((mutex = ioctl( get_unix_fd( device->fd ), NTSYNC_IOC_CREATE_MUTEX, &args )) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    release_object( device );
+
+    return create_inproc_sync( INPROC_SYNC_MUTEX, mutex );
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
     __u32 count;
@@ -315,6 +337,11 @@ void reset_inproc_event( struct inproc_sync *inproc_sync )
     ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_EVENT_RESET, &count );
 }
 
+void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
+{
+    ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_MUTEX_KILL, &tid );
+}
+
 #else
 
 struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled )
@@ -329,6 +356,12 @@ struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int ma
     return NULL;
 }
 
+struct inproc_sync *create_inproc_mutex( thread_id_t owner, unsigned int count )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
 }
@@ -337,4 +370,8 @@ void reset_inproc_event( struct inproc_sync *obj )
 {
 }
 
+void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
+{
+}
+
 #endif
diff --git a/server/mutex.c b/server/mutex.c
index 58ac83bd3f7..d97f54b8e82 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -38,6 +38,8 @@
 
 static const WCHAR mutex_name[] = {'M','u','t','a','n','t'};
 
+static struct list inproc_mutexes = LIST_INIT(inproc_mutexes);
+
 struct type_descr mutex_type =
 {
     { mutex_name, sizeof(mutex_name) },   /* name */
@@ -57,6 +59,8 @@ struct mutex
     unsigned int   count;           /* recursion count */
     int            abandoned;       /* has it been abandoned? */
     struct list    entry;           /* entry in owner thread mutex list */
+    struct list    inproc_mutexes_entry; /* entry in inproc_mutexes list */
+    struct inproc_sync *inproc_sync;/* in-process synchronization object */
 };
 
 static void mutex_dump( struct object *obj, int verbose );
@@ -64,6 +68,7 @@ static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_destroy( struct object *obj );
 static int mutex_signal( struct object *obj, unsigned int access );
+static struct inproc_sync *mutex_get_inproc_sync( struct object *obj );
 
 static const struct object_ops mutex_ops =
 {
@@ -87,7 +92,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    mutex_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
@@ -130,6 +135,7 @@ static struct mutex *create_mutex( struct object *root, const struct unicode_str
             mutex->owner = NULL;
             mutex->abandoned = 0;
             if (owned) do_grab( mutex, current );
+            mutex->inproc_sync = NULL;
         }
     }
     return mutex;
@@ -137,16 +143,20 @@ static struct mutex *create_mutex( struct object *root, const struct unicode_str
 
 void abandon_mutexes( struct thread *thread )
 {
+    struct mutex *mutex;
     struct list *ptr;
 
     while ((ptr = list_head( &thread->mutex_list )) != NULL)
     {
-        struct mutex *mutex = LIST_ENTRY( ptr, struct mutex, entry );
+        mutex = LIST_ENTRY( ptr, struct mutex, entry );
         assert( mutex->owner == thread );
         mutex->count = 0;
         mutex->abandoned = 1;
         do_release( mutex );
     }
+
+    LIST_FOR_EACH_ENTRY(mutex, &inproc_mutexes, struct mutex, inproc_mutexes_entry)
+        abandon_inproc_mutex( thread->id, mutex->inproc_sync );
 }
 
 static void mutex_dump( struct object *obj, int verbose )
@@ -192,14 +202,34 @@ static int mutex_signal( struct object *obj, unsigned int access )
     return 1;
 }
 
+static struct inproc_sync *mutex_get_inproc_sync( struct object *obj )
+{
+    struct mutex *mutex = (struct mutex *)obj;
+
+    if (!mutex->inproc_sync)
+    {
+        mutex->inproc_sync = create_inproc_mutex( mutex->owner ? mutex->owner->id : 0, mutex->count );
+        if (mutex->inproc_sync) list_add_tail( &inproc_mutexes, &mutex->inproc_mutexes_entry );
+    }
+    if (mutex->inproc_sync) grab_object( mutex->inproc_sync );
+    return mutex->inproc_sync;
+}
+
 static void mutex_destroy( struct object *obj )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
 
-    if (!mutex->count) return;
-    mutex->count = 0;
-    do_release( mutex );
+    if (mutex->count)
+    {
+        mutex->count = 0;
+        do_release( mutex );
+    }
+    if (mutex->inproc_sync)
+    {
+        release_object( mutex->inproc_sync );
+        list_remove( &mutex->inproc_mutexes_entry );
+    }
 }
 
 /* create a mutex */
diff --git a/server/object.h b/server/object.h
index 56e9c7c24db..2567f3a07e2 100644
--- a/server/object.h
+++ b/server/object.h
@@ -240,9 +240,11 @@ extern void abandon_mutexes( struct thread *thread );
 /* in-process synchronization functions */
 
 extern struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled );
+extern struct inproc_sync *create_inproc_mutex( thread_id_t owner, unsigned int count );
 extern struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max );
 extern void set_inproc_event( struct inproc_sync *obj );
 extern void reset_inproc_event( struct inproc_sync *obj );
+extern void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync );
 
 extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
 

From ec402348c57d350651eee86364de8158068685bc Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 12 Mar 2021 04:32:58 +0200
Subject: [PATCH 213/244] server: Create in-process synchronization objects for
 completion ports.

---
 server/completion.c | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/server/completion.c b/server/completion.c
index e2fd3b39924..ce9fd598abf 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -79,6 +79,7 @@ struct completion
     struct list    wait_queue;
     unsigned int   depth;
     int            closed;
+    struct inproc_sync *inproc_sync;
     int                esync_fd;
     unsigned int       fsync_idx;
 };
@@ -170,6 +171,7 @@ static int completion_signaled( struct object *obj, struct wait_queue_entry *ent
 static int completion_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int completion_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static int completion_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
+static struct inproc_sync *completion_get_inproc_sync( struct object *obj );
 static void completion_destroy( struct object * );
 
 static const struct object_ops completion_ops =
@@ -194,7 +196,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    completion_get_inproc_sync,/* get_inproc_sync */
     completion_close_handle,   /* close_handle */
     completion_destroy         /* destroy */
 };
@@ -211,6 +213,7 @@ static void completion_destroy( struct object *obj)
     {
         free( tmp );
     }
+    if (completion->inproc_sync) release_object( completion->inproc_sync );
 }
 
 static void completion_dump( struct object *obj, int verbose )
@@ -265,6 +268,7 @@ static int completion_close_handle( struct object *obj, struct process *process,
     }
     completion->closed = 1;
     wake_up( obj, 0 );
+    set_inproc_event( completion->inproc_sync );
     return 1;
 }
 
@@ -298,6 +302,16 @@ static struct completion_wait *create_completion_wait( struct thread *thread )
     return wait;
 }
 
+static struct inproc_sync *completion_get_inproc_sync( struct object *obj )
+{
+    struct completion *completion = (struct completion *)obj;
+
+    if (!completion->inproc_sync)
+        completion->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, !list_empty( &completion->queue ) );
+    if (completion->inproc_sync) grab_object( completion->inproc_sync );
+    return completion->inproc_sync;
+}
+
 static struct completion *create_completion( struct object *root, const struct unicode_str *name,
                                              unsigned int attr, unsigned int concurrent,
                                              const struct security_descriptor *sd )
@@ -312,6 +326,7 @@ static struct completion *create_completion( struct object *root, const struct u
             list_init( &completion->wait_queue );
             completion->depth = 0;
             completion->closed = 0;
+            completion->inproc_sync = NULL;
         }
     }
     if (do_esync()) completion->esync_fd = esync_create_fd( 0, 0 );
@@ -346,7 +361,11 @@ void add_completion( struct completion *completion, apc_param_t ckey, apc_param_
         wake_up( &wait->obj, 1 );
         if (list_empty( &completion->queue )) return;
     }
-    if (!list_empty( &completion->queue )) wake_up( &completion->obj, 0 );
+    if (!list_empty( &completion->queue ))
+    {
+        wake_up( &completion->obj, 0 );
+        set_inproc_event( completion->inproc_sync );
+    }
 }
 
 /* create a completion */
@@ -451,6 +470,7 @@ DECL_HANDLER(remove_completion)
         {
             if (do_esync()) esync_clear( completion->esync_fd );
             if (do_fsync()) fsync_clear( &completion->obj );
+            reset_inproc_event( completion->inproc_sync );
         }
     }
 

From 2999cc87f6b86ed4f4aea5636992ca9db4878a32 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 16:54:34 -0600
Subject: [PATCH 214/244] server: Create in-process synchronization objects for
 consoles.

---
 server/console.c | 64 ++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 59 insertions(+), 5 deletions(-)

diff --git a/server/console.c b/server/console.c
index 530ee31581f..7bee3435b6d 100644
--- a/server/console.c
+++ b/server/console.c
@@ -63,6 +63,7 @@ struct console
     struct fd                   *fd;            /* for bare console, attached input fd */
     struct async_queue           ioctl_q;       /* ioctl queue */
     struct async_queue           read_q;        /* read queue */
+    struct inproc_sync          *inproc_sync;   /* in-process synchronization object */
 };
 
 static void console_dump( struct object *obj, int verbose );
@@ -74,6 +75,7 @@ static struct object *console_lookup_name( struct object *obj, struct unicode_st
 static struct object *console_open_file( struct object *obj, unsigned int access,
                                          unsigned int sharing, unsigned int options );
 static int console_add_queue( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *console_get_inproc_sync( struct object *obj );
 
 static const struct object_ops console_ops =
 {
@@ -97,7 +99,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -230,6 +232,7 @@ static int screen_buffer_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *screen_buffer_get_fd( struct object *obj );
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
+static struct inproc_sync *screen_buffer_get_inproc_sync( struct object *obj );
 
 static const struct object_ops screen_buffer_ops =
 {
@@ -253,7 +256,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    screen_buffer_get_inproc_sync,    /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -321,6 +324,7 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
                                                unsigned int sharing, unsigned int options );
 static int console_input_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *console_input_get_fd( struct object *obj );
+static struct inproc_sync *console_input_get_inproc_sync( struct object *obj );
 static void console_input_destroy( struct object *obj );
 
 static const struct object_ops console_input_ops =
@@ -345,7 +349,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_input_get_inproc_sync,    /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -381,6 +385,7 @@ static int console_output_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *console_output_get_fd( struct object *obj );
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct inproc_sync *console_output_get_inproc_sync( struct object *obj );
 static void console_output_destroy( struct object *obj );
 
 static const struct object_ops console_output_ops =
@@ -405,7 +410,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_output_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -566,6 +571,7 @@ static struct object *create_console(void)
     console->server        = NULL;
     console->fd            = NULL;
     console->last_id       = 0;
+    console->inproc_sync     = NULL;
     init_async_queue( &console->ioctl_q );
     init_async_queue( &console->read_q );
 
@@ -795,6 +801,8 @@ static void console_destroy( struct object *obj )
     free_async_queue( &console->read_q );
     if (console->fd)
         release_object( console->fd );
+
+    if (console->inproc_sync) release_object( console->inproc_sync );
 }
 
 static struct object *create_console_connection( struct console *console )
@@ -848,6 +856,16 @@ static struct object *console_open_file( struct object *obj, unsigned int access
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_get_inproc_sync( struct object *obj )
+{
+    struct console *console = (struct console *)obj;
+
+    if (!console->inproc_sync)
+        console->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, console->signaled );
+    if (console->inproc_sync) grab_object( console->inproc_sync );
+    return console->inproc_sync;
+}
+
 static void screen_buffer_dump( struct object *obj, int verbose )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
@@ -897,6 +915,17 @@ static struct fd *screen_buffer_get_fd( struct object *obj )
     return NULL;
 }
 
+static struct inproc_sync *screen_buffer_get_inproc_sync( struct object *obj )
+{
+    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
+    if (!screen_buffer->input)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_inproc_sync( &screen_buffer->input->obj );
+}
+
 static void console_server_dump( struct object *obj, int verbose )
 {
     assert( obj->ops == &console_server_ops );
@@ -1469,6 +1498,16 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_input_get_inproc_sync( struct object *obj )
+{
+    if (!current->process->console)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_inproc_sync( &current->process->console->obj );
+}
+
 static void console_input_destroy( struct object *obj )
 {
     struct console_input *console_input = (struct console_input *)obj;
@@ -1541,6 +1580,16 @@ static struct object *console_output_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_output_get_inproc_sync( struct object *obj )
+{
+    if (!current->process->console || !current->process->console->active)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_inproc_sync( &current->process->console->obj );
+}
+
 static void console_output_destroy( struct object *obj )
 {
     struct console_output *console_output = (struct console_output *)obj;
@@ -1598,11 +1647,16 @@ DECL_HANDLER(get_next_console_request)
 
     if (!server->console->renderer) server->console->renderer = current;
 
-    if (!req->signal) server->console->signaled = 0;
+    if (!req->signal)
+    {
+        server->console->signaled = 0;
+        reset_inproc_event( server->console->inproc_sync );
+    }
     else if (!server->console->signaled)
     {
         server->console->signaled = 1;
         wake_up( &server->console->obj, 0 );
+        set_inproc_event( server->console->inproc_sync );
     }
 
     if (req->read)

From 81aa21b5f5a743a2eb7f9b2728777e5cb530084f Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:00:51 +0200
Subject: [PATCH 215/244] server: Create in-process synchronization objects for
 console servers.

---
 server/console.c | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/server/console.c b/server/console.c
index 7bee3435b6d..e173ad81206 100644
--- a/server/console.c
+++ b/server/console.c
@@ -146,6 +146,7 @@ struct console_server
     unsigned int          once_input : 1; /* flag if input thread has already been requested */
     int                   term_fd;     /* UNIX terminal fd */
     struct termios        termios;     /* original termios */
+    struct inproc_sync   *inproc_sync;    /* in-process synchronization object */
     int                   esync_fd;
     unsigned int          fsync_idx;
 };
@@ -160,6 +161,7 @@ static struct object *console_server_lookup_name( struct object *obj, struct uni
                                                 unsigned int attr, struct object *root );
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct inproc_sync *console_server_get_inproc_sync( struct object *obj );
 
 static const struct object_ops console_server_ops =
 {
@@ -183,7 +185,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_server_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -611,6 +613,7 @@ static int queue_host_ioctl( struct console_server *server, unsigned int code, u
     }
     list_add_tail( &server->queue, &ioctl->entry );
     wake_up( &server->obj, 0 );
+    set_inproc_event( server->inproc_sync );
     if (async) set_error( STATUS_PENDING );
     return 1;
 }
@@ -647,6 +650,7 @@ static void disconnect_console_server( struct console_server *server )
         server->console->server = NULL;
         server->console = NULL;
         wake_up( &server->obj, 0 );
+        set_inproc_event( server->inproc_sync );
     }
 }
 
@@ -940,6 +944,7 @@ static void console_server_destroy( struct object *obj )
     if (server->fd) release_object( server->fd );
     if (do_esync()) close( server->esync_fd );
     if (server->fsync_idx) fsync_free_shm_idx( server->fsync_idx );
+    if (server->inproc_sync) release_object( server->inproc_sync );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -1014,6 +1019,17 @@ static struct object *console_server_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_server_get_inproc_sync( struct object *obj )
+{
+    struct console_server *server = (struct console_server *)obj;
+    int signaled = !server->console || !list_empty( &server->queue );
+
+    if (!server->inproc_sync)
+        server->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, signaled );
+    if (server->inproc_sync) grab_object( server->inproc_sync );
+    return server->inproc_sync;
+}
+
 static struct object *create_console_server( void )
 {
     struct console_server *server;
@@ -1025,6 +1041,7 @@ static struct object *create_console_server( void )
     server->term_fd    = -1;
     list_init( &server->queue );
     list_init( &server->read_queue );
+    server->inproc_sync = NULL;
     server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT );
     if (!server->fd)
     {
@@ -1682,6 +1699,8 @@ DECL_HANDLER(get_next_console_request)
             fsync_clear( &server->obj );
         if (do_esync() && list_empty( &server->queue ))
             esync_clear( server->esync_fd );
+        if (list_empty( &server->queue ))
+            reset_inproc_event( server->inproc_sync );
     }
 
     if (ioctl)
@@ -1772,5 +1791,8 @@ DECL_HANDLER(get_next_console_request)
     if (do_esync() && list_empty( &server->queue ))
         esync_clear( server->esync_fd );
 
+    if (list_empty( &server->queue ))
+        reset_inproc_event( server->inproc_sync );
+
     release_object( server );
 }

From 9ccd6ae78cdeaa68611edde582219c62277fc86a Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:11:03 -0600
Subject: [PATCH 216/244] server: Create in-process synchronization objects for
 debug objects.

---
 server/debugger.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/server/debugger.c b/server/debugger.c
index 249c530e9b1..bb36c7aa51a 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -71,6 +71,7 @@ struct debug_obj
     struct object        obj;         /* object header */
     struct list          event_queue; /* pending events queue */
     unsigned int         flags;       /* debug flags */
+    struct inproc_sync  *inproc_sync; /* in-process synchronization object */
 };
 
 
@@ -107,6 +108,7 @@ static const struct object_ops debug_event_ops =
 
 static void debug_obj_dump( struct object *obj, int verbose );
 static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *debug_obj_get_inproc_sync( struct object *obj );
 static void debug_obj_destroy( struct object *obj );
 
 static const struct object_ops debug_obj_ops =
@@ -131,7 +133,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_inproc_sync,            /* get_inproc_sync */
+    debug_obj_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
@@ -259,6 +261,7 @@ static void link_event( struct debug_obj *debug_obj, struct debug_event *event )
         /* grab reference since debugger could be killed while trying to wake up */
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        set_inproc_event( debug_obj->inproc_sync );
         release_object( debug_obj );
     }
 }
@@ -271,6 +274,7 @@ static void resume_event( struct debug_obj *debug_obj, struct debug_event *event
     {
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        set_inproc_event( debug_obj->inproc_sync );
         release_object( debug_obj );
     }
 }
@@ -336,6 +340,17 @@ static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entr
     return find_event_to_send( debug_obj ) != NULL;
 }
 
+static struct inproc_sync *debug_obj_get_inproc_sync( struct object *obj )
+{
+    struct debug_obj *debug_obj = (struct debug_obj *)obj;
+    int signaled = find_event_to_send( debug_obj ) != NULL;
+
+    if (!debug_obj->inproc_sync)
+        debug_obj->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, signaled );
+    if (debug_obj->inproc_sync) grab_object( debug_obj->inproc_sync );
+    return debug_obj->inproc_sync;
+}
+
 static void debug_obj_destroy( struct object *obj )
 {
     struct list *ptr;
@@ -348,6 +363,8 @@ static void debug_obj_destroy( struct object *obj )
     /* free all pending events */
     while ((ptr = list_head( &debug_obj->event_queue )))
         unlink_event( debug_obj, LIST_ENTRY( ptr, struct debug_event, entry ));
+
+    if (debug_obj->inproc_sync) release_object( debug_obj->inproc_sync );
 }
 
 struct debug_obj *get_debug_obj( struct process *process, obj_handle_t handle, unsigned int access )
@@ -367,6 +384,7 @@ static struct debug_obj *create_debug_obj( struct object *root, const struct uni
         {
             debug_obj->flags = flags;
             list_init( &debug_obj->event_queue );
+            debug_obj->inproc_sync = NULL;
         }
     }
     return debug_obj;
@@ -575,6 +593,9 @@ DECL_HANDLER(wait_debug_event)
         reply->tid = get_thread_id( event->sender );
         alloc_event_handles( event, current->process );
         set_reply_data( &event->data, min( get_reply_max_size(), sizeof(event->data) ));
+
+        if (!find_event_to_send( debug_obj ))
+            reset_inproc_event( debug_obj->inproc_sync );
     }
     else
     {

From 9917f559098fa4b873586b60148df7f99d17ad72 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Wed, 10 Mar 2021 19:02:42 +0200
Subject: [PATCH 217/244] server: Create in-process synchronization objects for
 device managers.

---
 server/device.c | 31 +++++++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/server/device.c b/server/device.c
index 78a37ae3bc0..48969b91a1d 100644
--- a/server/device.c
+++ b/server/device.c
@@ -97,12 +97,14 @@ struct device_manager
     struct list            requests;       /* list of pending irps across all devices */
     struct irp_call       *current_call;   /* call currently executed on client side */
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
+    struct inproc_sync    *inproc_sync;    /* in-process synchronization object */
     int                    esync_fd;       /* esync file descriptor */
     unsigned int           fsync_idx;
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *device_manager_get_inproc_sync( struct object *obj );
 static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int device_manager_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void device_manager_destroy( struct object *obj );
@@ -129,7 +131,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    device_manager_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -436,7 +438,12 @@ static void add_irp_to_queue( struct device_manager *manager, struct irp_call *i
     irp->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     if (irp->file) list_add_tail( &irp->file->requests, &irp->dev_entry );
     list_add_tail( &manager->requests, &irp->mgr_entry );
-    if (list_head( &manager->requests ) == &irp->mgr_entry) wake_up( &manager->obj, 0 );  /* first one */
+    if (list_head( &manager->requests ) == &irp->mgr_entry)
+    {
+        /* first one */
+        wake_up( &manager->obj, 0 );
+        set_inproc_event( manager->inproc_sync );
+    }
 }
 
 static struct object *device_open_file( struct object *obj, unsigned int access,
@@ -776,6 +783,9 @@ static void delete_file( struct device_file *file )
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
 
+    if (list_empty( &file->device->manager->requests ))
+        reset_inproc_event( file->device->manager->inproc_sync );
+
     release_object( file );
 }
 
@@ -807,6 +817,16 @@ static int device_manager_signaled( struct object *obj, struct wait_queue_entry
     return !list_empty( &manager->requests );
 }
 
+static struct inproc_sync *device_manager_get_inproc_sync( struct object *obj )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+
+    if (!manager->inproc_sync)
+        manager->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, !list_empty( &manager->requests ) );
+    if (manager->inproc_sync) grab_object( manager->inproc_sync );
+    return manager->inproc_sync;
+}
+
 static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct device_manager *manager = (struct device_manager *)obj;
@@ -859,6 +879,8 @@ static void device_manager_destroy( struct object *obj )
     if (do_esync())
         close( manager->esync_fd );
     if (manager->fsync_idx) fsync_free_shm_idx( manager->fsync_idx );
+
+    if (manager->inproc_sync) release_object( manager->inproc_sync );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -868,6 +890,7 @@ static struct device_manager *create_device_manager(void)
     if ((manager = alloc_object( &device_manager_ops )))
     {
         manager->current_call = NULL;
+        manager->inproc_sync = NULL;
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
@@ -1064,6 +1087,10 @@ DECL_HANDLER(get_next_device_request)
                 }
                 list_remove( &irp->mgr_entry );
                 list_init( &irp->mgr_entry );
+
+                if (list_empty( &manager->requests ))
+                    reset_inproc_event( manager->inproc_sync );
+
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;

From 90dfae8f03563be49be3113de2afa21775f8dd74 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:13:20 -0600
Subject: [PATCH 218/244] server: Create in-process synchronization objects for
 keyed events.

---
 server/event.c | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/server/event.c b/server/event.c
index a9dc739a257..ef14582f1e0 100644
--- a/server/event.c
+++ b/server/event.c
@@ -118,10 +118,13 @@ struct type_descr keyed_event_type =
 struct keyed_event
 {
     struct object  obj;             /* object header */
+    struct inproc_sync *inproc_sync;/* in-process synchronization object */
 };
 
 static void keyed_event_dump( struct object *obj, int verbose );
 static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *keyed_event_get_inproc_sync( struct object *obj );
+static void keyed_event_destroy( struct object *obj );
 
 static const struct object_ops keyed_event_ops =
 {
@@ -145,9 +148,9 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
-    no_get_inproc_sync,          /* get_inproc_sync */
+    keyed_event_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,             /* close_handle */
-    no_destroy                   /* destroy */
+    keyed_event_destroy          /* destroy */
 };
 
 
@@ -336,6 +339,7 @@ struct keyed_event *create_keyed_event( struct object *root, const struct unicod
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
+            event->inproc_sync = NULL;
         }
     }
     return event;
@@ -379,6 +383,23 @@ static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *en
     return 0;
 }
 
+static struct inproc_sync *keyed_event_get_inproc_sync( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (!event->inproc_sync)
+        event->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, 1 );
+    if (event->inproc_sync) grab_object( event->inproc_sync );
+    return event->inproc_sync;
+}
+
+static void keyed_event_destroy( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (event->inproc_sync) release_object( event->inproc_sync );
+}
+
 /* create an event */
 DECL_HANDLER(create_event)
 {

From ad8c3248d931a0e0f09cdbe2c0640a17f5eaa439 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:16:53 +0200
Subject: [PATCH 219/244] server: Create in-process synchronization objects for
 processes.

---
 server/process.c | 16 +++++++++++++++-
 server/process.h |  1 +
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index bfa50cdfcb2..dde386f223b 100644
--- a/server/process.c
+++ b/server/process.c
@@ -96,6 +96,7 @@ static unsigned int process_map_access( struct object *obj, unsigned int access
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
+static struct inproc_sync *process_get_inproc_sync( struct object *obj );
 static void process_destroy( struct object *obj );
 static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int process_get_fsync_idx( struct object *obj, enum fsync_type *type );
@@ -124,7 +125,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_inproc_sync,          /* get_inproc_sync */
+    process_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -698,6 +699,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     process->rawinput_device_count = 0;
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
+    process->inproc_sync       = NULL;
     memset( &process->image_info, 0, sizeof(process->image_info) );
     process->esync_fd        = -1;
     process->fsync_idx       = 0;
@@ -813,6 +815,7 @@ static void process_destroy( struct object *obj )
         fsync_cleanup_process_shm_indices( process->id );
         fsync_free_shm_idx( process->fsync_idx );
     }
+    if (process->inproc_sync) release_object( process->inproc_sync );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -860,6 +863,16 @@ static struct list *process_get_kernel_obj_list( struct object *obj )
     return &process->kernel_object;
 }
 
+static struct inproc_sync *process_get_inproc_sync( struct object *obj )
+{
+    struct process *process = (struct process *)obj;
+
+    if (!process->inproc_sync)
+        process->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, !process->running_threads );
+    if (process->inproc_sync) grab_object( process->inproc_sync );
+    return process->inproc_sync;
+}
+
 static struct security_descriptor *process_get_sd( struct object *obj )
 {
     static struct security_descriptor *process_default_sd;
@@ -1024,6 +1037,7 @@ static void process_killed( struct process *process )
     release_job_process( process );
     start_sigkill_timer( process );
     wake_up( &process->obj, 0 );
+    set_inproc_event( process->inproc_sync );
 }
 
 /* add a thread to a process running threads list */
diff --git a/server/process.h b/server/process.h
index d2aadd521e8..25604958768 100644
--- a/server/process.h
+++ b/server/process.h
@@ -86,6 +86,7 @@ struct process
     struct list          rawinput_entry;  /* entry in the rawinput process list */
     struct list          kernel_object;   /* list of kernel object pointers */
     struct pe_image_info image_info;      /* main exe image info */
+    struct inproc_sync  *inproc_sync;     /* in-process synchronization object */
     int                  esync_fd;        /* esync file descriptor (signaled on exit) */
     unsigned int         fsync_idx;
     struct cpu_topology_override cpu_override; /* Overridden CPUs to host CPUs mapping. */

From 9e3257969b39154a21fbf8f1a246ae3e7036e465 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:17:35 -0600
Subject: [PATCH 220/244] server: Create in-process synchronization objects for
 jobs.

---
 server/process.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index dde386f223b..d2a0885ce7c 100644
--- a/server/process.c
+++ b/server/process.c
@@ -202,6 +202,7 @@ struct type_descr job_type =
 
 static void job_dump( struct object *obj, int verbose );
 static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *job_get_inproc_sync( struct object *obj );
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
@@ -219,6 +220,7 @@ struct job
     struct job *parent;
     struct list parent_job_entry;  /* list entry for parent job */
     struct list child_job_list;    /* list of child jobs */
+    struct inproc_sync *inproc_sync; /* in-process synchronization object */
 };
 
 static const struct object_ops job_ops =
@@ -243,7 +245,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_inproc_sync,            /* get_inproc_sync */
+    job_get_inproc_sync,           /* get_inproc_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
@@ -268,6 +270,7 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             job->completion_port = NULL;
             job->completion_key = 0;
             job->parent = NULL;
+            job->inproc_sync = NULL;
         }
     }
     return job;
@@ -424,6 +427,17 @@ static void terminate_job( struct job *job, int exit_code )
     job->terminating = 0;
     job->signaled = 1;
     wake_up( &job->obj, 0 );
+    set_inproc_event( job->inproc_sync );
+}
+
+static struct inproc_sync *job_get_inproc_sync( struct object *obj )
+{
+    struct job *job = (struct job *)obj;
+
+    if (!job->inproc_sync)
+        job->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, job->signaled );
+    if (job->inproc_sync) grab_object( job->inproc_sync );
+    return job->inproc_sync;
 }
 
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -454,6 +468,8 @@ static void job_destroy( struct object *obj )
         list_remove( &job->parent_job_entry );
         release_object( job->parent );
     }
+
+    if (job->inproc_sync) release_object( job->inproc_sync );
 }
 
 static void job_dump( struct object *obj, int verbose )

From 2be7abdae52b85bba220718cc1e9e9469ac892f4 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:24:15 +0200
Subject: [PATCH 221/244] server: Create in-process synchronization objects for
 message queues.

---
 server/queue.c | 46 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 43 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 6a28c3daac5..9e006690720 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -146,6 +146,7 @@ struct msg_queue
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
     const queue_shm_t     *shared;          /* queue in session shared memory */
+    struct inproc_sync    *inproc_sync;     /* in-process synchronization object */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
     unsigned int           fsync_idx;
@@ -169,6 +170,7 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
 static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int msg_queue_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *msg_queue_get_inproc_sync( struct object *obj );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
 static void thread_input_dump( struct object *obj, int verbose );
@@ -197,7 +199,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    msg_queue_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -338,6 +340,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
+        queue->inproc_sync     = NULL;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
         queue->fsync_idx       = 0;
@@ -764,7 +767,11 @@ static inline void set_queue_bits( struct msg_queue *queue, unsigned int bits )
     }
     SHARED_WRITE_END;
 
-    if (is_signaled( queue )) wake_up( &queue->obj, 0 );
+    if (is_signaled( queue ))
+    {
+        wake_up( &queue->obj, 0 );
+        set_inproc_event( queue->inproc_sync );
+    }
 }
 
 /* clear some queue bits */
@@ -1171,6 +1178,9 @@ static void reply_message( struct msg_queue *queue, lparam_t result,
         if (len && (res->data = memdup( data, len ))) res->data_size = len;
         store_message_result( res, result, error );
     }
+
+    if (!is_signaled( queue ))
+        reset_inproc_event( queue->inproc_sync );
 }
 
 static int match_window( user_handle_t win, user_handle_t msg_win )
@@ -1386,6 +1396,18 @@ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *en
         shared->changed_mask = 0;
     }
     SHARED_WRITE_END;
+
+    reset_inproc_event( queue->inproc_sync );
+}
+
+static struct inproc_sync *msg_queue_get_inproc_sync( struct object *obj )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+
+    if (!queue->inproc_sync)
+        queue->inproc_sync = create_inproc_event( INPROC_SYNC_QUEUE, is_signaled( queue ) );
+    if (queue->inproc_sync) grab_object( queue->inproc_sync );
+    return queue->inproc_sync;
 }
 
 static void msg_queue_destroy( struct object *obj )
@@ -1433,6 +1455,7 @@ static void msg_queue_destroy( struct object *obj )
     if (queue->shared) free_shared_object( queue->shared );
     if (do_esync()) close( queue->esync_fd );
     if (queue->fsync_idx) fsync_free_shm_idx( queue->fsync_idx );
+    if (queue->inproc_sync) release_object( queue->inproc_sync );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -1443,6 +1466,7 @@ static void msg_queue_poll_event( struct fd *fd, int event )
     if (event & (POLLERR | POLLHUP)) set_fd_events( fd, -1 );
     else set_fd_events( queue->fd, 0 );
     wake_up( &queue->obj, 0 );
+    set_inproc_event( queue->inproc_sync );
 }
 
 static void thread_input_dump( struct object *obj, int verbose )
@@ -3314,7 +3338,15 @@ DECL_HANDLER(set_queue_mask)
                 }
                 SHARED_WRITE_END;
             }
-            else wake_up( &queue->obj, 0 );
+            else
+            {
+                wake_up( &queue->obj, 0 );
+                set_inproc_event( queue->inproc_sync );
+            }
+        }
+        else
+        {
+            reset_inproc_event( queue->inproc_sync );
         }
 
         if (do_fsync() && !is_signaled( queue ))
@@ -3334,6 +3366,9 @@ DECL_HANDLER(get_queue_status)
     {
         const queue_shm_t *queue_shm = queue->shared;
 
+        if (!is_signaled( queue ))
+            reset_inproc_event( queue->inproc_sync );
+
         if (do_fsync() && !is_signaled( queue ))
             fsync_clear( &queue->obj );
 
@@ -3545,6 +3580,9 @@ DECL_HANDLER(get_message)
     }
     SHARED_WRITE_END;
 
+    if (!is_signaled( queue ))
+        reset_inproc_event( queue->inproc_sync );
+
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -3604,6 +3642,8 @@ DECL_HANDLER(get_message)
     }
     SHARED_WRITE_END;
 
+    reset_inproc_event( queue->inproc_sync );
+
     set_error( STATUS_PENDING );  /* FIXME */
 
     if (do_fsync() && !is_signaled( queue ))

From a6f07af656661b3b45d24bdcc640bb09fc28ad8a Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:26:35 +0200
Subject: [PATCH 222/244] server: Create in-process synchronization objects for
 threads.

---
 server/thread.c | 16 +++++++++++++++-
 server/thread.h |  1 +
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index 8fbfd553cc6..baf74aa6e56 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -190,6 +190,7 @@ static unsigned int thread_get_fsync_idx( struct object *obj, enum fsync_type *t
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
+static struct inproc_sync *thread_get_inproc_sync( struct object *obj );
 static void destroy_thread( struct object *obj );
 
 static const struct object_ops thread_ops =
@@ -214,7 +215,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_inproc_sync,         /* get_inproc_sync */
+    thread_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
@@ -312,6 +313,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->token           = NULL;
     thread->desc            = NULL;
     thread->desc_len        = 0;
+    thread->inproc_sync     = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -477,6 +479,16 @@ static struct list *thread_get_kernel_obj_list( struct object *obj )
     return &thread->kernel_object;
 }
 
+static struct inproc_sync *thread_get_inproc_sync( struct object *obj )
+{
+    struct thread *thread = (struct thread *)obj;
+
+    if (!thread->inproc_sync)
+        thread->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, thread->state == TERMINATED );
+    if (thread->inproc_sync) grab_object( thread->inproc_sync );
+    return thread->inproc_sync;
+}
+
 /* cleanup everything that is no longer needed by a dead thread */
 /* used by destroy_thread and kill_thread */
 static void cleanup_thread( struct thread *thread )
@@ -540,6 +552,7 @@ static void destroy_thread( struct object *obj )
         fsync_free_shm_idx( thread->fsync_idx );
         fsync_free_shm_idx( thread->fsync_apc_idx );
     }
+    if (thread->inproc_sync) release_object( thread->inproc_sync );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1475,6 +1488,7 @@ void kill_thread( struct thread *thread, int violent_death )
     if (do_esync())
         esync_abandon_mutexes( thread );
     wake_up( &thread->obj, 0 );
+    set_inproc_event( thread->inproc_sync );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
diff --git a/server/thread.h b/server/thread.h
index 057ad9ec2ae..0dae653dea4 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -97,6 +97,7 @@ struct thread
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
     struct completion_wait *completion_wait; /* completion port wait object the thread is associated with */
+    struct inproc_sync    *inproc_sync;   /* in-process synchronization object */
 };
 
 extern struct thread *current;

From 1439e9fcd50f4e2ec107623070569801292bd388 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:29:38 +0200
Subject: [PATCH 223/244] server: Create in-process synchronization objects for
 timers.

---
 server/timer.c | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/server/timer.c b/server/timer.c
index ca367a6fb7d..1050ac051b1 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -63,6 +63,7 @@ struct timer
     struct thread       *thread;    /* thread that set the APC function */
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
+    struct inproc_sync  *inproc_sync;   /* in-process synchronization object */
     int                  esync_fd;  /* esync file descriptor */
     unsigned int         fsync_idx; /* fsync shm index */
 };
@@ -72,6 +73,7 @@ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int timer_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *timer_get_inproc_sync( struct object *obj );
 static void timer_destroy( struct object *obj );
 
 static const struct object_ops timer_ops =
@@ -96,7 +98,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    timer_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
@@ -119,6 +121,7 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
+            timer->inproc_sync = NULL;
             timer->esync_fd = -1;
             timer->fsync_idx = 0;
 
@@ -168,6 +171,7 @@ static void timer_callback( void *private )
     /* wake up waiters */
     timer->signaled = 1;
     wake_up( &timer->obj, 0 );
+    set_inproc_event( timer->inproc_sync );
 }
 
 /* cancel a running timer */
@@ -204,6 +208,8 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
 
         if (do_esync())
             esync_clear( timer->esync_fd );
+
+        reset_inproc_event( timer->inproc_sync );
     }
     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
     timer->period   = period;
@@ -252,6 +258,19 @@ static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry
     if (!timer->manual) timer->signaled = 0;
 }
 
+static struct inproc_sync *timer_get_inproc_sync( struct object *obj )
+{
+    struct timer *timer = (struct timer *)obj;
+
+    if (!timer->inproc_sync)
+    {
+        enum inproc_sync_type type = timer->manual ? INPROC_SYNC_MANUAL_SERVER : INPROC_SYNC_AUTO_SERVER;
+        timer->inproc_sync = create_inproc_event( type, timer->signaled );
+    }
+    if (timer->inproc_sync) grab_object( timer->inproc_sync );
+    return timer->inproc_sync;
+}
+
 static void timer_destroy( struct object *obj )
 {
     struct timer *timer = (struct timer *)obj;
@@ -261,6 +280,7 @@ static void timer_destroy( struct object *obj )
     if (timer->thread) release_object( timer->thread );
     if (do_esync()) close( timer->esync_fd );
     if (timer->fsync_idx) fsync_free_shm_idx( timer->fsync_idx );
+    if (timer->inproc_sync) release_object( timer->inproc_sync );
 }
 
 /* create a timer */

From 453e2f8eb5e8be00b41ee647b6a83b107fef909b Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:40:57 -0600
Subject: [PATCH 224/244] server: Create in-process synchronization objects for
 fd-based objects.

---
 server/change.c     |  2 +-
 server/device.c     |  2 +-
 server/fd.c         | 27 ++++++++++++++++++++++++++-
 server/file.c       |  2 +-
 server/file.h       |  1 +
 server/mailslot.c   |  6 +++---
 server/named_pipe.c |  8 ++++----
 server/serial.c     |  2 +-
 server/sock.c       |  2 +-
 9 files changed, 39 insertions(+), 13 deletions(-)

diff --git a/server/change.c b/server/change.c
index f5129001836..5a9667eefcb 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,7 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
-    no_get_inproc_sync,       /* get_inproc_sync */
+    default_fd_get_inproc_sync, /* get_inproc_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 48969b91a1d..8c8e9f5e0ad 100644
--- a/server/device.c
+++ b/server/device.c
@@ -246,7 +246,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    default_fd_get_inproc_sync,       /* get_inproc_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 5d99eedd340..8e820606a25 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -156,6 +156,7 @@ struct fd
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
+    struct inproc_sync  *inproc_sync; /* in-process synchronization object */
     int                  esync_fd;    /* esync file descriptor */
     unsigned int         fsync_idx;   /* fsync shm index */
 };
@@ -1592,6 +1593,7 @@ static void fd_destroy( struct object *obj )
     if (do_esync())
         close( fd->esync_fd );
     if (fd->fsync_idx) fsync_free_shm_idx( fd->fsync_idx );
+    if (fd->inproc_sync) release_object( fd->inproc_sync );
 }
 
 /* check if the desired access is possible without violating */
@@ -1710,6 +1712,7 @@ static struct fd *alloc_fd_object(void)
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->inproc_sync = NULL;
     fd->esync_fd   = -1;
     fd->fsync_idx  = 0;
     init_async_queue( &fd->read_q );
@@ -1758,6 +1761,7 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->inproc_sync = NULL;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
     fd->esync_fd   = -1;
     fd->fsync_idx  = 0;
@@ -2216,7 +2220,15 @@ void set_fd_signaled( struct fd *fd, int signaled )
 {
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
-    if (signaled) wake_up( fd->user, 0 );
+    if (signaled)
+    {
+        wake_up( fd->user, 0 );
+        set_inproc_event( fd->inproc_sync );
+    }
+    else
+    {
+        reset_inproc_event( fd->inproc_sync );
+    }
 
     if (do_fsync() && !signaled)
         fsync_clear( fd->user );
@@ -2266,6 +2278,19 @@ unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type
     return ret;
 }
 
+struct inproc_sync *default_fd_get_inproc_sync( struct object *obj )
+{
+    struct fd *fd = get_obj_fd( obj );
+    struct inproc_sync *ret;
+
+    if (!fd->inproc_sync)
+        fd->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, fd->signaled );
+    ret = fd->inproc_sync;
+    release_object( fd );
+    if (ret) grab_object( ret );
+    return ret;
+}
+
 int default_fd_get_poll_events( struct fd *fd )
 {
     int events = 0;
diff --git a/server/file.c b/server/file.c
index 40ff667c98e..4af412d93c2 100644
--- a/server/file.c
+++ b/server/file.c
@@ -137,7 +137,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/file.h b/server/file.h
index e7c5a32bbb5..7fb1301970a 100644
--- a/server/file.h
+++ b/server/file.h
@@ -111,6 +111,7 @@ extern char *dup_fd_name( struct fd *root, const char *name ) __WINE_DEALLOC(fre
 extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
+extern struct inproc_sync *default_fd_get_inproc_sync( struct object *obj );
 extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
 extern unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type );
 extern int default_fd_get_poll_events( struct fd *fd );
diff --git a/server/mailslot.c b/server/mailslot.c
index f89778b924e..fef0ce25b4c 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -95,7 +95,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    default_fd_get_inproc_sync,/* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -159,7 +159,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
-    no_get_inproc_sync,         /* get_inproc_sync */
+    default_fd_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -260,7 +260,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
-    no_get_inproc_sync,                     /* get_inproc_sync */
+    default_fd_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index ad0c9f549a6..fbcd75321bc 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -187,7 +187,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -234,7 +234,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -318,7 +318,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    no_get_inproc_sync,                      /* get_inproc_sync */
+    default_fd_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
@@ -372,7 +372,7 @@ static const struct object_ops named_pipe_dir_ops =
     NULL,                                    /* unlink_name */
     named_pipe_dir_open_file,                /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    no_get_inproc_sync,                      /* get_inproc_sync */
+    default_fd_get_inproc_sync,              /* get_inproc_sync */
     named_pipe_dir_close_handle,             /* close_handle */
     named_pipe_dir_destroy                   /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 93619ebccde..c1bdfbbe2b5 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -105,7 +105,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 0e0bfd70793..51dd51bb353 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -485,7 +485,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };

From 7c06d170de46da818353baf0082a99657630fc42 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:46:06 -0600
Subject: [PATCH 225/244] server: Add a request to retrieve the in-process
 synchronization device.

---
 server/inproc_sync.c | 17 +++++++++++++++++
 server/protocol.def  |  6 ++++++
 2 files changed, 23 insertions(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 11c0a87d13f..feaa2ad8442 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -29,6 +29,8 @@
 #include "winternl.h"
 
 #include "file.h"
+#include "handle.h"
+#include "request.h"
 #include "thread.h"
 
 #ifdef HAVE_LINUX_NTSYNC_H
@@ -375,3 +377,18 @@ void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
 }
 
 #endif
+
+DECL_HANDLER(get_linux_sync_device)
+{
+#ifdef HAVE_LINUX_NTSYNC_H
+    struct linux_device *device;
+
+    if ((device = get_linux_device()))
+    {
+        reply->handle = alloc_handle_no_access_check( current->process, device, 0, 0 );
+        release_object( device );
+    }
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+#endif
+}
diff --git a/server/protocol.def b/server/protocol.def
index e240c4212db..8d7d5eba816 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4214,6 +4214,12 @@ enum inproc_sync_type
     INPROC_SYNC_QUEUE,
 };
 
+/* Obtain a handle to the ntsync device object */
+@REQ(get_linux_sync_device)
+@REPLY
+    obj_handle_t handle;          /* handle to the device */
+@END
+
 /* Create a new futex-based synchronization object */
 @REQ(create_fsync)
     unsigned int access;        /* wanted access rights */

From 312cf2ebbaa7bda226050679b36d6397671e24d7 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:55:00 -0600
Subject: [PATCH 226/244] server: Add a request to retrieve the in-process
 synchronization object from a handle.

---
 server/inproc_sync.c | 23 +++++++++++++++++++++++
 server/protocol.def  | 10 ++++++++++
 2 files changed, 33 insertions(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index feaa2ad8442..6cb02b16832 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -392,3 +392,26 @@ DECL_HANDLER(get_linux_sync_device)
     set_error( STATUS_NOT_IMPLEMENTED );
 #endif
 }
+
+DECL_HANDLER(get_linux_sync_obj)
+{
+#ifdef HAVE_LINUX_NTSYNC_H
+    struct object *obj;
+
+    if ((obj = get_handle_obj( current->process, req->handle, 0, NULL )))
+    {
+        struct inproc_sync *inproc_sync;
+
+        if ((inproc_sync = obj->ops->get_inproc_sync( obj )))
+        {
+            reply->handle = alloc_handle_no_access_check( current->process, inproc_sync, 0, 0 );
+            reply->type = inproc_sync->type;
+            reply->access = get_handle_access( current->process, req->handle );
+            release_object( inproc_sync );
+        }
+        release_object( obj );
+    }
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+#endif
+}
diff --git a/server/protocol.def b/server/protocol.def
index 8d7d5eba816..d601aba464b 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4267,3 +4267,13 @@ enum inproc_sync_type
     unsigned int shm_idx;
 @REPLY
 @END
+
+
+/* Get the in-process synchronization object associated with the given handle */
+@REQ(get_linux_sync_obj)
+    obj_handle_t handle;          /* handle to the object */
+@REPLY
+    obj_handle_t handle;          /* handle to the fast synchronization object */
+    int          type;            /* object type */
+    unsigned int access;          /* handle access rights */
+@END

From 4ac1a96acbf14e258d7d1585a0e5c3723b72e3ca Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 19:32:25 +0200
Subject: [PATCH 227/244] server: Introduce select_inproc_queue and
 unselect_inproc_queue requests.

---
 server/protocol.def | 11 +++++++++++
 server/queue.c      | 44 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index d601aba464b..47f22ede411 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4277,3 +4277,14 @@ enum inproc_sync_type
     int          type;            /* object type */
     unsigned int access;          /* handle access rights */
 @END
+
+
+/* Begin a client-side wait on a message queue */
+@REQ(select_inproc_queue)
+@END
+
+
+/* End a client-side wait on a message queue */
+@REQ(unselect_inproc_queue)
+    int          signaled;        /* was the queue signaled? */
+@END
diff --git a/server/queue.c b/server/queue.c
index 9e006690720..c13fbc1ac23 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -146,6 +146,7 @@ struct msg_queue
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
     const queue_shm_t     *shared;          /* queue in session shared memory */
+    int                    in_inproc_wait;  /* are we in a client-side wait? */
     struct inproc_sync    *inproc_sync;     /* in-process synchronization object */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
@@ -340,6 +341,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
+        queue->in_inproc_wait  = 0;
         queue->inproc_sync     = NULL;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
@@ -1317,6 +1319,9 @@ static int is_queue_hung( struct msg_queue *queue )
     if (do_esync() && queue->esync_in_msgwait)
         return 0;   /* thread is waiting on queue in absentia -> not hung */
 
+    if (queue->in_inproc_wait)
+        return 0;  /* thread is waiting on queue in absentia -> not hung */
+
     return 1;
 }
 
@@ -4439,6 +4444,45 @@ DECL_HANDLER(update_rawinput_devices)
     }
 }
 
+DECL_HANDLER(select_inproc_queue)
+{
+    struct msg_queue *queue = current->queue;
+
+    if (queue->in_inproc_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        check_thread_queue_idle( current );
+
+        if (queue->fd)
+            set_fd_events( queue->fd, POLLIN );
+
+        queue->in_inproc_wait = 1;
+    }
+}
+
+DECL_HANDLER(unselect_inproc_queue)
+{
+    struct msg_queue *queue = current->queue;
+
+    if (!queue->in_inproc_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (queue->fd)
+            set_fd_events( queue->fd, 0 );
+
+        if (req->signaled)
+            msg_queue_satisfied( &queue->obj, NULL );
+
+        queue->in_inproc_wait = 0;
+    }
+}
+
 DECL_HANDLER(set_keyboard_repeat)
 {
     struct desktop *desktop;

From 067baa57fe07db55e8a3a017f5a59d6c7243936f Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 22 Apr 2022 00:11:14 +0300
Subject: [PATCH 228/244] server: Allow creating an event object for
 client-side user APC signaling.

---
 server/protocol.def |  7 +++++++
 server/thread.c     | 19 +++++++++++++++++++
 server/thread.h     |  1 +
 3 files changed, 27 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index 47f22ede411..fe3b9e6a461 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4288,3 +4288,10 @@ enum inproc_sync_type
 @REQ(unselect_inproc_queue)
     int          signaled;        /* was the queue signaled? */
 @END
+
+
+/* Get an event handle to be used for thread alerts with in-process synchronization */
+@REQ(get_inproc_alert_event)
+@REPLY
+    obj_handle_t handle;          /* handle to the event */
+@END
diff --git a/server/thread.c b/server/thread.c
index baf74aa6e56..5475dd88b78 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -314,6 +314,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->desc            = NULL;
     thread->desc_len        = 0;
     thread->inproc_sync     = NULL;
+    thread->inproc_alert_event = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -553,6 +554,7 @@ static void destroy_thread( struct object *obj )
         fsync_free_shm_idx( thread->fsync_apc_idx );
     }
     if (thread->inproc_sync) release_object( thread->inproc_sync );
+    if (thread->inproc_alert_event) release_object( thread->inproc_alert_event );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1334,6 +1336,9 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
 
         if (do_esync() && queue == &thread->user_apc)
             esync_wake_fd( thread->esync_apc_fd );
+
+        if (apc->call.type == APC_USER && thread->inproc_alert_event)
+            set_event( thread->inproc_alert_event );
     }
 
     return 1;
@@ -1366,6 +1371,8 @@ void thread_cancel_apc( struct thread *thread, struct object *owner, enum apc_ty
         apc->executed = 1;
         wake_up( &apc->obj, 0 );
         release_object( apc );
+        if (list_empty( &thread->user_apc ) && thread->inproc_alert_event)
+            reset_event( thread->inproc_alert_event );
         return;
     }
 }
@@ -1380,6 +1387,9 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system
     {
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
+
+        if (list_empty( &thread->user_apc ) && thread->inproc_alert_event)
+            reset_event( thread->inproc_alert_event );
     }
 
     if (do_fsync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
@@ -2286,3 +2296,12 @@ DECL_HANDLER(get_next_thread)
     set_error( STATUS_NO_MORE_ENTRIES );
     release_object( process );
 }
+
+DECL_HANDLER(get_inproc_alert_event)
+{
+    if (!current->inproc_alert_event)
+        current->inproc_alert_event = create_event( NULL, NULL, 0, 1, !list_empty( &current->user_apc ), NULL );
+
+    if (current->inproc_alert_event)
+        reply->handle = alloc_handle( current->process, current->inproc_alert_event, SYNCHRONIZE, 0 );
+}
diff --git a/server/thread.h b/server/thread.h
index 0dae653dea4..4384b79483b 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -98,6 +98,7 @@ struct thread
     WCHAR                 *desc;          /* thread description string */
     struct completion_wait *completion_wait; /* completion port wait object the thread is associated with */
     struct inproc_sync    *inproc_sync;   /* in-process synchronization object */
+    struct event          *inproc_alert_event; /* in-process synchronization alert event */
 };
 
 extern struct thread *current;

From 1903eaa57ec718eb909bdd925556bf2d935c5f27 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 02:07:23 +0200
Subject: [PATCH 229/244] ntdll: Introduce a helper to wait on an internal
 server handle.

---
 dlls/ntdll/unix/file.c         |  2 +-
 dlls/ntdll/unix/process.c      |  2 +-
 dlls/ntdll/unix/server.c       | 17 ++++++++++++++++-
 dlls/ntdll/unix/thread.c       |  2 +-
 dlls/ntdll/unix/unix_private.h |  1 +
 5 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 89aedd2b05c..0754a931d5a 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -7038,7 +7038,7 @@ NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void
         }
         if (handle)
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index a4957342027..4b1d8e6f1bc 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -920,7 +920,7 @@ NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_
 
     /* wait for the new process info to be ready */
 
-    NtWaitForSingleObject( process_info, FALSE, NULL );
+    server_wait_for_object( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index c35cf741211..388e5e80c63 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -820,6 +820,21 @@ unsigned int server_wait( const union select_op *select_op, data_size_t size, UI
 }
 
 
+/* helper function to perform a server-side wait on an internal handle without
+ * using the fast synchronization path */
+unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout )
+{
+    union select_op select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+
+    select_op.wait.op = SELECT_WAIT;
+    select_op.wait.handles[0] = wine_server_obj_handle( handle );
+    return server_wait( &select_op, offsetof( union select_op, wait.handles[1] ), flags, timeout );
+}
+
+
 /***********************************************************************
  *              NtContinue  (NTDLL.@)
  */
@@ -896,7 +911,7 @@ unsigned int server_queue_process_apc( HANDLE process, const union apc_call *cal
         }
         else
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 5edca5fcf94..95d3a49b1a0 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1846,7 +1846,7 @@ NTSTATUS get_thread_context( HANDLE handle, void *context, BOOL *self, USHORT ma
 
     if (ret == STATUS_PENDING)
     {
-        NtWaitForSingleObject( context_handle, FALSE, NULL );
+        server_wait_for_object( context_handle, FALSE, NULL );
 
         SERVER_START_REQ( get_thread_context )
         {
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index afae39def06..2c4befe18a9 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -227,6 +227,7 @@ extern unsigned int server_select( const union select_op *select_op, data_size_t
                                    timeout_t abs_timeout, struct context_data *context, struct user_apc *user_apc );
 extern unsigned int server_wait( const union select_op *select_op, data_size_t size, UINT flags,
                                  const LARGE_INTEGER *timeout );
+extern unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout );
 extern NTSTATUS wait_internal_server( HANDLE handle, BOOLEAN alertable, const LARGE_INTEGER *timeout );
 extern unsigned int server_queue_process_apc( HANDLE process, const union apc_call *call,
                                               union apc_result *result );

From ca0684c0f96a4dab3fa40f44acec083f45e0db89 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 20:08:29 +0200
Subject: [PATCH 230/244] ntdll: Add some traces to synchronization methods.

Normally we can rely on +server for these, but with fast synchronization we'll
be skipping the server.
---
 dlls/ntdll/unix/sync.c | 58 ++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 56 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 47fd5b24c46..0fa08dfdc94 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -76,7 +76,8 @@ HANDLE keyed_event = 0;
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
 {
     if (!timeout) return "(infinite)";
-    return wine_dbgstr_longlong( timeout->QuadPart );
+    return wine_dbg_sprintf( "%lld.%07ld", (long long)(timeout->QuadPart / TICKSPERSEC),
+                             (long)(timeout->QuadPart % TICKSPERSEC) );
 }
 
 /* return a monotonic time counter, in Win32 ticks */
@@ -313,6 +314,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, initial %d, max %d\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", (int)initial, (int)max );
+
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
 
@@ -347,6 +351,8 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
 
     if (do_fsync())
@@ -425,6 +431,8 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
     if (do_esync())
         return esync_release_semaphore( handle, count, previous );
 
+    TRACE( "handle %p, count %u, prev_count %p\n", handle, (int)count, previous );
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -449,6 +457,9 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u, state %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type, state );
+
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
 
@@ -483,6 +494,8 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -521,6 +534,8 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
     if (do_esync())
         return esync_set_event( handle );
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -548,6 +563,8 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
         return esync_reset_event( handle );
 
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -583,6 +600,8 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
     if (do_esync())
         return esync_pulse_event( handle );
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -645,6 +664,9 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, owned %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", owned );
+
     *handle = 0;
 
     if (do_fsync())
@@ -677,6 +699,8 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -714,6 +738,8 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
     if (do_esync())
         return esync_release_mutex( handle, prev_count );
 
+    TRACE( "handle %p, prev_count %p\n", handle, prev_count );
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1519,6 +1545,9 @@ NTSTATUS WINAPI NtCreateTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type );
+
     *handle = 0;
     if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -1546,6 +1575,8 @@ NTSTATUS WINAPI NtOpenTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -1599,6 +1630,8 @@ NTSTATUS WINAPI NtCancelTimer( HANDLE handle, BOOLEAN *state )
 {
     unsigned int ret;
 
+    TRACE( "handle %p, state %p\n", handle, state );
+
     SERVER_START_REQ( cancel_timer )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1667,6 +1700,7 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
 {
     union select_op select_op;
     UINT i, flags = SELECT_INTERRUPTIBLE;
+    unsigned int ret;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
@@ -1684,10 +1718,19 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
             return ret;
     }
 
+    if (TRACE_ON(sync))
+    {
+        TRACE( "wait_any %u, alertable %u, handles {%p", wait_any, alertable, handles[0] );
+        for (i = 1; i < count; i++) TRACE( ", %p", handles[i] );
+        TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    return server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
+    ret = server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
+    TRACE( "-> %#x\n", ret );
+    return ret;
 }
 
 
@@ -1725,6 +1768,8 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
     if (do_esync())
         return esync_signal_and_wait( signal, wait, alertable, timeout );
 
+    TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
+
     if (!signal) return STATUS_INVALID_HANDLE;
 
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -1976,6 +2021,9 @@ NTSTATUS WINAPI NtCreateKeyedEvent( HANDLE *handle, ACCESS_MASK access,
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, flags %#x\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", (int)flags );
+
     *handle = 0;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -2000,6 +2048,8 @@ NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE *handle, ACCESS_MASK access, const OBJE
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -2026,6 +2076,8 @@ NTSTATUS WINAPI NtWaitForKeyedEvent( HANDLE handle, const void *key,
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -2045,6 +2097,8 @@ NTSTATUS WINAPI NtReleaseKeyedEvent( HANDLE handle, const void *key,
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;

From ed42f7641ee7b7e60eef7701c260ed64eaa85ea3 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 6 Apr 2021 23:37:02 +0300
Subject: [PATCH 231/244] ntdll: Use in-process synchronization objects.

---
 dlls/ntdll/unix/sync.c         | 760 +++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/unix_private.h |   2 +
 dlls/ntdll/unix/virtual.c      |   1 +
 3 files changed, 763 insertions(+)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 0fa08dfdc94..3924699fea1 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -30,9 +30,11 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
 #include <limits.h>
 #include <signal.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
 #include <sys/mman.h>
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
@@ -48,6 +50,7 @@
 #endif
 #include <string.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -57,6 +60,9 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
+#ifdef HAVE_LINUX_NTSYNC_H
+# include <linux/ntsync.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -304,6 +310,717 @@ static unsigned int validate_open_object_attributes( const OBJECT_ATTRIBUTES *at
 }
 
 
+#ifdef HAVE_LINUX_NTSYNC_H
+
+static int get_linux_sync_device(void)
+{
+    static LONG device = -2;
+
+    if (device == -2)
+    {
+        HANDLE handle;
+        int fd, needs_close;
+        NTSTATUS ret;
+
+        SERVER_START_REQ( get_linux_sync_device )
+        {
+            if (!(ret = wine_server_call( req ))) handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if (!ret)
+        {
+            if (!server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL ))
+            {
+                if (InterlockedCompareExchange( &device, fd, -2 ) != -2)
+                {
+                    /* someone beat us to it */
+                    if (needs_close) close( fd );
+                    NtClose( handle );
+                }
+                /* otherwise don't close the device */
+            }
+            else
+            {
+                InterlockedCompareExchange( &device, -1, -2 );
+                NtClose( handle );
+            }
+        }
+        else
+        {
+            InterlockedCompareExchange( &device, -1, -2 );
+        }
+    }
+    return device;
+}
+
+/* It's possible for synchronization primitives to remain alive even after being
+ * closed, because a thread is still waiting on them. It's rare in practice, and
+ * documented as being undefined behaviour by Microsoft, but it works, and some
+ * applications rely on it. This means we need to refcount handles, and defer
+ * deleting them on the server side until the refcount reaches zero. We do this
+ * by having each client process hold a handle to the in-process synchronization
+ * object, as well as a private refcount. When the client refcount reaches zero,
+ * it closes the handle; when all handles are closed, the server deletes the
+ * in-process synchronization object.
+ *
+ * We want lookup of objects from the cache to be very fast; ideally, it should
+ * be lock-free. We achieve this by using atomic modifications to "refcount",
+ * and guaranteeing that all other fields are valid and correct *as long as*
+ * refcount is nonzero, and we store the entire structure in memory which will
+ * never be freed.
+ *
+ * This means that acquiring the object can't use a simple atomic increment; it
+ * has to use a compare-and-swap loop to ensure that it doesn't try to increment
+ * an object with a zero refcount. That's still leagues better than a real lock,
+ * though, and release can be a single atomic decrement.
+ *
+ * It also means that threads modifying the cache need to take a lock, to
+ * prevent other threads from writing to it concurrently.
+ *
+ * It's possible for an object currently in use (by a waiter) to be closed and
+ * the same handle immediately reallocated to a different object. This should be
+ * a very rare situation, and in that case we simply don't cache the handle.
+ */
+struct inproc_sync_cache_entry
+{
+    LONG refcount;
+    int fd;
+    enum inproc_sync_type type;
+    unsigned int access;
+    BOOL closed;
+    /* handle to the underlying in-process sync object, stored as obj_handle_t
+     * to save space */
+    obj_handle_t handle;
+};
+
+
+static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
+{
+    /* save the handle and fd now; as soon as the refcount hits 0 we cannot
+     * access the cache anymore */
+    HANDLE handle = wine_server_ptr_handle( cache->handle );
+    int fd = cache->fd;
+    LONG refcount = InterlockedDecrement( &cache->refcount );
+
+    assert( refcount >= 0 );
+
+    if (!refcount)
+    {
+        NTSTATUS ret = NtClose( handle );
+        assert( !ret );
+        close( fd );
+    }
+}
+
+
+static BOOL inproc_sync_types_match( enum inproc_sync_type a, enum inproc_sync_type b )
+{
+    if (a == b) return TRUE;
+    if (a == INPROC_SYNC_AUTO_EVENT && b == INPROC_SYNC_MANUAL_EVENT) return TRUE;
+    if (b == INPROC_SYNC_AUTO_EVENT && a == INPROC_SYNC_MANUAL_EVENT) return TRUE;
+    return FALSE;
+}
+
+
+/* returns a pointer to a cache entry; if the object could not be cached,
+ * returns "stack_cache" instead, which should be allocated on stack */
+static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desired_type,
+                                     ACCESS_MASK desired_access,
+                                     struct inproc_sync_cache_entry *stack_cache,
+                                     struct inproc_sync_cache_entry **ret_cache )
+{
+    struct inproc_sync_cache_entry *cache = stack_cache;
+    int needs_close;
+    NTSTATUS ret;
+
+    *ret_cache = stack_cache;
+
+    SERVER_START_REQ( get_linux_sync_obj )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            cache->handle = reply->handle;
+            cache->access = reply->access;
+            cache->type = reply->type;
+            cache->refcount = 1;
+            cache->closed = FALSE;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret) return ret;
+
+    if ((ret = server_get_unix_fd( wine_server_ptr_handle( cache->handle ),
+                                   0, &cache->fd, &needs_close, NULL, NULL )))
+        return ret;
+
+    if (desired_type && !inproc_sync_types_match( cache->type, desired_type ))
+    {
+        release_inproc_sync_obj( cache );
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((cache->access & desired_access) != desired_access)
+    {
+        release_inproc_sync_obj( cache );
+        return STATUS_ACCESS_DENIED;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
+{
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_SEM_RELEASE, &count );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_SEMAPHORE,
+                                    SEMAPHORE_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_semaphore_obj( cache->fd, count, prev_count );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_semaphore_obj( int obj, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct ntsync_sem_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_SEM_READ, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->CurrentCount = args.count;
+    info->MaximumCount = args.max;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_SEMAPHORE,
+                                    SEMAPHORE_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_semaphore_obj( cache->fd, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_set_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_SET, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_set_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_reset_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_RESET, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_reset_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_pulse_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_PULSE, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_pulse_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_event_obj( int obj, enum inproc_sync_type type, EVENT_BASIC_INFORMATION *info )
+{
+    struct ntsync_event_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_READ, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->EventType = (type == INPROC_SYNC_AUTO_EVENT) ? SynchronizationEvent : NotificationEvent;
+    info->EventState = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_event_obj( cache->fd, cache->type, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_release_mutex_obj( int obj, LONG *prev_count )
+{
+    struct ntsync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.owner = GetCurrentThreadId();
+    ret = ioctl( obj, NTSYNC_IOC_MUTEX_UNLOCK, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_MUTANT_LIMIT_EXCEEDED;
+        else if (errno == EPERM)
+            return STATUS_MUTANT_NOT_OWNED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_MUTEX, 0, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_mutex_obj( cache->fd, prev_count );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_mutex_obj( int obj, MUTANT_BASIC_INFORMATION *info )
+{
+    struct ntsync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_MUTEX_READ, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOWNERDEAD)
+        {
+            info->AbandonedState = TRUE;
+            info->OwnedByCaller = FALSE;
+            info->CurrentCount = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    info->AbandonedState = FALSE;
+    info->OwnedByCaller = (args.owner == GetCurrentThreadId());
+    info->CurrentCount = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_MUTEX, MUTANT_QUERY_STATE,
+                                    &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_mutex_obj( cache->fd, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+static void select_queue(void)
+{
+    SERVER_START_REQ( select_inproc_queue )
+    {
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static void unselect_queue( BOOL signaled )
+{
+    SERVER_START_REQ( unselect_inproc_queue )
+    {
+        req->signaled = signaled;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static int get_inproc_alert_obj(void)
+{
+    struct ntdll_thread_data *data = ntdll_get_thread_data();
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    HANDLE alert_handle;
+    unsigned int ret;
+
+    if (data->linux_alert_obj == -1)
+    {
+        SERVER_START_REQ( get_inproc_alert_event )
+        {
+            if ((ret = wine_server_call( req )))
+                ERR( "failed to get inproc alert event, status %#x\n", ret );
+            alert_handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if ((ret = get_inproc_sync_obj( alert_handle, 0, SYNCHRONIZE, &stack_cache, &cache )))
+            ERR( "failed to get inproc alert obj, status %#x\n", ret );
+        data->linux_alert_obj = cache->fd;
+        /* Set the fd to -1 so release_inproc_sync_obj() won't close it.
+         * Manhandling the cache entry here is fine since we're the only thread
+         * that can access our own alert event. */
+        cache->fd = -1;
+        release_inproc_sync_obj( cache );
+        NtClose( alert_handle );
+    }
+
+    return data->linux_alert_obj;
+}
+
+static NTSTATUS linux_wait_objs( int device, const DWORD count, const int *objs,
+                                 BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct ntsync_wait_args args = {0};
+    unsigned long request;
+    struct timespec now;
+    int ret;
+
+    if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)
+    {
+        args.timeout = ~(__u64)0;
+    }
+    else if (timeout->QuadPart <= 0)
+    {
+        clock_gettime( CLOCK_MONOTONIC, &now );
+        args.timeout = (now.tv_sec * NSECPERSEC) + now.tv_nsec + (-timeout->QuadPart * 100);
+    }
+    else
+    {
+        args.timeout = (timeout->QuadPart * 100) - (SECS_1601_TO_1970 * NSECPERSEC);
+        args.flags |= NTSYNC_WAIT_REALTIME;
+    }
+
+    args.objs = (uintptr_t)objs;
+    args.count = count;
+    args.owner = GetCurrentThreadId();
+    args.index = ~0u;
+
+    if (alertable)
+        args.alert = get_inproc_alert_obj();
+
+    if (wait_any || count == 1)
+        request = NTSYNC_IOC_WAIT_ANY;
+    else
+        request = NTSYNC_IOC_WAIT_ALL;
+
+    do
+    {
+        ret = ioctl( device, request, &args );
+    } while (ret < 0 && errno == EINTR);
+
+    if (!ret)
+    {
+        if (args.index == count)
+        {
+            static const LARGE_INTEGER timeout;
+
+            ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &timeout );
+            assert( ret == STATUS_USER_APC );
+            return ret;
+        }
+
+        return wait_any ? args.index : 0;
+    }
+    else if (errno == EOWNERDEAD)
+        return STATUS_ABANDONED + (wait_any ? args.index : 0);
+    else if (errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    else
+        return errno_to_status( errno );
+}
+
+static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct inproc_sync_cache_entry stack_cache[64], *cache[64];
+    int device, objs[64];
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    DWORD i, j;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    for (i = 0; i < count; ++i)
+    {
+        if ((ret = get_inproc_sync_obj( handles[i], 0, SYNCHRONIZE, &stack_cache[i], &cache[i] )))
+        {
+            for (j = 0; j < i; ++j)
+                release_inproc_sync_obj( cache[j] );
+            return ret;
+        }
+        if (cache[i]->type == INPROC_SYNC_QUEUE)
+            queue = handles[i];
+
+        objs[i] = cache[i]->fd;
+    }
+
+    if (queue) select_queue();
+
+    ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );
+
+    if (queue) unselect_queue( handles[ret] == queue );
+
+    for (i = 0; i < count; ++i)
+        release_inproc_sync_obj( cache[i] );
+
+    return ret;
+}
+
+static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
+                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct inproc_sync_cache_entry signal_stack_cache, *signal_cache;
+    struct inproc_sync_cache_entry wait_stack_cache, *wait_cache;
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_inproc_sync_obj( signal, 0, 0, &signal_stack_cache, &signal_cache )))
+        return ret;
+
+    switch (signal_cache->type)
+    {
+        case INPROC_SYNC_SEMAPHORE:
+            if (!(signal_cache->access & SEMAPHORE_MODIFY_STATE))
+            {
+                release_inproc_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_MANUAL_EVENT:
+            if (!(signal_cache->access & EVENT_MODIFY_STATE))
+            {
+                release_inproc_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case INPROC_SYNC_MUTEX:
+            break;
+
+        default:
+            /* can't be signaled */
+            release_inproc_sync_obj( signal_cache );
+            return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((ret = get_inproc_sync_obj( wait, 0, SYNCHRONIZE, &wait_stack_cache, &wait_cache )))
+    {
+        release_inproc_sync_obj( signal_cache );
+        return ret;
+    }
+
+    if (wait_cache->type == INPROC_SYNC_QUEUE)
+        queue = wait;
+
+    switch (signal_cache->type)
+    {
+        case INPROC_SYNC_SEMAPHORE:
+            ret = linux_release_semaphore_obj( signal_cache->fd, 1, NULL );
+            break;
+
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_MANUAL_EVENT:
+            ret = linux_set_event_obj( signal_cache->fd, NULL );
+            break;
+
+        case INPROC_SYNC_MUTEX:
+            ret = linux_release_mutex_obj( signal_cache->fd, NULL );
+            break;
+
+        default:
+            assert( 0 );
+            break;
+    }
+
+    if (!ret)
+    {
+        if (queue) select_queue();
+        ret = linux_wait_objs( device, 1, &wait_cache->fd, TRUE, alertable, timeout );
+        if (queue) unselect_queue( !ret );
+    }
+
+    release_inproc_sync_obj( signal_cache );
+    release_inproc_sync_obj( wait_cache );
+    return ret;
+}
+
+#else
+
+static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
+                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
+
+
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
  */
@@ -403,6 +1120,12 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
     if (do_esync())
         return esync_query_semaphore( handle, info, ret_len );
 
+    if ((ret = inproc_query_semaphore( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -433,6 +1156,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 
     TRACE( "handle %p, count %u, prev_count %p\n", handle, (int)count, previous );
 
+    if ((ret = inproc_release_semaphore( handle, count, previous )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -536,6 +1262,9 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_set_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -565,6 +1294,9 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_reset_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -602,6 +1334,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_pulse_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -639,6 +1374,12 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
     if (do_esync())
         return esync_query_event( handle, info, ret_len );
 
+    if ((ret = inproc_query_event( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_event )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -740,6 +1481,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 
     TRACE( "handle %p, prev_count %p\n", handle, prev_count );
 
+    if ((ret = inproc_release_mutex( handle, prev_count )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -776,6 +1520,12 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
     if (do_esync())
         return esync_query_mutex( handle, info, ret_len );
 
+    if ((ret = inproc_query_mutex( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1725,6 +2475,12 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
         TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
     }
 
+    if ((ret = inproc_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+    {
+        TRACE( "-> %#x\n", ret );
+        return ret;
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
@@ -1761,6 +2517,7 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 {
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
     if (do_fsync())
         return fsync_signal_and_wait( signal, wait, alertable, timeout );
@@ -1772,6 +2529,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 
     if (!signal) return STATUS_INVALID_HANDLE;
 
+    if ((ret = inproc_signal_and_wait( signal, wait, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
     select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 2c4befe18a9..3a3711d0b85 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -114,6 +114,7 @@ struct ntdll_thread_data
     PRTL_THREAD_START_ROUTINE start;  /* thread entry point */
     void              *param;         /* thread entry point parameter */
     void              *jmp_buf;       /* setjmp buffer for exception handling */
+    int                linux_alert_obj; /* fd for the linux in-process alert event */
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
@@ -411,6 +412,7 @@ extern void call_raise_user_exception_dispatcher(void);
 extern const char * wine_debuginfostr_pc(void *pc);
 
 #define TICKSPERSEC 10000000
+#define NSECPERSEC 1000000000
 #define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)86400)
 
 static inline ULONGLONG ticks_from_time_t( time_t time )
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 355a88986a3..8c8a8369ac2 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -4175,6 +4175,7 @@ static TEB *init_teb( void *ptr, BOOL is_wow )
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
     thread_data->wait_fd[1] = -1;
+    thread_data->linux_alert_obj = -1;
     list_add_head( &teb_list, &thread_data->entry );
     return teb;
 }

From 74752cf4579b532c70513072e0dca5c805f5b059 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 20 Apr 2021 17:55:59 -0500
Subject: [PATCH 232/244] ntdll: Use server_wait_for_object() when waiting on
 only the queue object.

---
 dlls/ntdll/unix/sync.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 3924699fea1..3300f3d56cb 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -868,6 +868,17 @@ static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_an
         objs[i] = cache[i]->fd;
     }
 
+    /* It's common to wait on the message queue alone. Some applications wait
+     * on it in fast paths, with a zero timeout. Since we take two server calls
+     * instead of one when going through inproc_wait(), and since we only need
+     * to go through that path if we're waiting on other objects, just delegate
+     * to the server if we're only waiting on the message queue. */
+    if (count == 1 && queue)
+    {
+        release_inproc_sync_obj( cache[0] );
+        return server_wait_for_object( handles[0], alertable, timeout );
+    }
+
     if (queue) select_queue();
 
     ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );

From 0d4ef5eec591d25d9dccb68d1d6e2c50864c5eb5 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 12 Mar 2021 23:04:17 +0200
Subject: [PATCH 233/244] ntdll: Cache in-process synchronization objects.

---
 dlls/ntdll/unix/server.c       |   9 ++
 dlls/ntdll/unix/sync.c         | 195 +++++++++++++++++++++++++++++++--
 dlls/ntdll/unix/unix_private.h |   4 +
 3 files changed, 197 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 388e5e80c63..e725e9b0301 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1868,12 +1868,17 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
         return result.dup_handle.status;
     }
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     if (options & DUPLICATE_CLOSE_SOURCE)
+    {
         fd = remove_fd_from_cache( source );
+        close_inproc_sync_obj( source );
+    }
 
     SERVER_START_REQ( dup_handle )
     {
@@ -1939,6 +1944,8 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     if (HandleToLong( handle ) >= ~5 && HandleToLong( handle ) <= ~0)
         return STATUS_SUCCESS;
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
@@ -1951,6 +1958,8 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     if (do_esync())
         esync_close( handle );
 
+    close_inproc_sync_obj( handle );
+
     SERVER_START_REQ( close_handle )
     {
         req->handle = wine_server_obj_handle( handle );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 3300f3d56cb..846d8b6f37d 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -364,6 +364,12 @@ static int get_linux_sync_device(void)
  * it closes the handle; when all handles are closed, the server deletes the
  * in-process synchronization object.
  *
+ * We also need this for signal-and-wait. The signal and wait operations aren't
+ * atomic, but we can't perform the signal and then return STATUS_INVALID_HANDLE
+ * for the wait—we need to either do both operations or neither. That means we
+ * need to grab references to both objects, and prevent them from being
+ * destroyed before we're done with them.
+ *
  * We want lookup of objects from the cache to be very fast; ideally, it should
  * be lock-free. We achieve this by using atomic modifications to "refcount",
  * and guaranteeing that all other fields are valid and correct *as long as*
@@ -407,13 +413,140 @@ static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
 
     if (!refcount)
     {
-        NTSTATUS ret = NtClose( handle );
+        NTSTATUS ret;
+
+        /* we can't call NtClose here as we may be inside fd_cache_mutex */
+        SERVER_START_REQ( close_handle )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+
         assert( !ret );
         close( fd );
     }
 }
 
 
+#define INPROC_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct inproc_sync_cache_entry))
+#define INPROC_SYNC_CACHE_ENTRIES     128
+
+static struct inproc_sync_cache_entry *inproc_sync_cache[INPROC_SYNC_CACHE_ENTRIES];
+static struct inproc_sync_cache_entry inproc_sync_cache_initial_block[INPROC_SYNC_CACHE_BLOCK_SIZE];
+
+static inline unsigned int inproc_sync_handle_to_index( HANDLE handle, unsigned int *entry )
+{
+    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
+    *entry = idx / INPROC_SYNC_CACHE_BLOCK_SIZE;
+    return idx % INPROC_SYNC_CACHE_BLOCK_SIZE;
+}
+
+
+static struct inproc_sync_cache_entry *cache_inproc_sync_obj( HANDLE handle, obj_handle_t inproc_sync, int fd,
+                                                              enum inproc_sync_type type, unsigned int access )
+{
+    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
+    struct inproc_sync_cache_entry *cache;
+    sigset_t sigset;
+    int refcount;
+
+    if (entry >= INPROC_SYNC_CACHE_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return NULL;
+    }
+
+    if (!inproc_sync_cache[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) inproc_sync_cache[0] = inproc_sync_cache_initial_block;
+        else
+        {
+            static const size_t size = INPROC_SYNC_CACHE_BLOCK_SIZE * sizeof(struct inproc_sync_cache_entry);
+            void *ptr = anon_mmap_alloc( size, PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return NULL;
+            if (InterlockedCompareExchangePointer( (void **)&inproc_sync_cache[entry], ptr, NULL ))
+                munmap( ptr, size ); /* someone beat us to it */
+        }
+    }
+
+    cache = &inproc_sync_cache[entry][idx];
+
+    /* Hold fd_cache_mutex instead of a separate mutex, to prevent the same
+     * race between this function and NtClose. That is, prevent the object from
+     * being cached again between close_inproc_sync_obj() and close_handle. */
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (InterlockedCompareExchange( &cache->refcount, 0, 0 ))
+    {
+        /* We lost the race with another thread trying to cache this object, or
+         * the handle is currently being used for another object (i.e. it was
+         * closed and then reused). We have no way of knowing which, and in the
+         * latter case we can't cache this object until the old one is
+         * completely destroyed, so always return failure. */
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+        return NULL;
+    }
+
+    cache->handle = inproc_sync;
+    cache->fd = fd;
+    cache->type = type;
+    cache->access = access;
+    cache->closed = FALSE;
+    /* Make sure we set the other members before the refcount; this store needs
+     * release semantics [paired with the load in get_cached_inproc_sync_obj()].
+     * Set the refcount to 2 (one for the handle, one for the caller). */
+    refcount = InterlockedExchange( &cache->refcount, 2 );
+    assert( !refcount );
+
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    return cache;
+}
+
+
+/* returns the previous value */
+static inline LONG interlocked_inc_if_nonzero( LONG *dest )
+{
+    LONG val, tmp;
+    for (val = *dest;; val = tmp)
+    {
+        if (!val || (tmp = InterlockedCompareExchange( dest, val + 1, val )) == val)
+            break;
+    }
+    return val;
+}
+
+
+static struct inproc_sync_cache_entry *get_cached_inproc_sync_obj( HANDLE handle )
+{
+    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
+    struct inproc_sync_cache_entry *cache;
+
+    if (entry >= INPROC_SYNC_CACHE_ENTRIES || !inproc_sync_cache[entry])
+        return NULL;
+
+    cache = &inproc_sync_cache[entry][idx];
+
+    /* this load needs acquire semantics [paired with the store in
+     * cache_inproc_sync_obj()] */
+    if (!interlocked_inc_if_nonzero( &cache->refcount ))
+        return NULL;
+
+    if (cache->closed)
+    {
+        /* The object is still being used, but "handle" has been closed. The
+         * handle value might have been reused for another object in the
+         * meantime, in which case we have to report that valid object, so
+         * force the caller to check the server. */
+        release_inproc_sync_obj( cache );
+        return NULL;
+    }
+
+    return cache;
+}
+
+
 static BOOL inproc_sync_types_match( enum inproc_sync_type a, enum inproc_sync_type b )
 {
     if (a == b) return TRUE;
@@ -430,32 +563,53 @@ static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desire
                                      struct inproc_sync_cache_entry *stack_cache,
                                      struct inproc_sync_cache_entry **ret_cache )
 {
-    struct inproc_sync_cache_entry *cache = stack_cache;
-    int needs_close;
+    struct inproc_sync_cache_entry *cache;
+    obj_handle_t inproc_sync_handle;
+    enum inproc_sync_type type;
+    unsigned int access;
+    int fd, needs_close;
     NTSTATUS ret;
 
-    *ret_cache = stack_cache;
+    /* try to find it in the cache already */
+    if ((cache = get_cached_inproc_sync_obj( handle )))
+    {
+        *ret_cache = cache;
+        return STATUS_SUCCESS;
+    }
 
+    /* try to retrieve it from the server */
     SERVER_START_REQ( get_linux_sync_obj )
     {
         req->handle = wine_server_obj_handle( handle );
         if (!(ret = wine_server_call( req )))
         {
-            cache->handle = reply->handle;
-            cache->access = reply->access;
-            cache->type = reply->type;
-            cache->refcount = 1;
-            cache->closed = FALSE;
+            inproc_sync_handle = reply->handle;
+            access = reply->access;
+            type = reply->type;
         }
     }
     SERVER_END_REQ;
 
     if (ret) return ret;
 
-    if ((ret = server_get_unix_fd( wine_server_ptr_handle( cache->handle ),
-                                   0, &cache->fd, &needs_close, NULL, NULL )))
+    if ((ret = server_get_unix_fd( wine_server_ptr_handle( inproc_sync_handle ),
+                                   0, &fd, &needs_close, NULL, NULL )))
         return ret;
 
+    cache = cache_inproc_sync_obj( handle, inproc_sync_handle, fd, type, access );
+    if (!cache)
+    {
+        cache = stack_cache;
+        cache->handle = inproc_sync_handle;
+        cache->fd = fd;
+        cache->type = type;
+        cache->access = access;
+        cache->closed = FALSE;
+        cache->refcount = 1;
+    }
+
+    *ret_cache = cache;
+
     if (desired_type && !inproc_sync_types_match( cache->type, desired_type ))
     {
         release_inproc_sync_obj( cache );
@@ -472,6 +626,21 @@ static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desire
 }
 
 
+/* caller must hold fd_cache_mutex */
+void close_inproc_sync_obj( HANDLE handle )
+{
+    struct inproc_sync_cache_entry *cache = get_cached_inproc_sync_obj( handle );
+
+    if (cache)
+    {
+        cache->closed = TRUE;
+        /* once for the reference we just grabbed, and once for the handle */
+        release_inproc_sync_obj( cache );
+        release_inproc_sync_obj( cache );
+    }
+}
+
+
 static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
 {
     NTSTATUS ret;
@@ -977,6 +1146,10 @@ static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
 
 #else
 
+void close_inproc_sync_obj( HANDLE handle )
+{
+}
+
 static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
 {
     return STATUS_NOT_IMPLEMENTED;
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 3a3711d0b85..962a47f436c 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -221,6 +221,8 @@ extern NTSTATUS load_start_exe( WCHAR **image, void **module );
 extern ULONG_PTR redirect_arm64ec_rva( void *module, ULONG_PTR rva, const IMAGE_ARM64EC_METADATA *metadata );
 extern void start_server( BOOL debug );
 
+extern pthread_mutex_t fd_cache_mutex;
+
 extern unsigned int server_call_unlocked( void *req_ptr );
 extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset );
 extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset );
@@ -402,6 +404,8 @@ extern NTSTATUS wow64_wine_spawnvp( void *args );
 
 extern void dbg_init(void);
 
+extern void close_inproc_sync_obj( HANDLE handle );
+
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                           PNTAPCFUNC func, NTSTATUS status );
 extern NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context );

From f4cd2f04493f8694d40b58a3d2b40f00768bfd6f Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sat, 13 Mar 2021 16:20:30 -0600
Subject: [PATCH 234/244] server: Allow disabling in-process synchronization
 support.

---
 server/inproc_sync.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 6cb02b16832..fb9d2442c02 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -128,6 +128,12 @@ static struct linux_device *get_linux_device(void)
     struct linux_device *device;
     int unix_fd;
 
+    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return NULL;
+    }
+
     if (linux_device_object)
         return (struct linux_device *)grab_object( linux_device_object );
 

From d12949b03fc69d54778f0e2cf51f8d84b3722d68 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 14 Mar 2021 11:08:02 -0500
Subject: [PATCH 235/244] server: Add a message to signal that in-proces
 synchronization is indeed active.

---
 server/inproc_sync.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index fb9d2442c02..1c67eba245f 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -157,6 +157,7 @@ static struct linux_device *get_linux_device(void)
         return NULL;
     }
 
+    fprintf( stderr, "wine: using fast synchronization.\n" );
     linux_device_object = device;
     return device;
 }

From e01b377d154ca7d5c585c74f3a657065566d5a57 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 3 May 2024 14:35:50 -0400
Subject: [PATCH 236/244] extra debugging

---
 server/inproc_sync.c | 23 ++++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 1c67eba245f..a2781ac293c 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -21,6 +21,7 @@
 #include "config.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <stdint.h>
 #include <stdio.h>
 
@@ -126,21 +127,34 @@ static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd )
 static struct linux_device *get_linux_device(void)
 {
     struct linux_device *device;
+    static int initialized;
     int unix_fd;
 
+    if (initialized)
+    {
+        if (linux_device_object)
+            grab_object( linux_device_object );
+	else
+	  set_error( STATUS_NOT_IMPLEMENTED );
+        return linux_device_object;
+    }
+
     if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
     {
+      static int once;
         set_error( STATUS_NOT_IMPLEMENTED );
+	if (!once++) fprintf(stderr, "ntsync is explicitly disabled.\n");
+	initialized = 1;
         return NULL;
     }
 
-    if (linux_device_object)
-        return (struct linux_device *)grab_object( linux_device_object );
-
     unix_fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
     if (unix_fd == -1)
     {
+      static int once;
         file_set_error();
+	if (!once++) fprintf(stderr, "Cannot open /dev/ntsync: %s\n", strerror(errno));
+	initialized = 1;
         return NULL;
     }
 
@@ -148,17 +162,20 @@ static struct linux_device *get_linux_device(void)
     {
         close( unix_fd );
         set_error( STATUS_NO_MEMORY );
+	initialized = 1;
         return NULL;
     }
 
     if (!(device->fd = create_anonymous_fd( &inproc_sync_fd_ops, unix_fd, &device->obj, 0 )))
     {
         release_object( device );
+	initialized = 1;
         return NULL;
     }
 
     fprintf( stderr, "wine: using fast synchronization.\n" );
     linux_device_object = device;
+    initialized = 1;
     return device;
 }
 

From a3f8ceae5b00b6ea5989a7f11a6ce75626f26516 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Mon, 10 Feb 2025 12:55:36 -0800
Subject: [PATCH 238/244] fixup! HACK: win32u: Always call get_message request
 after waiting.

---
 dlls/ntdll/unix/esync.c      |  2 +-
 dlls/ntdll/unix/esync.h      |  2 +-
 dlls/ntdll/unix/fsync.c      |  2 +-
 dlls/ntdll/unix/fsync.h      |  2 +-
 dlls/win32u/message.c        | 12 +++++++++++-
 dlls/win32u/win32u_private.h |  3 +++
 6 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 22856231bc0..0e924e199bb 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -51,7 +51,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(esync);
 
-int do_esync(void)
+NTSTATUS do_esync(void)
 {
 #ifdef HAVE_SYS_EVENTFD_H
     static int do_esync_cached = -1;
diff --git a/dlls/ntdll/unix/esync.h b/dlls/ntdll/unix/esync.h
index 59f8809fc1a..9ab45d47fa6 100644
--- a/dlls/ntdll/unix/esync.h
+++ b/dlls/ntdll/unix/esync.h
@@ -18,7 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-extern int do_esync(void);
+extern NTSYSAPI NTSTATUS do_esync( void );
 extern void esync_init(void);
 extern NTSTATUS esync_close( HANDLE handle );
 
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2aa402a57b2..3736a0808ad 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -163,7 +163,7 @@ static inline int futex_wake( int *addr, int val )
     return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
 }
 
-int do_fsync(void)
+NTSTATUS do_fsync(void)
 {
 #ifdef __linux__
     static int do_fsync_cached = -1;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 6005c0fa322..4d87e4f02b6 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -18,7 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-extern int do_fsync(void);
+extern NTSYSAPI NTSTATUS do_fsync( void );
 extern void fsync_init(void);
 extern NTSTATUS fsync_close( HANDLE handle );
 
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 9331e928aa2..4d4431eab34 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2796,6 +2796,16 @@ static BOOL check_queue_bits( UINT wake_mask, UINT changed_mask, UINT signal_bit
     return skip;
 }
 
+static inline BOOL using_server_or_ntsync(void)
+{
+    static int server_or_nt_cached = -1;
+    if (server_or_nt_cached == -1)
+    {
+        server_or_nt_cached = !(do_esync() || do_fsync());
+    }
+    return !!server_or_nt_cached;
+}
+
 /***********************************************************************
  *           peek_message
  *
@@ -2843,7 +2853,7 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
         thread_info->client_info.msg_source = prev_source;
         wake_mask = filter->mask & (QS_SENDMESSAGE | QS_SMRESULT);
 
-        if (!filter->waited && NtGetTickCount() - thread_info->last_getmsg_time < 3000 && /* avoid hung queue */
+        if ((using_server_or_ntsync() || !filter->waited) && NtGetTickCount() - thread_info->last_getmsg_time < 3000 && /* avoid hung queue */
             check_queue_bits( wake_mask, filter->mask, wake_mask | signal_bits, filter->mask | clear_bits,
                               &wake_bits, &changed_bits ))
             res = STATUS_PENDING;
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index f9b812ff70c..8ba5771d2f3 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -323,6 +323,9 @@ extern const struct user_driver_funcs *user_driver;
 
 extern ULONG_PTR zero_bits;
 
+extern NTSTATUS do_esync( void );
+extern NTSTATUS do_fsync( void );
+
 static inline BOOL set_ntstatus( NTSTATUS status )
 {
     if (status) RtlSetLastWin32Error( RtlNtStatusToDosError( status ));

From 9e6a486391799d99386744eb78347433bcc4bea4 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 26 Dec 2024 07:00:02 -0800
Subject: [PATCH 239/244] ntdll: Increase cache entries to 256.

Match esync/fsync size to reduce 'too many allocated handles, not caching'.
---
 dlls/ntdll/unix/server.c | 2 +-
 dlls/ntdll/unix/sync.c   | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index e725e9b0301..80c603068b5 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1044,7 +1044,7 @@ union fd_cache_entry
 C_ASSERT( sizeof(union fd_cache_entry) == sizeof(LONG64) );
 
 #define FD_CACHE_BLOCK_SIZE  (65536 / sizeof(union fd_cache_entry))
-#define FD_CACHE_ENTRIES     128
+#define FD_CACHE_ENTRIES     256
 
 static union fd_cache_entry *fd_cache[FD_CACHE_ENTRIES];
 static union fd_cache_entry fd_cache_initial_block[FD_CACHE_BLOCK_SIZE];
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 846d8b6f37d..25ee0f59e62 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -430,7 +430,7 @@ static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
 
 
 #define INPROC_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct inproc_sync_cache_entry))
-#define INPROC_SYNC_CACHE_ENTRIES     128
+#define INPROC_SYNC_CACHE_ENTRIES     256
 
 static struct inproc_sync_cache_entry *inproc_sync_cache[INPROC_SYNC_CACHE_ENTRIES];
 static struct inproc_sync_cache_entry inproc_sync_cache_initial_block[INPROC_SYNC_CACHE_BLOCK_SIZE];

From 3774df289c4cab09e7bfe912488c448bb04c3bef Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Mon, 23 Dec 2024 11:31:27 +0200
Subject: [PATCH 240/244] include: use ntsync.h v7 module header as an in-tree
 header

---
 configure.ac           |  1 -
 dlls/ntdll/unix/sync.c |  4 +--
 include/Makefile.in    |  1 +
 include/ntsync.h       | 61 ++++++++++++++++++++++++++++++++++++++++++
 server/inproc_sync.c   |  4 ++-
 5 files changed, 67 insertions(+), 4 deletions(-)
 create mode 100644 include/ntsync.h

diff --git a/configure.ac b/configure.ac
index 2a5808b65d7..d4e999fb727 100644
--- a/configure.ac
+++ b/configure.ac
@@ -387,7 +387,6 @@ AC_CHECK_HEADERS(\
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
-	linux/ntsync.h \
 	linux/param.h \
 	linux/seccomp.h \
 	linux/serial.h \
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 25ee0f59e62..e5d07813c34 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -60,8 +60,8 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
-#ifdef HAVE_LINUX_NTSYNC_H
-# include <linux/ntsync.h>
+#ifdef HAVE_LINUX_TYPES_H
+# include "ntsync.h"
 #endif
 
 #include "ntstatus.h"
diff --git a/include/Makefile.in b/include/Makefile.in
index 37d4af0f82f..d8efa97ec2c 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -598,6 +598,7 @@ SOURCES = \
 	ntsecapi.h \
 	ntsecpkg.h \
 	ntstatus.h \
+	ntsync.h \
 	ntuser.h \
 	oaidl.idl \
 	objbase.h \
diff --git a/include/ntsync.h b/include/ntsync.h
new file mode 100644
index 00000000000..7d85cb82ca5
--- /dev/null
+++ b/include/ntsync.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Kernel support for NT synchronization primitive emulation
+ *
+ * Copyright (C) 2021-2022 Elizabeth Figura <zfigura@codeweavers.com>
+ */
+
+#ifndef __LINUX_NTSYNC_H
+#define __LINUX_NTSYNC_H
+
+#include <linux/types.h>
+
+struct ntsync_sem_args {
+	__u32 count;
+	__u32 max;
+};
+
+struct ntsync_mutex_args {
+	__u32 owner;
+	__u32 count;
+};
+
+struct ntsync_event_args {
+	__u32 manual;
+	__u32 signaled;
+};
+
+#define NTSYNC_WAIT_REALTIME	0x1
+
+struct ntsync_wait_args {
+	__u64 timeout;
+	__u64 objs;
+	__u32 count;
+	__u32 index;
+	__u32 flags;
+	__u32 owner;
+	__u32 alert;
+	__u32 pad;
+};
+
+#define NTSYNC_MAX_WAIT_COUNT 64
+
+#define NTSYNC_IOC_CREATE_SEM		_IOW ('N', 0x80, struct ntsync_sem_args)
+#define NTSYNC_IOC_WAIT_ANY		_IOWR('N', 0x82, struct ntsync_wait_args)
+#define NTSYNC_IOC_WAIT_ALL		_IOWR('N', 0x83, struct ntsync_wait_args)
+#define NTSYNC_IOC_CREATE_MUTEX		_IOW ('N', 0x84, struct ntsync_mutex_args)
+#define NTSYNC_IOC_CREATE_EVENT		_IOW ('N', 0x87, struct ntsync_event_args)
+
+#define NTSYNC_IOC_SEM_RELEASE		_IOWR('N', 0x81, __u32)
+#define NTSYNC_IOC_MUTEX_UNLOCK		_IOWR('N', 0x85, struct ntsync_mutex_args)
+#define NTSYNC_IOC_MUTEX_KILL		_IOW ('N', 0x86, __u32)
+#define NTSYNC_IOC_EVENT_SET		_IOR ('N', 0x88, __u32)
+#define NTSYNC_IOC_EVENT_RESET		_IOR ('N', 0x89, __u32)
+#define NTSYNC_IOC_EVENT_PULSE		_IOR ('N', 0x8a, __u32)
+#define NTSYNC_IOC_SEM_READ		_IOR ('N', 0x8b, struct ntsync_sem_args)
+#define NTSYNC_IOC_MUTEX_READ		_IOR ('N', 0x8c, struct ntsync_mutex_args)
+#define NTSYNC_IOC_EVENT_READ		_IOR ('N', 0x8d, struct ntsync_event_args)
+
+#define HAVE_LINUX_NTSYNC_H
+
+#endif
diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index a2781ac293c..10a4d0e2538 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -33,6 +33,9 @@
 #include "handle.h"
 #include "request.h"
 #include "thread.h"
+#ifdef HAVE_LINUX_TYPES_H
+# include "ntsync.h"
+#endif
 
 #ifdef HAVE_LINUX_NTSYNC_H
 
@@ -40,7 +43,6 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <unistd.h>
-#include <linux/ntsync.h>
 
 struct linux_device
 {

From d24b788a98f230fabb88d83da6f2bf29988c541c Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Wed, 26 Feb 2025 12:14:30 -0800
Subject: [PATCH 241/244] ntdll: Check for esync/fsync before doing server
 waits.

---
 dlls/ntdll/unix/file.c    |  7 ++++++-
 dlls/ntdll/unix/process.c |  7 ++++++-
 dlls/ntdll/unix/server.c  |  5 ++++-
 dlls/ntdll/unix/thread.c  | 12 ++++++++++--
 4 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 0754a931d5a..8ec17ec1591 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -121,6 +121,8 @@
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "fsync.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
@@ -7038,7 +7040,10 @@ NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void
         }
         if (handle)
         {
-            server_wait_for_object( handle, FALSE, NULL );
+            if (!(do_fsync() || do_esync()))
+                server_wait_for_object( handle, FALSE, NULL );
+            else
+                NtWaitForSingleObject( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 4b1d8e6f1bc..ea3e10e73d9 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -70,6 +70,8 @@
 #include "wine/condrv.h"
 #include "wine/server.h"
 #include "wine/debug.h"
+#include "fsync.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 
@@ -920,7 +922,10 @@ NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_
 
     /* wait for the new process info to be ready */
 
-    server_wait_for_object( process_info, FALSE, NULL );
+    if (!(do_fsync() || do_esync()))
+        server_wait_for_object( process_info, FALSE, NULL );
+    else
+        NtWaitForSingleObject( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 80c603068b5..ebdb52e79ca 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -911,7 +911,10 @@ unsigned int server_queue_process_apc( HANDLE process, const union apc_call *cal
         }
         else
         {
-            server_wait_for_object( handle, FALSE, NULL );
+            if (!(do_fsync() || do_esync()))
+                server_wait_for_object( handle, FALSE, NULL );
+            else
+                NtWaitForSingleObject( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 95d3a49b1a0..374bbb8f8af 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -76,6 +76,8 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "fsync.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(thread);
 WINE_DECLARE_DEBUG_CHANNEL(seh);
@@ -1671,7 +1673,10 @@ NTSTATUS WINAPI NtSuspendThread( HANDLE handle, ULONG *ret_count )
 
     if (ret == STATUS_PENDING && wait_handle)
     {
-        NtWaitForSingleObject( wait_handle, FALSE, NULL );
+        if ((do_fsync() || do_esync())) // this breaks with ntsync
+            NtWaitForSingleObject( wait_handle, FALSE, NULL );
+        else
+            server_wait_for_object( wait_handle, FALSE, NULL );
 
         SERVER_START_REQ( suspend_thread )
         {
@@ -1846,7 +1851,10 @@ NTSTATUS get_thread_context( HANDLE handle, void *context, BOOL *self, USHORT ma
 
     if (ret == STATUS_PENDING)
     {
-        server_wait_for_object( context_handle, FALSE, NULL );
+        if (!(do_fsync() || do_esync()))
+            server_wait_for_object( context_handle, FALSE, NULL );
+        else
+            NtWaitForSingleObject( context_handle, FALSE, NULL );
 
         SERVER_START_REQ( get_thread_context )
         {


From 66635907183c316dcac78dbbc3382f5d54e29a07 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 4 Apr 2025 20:37:03 +0300
Subject: [PATCH 243/244] ntdll: Make the staging_warn_event a permanent
 object.

Avoids printing it repeatedly.
---
 dlls/ntdll/loader.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 84df6640bb3..a62f19c1c58 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4692,7 +4692,7 @@ void loader_init( CONTEXT *context, void **entry )
 {
     OBJECT_ATTRIBUTES staging_event_attr;
     UNICODE_STRING staging_event_string;
-    HANDLE staging_event;
+    HANDLE staging_event = 0;
     static int attach_done;
     NTSTATUS status;
     ULONG_PTR cookie, port = 0;
@@ -4808,7 +4808,7 @@ void loader_init( CONTEXT *context, void **entry )
          * add a comment here to try to prevent that. */
     }
     RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
-    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF, NULL, NULL );
+    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF | OBJ_PERMANENT, NULL, NULL );
     if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
     {
         FIXME_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
@@ -4817,6 +4817,8 @@ void loader_init( CONTEXT *context, void **entry )
     else
         WARN_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
 
+    NtClose( staging_event );
+
     NtCurrentTeb()->FlsSlots = fls_alloc_data();
 
     if (!attach_done)  /* first time around */

